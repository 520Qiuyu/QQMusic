// ==UserScript==
// @name         qqmusic
// @namespace    npm/vite-plugin-monkey
// @version      0.0.0
// @author       520Qiuyu
// @description  QQ音乐下载助手
// @icon         https://vitejs.dev/logo.svg
// @homepage     https://github.com/520Qiuyu/QQMusic
// @homepageURL  https://github.com/520Qiuyu/QQMusic
// @source       https://github.com/520Qiuyu/QQMusic.git
// @match        https://y.qq.com/*
// @require      https://cdn.jsdelivr.net/npm/dayjs@1.11.13/dayjs.min.js
// @require      https://cdn.jsdelivr.net/npm/react@18.3.1/umd/react.production.min.js
// @require      https://cdn.jsdelivr.net/npm/react-dom@18.3.1/umd/react-dom.production.min.js
// @require      https://cdn.jsdelivr.net/npm/antd@5.27.1/dist/antd.min.js
// @require      https://cdn.jsdelivr.net/npm/@ant-design/icons@5.6.1/dist/index.umd.min.js
// @require      https://cdn.jsdelivr.net/npm/systemjs@6.15.1/dist/system.min.js
// @require      https://cdn.jsdelivr.net/npm/systemjs@6.15.1/dist/extras/named-register.min.js
// @require      data:application/javascript,%3B(typeof%20System!%3D'undefined')%26%26(System%3Dnew%20System.constructor())%3B
// @connect      y.qq.com
// @connect      music.163.com
// @connect      aqqmusic.tc.qq.com
// @grant        GM_addStyle
// @grant        GM_deleteValue
// @grant        GM_getValue
// @grant        GM_listValues
// @grant        GM_setValue
// @grant        GM_xmlhttpRequest
// ==/UserScript==

System.addImportMap({ imports: {"antd":"user:antd","react":"user:react","react-dom":"user:react-dom","@ant-design/icons":"user:@ant-design/icons"} });
System.set("user:antd", (()=>{const _=antd;('default' in _)||(_.default=_);return _})());
System.set("user:react", (()=>{const _=React;('default' in _)||(_.default=_);return _})());
System.set("user:react-dom", (()=>{const _=ReactDOM;('default' in _)||(_.default=_);return _})());
System.set("user:@ant-design/icons", (()=>{const _=icons;('default' in _)||(_.default=_);return _})());

System.register("./__entry.js", ['react', 'antd', 'react-dom', '@ant-design/icons'], (function (exports, module) {
  'use strict';
  var forwardRef, useState, useMemo, useEffect, require$$0, useImperativeHandle, useRef, useCallback, useLayoutEffect, Input, DatePicker, Form, Typography, Modal, Button, Table, Spin, Descriptions, Space, Image, Pagination, Select, Tabs, ConfigProvider, Avatar, Tag, Tooltip, message$1, App$1, TreeSelect, Upload, Card, Switch, TimePicker, Checkbox, Radio, require$$0$1, LinkOutlined, GithubOutlined, StarOutlined, ForkOutlined, EyeOutlined, UploadOutlined, DownloadOutlined, CloudDownloadOutlined, FileOutlined, PauseCircleOutlined, PlayCircleOutlined, UserOutlined, SaveOutlined, SelectOutlined, TrophyOutlined, ClockCircleOutlined, CopyOutlined, PictureOutlined, UnorderedListOutlined, ContainerOutlined, BookOutlined, SearchOutlined, InfoCircleOutlined;
  return {
    setters: [module => {
      forwardRef = module.forwardRef;
      useState = module.useState;
      useMemo = module.useMemo;
      useEffect = module.useEffect;
      require$$0 = module.default;
      useImperativeHandle = module.useImperativeHandle;
      useRef = module.useRef;
      useCallback = module.useCallback;
      useLayoutEffect = module.useLayoutEffect;
    }, module => {
      Input = module.Input;
      DatePicker = module.DatePicker;
      Form = module.Form;
      Typography = module.Typography;
      Modal = module.Modal;
      Button = module.Button;
      Table = module.Table;
      Spin = module.Spin;
      Descriptions = module.Descriptions;
      Space = module.Space;
      Image = module.Image;
      Pagination = module.Pagination;
      Select = module.Select;
      Tabs = module.Tabs;
      ConfigProvider = module.ConfigProvider;
      Avatar = module.Avatar;
      Tag = module.Tag;
      Tooltip = module.Tooltip;
      message$1 = module.message;
      App$1 = module.App;
      TreeSelect = module.TreeSelect;
      Upload = module.Upload;
      Card = module.Card;
      Switch = module.Switch;
      TimePicker = module.TimePicker;
      Checkbox = module.Checkbox;
      Radio = module.Radio;
    }, module => {
      require$$0$1 = module.default;
    }, module => {
      LinkOutlined = module.LinkOutlined;
      GithubOutlined = module.GithubOutlined;
      StarOutlined = module.StarOutlined;
      ForkOutlined = module.ForkOutlined;
      EyeOutlined = module.EyeOutlined;
      UploadOutlined = module.UploadOutlined;
      DownloadOutlined = module.DownloadOutlined;
      CloudDownloadOutlined = module.CloudDownloadOutlined;
      FileOutlined = module.FileOutlined;
      PauseCircleOutlined = module.PauseCircleOutlined;
      PlayCircleOutlined = module.PlayCircleOutlined;
      UserOutlined = module.UserOutlined;
      SaveOutlined = module.SaveOutlined;
      SelectOutlined = module.SelectOutlined;
      TrophyOutlined = module.TrophyOutlined;
      ClockCircleOutlined = module.ClockCircleOutlined;
      CopyOutlined = module.CopyOutlined;
      PictureOutlined = module.PictureOutlined;
      UnorderedListOutlined = module.UnorderedListOutlined;
      ContainerOutlined = module.ContainerOutlined;
      BookOutlined = module.BookOutlined;
      SearchOutlined = module.SearchOutlined;
      InfoCircleOutlined = module.InfoCircleOutlined;
    }],
    execute: (function () {

      const d=new Set;const _ = async e=>{d.has(e)||(d.add(e),(t=>{typeof GM_addStyle=="function"?GM_addStyle(t):document.head.appendChild(document.createElement("style")).append(t);})(e));};

      _(' @charset "UTF-8";._copy-text_1att4_1{display:flex;align-items:center;width:100%}._copy-text_1att4_1 ._text_1att4_6{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}._copy-text_1att4_1 ._copy-btn_1att4_12{flex-shrink:0;padding:0}._text-overflow-show-tips-container_btabq_1{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;cursor:text}._select-search_19wb1_1 .ant-select:first-child .ant-select-selector{border-radius:32px 0 0 32px!important}._select-search_19wb1_1>:last-child{border-radius:0 32px 32px 0!important}._search-form_10eg9_1{margin-bottom:-16px}._search-form_10eg9_1 .ant-form-item{margin-bottom:16px}._search-form_10eg9_1 input.ant-input,._search-form_10eg9_1 .ant-input-affix-wrapper,._search-form_10eg9_1 .ant-picker,._search-form_10eg9_1 .ant-calendar-picker-input,._search-form_10eg9_1 .ant-select-selector,._search-form_10eg9_1 .ant-select-multiple .ant-select-selection-item{border-radius:32px}._album-detail-modal_e7ura_1 ._modal-header_e7ura_1{display:flex;flex-direction:column;gap:8px}._album-detail-modal_e7ura_1 ._album-basic-info_e7ura_6{display:flex;align-items:center;gap:12px}._album-detail-modal_e7ura_1 ._album-info_e7ura_11{display:flex;flex-direction:column;gap:4px}._album-detail-modal_e7ura_1 ._album-name_e7ura_16{margin:0}._album-detail-modal_e7ura_1 ._album-meta_e7ura_19{display:flex;align-items:center;gap:8px}._album-detail-modal_e7ura_1 ._song-table_e7ura_24{margin-top:8px}._album-detail-modal_e7ura_1 ._song-name_e7ura_27{max-width:260px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}._album-detail-modal_e7ura_1 ._artist-item_e7ura_33{display:inline-flex;align-items:center}._album-detail-modal_e7ura_1 ._artist-name_e7ura_37{font-size:12px;color:#595959}._album-detail-modal_e7ura_1 ._artist-separator_e7ura_41{margin:0 4px;color:#bfbfbf}._album-detail-modal_e7ura_1 ._song-duration_e7ura_45{font-variant-numeric:tabular-nums}._album-detail-modal_e7ura_1 ._footer_e7ura_48{display:flex;justify-content:space-between;align-items:center;padding:16px 0;border-top:1px solid #f0f0f0}._album-detail-modal_e7ura_1 ._footer_e7ura_48 ._selected-count_e7ura_55{font-size:14px;color:#666}._album-detail-modal_e7ura_1 ._footer_e7ura_48 ._selected-count_e7ura_55 ._selected-info_e7ura_59{color:#1890ff;margin-left:8px;font-weight:500}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1{width:100%}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4{display:flex;align-items:center;justify-content:space-between;padding-right:30px}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10{display:flex;align-items:center}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14{display:flex;flex-direction:column;align-items:center;padding:8px 16px;border-radius:8px;margin-left:12px;box-shadow:0 2px 8px #0000001a;transition:all .3s ease;position:relative;overflow:hidden}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14:nth-child(1){background:linear-gradient(135deg,#667eea,#764ba2);box-shadow:0 2px 8px #667eea4d}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14:nth-child(1):hover{box-shadow:0 4px 12px #667eea66}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14:nth-child(2){background:linear-gradient(135deg,#f093fb,#f5576c);box-shadow:0 2px 8px #f093fb4d}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14:nth-child(2):hover{box-shadow:0 4px 12px #f093fb66}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14:nth-child(3){background:linear-gradient(135deg,#4facfe,#00f2fe);box-shadow:0 2px 8px #4facfe4d}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14:nth-child(3):hover{box-shadow:0 4px 12px #4facfe66}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14:nth-child(1):hover{transform:translateY(-2px) scale(1.02)}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14:nth-child(2):hover{transform:translateY(-2px) scale(1.02)}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14:nth-child(3):hover{transform:translateY(-2px) scale(1.02)}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14:hover{transform:translateY(-2px)}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14._loading_jnpqx_59{opacity:.7}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14._loading_jnpqx_59:nth-child(1) ._stat-value_jnpqx_62{animation:_pulse_jnpqx_1 1.5s ease-in-out infinite;animation-delay:.2s}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14._loading_jnpqx_59:nth-child(2) ._stat-value_jnpqx_62{animation:_pulse_jnpqx_1 1.5s ease-in-out infinite;animation-delay:.4s}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14._loading_jnpqx_59:nth-child(3) ._stat-value_jnpqx_62{animation:_pulse_jnpqx_1 1.5s ease-in-out infinite;animation-delay:.6s}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14 ._stat-label_jnpqx_74{font-size:12px;color:#fffc;font-weight:500;margin-bottom:2px}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14 ._stat-value_jnpqx_62{font-size:16px;color:#fff;font-weight:600;line-height:1;transition:all .3s ease}._hot-song-modal_jnpqx_1 ._modal-title_jnpqx_1 ._title-content_jnpqx_4 ._title-stats_jnpqx_10 ._stat-item_jnpqx_14 ._stat-value_jnpqx_62:hover{transform:scale(1.1)}._hot-song-modal_jnpqx_1 ._singer-info-display_jnpqx_90{margin-bottom:16px;padding:16px;background-color:#f5f5f5;border-radius:6px;border-left:4px solid #1890ff}._hot-song-modal_jnpqx_1 ._song-table_jnpqx_97{margin-bottom:16px}._hot-song-modal_jnpqx_1 ._song-info_jnpqx_100 ._album-cover_jnpqx_100{width:40px;height:40px;border-radius:4px;overflow:hidden;flex-shrink:0}._hot-song-modal_jnpqx_1 ._song-info_jnpqx_100 ._album-cover_jnpqx_100 img{width:100%;height:100%;object-fit:cover;border-radius:4px}._hot-song-modal_jnpqx_1 ._song-info_jnpqx_100 ._song-details_jnpqx_113{flex:1;min-width:0}._hot-song-modal_jnpqx_1 ._song-info_jnpqx_100 ._song-details_jnpqx_113 ._song-name_jnpqx_117{font-weight:500;color:#262626;margin-bottom:4px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:150px}._hot-song-modal_jnpqx_1 ._song-info_jnpqx_100 ._song-details_jnpqx_113 ._song-album_jnpqx_126{font-size:12px;color:#8c8c8c;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:150px}._hot-song-modal_jnpqx_1 ._singer-info_jnpqx_90 ._singer-name_jnpqx_134{font-weight:500;color:#262626;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:120px}._hot-song-modal_jnpqx_1 ._singer-info_jnpqx_90 ._singer-id_jnpqx_142{font-size:12px;color:#8c8c8c;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:120px}._hot-song-modal_jnpqx_1 ._song-id-text_jnpqx_150,._hot-song-modal_jnpqx_1 ._song-mid-text_jnpqx_151{font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:12px;color:#595959;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:100px;display:inline-block}._hot-song-modal_jnpqx_1 ._footer_jnpqx_161{display:flex;align-items:center;justify-content:flex-end;margin-top:16px}._hot-song-modal_jnpqx_1 ._footer_jnpqx_161 ._selected-count_jnpqx_167{font-size:14px;color:#595959;margin-right:auto}@keyframes _pulse_jnpqx_1{0%,to{opacity:1}50%{opacity:.5}}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1{width:100%}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1 ._title-content_1fb5b_4{display:flex;align-items:center;justify-content:space-between;padding-right:30px}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1 ._title-content_1fb5b_4 ._title-stats_1fb5b_10{display:flex;align-items:center}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1 ._title-content_1fb5b_4 ._title-stats_1fb5b_10 ._stat-item_1fb5b_14{display:flex;flex-direction:column;align-items:center;padding:8px 16px;border-radius:8px;margin-left:12px;box-shadow:0 2px 8px #0000001a;transition:all .3s ease;position:relative;overflow:hidden}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1 ._title-content_1fb5b_4 ._title-stats_1fb5b_10 ._stat-item_1fb5b_14:nth-child(1){background:linear-gradient(135deg,#667eea,#764ba2);box-shadow:0 2px 8px #667eea4d}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1 ._title-content_1fb5b_4 ._title-stats_1fb5b_10 ._stat-item_1fb5b_14:nth-child(1):hover{box-shadow:0 4px 12px #667eea66}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1 ._title-content_1fb5b_4 ._title-stats_1fb5b_10 ._stat-item_1fb5b_14:nth-child(2){background:linear-gradient(135deg,#f093fb,#f5576c);box-shadow:0 2px 8px #f093fb4d}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1 ._title-content_1fb5b_4 ._title-stats_1fb5b_10 ._stat-item_1fb5b_14:nth-child(2):hover{box-shadow:0 4px 12px #f093fb66}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1 ._title-content_1fb5b_4 ._title-stats_1fb5b_10 ._stat-item_1fb5b_14:nth-child(1):hover{transform:translateY(-2px) scale(1.02)}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1 ._title-content_1fb5b_4 ._title-stats_1fb5b_10 ._stat-item_1fb5b_14:nth-child(2):hover{transform:translateY(-2px) scale(1.02)}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1 ._title-content_1fb5b_4 ._title-stats_1fb5b_10 ._stat-item_1fb5b_14:hover{transform:translateY(-2px)}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1 ._title-content_1fb5b_4 ._title-stats_1fb5b_10 ._stat-item_1fb5b_14._loading_1fb5b_49{opacity:.7}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1 ._title-content_1fb5b_4 ._title-stats_1fb5b_10 ._stat-item_1fb5b_14._loading_1fb5b_49:nth-child(1) ._stat-value_1fb5b_52{animation:_pulse_1fb5b_1 1.5s ease-in-out infinite;animation-delay:.2s}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1 ._title-content_1fb5b_4 ._title-stats_1fb5b_10 ._stat-item_1fb5b_14._loading_1fb5b_49:nth-child(2) ._stat-value_1fb5b_52{animation:_pulse_1fb5b_1 1.5s ease-in-out infinite;animation-delay:.4s}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1 ._title-content_1fb5b_4 ._title-stats_1fb5b_10 ._stat-item_1fb5b_14 ._stat-label_1fb5b_60{font-size:12px;color:#fffc;font-weight:500;margin-bottom:2px}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1 ._title-content_1fb5b_4 ._title-stats_1fb5b_10 ._stat-item_1fb5b_14 ._stat-value_1fb5b_52{font-size:16px;color:#fff;font-weight:600;line-height:1;transition:all .3s ease}._album-list-modal_1fb5b_1 ._modal-title_1fb5b_1 ._title-content_1fb5b_4 ._title-stats_1fb5b_10 ._stat-item_1fb5b_14 ._stat-value_1fb5b_52:hover{transform:scale(1.1)}._album-list-modal_1fb5b_1 ._album-table_1fb5b_76{margin-bottom:16px}._album-list-modal_1fb5b_1 ._album-info_1fb5b_79 ._album-cover_1fb5b_79{width:60px;height:60px;border-radius:6px;overflow:hidden;flex-shrink:0}._album-list-modal_1fb5b_1 ._album-info_1fb5b_79 ._album-cover_1fb5b_79 img{width:100%;height:100%;object-fit:cover;border-radius:6px}._album-list-modal_1fb5b_1 ._album-info_1fb5b_79 ._album-details_1fb5b_92{flex:1;min-width:0;cursor:pointer}._album-list-modal_1fb5b_1 ._album-info_1fb5b_79 ._album-details_1fb5b_92 ._album-name_1fb5b_97{font-weight:500;color:#262626;margin-bottom:4px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:180px}._album-list-modal_1fb5b_1 ._album-info_1fb5b_79 ._album-details_1fb5b_92 ._album-trans-name_1fb5b_106{font-size:12px;color:#8c8c8c;margin-bottom:4px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:180px}._album-list-modal_1fb5b_1 ._album-info_1fb5b_79 ._album-details_1fb5b_92 ._album-type_1fb5b_115{margin-top:4px}._album-list-modal_1fb5b_1 ._singer-info_1fb5b_118 ._singer-name_1fb5b_118{font-weight:500;color:#262626;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:120px}._album-list-modal_1fb5b_1 ._singer-info_1fb5b_118 ._singer-id_1fb5b_126{font-size:12px;color:#8c8c8c;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:120px}._album-list-modal_1fb5b_1 ._album-id-text_1fb5b_134,._album-list-modal_1fb5b_1 ._album-mid-text_1fb5b_135{font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:12px;color:#595959;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:100px;display:inline-block}._album-list-modal_1fb5b_1 ._publish-date_1fb5b_145{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:120px;display:inline-block}._album-list-modal_1fb5b_1 ._footer_1fb5b_152{display:flex;justify-content:space-between;align-items:center;padding:16px 0;border-top:1px solid #f0f0f0}._album-list-modal_1fb5b_1 ._footer_1fb5b_152 ._selected-count_1fb5b_159{font-size:14px;color:#666}._album-list-modal_1fb5b_1 ._footer_1fb5b_152 ._selected-count_1fb5b_159 ._selected-info_1fb5b_163{color:#1890ff;margin-left:8px;font-weight:500}@keyframes _pulse_1fb5b_1{0%,to{opacity:1}50%{opacity:.5}}._singer-search-modal_1jeib_2 .ant-modal-body{display:flex;flex-direction:column;gap:16px}._singer-info_1jeib_8{display:flex;align-items:center}._singer-info_1jeib_8 ._singer-avatar_1jeib_12{border:3px solid #f0f0f0;box-shadow:0 2px 8px #0000001a;transition:all .3s ease}._singer-info_1jeib_8 ._singer-avatar_1jeib_12:hover{border-color:#31c27c;transform:scale(1.05)}._singer-info_1jeib_8 ._singer-details_1jeib_21{display:flex;flex-direction:column;gap:4px}._singer-info_1jeib_8 ._singer-details_1jeib_21 ._singer-name_1jeib_26{font-size:16px;font-weight:600;color:#262626;line-height:1.4}._singer-info_1jeib_8 ._singer-details_1jeib_21 ._singer-country_1jeib_32{font-size:13px;color:#666;display:flex;align-items:center;gap:4px}._singer-info_1jeib_8 ._singer-details_1jeib_21 ._singer-country_1jeib_32:before{content:"\u{1F4CD}";font-size:12px}._singer-info_1jeib_8 ._singer-details_1jeib_21 ._singer-id_1jeib_43{font-size:12px;color:#999;font-family:Courier New,monospace;background:#f5f5f5;padding:2px 6px;border-radius:4px;display:inline-block;width:fit-content}._singer-id-text_1jeib_54{font-family:Courier New,monospace;font-size:13px;color:#666;background:#f8f9fa;padding:4px 8px;border-radius:4px;border:1px solid #e9ecef}._singer-mid-text_1jeib_64{font-family:Courier New,monospace;font-size:12px;color:#999;background:#f5f5f5;padding:4px 8px;border-radius:4px;border:1px solid #e9ecef;word-break:break-all}._info-tag_1jeib_75{border-radius:6px;font-size:12px;padding:4px 8px;font-weight:500;border:none;box-shadow:0 1px 3px #0000001a}._info-tag_1jeib_75._ant-tag-blue_1jeib_83{background:linear-gradient(135deg,#e6f7ff,#bae7ff);color:#1890ff}._song-list-detail-modal_pu8y8_1 ._modal-header_pu8y8_1 ._modal-title_pu8y8_1{margin-bottom:16px}._song-list-detail-modal_pu8y8_1 ._modal-header_pu8y8_1 ._playlist-basic-info_pu8y8_4{display:flex;align-items:flex-start;gap:16px;padding:16px;background:#fafafa;border-radius:8px;margin-bottom:16px}._song-list-detail-modal_pu8y8_1 ._modal-header_pu8y8_1 ._playlist-basic-info_pu8y8_4 ._playlist-info_pu8y8_13{flex:1;display:flex;flex-direction:column;gap:8px}._song-list-detail-modal_pu8y8_1 ._modal-header_pu8y8_1 ._playlist-basic-info_pu8y8_4 ._playlist-info_pu8y8_13 ._playlist-name_pu8y8_19{margin:0;color:#262626}._song-list-detail-modal_pu8y8_1 ._modal-header_pu8y8_1 ._playlist-basic-info_pu8y8_4 ._playlist-info_pu8y8_13 ._creator-info_pu8y8_23{display:flex;align-items:center;gap:8px}._song-list-detail-modal_pu8y8_1 ._modal-header_pu8y8_1 ._playlist-basic-info_pu8y8_4 ._playlist-info_pu8y8_13 ._creator-info_pu8y8_23 ._creator-name_pu8y8_28{font-size:14px;color:#666}._song-list-detail-modal_pu8y8_1 ._modal-header_pu8y8_1 ._playlist-basic-info_pu8y8_4 ._playlist-info_pu8y8_13 ._playlist-stats_pu8y8_32{display:flex;align-items:center;gap:16px}._song-list-detail-modal_pu8y8_1 ._modal-header_pu8y8_1 ._playlist-basic-info_pu8y8_4 ._playlist-info_pu8y8_13 ._playlist-stats_pu8y8_32 ._ant-typography_pu8y8_37{font-size:12px;color:#999}._song-list-detail-modal_pu8y8_1 ._modal-header_pu8y8_1 ._playlist-basic-info_pu8y8_4 ._playlist-info_pu8y8_13 ._playlist-desc_pu8y8_41{margin-top:8px}._song-list-detail-modal_pu8y8_1 ._modal-header_pu8y8_1 ._playlist-basic-info_pu8y8_4 ._playlist-info_pu8y8_13 ._playlist-desc_pu8y8_41 ._description-text_pu8y8_44{font-size:12px;line-height:1.4;color:#666;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;text-overflow:ellipsis}._song-list-detail-modal_pu8y8_1 ._action-buttons_pu8y8_54{margin-top:24px;padding:16px;background:#f8f9fa;border-radius:8px;text-align:center}._song-list-detail-modal_pu8y8_1 ._song-list-section_pu8y8_61 ._ant-table_pu8y8_61 ._ant-table-thead_pu8y8_61>tr>th{background:#fafafa;font-weight:500}._song-list-detail-modal_pu8y8_1 ._song-list-section_pu8y8_61 ._ant-table_pu8y8_61 ._ant-table-tbody_pu8y8_65>tr:hover>td{background:#f5f5f5}._song-list-detail-modal_pu8y8_1 ._song-info_pu8y8_68{display:flex;flex-direction:column;gap:8px}._song-list-detail-modal_pu8y8_1 ._song-info_pu8y8_68 ._song-name_pu8y8_73{font-weight:500;font-size:14px;color:#262626;line-height:1.4}._song-list-detail-modal_pu8y8_1 ._song-info_pu8y8_68 ._song-artist_pu8y8_79{font-size:12px;color:#666;display:flex;align-items:center;flex-wrap:wrap;gap:4px}._song-list-detail-modal_pu8y8_1 ._song-info_pu8y8_68 ._song-artist_pu8y8_79 ._artist-item_pu8y8_87{display:flex;align-items:center}._song-list-detail-modal_pu8y8_1 ._song-info_pu8y8_68 ._song-artist_pu8y8_79 ._artist-item_pu8y8_87 ._artist-name_pu8y8_91{font-size:12px;color:#666}._song-list-detail-modal_pu8y8_1 ._song-info_pu8y8_68 ._song-artist_pu8y8_79 ._artist-item_pu8y8_87 ._artist-separator_pu8y8_95{margin:0 4px;color:#999;font-size:10px}._song-list-detail-modal_pu8y8_1 ._song-info_pu8y8_68 ._song-id_pu8y8_100 ._id-copy_pu8y8_100{font-size:11px}._song-list-detail-modal_pu8y8_1 ._album-info_pu8y8_103{display:flex;align-items:center}._song-list-detail-modal_pu8y8_1 ._album-info_pu8y8_103 ._album-details_pu8y8_107{display:flex;flex-direction:column;gap:4px;flex:1;min-width:0}._song-list-detail-modal_pu8y8_1 ._album-info_pu8y8_103 ._album-details_pu8y8_107 ._album-name_pu8y8_114{font-size:13px;color:#262626;font-weight:500;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}._song-list-detail-modal_pu8y8_1 ._album-info_pu8y8_103 ._album-details_pu8y8_107 ._album-id_pu8y8_122 ._id-copy_pu8y8_100{font-size:11px}._song-list-detail-modal_pu8y8_1 ._singer-list_pu8y8_125{display:flex;flex-direction:column;gap:8px}._song-list-detail-modal_pu8y8_1 ._singer-list_pu8y8_125 ._singer-item_pu8y8_130{display:flex;align-items:center}._song-list-detail-modal_pu8y8_1 ._singer-list_pu8y8_125 ._singer-item_pu8y8_130 ._singer-details_pu8y8_134{display:flex;flex-direction:column;gap:2px;flex:1;min-width:0}._song-list-detail-modal_pu8y8_1 ._singer-list_pu8y8_125 ._singer-item_pu8y8_130 ._singer-details_pu8y8_134 ._singer-name_pu8y8_141{font-size:13px;color:#262626;font-weight:500}._song-list-detail-modal_pu8y8_1 ._singer-list_pu8y8_125 ._singer-item_pu8y8_130 ._singer-details_pu8y8_134 ._id-copy_pu8y8_100{font-size:11px}._song-list-detail-modal_pu8y8_1 ._album-name_pu8y8_114{font-size:12px;color:#666;max-width:150px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}._song-list-detail-modal_pu8y8_1 ._song-duration_pu8y8_157{font-family:monospace;font-size:12px;color:#999}._song-list-search-modal_1h6z1_1 ._play-count-overlay_1h6z1_1{position:absolute;bottom:2px;right:2px;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);color:#fff;font-size:10px;padding:2px 6px;border-radius:4px;font-weight:500;display:flex;align-items:center;gap:2px;min-width:20px;justify-content:center;line-height:1}._song-list-search-modal_1h6z1_1 ._playlist-cover-container_1h6z1_19{position:relative;display:inline-block}._song-list-search-modal_1h6z1_1 ._playlist-info_1h6z1_23{display:flex;flex-direction:column;gap:4px}._song-list-search-modal_1h6z1_1 ._playlist-info_1h6z1_23 ._playlist-name_1h6z1_28{font-weight:500;font-size:14px}._song-list-search-modal_1h6z1_1 ._playlist-info_1h6z1_23 ._creator-info_1h6z1_32{display:flex;align-items:center;gap:4px;font-size:12px;color:#666}._song-list-search-modal_1h6z1_1 ._playlist-info_1h6z1_23 ._creator-name_1h6z1_39{font-size:12px;color:#666}._song-list-search-modal_1h6z1_1 ._playlist-info_1h6z1_23 ._creator-qq_1h6z1_43{font-size:11px;color:#999}._song-list-search-modal_1h6z1_1 ._playlist-info_1h6z1_23 ._introduction_1h6z1_47{font-size:11px;color:#999;max-width:280px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}._song-list-search-modal_1h6z1_1 ._stats-info_1h6z1_55{display:flex;flex-direction:column;gap:4px;align-items:center}._song-list-search-modal_1h6z1_1 ._stats-info_1h6z1_55 ._score-item_1h6z1_61{display:flex;align-items:center;gap:8px}._song-list-search-modal_1h6z1_1 ._stats-info_1h6z1_55 ._score-item_1h6z1_61 ._score-value_1h6z1_66{font-size:14px;font-weight:500}._song-list-search-modal_1h6z1_1 ._stats-info_1h6z1_55 ._version-item_1h6z1_70{display:flex;align-items:center;gap:8px}._song-list-search-modal_1h6z1_1 ._stats-info_1h6z1_55 ._version-item_1h6z1_70 ._version-text_1h6z1_75{font-size:12px;color:#666}._song-list-search-modal_1h6z1_1 ._time-info_1h6z1_79{display:flex;flex-direction:column;gap:4px;align-items:center}._song-list-search-modal_1h6z1_1 ._time-info_1h6z1_79 ._create-time_1h6z1_85{display:flex;align-items:center;gap:4px;font-size:12px}._song-list-search-modal_1h6z1_1 ._time-info_1h6z1_79 ._commit-time_1h6z1_91{font-size:11px;color:#999}._song-list-search-modal_1h6z1_1 ._playlist-id_1h6z1_95{font-size:12px;color:#666;font-family:monospace;background:#f5f5f5;padding:2px 6px;border-radius:4px;cursor:pointer}._song-list-search-modal_1h6z1_1 ._playlist-id_1h6z1_95:hover{background:#e6f7ff;color:#1890ff}._song-search-modal_15iqn_1 ._modal-title_15iqn_1{display:flex;align-items:center;justify-content:space-between}._song-search-modal_15iqn_1 ._modal-title_15iqn_1 ._title-content_15iqn_6{display:flex;align-items:center;gap:12px}._song-search-modal_15iqn_1 ._modal-title_15iqn_1 ._title-content_15iqn_6 ._title-text_15iqn_11{font-size:16px;font-weight:600;color:#333}._song-search-modal_15iqn_1 ._song-table_15iqn_16 ._song-info_15iqn_16{display:flex;align-items:center;gap:12px}._song-search-modal_15iqn_1 ._song-table_15iqn_16 ._song-info_15iqn_16 ._song-cover_15iqn_21{width:60px;height:60px;border-radius:8px;overflow:hidden;background-color:#f5f5f5;display:flex;align-items:center;justify-content:center}._song-search-modal_15iqn_1 ._song-table_15iqn_16 ._song-info_15iqn_16 ._song-details_15iqn_31{display:flex;flex-direction:column;gap:4px}._song-search-modal_15iqn_1 ._song-table_15iqn_16 ._song-info_15iqn_16 ._song-details_15iqn_31 ._song-name_15iqn_36{font-size:14px;font-weight:500;color:#333;line-height:1.4;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:200px}._song-search-modal_15iqn_1 ._song-table_15iqn_16 ._song-info_15iqn_16 ._song-details_15iqn_31 ._song-album_15iqn_46{font-size:12px;color:#666;line-height:1.4;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:200px}._song-search-modal_15iqn_1 ._song-table_15iqn_16 ._singer-info_15iqn_55{display:flex;flex-direction:column;gap:4px}._song-search-modal_15iqn_1 ._song-table_15iqn_16 ._singer-info_15iqn_55 ._singer-name_15iqn_60{font-size:14px;color:#333;line-height:1.4;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:120px}._song-search-modal_15iqn_1 ._song-table_15iqn_16 ._duration_15iqn_69{font-size:14px;color:#666;font-family:monospace}._song-search-modal_15iqn_1 ._song-table_15iqn_16 ._song-id-text_15iqn_74,._song-search-modal_15iqn_1 ._song-table_15iqn_16 ._song-mid-text_15iqn_75{font-size:12px;color:#666;font-family:monospace;background-color:#f5f5f5;padding:2px 6px;border-radius:4px;cursor:pointer}._song-search-modal_15iqn_1 ._song-table_15iqn_16 ._song-id-text_15iqn_74:hover,._song-search-modal_15iqn_1 ._song-table_15iqn_16 ._song-mid-text_15iqn_75:hover{background-color:#e6f7ff;color:#1890ff}._button-group_fmug6_1{position:fixed;right:20px;top:50%;transform:translateY(-20%);width:44px;max-height:400px;overflow-y:auto;background:#fff3;border-radius:22px;box-shadow:0 2px 10px #0006;padding:10px 0;z-index:999;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}._button-group_fmug6_1::-webkit-scrollbar{width:0;background:transparent}._button-group_fmug6_1 .ant-btn{width:36px;height:36px;padding:0;border:none;background:transparent;display:flex;align-items:center;justify-content:center;margin:4px auto;transition:all .3s}._button-group_fmug6_1 .ant-btn:hover{background:#c20c0c1a;color:#fff;transform:scale(1.1)}._button-group_fmug6_1 .ant-btn:active{transform:scale(.95)}._button-group_fmug6_1 .ant-btn .anticon{font-size:20px;color:#666}._button-group_fmug6_1 .ant-btn:hover .anticon{color:#fff}._button-group_fmug6_1 .ant-tooltip .ant-tooltip-inner{background-color:#000c;border-radius:4px;font-size:12px;padding:4px 8px}._button-group_fmug6_1 .ant-tooltip .ant-tooltip-arrow-content{background-color:#000c}::-webkit-scrollbar{width:6px;height:6px}::-webkit-scrollbar-track{background:transparent;border-radius:6px}::-webkit-scrollbar-thumb{background:#8080804d;border-radius:6px;transition:all .2s ease-in-out}::-webkit-scrollbar-thumb:hover{background:#80808080}*{scrollbar-width:thin;scrollbar-color:rgba(128,128,128,.3) transparent} ');

      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function getDefaultExportFromCjs(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
      }
      function getAugmentedNamespace(n) {
        if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
        var f = n.default;
        if (typeof f == "function") {
          var a = function a2() {
            var isInstance = false;
            try {
              isInstance = this instanceof a2;
            } catch {
            }
            if (isInstance) {
              return Reflect.construct(f, arguments, this.constructor);
            }
            return f.apply(this, arguments);
          };
          a.prototype = f.prototype;
        } else a = {};
        Object.defineProperty(a, "__esModule", { value: true });
        Object.keys(n).forEach(function(k) {
          var d = Object.getOwnPropertyDescriptor(n, k);
          Object.defineProperty(a, k, d.get ? d : {
            enumerable: true,
            get: function() {
              return n[k];
            }
          });
        });
        return a;
      }
      var jsxRuntime = { exports: {} };
      var reactJsxRuntime_production_min = {};
      /**
       * @license React
       * react-jsx-runtime.production.min.js
       *
       * Copyright (c) Facebook, Inc. and its affiliates.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */
      var hasRequiredReactJsxRuntime_production_min;
      function requireReactJsxRuntime_production_min() {
        if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
        hasRequiredReactJsxRuntime_production_min = 1;
        var f = require$$0, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
        function q(c, a, g) {
          var b, d = {}, e = null, h = null;
          void 0 !== g && (e = "" + g);
          void 0 !== a.key && (e = "" + a.key);
          void 0 !== a.ref && (h = a.ref);
          for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
          if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
          return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
        }
        reactJsxRuntime_production_min.Fragment = l;
        reactJsxRuntime_production_min.jsx = q;
        reactJsxRuntime_production_min.jsxs = q;
        return reactJsxRuntime_production_min;
      }
      var hasRequiredJsxRuntime;
      function requireJsxRuntime() {
        if (hasRequiredJsxRuntime) return jsxRuntime.exports;
        hasRequiredJsxRuntime = 1;
        {
          jsxRuntime.exports = requireReactJsxRuntime_production_min();
        }
        return jsxRuntime.exports;
      }
      var jsxRuntimeExports = requireJsxRuntime();
      var zh_CN$6 = {};
      var interopRequireDefault = { exports: {} };
      var hasRequiredInteropRequireDefault;
      function requireInteropRequireDefault() {
        if (hasRequiredInteropRequireDefault) return interopRequireDefault.exports;
        hasRequiredInteropRequireDefault = 1;
        (function(module) {
          function _interopRequireDefault(e) {
            return e && e.__esModule ? e : {
              "default": e
            };
          }
          module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(interopRequireDefault);
        return interopRequireDefault.exports;
      }
      var zh_CN$5 = {};
      var hasRequiredZh_CN$6;
      function requireZh_CN$6() {
        if (hasRequiredZh_CN$6) return zh_CN$5;
        hasRequiredZh_CN$6 = 1;
        Object.defineProperty(zh_CN$5, "__esModule", {
          value: true
        });
        zh_CN$5.default = void 0;
        var locale = {
          // Options
          items_per_page: "条/页",
          jump_to: "跳至",
          jump_to_confirm: "确定",
          page: "页",
          // Pagination
          prev_page: "上一页",
          next_page: "下一页",
          prev_5: "向前 5 页",
          next_5: "向后 5 页",
          prev_3: "向前 3 页",
          next_3: "向后 3 页",
          page_size: "页码"
        };
        zh_CN$5.default = locale;
        return zh_CN$5;
      }
      var zh_CN$4 = {};
      var zh_CN$3 = {};
      var zh_CN$2 = {};
      var objectSpread2 = { exports: {} };
      var defineProperty = { exports: {} };
      var toPropertyKey = { exports: {} };
      var _typeof = { exports: {} };
      var hasRequired_typeof;
      function require_typeof() {
        if (hasRequired_typeof) return _typeof.exports;
        hasRequired_typeof = 1;
        (function(module) {
          function _typeof2(o) {
            "@babel/helpers - typeof";
            return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
              return typeof o2;
            } : function(o2) {
              return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
            }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o);
          }
          module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(_typeof);
        return _typeof.exports;
      }
      var toPrimitive = { exports: {} };
      var hasRequiredToPrimitive;
      function requireToPrimitive() {
        if (hasRequiredToPrimitive) return toPrimitive.exports;
        hasRequiredToPrimitive = 1;
        (function(module) {
          var _typeof2 = require_typeof()["default"];
          function toPrimitive2(t, r) {
            if ("object" != _typeof2(t) || !t) return t;
            var e = t[Symbol.toPrimitive];
            if (void 0 !== e) {
              var i = e.call(t, r || "default");
              if ("object" != _typeof2(i)) return i;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === r ? String : Number)(t);
          }
          module.exports = toPrimitive2, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(toPrimitive);
        return toPrimitive.exports;
      }
      var hasRequiredToPropertyKey;
      function requireToPropertyKey() {
        if (hasRequiredToPropertyKey) return toPropertyKey.exports;
        hasRequiredToPropertyKey = 1;
        (function(module) {
          var _typeof2 = require_typeof()["default"];
          var toPrimitive2 = requireToPrimitive();
          function toPropertyKey2(t) {
            var i = toPrimitive2(t, "string");
            return "symbol" == _typeof2(i) ? i : i + "";
          }
          module.exports = toPropertyKey2, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(toPropertyKey);
        return toPropertyKey.exports;
      }
      var hasRequiredDefineProperty;
      function requireDefineProperty() {
        if (hasRequiredDefineProperty) return defineProperty.exports;
        hasRequiredDefineProperty = 1;
        (function(module) {
          var toPropertyKey2 = requireToPropertyKey();
          function _defineProperty(e, r, t) {
            return (r = toPropertyKey2(r)) in e ? Object.defineProperty(e, r, {
              value: t,
              enumerable: true,
              configurable: true,
              writable: true
            }) : e[r] = t, e;
          }
          module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(defineProperty);
        return defineProperty.exports;
      }
      var hasRequiredObjectSpread2;
      function requireObjectSpread2() {
        if (hasRequiredObjectSpread2) return objectSpread2.exports;
        hasRequiredObjectSpread2 = 1;
        (function(module) {
          var defineProperty2 = requireDefineProperty();
          function ownKeys(e, r) {
            var t = Object.keys(e);
            if (Object.getOwnPropertySymbols) {
              var o = Object.getOwnPropertySymbols(e);
              r && (o = o.filter(function(r2) {
                return Object.getOwnPropertyDescriptor(e, r2).enumerable;
              })), t.push.apply(t, o);
            }
            return t;
          }
          function _objectSpread2(e) {
            for (var r = 1; r < arguments.length; r++) {
              var t = null != arguments[r] ? arguments[r] : {};
              r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
                defineProperty2(e, r2, t[r2]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
                Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
              });
            }
            return e;
          }
          module.exports = _objectSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(objectSpread2);
        return objectSpread2.exports;
      }
      var common$1 = {};
      var hasRequiredCommon$1;
      function requireCommon$1() {
        if (hasRequiredCommon$1) return common$1;
        hasRequiredCommon$1 = 1;
        Object.defineProperty(common$1, "__esModule", {
          value: true
        });
        common$1.commonLocale = void 0;
        common$1.commonLocale = {
          yearFormat: "YYYY",
          dayFormat: "D",
          cellMeridiemFormat: "A",
          monthBeforeYear: true
        };
        return common$1;
      }
      var hasRequiredZh_CN$5;
      function requireZh_CN$5() {
        if (hasRequiredZh_CN$5) return zh_CN$2;
        hasRequiredZh_CN$5 = 1;
        var _interopRequireDefault = requireInteropRequireDefault().default;
        Object.defineProperty(zh_CN$2, "__esModule", {
          value: true
        });
        zh_CN$2.default = void 0;
        var _objectSpread2 = _interopRequireDefault(requireObjectSpread2());
        var _common = requireCommon$1();
        var locale = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, _common.commonLocale), {}, {
          locale: "zh_CN",
          today: "今天",
          now: "此刻",
          backToToday: "返回今天",
          ok: "确定",
          timeSelect: "选择时间",
          dateSelect: "选择日期",
          weekSelect: "选择周",
          clear: "清除",
          week: "周",
          month: "月",
          year: "年",
          previousMonth: "上个月 (翻页上键)",
          nextMonth: "下个月 (翻页下键)",
          monthSelect: "选择月份",
          yearSelect: "选择年份",
          decadeSelect: "选择年代",
          previousYear: "上一年 (Control键加左方向键)",
          nextYear: "下一年 (Control键加右方向键)",
          previousDecade: "上一年代",
          nextDecade: "下一年代",
          previousCentury: "上一世纪",
          nextCentury: "下一世纪",
          yearFormat: "YYYY年",
          cellDateFormat: "D",
          monthBeforeYear: false
        });
        zh_CN$2.default = locale;
        return zh_CN$2;
      }
      var zh_CN$1 = {};
      var hasRequiredZh_CN$4;
      function requireZh_CN$4() {
        if (hasRequiredZh_CN$4) return zh_CN$1;
        hasRequiredZh_CN$4 = 1;
        Object.defineProperty(zh_CN$1, "__esModule", {
          value: true
        });
        zh_CN$1.default = void 0;
        const locale = {
          placeholder: "请选择时间",
          rangePlaceholder: ["开始时间", "结束时间"]
        };
        zh_CN$1.default = locale;
        return zh_CN$1;
      }
      var hasRequiredZh_CN$3;
      function requireZh_CN$3() {
        if (hasRequiredZh_CN$3) return zh_CN$3;
        hasRequiredZh_CN$3 = 1;
        var _interopRequireDefault = requireInteropRequireDefault().default;
        Object.defineProperty(zh_CN$3, "__esModule", {
          value: true
        });
        zh_CN$3.default = void 0;
        var _zh_CN = _interopRequireDefault(requireZh_CN$5());
        var _zh_CN2 = _interopRequireDefault(/* @__PURE__ */ requireZh_CN$4());
        const locale = {
          lang: Object.assign({
            placeholder: "请选择日期",
            yearPlaceholder: "请选择年份",
            quarterPlaceholder: "请选择季度",
            monthPlaceholder: "请选择月份",
            weekPlaceholder: "请选择周",
            rangePlaceholder: ["开始日期", "结束日期"],
            rangeYearPlaceholder: ["开始年份", "结束年份"],
            rangeMonthPlaceholder: ["开始月份", "结束月份"],
            rangeQuarterPlaceholder: ["开始季度", "结束季度"],
            rangeWeekPlaceholder: ["开始周", "结束周"]
          }, _zh_CN.default),
          timePickerLocale: Object.assign({}, _zh_CN2.default)
        };
        locale.lang.ok = "确定";
        zh_CN$3.default = locale;
        return zh_CN$3;
      }
      var hasRequiredZh_CN$2;
      function requireZh_CN$2() {
        if (hasRequiredZh_CN$2) return zh_CN$4;
        hasRequiredZh_CN$2 = 1;
        var _interopRequireDefault = requireInteropRequireDefault().default;
        Object.defineProperty(zh_CN$4, "__esModule", {
          value: true
        });
        zh_CN$4.default = void 0;
        var _zh_CN = _interopRequireDefault(/* @__PURE__ */ requireZh_CN$3());
        zh_CN$4.default = _zh_CN.default;
        return zh_CN$4;
      }
      var hasRequiredZh_CN$1;
      function requireZh_CN$1() {
        if (hasRequiredZh_CN$1) return zh_CN$6;
        hasRequiredZh_CN$1 = 1;
        var _interopRequireDefault = requireInteropRequireDefault().default;
        Object.defineProperty(zh_CN$6, "__esModule", {
          value: true
        });
        zh_CN$6.default = void 0;
        var _zh_CN = _interopRequireDefault(requireZh_CN$6());
        var _zh_CN2 = _interopRequireDefault(/* @__PURE__ */ requireZh_CN$2());
        var _zh_CN3 = _interopRequireDefault(/* @__PURE__ */ requireZh_CN$3());
        var _zh_CN4 = _interopRequireDefault(/* @__PURE__ */ requireZh_CN$4());
        const typeTemplate = "${label}不是一个有效的${type}";
        const localeValues = {
          locale: "zh-cn",
          Pagination: _zh_CN.default,
          DatePicker: _zh_CN3.default,
          TimePicker: _zh_CN4.default,
          Calendar: _zh_CN2.default,
          // locales for all components
          global: {
            placeholder: "请选择",
            close: "关闭"
          },
          Table: {
            filterTitle: "筛选",
            filterConfirm: "确定",
            filterReset: "重置",
            filterEmptyText: "无筛选项",
            filterCheckAll: "全选",
            filterSearchPlaceholder: "在筛选项中搜索",
            emptyText: "暂无数据",
            selectAll: "全选当页",
            selectInvert: "反选当页",
            selectNone: "清空所有",
            selectionAll: "全选所有",
            sortTitle: "排序",
            expand: "展开行",
            collapse: "关闭行",
            triggerDesc: "点击降序",
            triggerAsc: "点击升序",
            cancelSort: "取消排序"
          },
          Modal: {
            okText: "确定",
            cancelText: "取消",
            justOkText: "知道了"
          },
          Tour: {
            Next: "下一步",
            Previous: "上一步",
            Finish: "结束导览"
          },
          Popconfirm: {
            cancelText: "取消",
            okText: "确定"
          },
          Transfer: {
            titles: ["", ""],
            searchPlaceholder: "请输入搜索内容",
            itemUnit: "项",
            itemsUnit: "项",
            remove: "删除",
            selectCurrent: "全选当页",
            removeCurrent: "删除当页",
            selectAll: "全选所有",
            deselectAll: "取消全选",
            removeAll: "删除全部",
            selectInvert: "反选当页"
          },
          Upload: {
            uploading: "文件上传中",
            removeFile: "删除文件",
            uploadError: "上传错误",
            previewFile: "预览文件",
            downloadFile: "下载文件"
          },
          Empty: {
            description: "暂无数据"
          },
          Icon: {
            icon: "图标"
          },
          Text: {
            edit: "编辑",
            copy: "复制",
            copied: "复制成功",
            expand: "展开",
            collapse: "收起"
          },
          Form: {
            optional: "（可选）",
            defaultValidateMessages: {
              default: "字段验证错误${label}",
              required: "请输入${label}",
              enum: "${label}必须是其中一个[${enum}]",
              whitespace: "${label}不能为空字符",
              date: {
                format: "${label}日期格式无效",
                parse: "${label}不能转换为日期",
                invalid: "${label}是一个无效日期"
              },
              types: {
                string: typeTemplate,
                method: typeTemplate,
                array: typeTemplate,
                object: typeTemplate,
                number: typeTemplate,
                date: typeTemplate,
                boolean: typeTemplate,
                integer: typeTemplate,
                float: typeTemplate,
                regexp: typeTemplate,
                email: typeTemplate,
                url: typeTemplate,
                hex: typeTemplate
              },
              string: {
                len: "${label}须为${len}个字符",
                min: "${label}最少${min}个字符",
                max: "${label}最多${max}个字符",
                range: "${label}须在${min}-${max}字符之间"
              },
              number: {
                len: "${label}必须等于${len}",
                min: "${label}最小值为${min}",
                max: "${label}最大值为${max}",
                range: "${label}须在${min}-${max}之间"
              },
              array: {
                len: "须为${len}个${label}",
                min: "最少${min}个${label}",
                max: "最多${max}个${label}",
                range: "${label}数量须在${min}-${max}之间"
              },
              pattern: {
                mismatch: "${label}与模式不匹配${pattern}"
              }
            }
          },
          Image: {
            preview: "预览"
          },
          QRCode: {
            expired: "二维码过期",
            refresh: "点击刷新",
            scanned: "已扫描"
          },
          ColorPicker: {
            presetEmpty: "暂无",
            transparent: "无色",
            singleColor: "单色",
            gradientColor: "渐变色"
          }
        };
        zh_CN$6.default = localeValues;
        return zh_CN$6;
      }
      var zh_CN;
      var hasRequiredZh_CN;
      function requireZh_CN() {
        if (hasRequiredZh_CN) return zh_CN;
        hasRequiredZh_CN = 1;
        zh_CN = /* @__PURE__ */ requireZh_CN$1();
        return zh_CN;
      }
      var zh_CNExports = /* @__PURE__ */ requireZh_CN();
      const zhCN = /* @__PURE__ */ getDefaultExportFromCjs(zh_CNExports);
      var client = {};
      var hasRequiredClient;
      function requireClient() {
        if (hasRequiredClient) return client;
        hasRequiredClient = 1;
        var m = require$$0$1;
        {
          client.createRoot = m.createRoot;
          client.hydrateRoot = m.hydrateRoot;
        }
        return client;
      }
      var clientExports = requireClient();
      const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(clientExports);
      const useCompRef = (_component) => {
        const initObj = {};
        const proxy = new Proxy(initObj, {
          get: (target, prop) => {
            console.log("target", target);
            console.log("prop", prop);
            if (target === initObj) {
              console.warn("是否忘记了传递组件Ref?");
            }
            return null;
          }
        });
        return useRef(proxy);
      };
      const isDev = false;
      const defaultFunctionConfig = {
        /**
         * 是否开启搜索
         */
        enableSearch: isDev,
        /**
         * 是否开启GitHub信息
         */
        enableGithubInfo: true,
        /**
         * 是否开启功能开关Tab
         */
        enableFunctionSwitchTab: true,
        /**
         * 是否开启下载设置Tab
         */
        enableDownloadSetting: true,
        /**
         * 并发上传歌曲数量
         */
        uploadConcurrency: 6,
        /**
         * 是否开启测试Modal
         */
        enableTestModal: isDev,
        /**
         * 演唱会关键词
         */
        liveKeywords: ["演唱会", "Live", "live"]
      };
      const defaultDownloadConfig = {
        /** 下载音质 */
        quality: "flac",
        /** 是否下载歌词 */
        downloadLyric: true,
        /** 是否内嵌歌词封面 */
        embedLyricCover: true,
        /** 是否内嵌歌曲信息 */
        embedSongInfo: true
      };
      var createUpdateEffect = function(hook) {
        return function(effect, deps) {
          var isMounted = useRef(false);
          hook(function() {
            return function() {
              isMounted.current = false;
            };
          }, []);
          hook(function() {
            if (!isMounted.current) {
              isMounted.current = true;
            } else {
              return effect();
            }
          }, deps);
        };
      };
      function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"])) m.call(i);
          } finally {
            if (e) throw e.error;
          }
        }
        return ar;
      }
      typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
        var e = new Error(message2);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
      };
      var isFunction = function(value) {
        return typeof value === "function";
      };
      var isUndef = function(value) {
        return typeof value === "undefined";
      };
      var useMemoizedFn = function(fn) {
        var fnRef = useRef(fn);
        fnRef.current = useMemo(function() {
          return fn;
        }, [fn]);
        var memoizedFn = useRef(void 0);
        if (!memoizedFn.current) {
          memoizedFn.current = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return fnRef.current.apply(this, args);
          };
        }
        return memoizedFn.current;
      };
      const useUpdateEffect = createUpdateEffect(useEffect);
      function depsAreSame(oldDeps, deps) {
        if (oldDeps === deps) {
          return true;
        }
        for (var i = 0; i < oldDeps.length; i++) {
          if (!Object.is(oldDeps[i], deps[i])) {
            return false;
          }
        }
        return true;
      }
      function useLatest(value) {
        var ref = useRef(value);
        ref.current = value;
        return ref;
      }
      var useUnmount = function(fn) {
        var fnRef = useLatest(fn);
        useEffect(function() {
          return function() {
            fnRef.current();
          };
        }, []);
      };
      var isBrowser$1 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
      function getTargetElement(target, defaultElement) {
        if (!isBrowser$1) {
          return void 0;
        }
        if (!target) {
          return defaultElement;
        }
        var targetElement;
        if (isFunction(target)) {
          targetElement = target();
        } else if ("current" in target) {
          targetElement = target.current;
        } else {
          targetElement = target;
        }
        return targetElement;
      }
      var createEffectWithTarget = function(useEffectType) {
        var useEffectWithTarget2 = function(effect, deps, target) {
          var hasInitRef = useRef(false);
          var lastElementRef = useRef([]);
          var lastDepsRef = useRef([]);
          var unLoadRef = useRef(void 0);
          useEffectType(function() {
            var _a2;
            var targets = Array.isArray(target) ? target : [target];
            var els = targets.map(function(item) {
              return getTargetElement(item);
            });
            if (!hasInitRef.current) {
              hasInitRef.current = true;
              lastElementRef.current = els;
              lastDepsRef.current = deps;
              unLoadRef.current = effect();
              return;
            }
            if (els.length !== lastElementRef.current.length || !depsAreSame(lastElementRef.current, els) || !depsAreSame(lastDepsRef.current, deps)) {
              (_a2 = unLoadRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unLoadRef);
              lastElementRef.current = els;
              lastDepsRef.current = deps;
              unLoadRef.current = effect();
            }
          });
          useUnmount(function() {
            var _a2;
            (_a2 = unLoadRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unLoadRef);
            hasInitRef.current = false;
          });
        };
        return useEffectWithTarget2;
      };
      var useEffectWithTarget$1 = createEffectWithTarget(useEffect);
      var dayjs_min$1 = { exports: {} };
      var dayjs_min = dayjs_min$1.exports;
      var hasRequiredDayjs_min;
      function requireDayjs_min() {
        if (hasRequiredDayjs_min) return dayjs_min$1.exports;
        hasRequiredDayjs_min = 1;
        (function(module, exports) {
          !(function(t, e) {
            module.exports = e();
          })(dayjs_min, (function() {
            var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
              var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
              return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
            } }, m = function(t2, e2, n2) {
              var r2 = String(t2);
              return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
            }, v = { s: m, z: function(t2) {
              var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
              return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
            }, m: function t2(e2, n2) {
              if (e2.date() < n2.date()) return -t2(n2, e2);
              var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
              return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
            }, a: function(t2) {
              return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
            }, p: function(t2) {
              return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
            }, u: function(t2) {
              return void 0 === t2;
            } }, g = "en", D = {};
            D[g] = M;
            var p = "$isDayjsObject", S = function(t2) {
              return t2 instanceof _ || !(!t2 || !t2[p]);
            }, w = function t2(e2, n2, r2) {
              var i2;
              if (!e2) return g;
              if ("string" == typeof e2) {
                var s2 = e2.toLowerCase();
                D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
                var u2 = e2.split("-");
                if (!i2 && u2.length > 1) return t2(u2[0]);
              } else {
                var a2 = e2.name;
                D[a2] = e2, i2 = a2;
              }
              return !r2 && i2 && (g = i2), i2 || !r2 && g;
            }, O = function(t2, e2) {
              if (S(t2)) return t2.clone();
              var n2 = "object" == typeof e2 ? e2 : {};
              return n2.date = t2, n2.args = arguments, new _(n2);
            }, b = v;
            b.l = w, b.i = S, b.w = function(t2, e2) {
              return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
            };
            var _ = (function() {
              function M2(t2) {
                this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
              }
              var m2 = M2.prototype;
              return m2.parse = function(t2) {
                this.$d = (function(t3) {
                  var e2 = t3.date, n2 = t3.utc;
                  if (null === e2) return /* @__PURE__ */ new Date(NaN);
                  if (b.u(e2)) return /* @__PURE__ */ new Date();
                  if (e2 instanceof Date) return new Date(e2);
                  if ("string" == typeof e2 && !/Z$/i.test(e2)) {
                    var r2 = e2.match($);
                    if (r2) {
                      var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                      return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
                    }
                  }
                  return new Date(e2);
                })(t2), this.init();
              }, m2.init = function() {
                var t2 = this.$d;
                this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
              }, m2.$utils = function() {
                return b;
              }, m2.isValid = function() {
                return !(this.$d.toString() === l);
              }, m2.isSame = function(t2, e2) {
                var n2 = O(t2);
                return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
              }, m2.isAfter = function(t2, e2) {
                return O(t2) < this.startOf(e2);
              }, m2.isBefore = function(t2, e2) {
                return this.endOf(e2) < O(t2);
              }, m2.$g = function(t2, e2, n2) {
                return b.u(t2) ? this[e2] : this.set(n2, t2);
              }, m2.unix = function() {
                return Math.floor(this.valueOf() / 1e3);
              }, m2.valueOf = function() {
                return this.$d.getTime();
              }, m2.startOf = function(t2, e2) {
                var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
                  var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
                  return r2 ? i2 : i2.endOf(a);
                }, $2 = function(t3, e3) {
                  return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
                }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
                switch (f2) {
                  case h:
                    return r2 ? l2(1, 0) : l2(31, 11);
                  case c:
                    return r2 ? l2(1, M3) : l2(0, M3 + 1);
                  case o:
                    var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
                    return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
                  case a:
                  case d:
                    return $2(v2 + "Hours", 0);
                  case u:
                    return $2(v2 + "Minutes", 1);
                  case s:
                    return $2(v2 + "Seconds", 2);
                  case i:
                    return $2(v2 + "Milliseconds", 3);
                  default:
                    return this.clone();
                }
              }, m2.endOf = function(t2) {
                return this.startOf(t2, false);
              }, m2.$set = function(t2, e2) {
                var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
                if (o2 === c || o2 === h) {
                  var y2 = this.clone().set(d, 1);
                  y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
                } else l2 && this.$d[l2]($2);
                return this.init(), this;
              }, m2.set = function(t2, e2) {
                return this.clone().$set(t2, e2);
              }, m2.get = function(t2) {
                return this[b.p(t2)]();
              }, m2.add = function(r2, f2) {
                var d2, l2 = this;
                r2 = Number(r2);
                var $2 = b.p(f2), y2 = function(t2) {
                  var e2 = O(l2);
                  return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
                };
                if ($2 === c) return this.set(c, this.$M + r2);
                if ($2 === h) return this.set(h, this.$y + r2);
                if ($2 === a) return y2(1);
                if ($2 === o) return y2(7);
                var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
                return b.w(m3, this);
              }, m2.subtract = function(t2, e2) {
                return this.add(-1 * t2, e2);
              }, m2.format = function(t2) {
                var e2 = this, n2 = this.$locale();
                if (!this.isValid()) return n2.invalidDate || l;
                var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
                  return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
                }, d2 = function(t3) {
                  return b.s(s2 % 12 || 12, t3, "0");
                }, $2 = f2 || function(t3, e3, n3) {
                  var r3 = t3 < 12 ? "AM" : "PM";
                  return n3 ? r3.toLowerCase() : r3;
                };
                return r2.replace(y, (function(t3, r3) {
                  return r3 || (function(t4) {
                    switch (t4) {
                      case "YY":
                        return String(e2.$y).slice(-2);
                      case "YYYY":
                        return b.s(e2.$y, 4, "0");
                      case "M":
                        return a2 + 1;
                      case "MM":
                        return b.s(a2 + 1, 2, "0");
                      case "MMM":
                        return h2(n2.monthsShort, a2, c2, 3);
                      case "MMMM":
                        return h2(c2, a2);
                      case "D":
                        return e2.$D;
                      case "DD":
                        return b.s(e2.$D, 2, "0");
                      case "d":
                        return String(e2.$W);
                      case "dd":
                        return h2(n2.weekdaysMin, e2.$W, o2, 2);
                      case "ddd":
                        return h2(n2.weekdaysShort, e2.$W, o2, 3);
                      case "dddd":
                        return o2[e2.$W];
                      case "H":
                        return String(s2);
                      case "HH":
                        return b.s(s2, 2, "0");
                      case "h":
                        return d2(1);
                      case "hh":
                        return d2(2);
                      case "a":
                        return $2(s2, u2, true);
                      case "A":
                        return $2(s2, u2, false);
                      case "m":
                        return String(u2);
                      case "mm":
                        return b.s(u2, 2, "0");
                      case "s":
                        return String(e2.$s);
                      case "ss":
                        return b.s(e2.$s, 2, "0");
                      case "SSS":
                        return b.s(e2.$ms, 3, "0");
                      case "Z":
                        return i2;
                    }
                    return null;
                  })(t3) || i2.replace(":", "");
                }));
              }, m2.utcOffset = function() {
                return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
              }, m2.diff = function(r2, d2, l2) {
                var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
                  return b.m(y2, m3);
                };
                switch (M3) {
                  case h:
                    $2 = D2() / 12;
                    break;
                  case c:
                    $2 = D2();
                    break;
                  case f:
                    $2 = D2() / 3;
                    break;
                  case o:
                    $2 = (g2 - v2) / 6048e5;
                    break;
                  case a:
                    $2 = (g2 - v2) / 864e5;
                    break;
                  case u:
                    $2 = g2 / n;
                    break;
                  case s:
                    $2 = g2 / e;
                    break;
                  case i:
                    $2 = g2 / t;
                    break;
                  default:
                    $2 = g2;
                }
                return l2 ? $2 : b.a($2);
              }, m2.daysInMonth = function() {
                return this.endOf(c).$D;
              }, m2.$locale = function() {
                return D[this.$L];
              }, m2.locale = function(t2, e2) {
                if (!t2) return this.$L;
                var n2 = this.clone(), r2 = w(t2, e2, true);
                return r2 && (n2.$L = r2), n2;
              }, m2.clone = function() {
                return b.w(this.$d, this);
              }, m2.toDate = function() {
                return new Date(this.valueOf());
              }, m2.toJSON = function() {
                return this.isValid() ? this.toISOString() : null;
              }, m2.toISOString = function() {
                return this.$d.toISOString();
              }, m2.toString = function() {
                return this.$d.toUTCString();
              }, M2;
            })(), k = _.prototype;
            return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach((function(t2) {
              k[t2[1]] = function(e2) {
                return this.$g(e2, t2[0], t2[1]);
              };
            })), O.extend = function(t2, e2) {
              return t2.$i || (t2(e2, _, O), t2.$i = true), O;
            }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
              return O(1e3 * t2);
            }, O.en = D[g], O.Ls = D, O.p = {}, O;
          }));
        })(dayjs_min$1);
        return dayjs_min$1.exports;
      }
      var dayjs_minExports = requireDayjs_min();
      const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
      function useEventListener(eventName, handler, options) {
        if (options === void 0) {
          options = {};
        }
        var _a2 = options.enable, enable = _a2 === void 0 ? true : _a2;
        var handlerRef = useLatest(handler);
        useEffectWithTarget$1(function() {
          if (!enable) {
            return;
          }
          var targetElement = getTargetElement(options.target, window);
          if (!(targetElement === null || targetElement === void 0 ? void 0 : targetElement.addEventListener)) {
            return;
          }
          var eventListener = function(event) {
            return handlerRef.current(event);
          };
          var eventNameArray = Array.isArray(eventName) ? eventName : [eventName];
          eventNameArray.forEach(function(event) {
            targetElement.addEventListener(event, eventListener, {
              capture: options.capture,
              once: options.once,
              passive: options.passive
            });
          });
          return function() {
            eventNameArray.forEach(function(event) {
              targetElement.removeEventListener(event, eventListener, {
                capture: options.capture
              });
            });
          };
        }, [eventName, options.capture, options.once, options.passive, enable], options.target);
      }
      var SYNC_STORAGE_EVENT_NAME = "AHOOKS_SYNC_STORAGE_EVENT_NAME";
      function createUseStorageState(getStorage) {
        function useStorageState(key, options) {
          if (options === void 0) {
            options = {};
          }
          var storage;
          var _a2 = options.listenStorageChange, listenStorageChange = _a2 === void 0 ? false : _a2, _b2 = options.onError, onError = _b2 === void 0 ? function(e) {
            console.error(e);
          } : _b2;
          try {
            storage = getStorage();
          } catch (err2) {
            onError(err2);
          }
          var serializer = function(value) {
            if (options.serializer) {
              return options.serializer(value);
            }
            return JSON.stringify(value);
          };
          var deserializer = function(value) {
            if (options.deserializer) {
              return options.deserializer(value);
            }
            return JSON.parse(value);
          };
          function getStoredValue() {
            try {
              var raw = storage === null || storage === void 0 ? void 0 : storage.getItem(key);
              if (raw) {
                return deserializer(raw);
              }
            } catch (e) {
              onError(e);
            }
            if (isFunction(options.defaultValue)) {
              return options.defaultValue();
            }
            return options.defaultValue;
          }
          var _c = __read(useState(getStoredValue), 2), state = _c[0], setState = _c[1];
          useUpdateEffect(function() {
            setState(getStoredValue());
          }, [key]);
          var updateState = function(value) {
            var currentState = isFunction(value) ? value(state) : value;
            if (!listenStorageChange) {
              setState(currentState);
            }
            try {
              var newValue = void 0;
              var oldValue = storage === null || storage === void 0 ? void 0 : storage.getItem(key);
              if (isUndef(currentState)) {
                newValue = null;
                storage === null || storage === void 0 ? void 0 : storage.removeItem(key);
              } else {
                newValue = serializer(currentState);
                storage === null || storage === void 0 ? void 0 : storage.setItem(key, newValue);
              }
              dispatchEvent(
                // send custom event to communicate within same page
                // importantly this should not be a StorageEvent since those cannot
                // be constructed with a non-built-in storage area
                new CustomEvent(SYNC_STORAGE_EVENT_NAME, {
                  detail: {
                    key,
                    newValue,
                    oldValue,
                    storageArea: storage
                  }
                })
              );
            } catch (e) {
              onError(e);
            }
          };
          var syncState = function(event) {
            if (event.key !== key || event.storageArea !== storage) {
              return;
            }
            setState(getStoredValue());
          };
          var syncStateFromCustomEvent = function(event) {
            syncState(event.detail);
          };
          useEventListener("storage", syncState, {
            enable: listenStorageChange
          });
          useEventListener(SYNC_STORAGE_EVENT_NAME, syncStateFromCustomEvent, {
            enable: listenStorageChange
          });
          return [state, useMemoizedFn(updateState)];
        }
        return useStorageState;
      }
      var useLocalStorageState = createUseStorageState(function() {
        return isBrowser$1 ? localStorage : void 0;
      });
      function useRafState(initialState) {
        var ref = useRef(0);
        var _a2 = __read(useState(initialState), 2), state = _a2[0], setState = _a2[1];
        var setRafState = useCallback(function(value) {
          cancelAnimationFrame(ref.current);
          ref.current = requestAnimationFrame(function() {
            setState(value);
          });
        }, []);
        useUnmount(function() {
          cancelAnimationFrame(ref.current);
        });
        return [state, setRafState];
      }
      var MapShim = (function() {
        if (typeof Map !== "undefined") {
          return Map;
        }
        function getIndex(arr, key) {
          var result = -1;
          arr.some(function(entry, index2) {
            if (entry[0] === key) {
              result = index2;
              return true;
            }
            return false;
          });
          return result;
        }
        return (
          /** @class */
          (function() {
            function class_1() {
              this.__entries__ = [];
            }
            Object.defineProperty(class_1.prototype, "size", {
              /**
               * @returns {boolean}
               */
              get: function() {
                return this.__entries__.length;
              },
              enumerable: true,
              configurable: true
            });
            class_1.prototype.get = function(key) {
              var index2 = getIndex(this.__entries__, key);
              var entry = this.__entries__[index2];
              return entry && entry[1];
            };
            class_1.prototype.set = function(key, value) {
              var index2 = getIndex(this.__entries__, key);
              if (~index2) {
                this.__entries__[index2][1] = value;
              } else {
                this.__entries__.push([key, value]);
              }
            };
            class_1.prototype.delete = function(key) {
              var entries = this.__entries__;
              var index2 = getIndex(entries, key);
              if (~index2) {
                entries.splice(index2, 1);
              }
            };
            class_1.prototype.has = function(key) {
              return !!~getIndex(this.__entries__, key);
            };
            class_1.prototype.clear = function() {
              this.__entries__.splice(0);
            };
            class_1.prototype.forEach = function(callback, ctx) {
              if (ctx === void 0) {
                ctx = null;
              }
              for (var _i = 0, _a2 = this.__entries__; _i < _a2.length; _i++) {
                var entry = _a2[_i];
                callback.call(ctx, entry[1], entry[0]);
              }
            };
            return class_1;
          })()
        );
      })();
      var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
      var global$1 = (function() {
        if (typeof global !== "undefined" && global.Math === Math) {
          return global;
        }
        if (typeof self !== "undefined" && self.Math === Math) {
          return self;
        }
        if (typeof window !== "undefined" && window.Math === Math) {
          return window;
        }
        return Function("return this")();
      })();
      var requestAnimationFrame$1 = (function() {
        if (typeof requestAnimationFrame === "function") {
          return requestAnimationFrame.bind(global$1);
        }
        return function(callback) {
          return setTimeout(function() {
            return callback(Date.now());
          }, 1e3 / 60);
        };
      })();
      var trailingTimeout = 2;
      function throttle(callback, delay) {
        var leadingCall = false, trailingCall = false, lastCallTime = 0;
        function resolvePending() {
          if (leadingCall) {
            leadingCall = false;
            callback();
          }
          if (trailingCall) {
            proxy();
          }
        }
        function timeoutCallback() {
          requestAnimationFrame$1(resolvePending);
        }
        function proxy() {
          var timeStamp = Date.now();
          if (leadingCall) {
            if (timeStamp - lastCallTime < trailingTimeout) {
              return;
            }
            trailingCall = true;
          } else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
          }
          lastCallTime = timeStamp;
        }
        return proxy;
      }
      var REFRESH_DELAY = 20;
      var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
      var mutationObserverSupported = typeof MutationObserver !== "undefined";
      var ResizeObserverController = (
        /** @class */
        (function() {
          function ResizeObserverController2() {
            this.connected_ = false;
            this.mutationEventsAdded_ = false;
            this.mutationsObserver_ = null;
            this.observers_ = [];
            this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
            this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
          }
          ResizeObserverController2.prototype.addObserver = function(observer) {
            if (!~this.observers_.indexOf(observer)) {
              this.observers_.push(observer);
            }
            if (!this.connected_) {
              this.connect_();
            }
          };
          ResizeObserverController2.prototype.removeObserver = function(observer) {
            var observers2 = this.observers_;
            var index2 = observers2.indexOf(observer);
            if (~index2) {
              observers2.splice(index2, 1);
            }
            if (!observers2.length && this.connected_) {
              this.disconnect_();
            }
          };
          ResizeObserverController2.prototype.refresh = function() {
            var changesDetected = this.updateObservers_();
            if (changesDetected) {
              this.refresh();
            }
          };
          ResizeObserverController2.prototype.updateObservers_ = function() {
            var activeObservers = this.observers_.filter(function(observer) {
              return observer.gatherActive(), observer.hasActive();
            });
            activeObservers.forEach(function(observer) {
              return observer.broadcastActive();
            });
            return activeObservers.length > 0;
          };
          ResizeObserverController2.prototype.connect_ = function() {
            if (!isBrowser || this.connected_) {
              return;
            }
            document.addEventListener("transitionend", this.onTransitionEnd_);
            window.addEventListener("resize", this.refresh);
            if (mutationObserverSupported) {
              this.mutationsObserver_ = new MutationObserver(this.refresh);
              this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
              });
            } else {
              document.addEventListener("DOMSubtreeModified", this.refresh);
              this.mutationEventsAdded_ = true;
            }
            this.connected_ = true;
          };
          ResizeObserverController2.prototype.disconnect_ = function() {
            if (!isBrowser || !this.connected_) {
              return;
            }
            document.removeEventListener("transitionend", this.onTransitionEnd_);
            window.removeEventListener("resize", this.refresh);
            if (this.mutationsObserver_) {
              this.mutationsObserver_.disconnect();
            }
            if (this.mutationEventsAdded_) {
              document.removeEventListener("DOMSubtreeModified", this.refresh);
            }
            this.mutationsObserver_ = null;
            this.mutationEventsAdded_ = false;
            this.connected_ = false;
          };
          ResizeObserverController2.prototype.onTransitionEnd_ = function(_a2) {
            var _b2 = _a2.propertyName, propertyName = _b2 === void 0 ? "" : _b2;
            var isReflowProperty = transitionKeys.some(function(key) {
              return !!~propertyName.indexOf(key);
            });
            if (isReflowProperty) {
              this.refresh();
            }
          };
          ResizeObserverController2.getInstance = function() {
            if (!this.instance_) {
              this.instance_ = new ResizeObserverController2();
            }
            return this.instance_;
          };
          ResizeObserverController2.instance_ = null;
          return ResizeObserverController2;
        })()
      );
      var defineConfigurable = (function(target, props) {
        for (var _i = 0, _a2 = Object.keys(props); _i < _a2.length; _i++) {
          var key = _a2[_i];
          Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
          });
        }
        return target;
      });
      var getWindowOf = (function(target) {
        var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
        return ownerGlobal || global$1;
      });
      var emptyRect = createRectInit(0, 0, 0, 0);
      function toFloat(value) {
        return parseFloat(value) || 0;
      }
      function getBordersSize(styles2) {
        var positions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          positions[_i - 1] = arguments[_i];
        }
        return positions.reduce(function(size, position) {
          var value = styles2["border-" + position + "-width"];
          return size + toFloat(value);
        }, 0);
      }
      function getPaddings(styles2) {
        var positions = ["top", "right", "bottom", "left"];
        var paddings = {};
        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
          var position = positions_1[_i];
          var value = styles2["padding-" + position];
          paddings[position] = toFloat(value);
        }
        return paddings;
      }
      function getSVGContentRect(target) {
        var bbox = target.getBBox();
        return createRectInit(0, 0, bbox.width, bbox.height);
      }
      function getHTMLElementContentRect(target) {
        var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
        if (!clientWidth && !clientHeight) {
          return emptyRect;
        }
        var styles2 = getWindowOf(target).getComputedStyle(target);
        var paddings = getPaddings(styles2);
        var horizPad = paddings.left + paddings.right;
        var vertPad = paddings.top + paddings.bottom;
        var width = toFloat(styles2.width), height = toFloat(styles2.height);
        if (styles2.boxSizing === "border-box") {
          if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles2, "left", "right") + horizPad;
          }
          if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles2, "top", "bottom") + vertPad;
          }
        }
        if (!isDocumentElement(target)) {
          var vertScrollbar = Math.round(width + horizPad) - clientWidth;
          var horizScrollbar = Math.round(height + vertPad) - clientHeight;
          if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
          }
          if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
          }
        }
        return createRectInit(paddings.left, paddings.top, width, height);
      }
      var isSVGGraphicsElement = (function() {
        if (typeof SVGGraphicsElement !== "undefined") {
          return function(target) {
            return target instanceof getWindowOf(target).SVGGraphicsElement;
          };
        }
        return function(target) {
          return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
        };
      })();
      function isDocumentElement(target) {
        return target === getWindowOf(target).document.documentElement;
      }
      function getContentRect(target) {
        if (!isBrowser) {
          return emptyRect;
        }
        if (isSVGGraphicsElement(target)) {
          return getSVGContentRect(target);
        }
        return getHTMLElementContentRect(target);
      }
      function createReadOnlyRect(_a2) {
        var x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
        var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
        var rect = Object.create(Constr.prototype);
        defineConfigurable(rect, {
          x,
          y,
          width,
          height,
          top: y,
          right: x + width,
          bottom: height + y,
          left: x
        });
        return rect;
      }
      function createRectInit(x, y, width, height) {
        return { x, y, width, height };
      }
      var ResizeObservation = (
        /** @class */
        (function() {
          function ResizeObservation2(target) {
            this.broadcastWidth = 0;
            this.broadcastHeight = 0;
            this.contentRect_ = createRectInit(0, 0, 0, 0);
            this.target = target;
          }
          ResizeObservation2.prototype.isActive = function() {
            var rect = getContentRect(this.target);
            this.contentRect_ = rect;
            return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
          };
          ResizeObservation2.prototype.broadcastRect = function() {
            var rect = this.contentRect_;
            this.broadcastWidth = rect.width;
            this.broadcastHeight = rect.height;
            return rect;
          };
          return ResizeObservation2;
        })()
      );
      var ResizeObserverEntry = (
        /** @class */
        /* @__PURE__ */ (function() {
          function ResizeObserverEntry2(target, rectInit) {
            var contentRect = createReadOnlyRect(rectInit);
            defineConfigurable(this, { target, contentRect });
          }
          return ResizeObserverEntry2;
        })()
      );
      var ResizeObserverSPI = (
        /** @class */
        (function() {
          function ResizeObserverSPI2(callback, controller, callbackCtx) {
            this.activeObservations_ = [];
            this.observations_ = new MapShim();
            if (typeof callback !== "function") {
              throw new TypeError("The callback provided as parameter 1 is not a function.");
            }
            this.callback_ = callback;
            this.controller_ = controller;
            this.callbackCtx_ = callbackCtx;
          }
          ResizeObserverSPI2.prototype.observe = function(target) {
            if (!arguments.length) {
              throw new TypeError("1 argument required, but only 0 present.");
            }
            if (typeof Element === "undefined" || !(Element instanceof Object)) {
              return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            if (observations.has(target)) {
              return;
            }
            observations.set(target, new ResizeObservation(target));
            this.controller_.addObserver(this);
            this.controller_.refresh();
          };
          ResizeObserverSPI2.prototype.unobserve = function(target) {
            if (!arguments.length) {
              throw new TypeError("1 argument required, but only 0 present.");
            }
            if (typeof Element === "undefined" || !(Element instanceof Object)) {
              return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            if (!observations.has(target)) {
              return;
            }
            observations.delete(target);
            if (!observations.size) {
              this.controller_.removeObserver(this);
            }
          };
          ResizeObserverSPI2.prototype.disconnect = function() {
            this.clearActive();
            this.observations_.clear();
            this.controller_.removeObserver(this);
          };
          ResizeObserverSPI2.prototype.gatherActive = function() {
            var _this = this;
            this.clearActive();
            this.observations_.forEach(function(observation) {
              if (observation.isActive()) {
                _this.activeObservations_.push(observation);
              }
            });
          };
          ResizeObserverSPI2.prototype.broadcastActive = function() {
            if (!this.hasActive()) {
              return;
            }
            var ctx = this.callbackCtx_;
            var entries = this.activeObservations_.map(function(observation) {
              return new ResizeObserverEntry(observation.target, observation.broadcastRect());
            });
            this.callback_.call(ctx, entries, ctx);
            this.clearActive();
          };
          ResizeObserverSPI2.prototype.clearActive = function() {
            this.activeObservations_.splice(0);
          };
          ResizeObserverSPI2.prototype.hasActive = function() {
            return this.activeObservations_.length > 0;
          };
          return ResizeObserverSPI2;
        })()
      );
      var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
      var ResizeObserver = (
        /** @class */
        /* @__PURE__ */ (function() {
          function ResizeObserver2(callback) {
            if (!(this instanceof ResizeObserver2)) {
              throw new TypeError("Cannot call a class as a function.");
            }
            if (!arguments.length) {
              throw new TypeError("1 argument required, but only 0 present.");
            }
            var controller = ResizeObserverController.getInstance();
            var observer = new ResizeObserverSPI(callback, controller, this);
            observers.set(this, observer);
          }
          return ResizeObserver2;
        })()
      );
      [
        "observe",
        "unobserve",
        "disconnect"
      ].forEach(function(method) {
        ResizeObserver.prototype[method] = function() {
          var _a2;
          return (_a2 = observers.get(this))[method].apply(_a2, arguments);
        };
      });
      var index = (function() {
        if (typeof global$1.ResizeObserver !== "undefined") {
          return global$1.ResizeObserver;
        }
        return ResizeObserver;
      })();
      var useEffectWithTarget = createEffectWithTarget(useLayoutEffect);
      var useIsomorphicLayoutEffectWithTarget = isBrowser$1 ? useEffectWithTarget : useEffectWithTarget$1;
      function useSize(target) {
        var _a2 = __read(useRafState(function() {
          var el = getTargetElement(target);
          return el ? { width: el.clientWidth, height: el.clientHeight } : void 0;
        }), 2), state = _a2[0], setState = _a2[1];
        useIsomorphicLayoutEffectWithTarget(function() {
          var el = getTargetElement(target);
          if (!el) {
            return;
          }
          var resizeObserver = new index(function(entries) {
            entries.forEach(function(entry) {
              var _a3 = entry.target, clientWidth = _a3.clientWidth, clientHeight = _a3.clientHeight;
              setState({ width: clientWidth, height: clientHeight });
            });
          });
          resizeObserver.observe(el);
          return function() {
            resizeObserver.disconnect();
          };
        }, [], target);
        return state;
      }
      const useConfig = () => {
        const [downloadConfig, setDownloadConfig] = useLocalStorageState(
          "qqmusic_downloadConfig",
          {
            defaultValue: defaultDownloadConfig,
            listenStorageChange: true
          }
        );
        const [functionConfig, setFunctionConfig] = useLocalStorageState(
          "qqmusic_functionConfig",
          {
            defaultValue: defaultFunctionConfig,
            listenStorageChange: true
          }
        );
        useEffect(() => {
          setFunctionConfig({
            ...defaultFunctionConfig,
            ...functionConfig
          });
          setDownloadConfig({
            ...defaultDownloadConfig,
            ...downloadConfig
          });
        }, []);
        return {
          /** 下载配置 */
          downloadConfig: downloadConfig || defaultDownloadConfig,
          /** 设置下载配置 */
          setDownloadConfig,
          /** 功能配置 */
          functionConfig: functionConfig || defaultFunctionConfig,
          /** 设置功能配置 */
          setFunctionConfig
        };
      };
      function useFilter(list, config) {
        const [filteredList, setFilteredList] = useState(list);
        useEffect(() => {
          setFilteredList(list);
        }, [list]);
        const handleFilter = (values) => {
          const filtered = list.filter((item) => {
            return Object.entries(config.fields).every(([field, fieldConfig]) => {
              const filterValue = values[field];
              if (!filterValue?.length) return true;
              const itemValue = fieldConfig.getValue(item);
              if (!itemValue) return false;
              return filterValue.some(
                (keyword) => itemValue.toLowerCase().includes(keyword.toLowerCase())
              );
            });
          });
          setFilteredList(filtered);
        };
        return { filteredList, setFilteredList, handleFilter };
      }
      var _GM_xmlhttpRequest = /* @__PURE__ */ (() => typeof GM_xmlhttpRequest != "undefined" ? GM_xmlhttpRequest : void 0)();
      const yURL = "https://y.qq.com";
      const cURL = "https://c.y.qq.com";
      const uURL = "https://u.y.qq.com";
      const getBaseURL = (url, type = "c") => {
        let baseURL = "";
        switch (type) {
          case "y":
            baseURL = yURL + url;
            break;
          case "u":
            baseURL = uURL + url;
            break;
          case "c":
            baseURL = cURL + url;
            break;
          default:
            baseURL = cURL + url;
            break;
        }
        return baseURL;
      };
      const getDefaultHeaders = (type = "c") => {
        switch (type) {
          case "y":
            return { referer: "https://y.qq.com/", host: "y.qq.com" };
          case "u":
            return {
              referer: "https://y.qq.com/portal/player.html",
              host: "u.y.qq.com",
              "content-type": "application/x-www-form-urlencoded"
            };
          case "c":
            return { referer: "https://c.y.qq.com/", host: "c.y.qq.com" };
          default:
            return { referer: "https://c.y.qq.com/", host: "c.y.qq.com" };
        }
      };
      const qqMusicRequest = async (url, config, type = "c") => {
        const baseURL = getBaseURL(url, type);
        const { headers, method = "GET", responseType = "json", ...rest } = config;
        const cookie = document.cookie;
        return new Promise((resolve, reject) => {
          _GM_xmlhttpRequest({
            method,
            url: baseURL,
            responseType,
            headers: { ...getDefaultHeaders(type), cookie, ...headers },
            cookie,
            onload: (res) => resolve(res.response),
            onerror: reject,
            ...rest
          });
        });
      };
      const getAlbumInfo = async (albummid) => {
        const params = {
          albummid,
          format: "json",
          outCharset: "utf-8"
        };
        const res = await qqMusicRequest(
          `/v8/fcg-bin/fcg_v8_album_info_cp.fcg?${new URLSearchParams(params).toString()}`,
          {}
        );
        if (res.code === 0) {
          return res.data;
        }
        throw new Error("获取专辑信息失败");
      };
      const getAlbumPicUrl = (albummid, options) => {
        const { size = "800x800", maxAge = 2592e3 } = options || {};
        return `https://y.gtimg.cn/music/photo_new/T002R${size}M000${albummid}.jpg?max_age=${maxAge}`;
      };
      var md5$2 = { exports: {} };
      var crypt = { exports: {} };
      var hasRequiredCrypt;
      function requireCrypt() {
        if (hasRequiredCrypt) return crypt.exports;
        hasRequiredCrypt = 1;
        (function() {
          var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt$1 = {
            // Bit-wise rotation left
            rotl: function(n, b) {
              return n << b | n >>> 32 - b;
            },
            // Bit-wise rotation right
            rotr: function(n, b) {
              return n << 32 - b | n >>> b;
            },
            // Swap big-endian to little-endian and vice versa
            endian: function(n) {
              if (n.constructor == Number) {
                return crypt$1.rotl(n, 8) & 16711935 | crypt$1.rotl(n, 24) & 4278255360;
              }
              for (var i = 0; i < n.length; i++)
                n[i] = crypt$1.endian(n[i]);
              return n;
            },
            // Generate an array of any length of random bytes
            randomBytes: function(n) {
              for (var bytes = []; n > 0; n--)
                bytes.push(Math.floor(Math.random() * 256));
              return bytes;
            },
            // Convert a byte array to big-endian 32-bit words
            bytesToWords: function(bytes) {
              for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
                words[b >>> 5] |= bytes[i] << 24 - b % 32;
              return words;
            },
            // Convert big-endian 32-bit words to a byte array
            wordsToBytes: function(words) {
              for (var bytes = [], b = 0; b < words.length * 32; b += 8)
                bytes.push(words[b >>> 5] >>> 24 - b % 32 & 255);
              return bytes;
            },
            // Convert a byte array to a hex string
            bytesToHex: function(bytes) {
              for (var hex = [], i = 0; i < bytes.length; i++) {
                hex.push((bytes[i] >>> 4).toString(16));
                hex.push((bytes[i] & 15).toString(16));
              }
              return hex.join("");
            },
            // Convert a hex string to a byte array
            hexToBytes: function(hex) {
              for (var bytes = [], c = 0; c < hex.length; c += 2)
                bytes.push(parseInt(hex.substr(c, 2), 16));
              return bytes;
            },
            // Convert a byte array to a base-64 string
            bytesToBase64: function(bytes) {
              for (var base64 = [], i = 0; i < bytes.length; i += 3) {
                var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
                for (var j = 0; j < 4; j++)
                  if (i * 8 + j * 6 <= bytes.length * 8)
                    base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63));
                  else
                    base64.push("=");
              }
              return base64.join("");
            },
            // Convert a base-64 string to a byte array
            base64ToBytes: function(base64) {
              base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
              for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
                if (imod4 == 0) continue;
                bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
              }
              return bytes;
            }
          };
          crypt.exports = crypt$1;
        })();
        return crypt.exports;
      }
      var charenc_1;
      var hasRequiredCharenc;
      function requireCharenc() {
        if (hasRequiredCharenc) return charenc_1;
        hasRequiredCharenc = 1;
        var charenc = {
          // UTF-8 encoding
          utf8: {
            // Convert a string to a byte array
            stringToBytes: function(str) {
              return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
            },
            // Convert a byte array to a string
            bytesToString: function(bytes) {
              return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
            }
          },
          // Binary encoding
          bin: {
            // Convert a string to a byte array
            stringToBytes: function(str) {
              for (var bytes = [], i = 0; i < str.length; i++)
                bytes.push(str.charCodeAt(i) & 255);
              return bytes;
            },
            // Convert a byte array to a string
            bytesToString: function(bytes) {
              for (var str = [], i = 0; i < bytes.length; i++)
                str.push(String.fromCharCode(bytes[i]));
              return str.join("");
            }
          }
        };
        charenc_1 = charenc;
        return charenc_1;
      }
      /*!
       * Determine if an object is a Buffer
       *
       * @author   Feross Aboukhadijeh <https://feross.org>
       * @license  MIT
       */
      var isBuffer_1;
      var hasRequiredIsBuffer;
      function requireIsBuffer() {
        if (hasRequiredIsBuffer) return isBuffer_1;
        hasRequiredIsBuffer = 1;
        isBuffer_1 = function(obj) {
          return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
        };
        function isBuffer(obj) {
          return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
        }
        function isSlowBuffer(obj) {
          return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
        }
        return isBuffer_1;
      }
      var hasRequiredMd5$1;
      function requireMd5$1() {
        if (hasRequiredMd5$1) return md5$2.exports;
        hasRequiredMd5$1 = 1;
        (function() {
          var crypt2 = requireCrypt(), utf8 = requireCharenc().utf8, isBuffer = requireIsBuffer(), bin = requireCharenc().bin, md52 = function(message2, options) {
            if (message2.constructor == String)
              if (options && options.encoding === "binary")
                message2 = bin.stringToBytes(message2);
              else
                message2 = utf8.stringToBytes(message2);
            else if (isBuffer(message2))
              message2 = Array.prototype.slice.call(message2, 0);
            else if (!Array.isArray(message2) && message2.constructor !== Uint8Array)
              message2 = message2.toString();
            var m = crypt2.bytesToWords(message2), l = message2.length * 8, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
            for (var i = 0; i < m.length; i++) {
              m[i] = (m[i] << 8 | m[i] >>> 24) & 16711935 | (m[i] << 24 | m[i] >>> 8) & 4278255360;
            }
            m[l >>> 5] |= 128 << l % 32;
            m[(l + 64 >>> 9 << 4) + 14] = l;
            var FF = md52._ff, GG = md52._gg, HH = md52._hh, II = md52._ii;
            for (var i = 0; i < m.length; i += 16) {
              var aa = a, bb = b, cc = c, dd = d;
              a = FF(a, b, c, d, m[i + 0], 7, -680876936);
              d = FF(d, a, b, c, m[i + 1], 12, -389564586);
              c = FF(c, d, a, b, m[i + 2], 17, 606105819);
              b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
              a = FF(a, b, c, d, m[i + 4], 7, -176418897);
              d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
              c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
              b = FF(b, c, d, a, m[i + 7], 22, -45705983);
              a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
              d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
              c = FF(c, d, a, b, m[i + 10], 17, -42063);
              b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
              a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
              d = FF(d, a, b, c, m[i + 13], 12, -40341101);
              c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
              b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
              a = GG(a, b, c, d, m[i + 1], 5, -165796510);
              d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
              c = GG(c, d, a, b, m[i + 11], 14, 643717713);
              b = GG(b, c, d, a, m[i + 0], 20, -373897302);
              a = GG(a, b, c, d, m[i + 5], 5, -701558691);
              d = GG(d, a, b, c, m[i + 10], 9, 38016083);
              c = GG(c, d, a, b, m[i + 15], 14, -660478335);
              b = GG(b, c, d, a, m[i + 4], 20, -405537848);
              a = GG(a, b, c, d, m[i + 9], 5, 568446438);
              d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
              c = GG(c, d, a, b, m[i + 3], 14, -187363961);
              b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
              a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
              d = GG(d, a, b, c, m[i + 2], 9, -51403784);
              c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
              b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
              a = HH(a, b, c, d, m[i + 5], 4, -378558);
              d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
              c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
              b = HH(b, c, d, a, m[i + 14], 23, -35309556);
              a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
              d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
              c = HH(c, d, a, b, m[i + 7], 16, -155497632);
              b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
              a = HH(a, b, c, d, m[i + 13], 4, 681279174);
              d = HH(d, a, b, c, m[i + 0], 11, -358537222);
              c = HH(c, d, a, b, m[i + 3], 16, -722521979);
              b = HH(b, c, d, a, m[i + 6], 23, 76029189);
              a = HH(a, b, c, d, m[i + 9], 4, -640364487);
              d = HH(d, a, b, c, m[i + 12], 11, -421815835);
              c = HH(c, d, a, b, m[i + 15], 16, 530742520);
              b = HH(b, c, d, a, m[i + 2], 23, -995338651);
              a = II(a, b, c, d, m[i + 0], 6, -198630844);
              d = II(d, a, b, c, m[i + 7], 10, 1126891415);
              c = II(c, d, a, b, m[i + 14], 15, -1416354905);
              b = II(b, c, d, a, m[i + 5], 21, -57434055);
              a = II(a, b, c, d, m[i + 12], 6, 1700485571);
              d = II(d, a, b, c, m[i + 3], 10, -1894986606);
              c = II(c, d, a, b, m[i + 10], 15, -1051523);
              b = II(b, c, d, a, m[i + 1], 21, -2054922799);
              a = II(a, b, c, d, m[i + 8], 6, 1873313359);
              d = II(d, a, b, c, m[i + 15], 10, -30611744);
              c = II(c, d, a, b, m[i + 6], 15, -1560198380);
              b = II(b, c, d, a, m[i + 13], 21, 1309151649);
              a = II(a, b, c, d, m[i + 4], 6, -145523070);
              d = II(d, a, b, c, m[i + 11], 10, -1120210379);
              c = II(c, d, a, b, m[i + 2], 15, 718787259);
              b = II(b, c, d, a, m[i + 9], 21, -343485551);
              a = a + aa >>> 0;
              b = b + bb >>> 0;
              c = c + cc >>> 0;
              d = d + dd >>> 0;
            }
            return crypt2.endian([a, b, c, d]);
          };
          md52._ff = function(a, b, c, d, x, s, t) {
            var n = a + (b & c | ~b & d) + (x >>> 0) + t;
            return (n << s | n >>> 32 - s) + b;
          };
          md52._gg = function(a, b, c, d, x, s, t) {
            var n = a + (b & d | c & ~d) + (x >>> 0) + t;
            return (n << s | n >>> 32 - s) + b;
          };
          md52._hh = function(a, b, c, d, x, s, t) {
            var n = a + (b ^ c ^ d) + (x >>> 0) + t;
            return (n << s | n >>> 32 - s) + b;
          };
          md52._ii = function(a, b, c, d, x, s, t) {
            var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
            return (n << s | n >>> 32 - s) + b;
          };
          md52._blocksize = 16;
          md52._digestsize = 16;
          md5$2.exports = function(message2, options) {
            if (message2 === void 0 || message2 === null)
              throw new Error("Illegal argument " + message2);
            var digestbytes = crypt2.wordsToBytes(md52(message2, options));
            return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt2.bytesToHex(digestbytes);
          };
        })();
        return md5$2.exports;
      }
      var md5Exports = requireMd5$1();
      const md5$1 = /* @__PURE__ */ getDefaultExportFromCjs(md5Exports);
      const defaultMessages = "End-Of-Stream";
      class EndOfStreamError extends Error {
        constructor() {
          super(defaultMessages);
          this.name = "EndOfStreamError";
        }
      }
      class AbortError extends Error {
        constructor(message2 = "The operation was aborted") {
          super(message2);
          this.name = "AbortError";
        }
      }
      class AbstractStreamReader {
        constructor() {
          this.endOfStream = false;
          this.interrupted = false;
          this.peekQueue = [];
        }
        async peek(uint8Array, mayBeLess = false) {
          const bytesRead = await this.read(uint8Array, mayBeLess);
          this.peekQueue.push(uint8Array.subarray(0, bytesRead));
          return bytesRead;
        }
        async read(buffer, mayBeLess = false) {
          if (buffer.length === 0) {
            return 0;
          }
          let bytesRead = this.readFromPeekBuffer(buffer);
          if (!this.endOfStream) {
            bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);
          }
          if (bytesRead === 0 && !mayBeLess) {
            throw new EndOfStreamError();
          }
          return bytesRead;
        }
        /**
         * Read chunk from stream
         * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
         * @returns Number of bytes read
         */
        readFromPeekBuffer(buffer) {
          let remaining = buffer.length;
          let bytesRead = 0;
          while (this.peekQueue.length > 0 && remaining > 0) {
            const peekData = this.peekQueue.pop();
            if (!peekData)
              throw new Error("peekData should be defined");
            const lenCopy = Math.min(peekData.length, remaining);
            buffer.set(peekData.subarray(0, lenCopy), bytesRead);
            bytesRead += lenCopy;
            remaining -= lenCopy;
            if (lenCopy < peekData.length) {
              this.peekQueue.push(peekData.subarray(lenCopy));
            }
          }
          return bytesRead;
        }
        async readRemainderFromStream(buffer, mayBeLess) {
          let bytesRead = 0;
          while (bytesRead < buffer.length && !this.endOfStream) {
            if (this.interrupted) {
              throw new AbortError();
            }
            const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);
            if (chunkLen === 0)
              break;
            bytesRead += chunkLen;
          }
          if (!mayBeLess && bytesRead < buffer.length) {
            throw new EndOfStreamError();
          }
          return bytesRead;
        }
      }
      class WebStreamReader extends AbstractStreamReader {
        constructor(reader) {
          super();
          this.reader = reader;
        }
        async abort() {
          return this.close();
        }
        async close() {
          this.reader.releaseLock();
        }
      }
      class WebStreamByobReader extends WebStreamReader {
        /**
         * Read from stream
         * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
         * @param mayBeLess - If true, may fill the buffer partially
         * @protected Bytes read
         */
        async readFromStream(buffer, mayBeLess) {
          if (buffer.length === 0)
            return 0;
          const result = await this.reader.read(new Uint8Array(buffer.length), { min: mayBeLess ? void 0 : buffer.length });
          if (result.done) {
            this.endOfStream = result.done;
          }
          if (result.value) {
            buffer.set(result.value);
            return result.value.length;
          }
          return 0;
        }
      }
      class WebStreamDefaultReader extends AbstractStreamReader {
        constructor(reader) {
          super();
          this.reader = reader;
          this.buffer = null;
        }
        /**
         * Copy chunk to target, and store the remainder in this.buffer
         */
        writeChunk(target, chunk) {
          const written = Math.min(chunk.length, target.length);
          target.set(chunk.subarray(0, written));
          if (written < chunk.length) {
            this.buffer = chunk.subarray(written);
          } else {
            this.buffer = null;
          }
          return written;
        }
        /**
         * Read from stream
         * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
         * @param mayBeLess - If true, may fill the buffer partially
         * @protected Bytes read
         */
        async readFromStream(buffer, mayBeLess) {
          if (buffer.length === 0)
            return 0;
          let totalBytesRead = 0;
          if (this.buffer) {
            totalBytesRead += this.writeChunk(buffer, this.buffer);
          }
          while (totalBytesRead < buffer.length && !this.endOfStream) {
            const result = await this.reader.read();
            if (result.done) {
              this.endOfStream = true;
              break;
            }
            if (result.value) {
              totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);
            }
          }
          if (!mayBeLess && totalBytesRead === 0 && this.endOfStream) {
            throw new EndOfStreamError();
          }
          return totalBytesRead;
        }
        abort() {
          this.interrupted = true;
          return this.reader.cancel();
        }
        async close() {
          await this.abort();
          this.reader.releaseLock();
        }
      }
      function makeWebStreamReader(stream) {
        try {
          const reader = stream.getReader({ mode: "byob" });
          if (reader instanceof ReadableStreamDefaultReader) {
            return new WebStreamDefaultReader(reader);
          }
          return new WebStreamByobReader(reader);
        } catch (error) {
          if (error instanceof TypeError) {
            return new WebStreamDefaultReader(stream.getReader());
          }
          throw error;
        }
      }
      class AbstractTokenizer {
        /**
         * Constructor
         * @param options Tokenizer options
         * @protected
         */
        constructor(options) {
          this.numBuffer = new Uint8Array(8);
          this.position = 0;
          this.onClose = options?.onClose;
          if (options?.abortSignal) {
            options.abortSignal.addEventListener("abort", () => {
              this.abort();
            });
          }
        }
        /**
         * Read a token from the tokenizer-stream
         * @param token - The token to read
         * @param position - If provided, the desired position in the tokenizer-stream
         * @returns Promise with token data
         */
        async readToken(token, position = this.position) {
          const uint8Array = new Uint8Array(token.len);
          const len = await this.readBuffer(uint8Array, { position });
          if (len < token.len)
            throw new EndOfStreamError();
          return token.get(uint8Array, 0);
        }
        /**
         * Peek a token from the tokenizer-stream.
         * @param token - Token to peek from the tokenizer-stream.
         * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
         * @returns Promise with token data
         */
        async peekToken(token, position = this.position) {
          const uint8Array = new Uint8Array(token.len);
          const len = await this.peekBuffer(uint8Array, { position });
          if (len < token.len)
            throw new EndOfStreamError();
          return token.get(uint8Array, 0);
        }
        /**
         * Read a numeric token from the stream
         * @param token - Numeric token
         * @returns Promise with number
         */
        async readNumber(token) {
          const len = await this.readBuffer(this.numBuffer, { length: token.len });
          if (len < token.len)
            throw new EndOfStreamError();
          return token.get(this.numBuffer, 0);
        }
        /**
         * Read a numeric token from the stream
         * @param token - Numeric token
         * @returns Promise with number
         */
        async peekNumber(token) {
          const len = await this.peekBuffer(this.numBuffer, { length: token.len });
          if (len < token.len)
            throw new EndOfStreamError();
          return token.get(this.numBuffer, 0);
        }
        /**
         * Ignore number of bytes, advances the pointer in under tokenizer-stream.
         * @param length - Number of bytes to ignore
         * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
         */
        async ignore(length) {
          if (this.fileInfo.size !== void 0) {
            const bytesLeft = this.fileInfo.size - this.position;
            if (length > bytesLeft) {
              this.position += bytesLeft;
              return bytesLeft;
            }
          }
          this.position += length;
          return length;
        }
        async close() {
          await this.abort();
          await this.onClose?.();
        }
        normalizeOptions(uint8Array, options) {
          if (!this.supportsRandomAccess() && options && options.position !== void 0 && options.position < this.position) {
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          }
          return {
            ...{
              mayBeLess: false,
              offset: 0,
              length: uint8Array.length,
              position: this.position
            },
            ...options
          };
        }
        abort() {
          return Promise.resolve();
        }
      }
      const maxBufferSize = 256e3;
      class ReadStreamTokenizer extends AbstractTokenizer {
        /**
         * Constructor
         * @param streamReader stream-reader to read from
         * @param options Tokenizer options
         */
        constructor(streamReader, options) {
          super(options);
          this.streamReader = streamReader;
          this.fileInfo = options?.fileInfo ?? {};
        }
        /**
         * Read buffer from tokenizer
         * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
         * @param options - Read behaviour options
         * @returns Promise with number of bytes read
         */
        async readBuffer(uint8Array, options) {
          const normOptions = this.normalizeOptions(uint8Array, options);
          const skipBytes = normOptions.position - this.position;
          if (skipBytes > 0) {
            await this.ignore(skipBytes);
            return this.readBuffer(uint8Array, options);
          }
          if (skipBytes < 0) {
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          }
          if (normOptions.length === 0) {
            return 0;
          }
          const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
          this.position += bytesRead;
          if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
            throw new EndOfStreamError();
          }
          return bytesRead;
        }
        /**
         * Peek (read ahead) buffer from tokenizer
         * @param uint8Array - Uint8Array (or Buffer) to write data to
         * @param options - Read behaviour options
         * @returns Promise with number of bytes peeked
         */
        async peekBuffer(uint8Array, options) {
          const normOptions = this.normalizeOptions(uint8Array, options);
          let bytesRead = 0;
          if (normOptions.position) {
            const skipBytes = normOptions.position - this.position;
            if (skipBytes > 0) {
              const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
              bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
              uint8Array.set(skipBuffer.subarray(skipBytes));
              return bytesRead - skipBytes;
            }
            if (skipBytes < 0) {
              throw new Error("Cannot peek from a negative offset in a stream");
            }
          }
          if (normOptions.length > 0) {
            try {
              bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
            } catch (err2) {
              if (options?.mayBeLess && err2 instanceof EndOfStreamError) {
                return 0;
              }
              throw err2;
            }
            if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
              throw new EndOfStreamError();
            }
          }
          return bytesRead;
        }
        async ignore(length) {
          const bufSize = Math.min(maxBufferSize, length);
          const buf = new Uint8Array(bufSize);
          let totBytesRead = 0;
          while (totBytesRead < length) {
            const remaining = length - totBytesRead;
            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
            if (bytesRead < 0) {
              return bytesRead;
            }
            totBytesRead += bytesRead;
          }
          return totBytesRead;
        }
        abort() {
          return this.streamReader.abort();
        }
        async close() {
          return this.streamReader.close();
        }
        supportsRandomAccess() {
          return false;
        }
      }
      class BufferTokenizer extends AbstractTokenizer {
        /**
         * Construct BufferTokenizer
         * @param uint8Array - Uint8Array to tokenize
         * @param options Tokenizer options
         */
        constructor(uint8Array, options) {
          super(options);
          this.uint8Array = uint8Array;
          this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };
        }
        /**
         * Read buffer from tokenizer
         * @param uint8Array - Uint8Array to tokenize
         * @param options - Read behaviour options
         * @returns {Promise<number>}
         */
        async readBuffer(uint8Array, options) {
          if (options?.position) {
            this.position = options.position;
          }
          const bytesRead = await this.peekBuffer(uint8Array, options);
          this.position += bytesRead;
          return bytesRead;
        }
        /**
         * Peek (read ahead) buffer from tokenizer
         * @param uint8Array
         * @param options - Read behaviour options
         * @returns {Promise<number>}
         */
        async peekBuffer(uint8Array, options) {
          const normOptions = this.normalizeOptions(uint8Array, options);
          const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
          if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
            throw new EndOfStreamError();
          }
          uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
          return bytes2read;
        }
        close() {
          return super.close();
        }
        supportsRandomAccess() {
          return true;
        }
        setPosition(position) {
          this.position = position;
        }
      }
      class BlobTokenizer extends AbstractTokenizer {
        /**
         * Construct BufferTokenizer
         * @param blob - Uint8Array to tokenize
         * @param options Tokenizer options
         */
        constructor(blob, options) {
          super(options);
          this.blob = blob;
          this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: blob.size, mimeType: blob.type } };
        }
        /**
         * Read buffer from tokenizer
         * @param uint8Array - Uint8Array to tokenize
         * @param options - Read behaviour options
         * @returns {Promise<number>}
         */
        async readBuffer(uint8Array, options) {
          if (options?.position) {
            this.position = options.position;
          }
          const bytesRead = await this.peekBuffer(uint8Array, options);
          this.position += bytesRead;
          return bytesRead;
        }
        /**
         * Peek (read ahead) buffer from tokenizer
         * @param buffer
         * @param options - Read behaviour options
         * @returns {Promise<number>}
         */
        async peekBuffer(buffer, options) {
          const normOptions = this.normalizeOptions(buffer, options);
          const bytes2read = Math.min(this.blob.size - normOptions.position, normOptions.length);
          if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
            throw new EndOfStreamError();
          }
          const arrayBuffer = await this.blob.slice(normOptions.position, normOptions.position + bytes2read).arrayBuffer();
          buffer.set(new Uint8Array(arrayBuffer));
          return bytes2read;
        }
        close() {
          return super.close();
        }
        supportsRandomAccess() {
          return true;
        }
        setPosition(position) {
          this.position = position;
        }
      }
      function fromWebStream(webStream, options) {
        const webStreamReader = makeWebStreamReader(webStream);
        const _options = options ?? {};
        const chainedClose = _options.onClose;
        _options.onClose = async () => {
          await webStreamReader.close();
          if (chainedClose) {
            return chainedClose();
          }
        };
        return new ReadStreamTokenizer(webStreamReader, _options);
      }
      function fromBuffer(uint8Array, options) {
        return new BufferTokenizer(uint8Array, options);
      }
      function fromBlob(blob, options) {
        return new BlobTokenizer(blob, options);
      }
      var ieee754 = {};
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      var hasRequiredIeee754;
      function requireIeee754() {
        if (hasRequiredIeee754) return ieee754;
        hasRequiredIeee754 = 1;
        ieee754.read = function(buffer, offset, isLE, mLen, nBytes) {
          var e, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];
          i += d;
          e = s & (1 << -nBits) - 1;
          s >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          m = e & (1 << -nBits) - 1;
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        ieee754.write = function(buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
          }
          e = e << mLen | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
          }
          buffer[offset + i - d] |= s * 128;
        };
        return ieee754;
      }
      requireIeee754();
      const WINDOWS_1252_EXTRA$1 = {
        128: "€",
        130: "‚",
        131: "ƒ",
        132: "„",
        133: "…",
        134: "†",
        135: "‡",
        136: "ˆ",
        137: "‰",
        138: "Š",
        139: "‹",
        140: "Œ",
        142: "Ž",
        145: "‘",
        146: "’",
        147: "“",
        148: "”",
        149: "•",
        150: "–",
        151: "—",
        152: "˜",
        153: "™",
        154: "š",
        155: "›",
        156: "œ",
        158: "ž",
        159: "Ÿ"
      };
      for (const [code, char] of Object.entries(WINDOWS_1252_EXTRA$1)) {
      }
      function textDecode$1(bytes, encoding = "utf-8") {
        switch (encoding.toLowerCase()) {
          case "utf-8":
          case "utf8":
            if (typeof globalThis.TextDecoder !== "undefined") {
              return new globalThis.TextDecoder("utf-8").decode(bytes);
            }
            return decodeUTF8$1(bytes);
          case "utf-16le":
            return decodeUTF16LE$1(bytes);
          case "ascii":
            return decodeASCII$1(bytes);
          case "latin1":
          case "iso-8859-1":
            return decodeLatin1$1(bytes);
          case "windows-1252":
            return decodeWindows1252$1(bytes);
          default:
            throw new RangeError(`Encoding '${encoding}' not supported`);
        }
      }
      function decodeUTF8$1(bytes) {
        let out = "";
        let i = 0;
        while (i < bytes.length) {
          const b1 = bytes[i++];
          if (b1 < 128) {
            out += String.fromCharCode(b1);
          } else if (b1 < 224) {
            const b2 = bytes[i++] & 63;
            out += String.fromCharCode((b1 & 31) << 6 | b2);
          } else if (b1 < 240) {
            const b2 = bytes[i++] & 63;
            const b3 = bytes[i++] & 63;
            out += String.fromCharCode((b1 & 15) << 12 | b2 << 6 | b3);
          } else {
            const b2 = bytes[i++] & 63;
            const b3 = bytes[i++] & 63;
            const b4 = bytes[i++] & 63;
            let cp = (b1 & 7) << 18 | b2 << 12 | b3 << 6 | b4;
            cp -= 65536;
            out += String.fromCharCode(55296 + (cp >> 10 & 1023), 56320 + (cp & 1023));
          }
        }
        return out;
      }
      function decodeUTF16LE$1(bytes) {
        let out = "";
        for (let i = 0; i < bytes.length; i += 2) {
          out += String.fromCharCode(bytes[i] | bytes[i + 1] << 8);
        }
        return out;
      }
      function decodeASCII$1(bytes) {
        return String.fromCharCode(...bytes.map((b) => b & 127));
      }
      function decodeLatin1$1(bytes) {
        return String.fromCharCode(...bytes);
      }
      function decodeWindows1252$1(bytes) {
        let out = "";
        for (const b of bytes) {
          if (b >= 128 && b <= 159 && WINDOWS_1252_EXTRA$1[b]) {
            out += WINDOWS_1252_EXTRA$1[b];
          } else {
            out += String.fromCharCode(b);
          }
        }
        return out;
      }
      function dv(array) {
        return new DataView(array.buffer, array.byteOffset);
      }
      const UINT8 = {
        len: 1,
        get(array, offset) {
          return dv(array).getUint8(offset);
        },
        put(array, offset, value) {
          dv(array).setUint8(offset, value);
          return offset + 1;
        }
      };
      const UINT16_LE = {
        len: 2,
        get(array, offset) {
          return dv(array).getUint16(offset, true);
        },
        put(array, offset, value) {
          dv(array).setUint16(offset, value, true);
          return offset + 2;
        }
      };
      const UINT16_BE = {
        len: 2,
        get(array, offset) {
          return dv(array).getUint16(offset);
        },
        put(array, offset, value) {
          dv(array).setUint16(offset, value);
          return offset + 2;
        }
      };
      const UINT32_LE = {
        len: 4,
        get(array, offset) {
          return dv(array).getUint32(offset, true);
        },
        put(array, offset, value) {
          dv(array).setUint32(offset, value, true);
          return offset + 4;
        }
      };
      const UINT32_BE = {
        len: 4,
        get(array, offset) {
          return dv(array).getUint32(offset);
        },
        put(array, offset, value) {
          dv(array).setUint32(offset, value);
          return offset + 4;
        }
      };
      const INT32_BE = {
        len: 4,
        get(array, offset) {
          return dv(array).getInt32(offset);
        },
        put(array, offset, value) {
          dv(array).setInt32(offset, value);
          return offset + 4;
        }
      };
      const UINT64_LE = {
        len: 8,
        get(array, offset) {
          return dv(array).getBigUint64(offset, true);
        },
        put(array, offset, value) {
          dv(array).setBigUint64(offset, value, true);
          return offset + 8;
        }
      };
      class Uint8ArrayType {
        constructor(len) {
          this.len = len;
        }
        get(array, offset) {
          return array.subarray(offset, offset + this.len);
        }
      }
      class StringType {
        constructor(len, encoding) {
          this.len = len;
          this.encoding = encoding;
        }
        get(data, offset = 0) {
          const bytes = data.subarray(offset, offset + this.len);
          return textDecode$1(bytes, this.encoding);
        }
      }
      var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
      var fleb = new u8([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0,
        /* unused */
        0,
        0,
        /* impossible */
        0
      ]);
      var fdeb = new u8([
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13,
        /* unused */
        0,
        0
      ]);
      var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      var freb = function(eb, start) {
        var b = new u16(31);
        for (var i = 0; i < 31; ++i) {
          b[i] = start += 1 << eb[i - 1];
        }
        var r = new i32(b[30]);
        for (var i = 1; i < 30; ++i) {
          for (var j = b[i]; j < b[i + 1]; ++j) {
            r[j] = j - b[i] << 5 | i;
          }
        }
        return { b, r };
      };
      var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
      fl[28] = 258, revfl[258] = 28;
      var _b = freb(fdeb, 0), fd = _b.b;
      var rev = new u16(32768);
      for (var i = 0; i < 32768; ++i) {
        var x = (i & 43690) >> 1 | (i & 21845) << 1;
        x = (x & 52428) >> 2 | (x & 13107) << 2;
        x = (x & 61680) >> 4 | (x & 3855) << 4;
        rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
      }
      var hMap = (function(cd, mb, r) {
        var s = cd.length;
        var i = 0;
        var l = new u16(mb);
        for (; i < s; ++i) {
          if (cd[i])
            ++l[cd[i] - 1];
        }
        var le = new u16(mb);
        for (i = 1; i < mb; ++i) {
          le[i] = le[i - 1] + l[i - 1] << 1;
        }
        var co;
        {
          co = new u16(1 << mb);
          var rvb = 15 - mb;
          for (i = 0; i < s; ++i) {
            if (cd[i]) {
              var sv = i << 4 | cd[i];
              var r_1 = mb - cd[i];
              var v = le[cd[i] - 1]++ << r_1;
              for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
                co[rev[v] >> rvb] = sv;
              }
            }
          }
        }
        return co;
      });
      var flt = new u8(288);
      for (var i = 0; i < 144; ++i)
        flt[i] = 8;
      for (var i = 144; i < 256; ++i)
        flt[i] = 9;
      for (var i = 256; i < 280; ++i)
        flt[i] = 7;
      for (var i = 280; i < 288; ++i)
        flt[i] = 8;
      var fdt = new u8(32);
      for (var i = 0; i < 32; ++i)
        fdt[i] = 5;
      var flrm = /* @__PURE__ */ hMap(flt, 9);
      var fdrm = /* @__PURE__ */ hMap(fdt, 5);
      var max = function(a) {
        var m = a[0];
        for (var i = 1; i < a.length; ++i) {
          if (a[i] > m)
            m = a[i];
        }
        return m;
      };
      var bits = function(d, p, m) {
        var o = p / 8 | 0;
        return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
      };
      var bits16 = function(d, p) {
        var o = p / 8 | 0;
        return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
      };
      var shft = function(p) {
        return (p + 7) / 8 | 0;
      };
      var slc = function(v, s, e) {
        if (e == null || e > v.length)
          e = v.length;
        return new u8(v.subarray(s, e));
      };
      var ec = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data"
        // determined by unknown compression method
      ];
      var err = function(ind, msg, nt) {
        var e = new Error(msg || ec[ind]);
        e.code = ind;
        if (Error.captureStackTrace)
          Error.captureStackTrace(e, err);
        if (!nt)
          throw e;
        return e;
      };
      var inflt = function(dat, st, buf, dict) {
        var sl = dat.length, dl = 0;
        if (!sl || st.f && !st.l)
          return buf || new u8(0);
        var noBuf = !buf;
        var resize = noBuf || st.i != 2;
        var noSt = st.i;
        if (noBuf)
          buf = new u8(sl * 3);
        var cbuf = function(l2) {
          var bl = buf.length;
          if (l2 > bl) {
            var nbuf = new u8(Math.max(bl * 2, l2));
            nbuf.set(buf);
            buf = nbuf;
          }
        };
        var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
        var tbts = sl * 8;
        do {
          if (!lm) {
            final = bits(dat, pos, 1);
            var type = bits(dat, pos + 1, 3);
            pos += 3;
            if (!type) {
              var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
              if (t > sl) {
                if (noSt)
                  err(0);
                break;
              }
              if (resize)
                cbuf(bt + l);
              buf.set(dat.subarray(s, t), bt);
              st.b = bt += l, st.p = pos = t * 8, st.f = final;
              continue;
            } else if (type == 1)
              lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
            else if (type == 2) {
              var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
              var tl = hLit + bits(dat, pos + 5, 31) + 1;
              pos += 14;
              var ldt = new u8(tl);
              var clt = new u8(19);
              for (var i = 0; i < hcLen; ++i) {
                clt[clim[i]] = bits(dat, pos + i * 3, 7);
              }
              pos += hcLen * 3;
              var clb = max(clt), clbmsk = (1 << clb) - 1;
              var clm = hMap(clt, clb);
              for (var i = 0; i < tl; ) {
                var r = clm[bits(dat, pos, clbmsk)];
                pos += r & 15;
                var s = r >> 4;
                if (s < 16) {
                  ldt[i++] = s;
                } else {
                  var c = 0, n = 0;
                  if (s == 16)
                    n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                  else if (s == 17)
                    n = 3 + bits(dat, pos, 7), pos += 3;
                  else if (s == 18)
                    n = 11 + bits(dat, pos, 127), pos += 7;
                  while (n--)
                    ldt[i++] = c;
                }
              }
              var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
              lbt = max(lt);
              dbt = max(dt);
              lm = hMap(lt, lbt);
              dm = hMap(dt, dbt);
            } else
              err(1);
            if (pos > tbts) {
              if (noSt)
                err(0);
              break;
            }
          }
          if (resize)
            cbuf(bt + 131072);
          var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
          var lpos = pos;
          for (; ; lpos = pos) {
            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
            pos += c & 15;
            if (pos > tbts) {
              if (noSt)
                err(0);
              break;
            }
            if (!c)
              err(2);
            if (sym < 256)
              buf[bt++] = sym;
            else if (sym == 256) {
              lpos = pos, lm = null;
              break;
            } else {
              var add = sym - 254;
              if (sym > 264) {
                var i = sym - 257, b = fleb[i];
                add = bits(dat, pos, (1 << b) - 1) + fl[i];
                pos += b;
              }
              var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
              if (!d)
                err(3);
              pos += d & 15;
              var dt = fd[dsym];
              if (dsym > 3) {
                var b = fdeb[dsym];
                dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
              }
              if (pos > tbts) {
                if (noSt)
                  err(0);
                break;
              }
              if (resize)
                cbuf(bt + 131072);
              var end = bt + add;
              if (bt < dt) {
                var shift = dl - dt, dend = Math.min(dt, end);
                if (shift + bt < 0)
                  err(3);
                for (; bt < dend; ++bt)
                  buf[bt] = dict[shift + bt];
              }
              for (; bt < end; ++bt)
                buf[bt] = buf[bt - dt];
            }
          }
          st.l = lm, st.p = lpos, st.b = bt, st.f = final;
          if (lm)
            final = 1, st.m = lbt, st.d = dm, st.n = dbt;
        } while (!final);
        return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
      };
      var et = /* @__PURE__ */ new u8(0);
      var gzs = function(d) {
        if (d[0] != 31 || d[1] != 139 || d[2] != 8)
          err(6, "invalid gzip data");
        var flg = d[3];
        var st = 10;
        if (flg & 4)
          st += (d[10] | d[11] << 8) + 2;
        for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
          ;
        return st + (flg & 2);
      };
      var gzl = function(d) {
        var l = d.length;
        return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
      };
      var zls = function(d, dict) {
        if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
          err(6, "invalid zlib data");
        if ((d[1] >> 5 & 1) == 1)
          err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
        return (d[1] >> 3 & 4) + 2;
      };
      function inflateSync(data, opts) {
        return inflt(data, { i: 2 }, opts, opts);
      }
      function gunzipSync(data, opts) {
        var st = gzs(data);
        if (st + 8 > data.length)
          err(6, "invalid gzip data");
        return inflt(data.subarray(st, -8), { i: 2 }, new u8(gzl(data)), opts);
      }
      function unzlibSync(data, opts) {
        return inflt(data.subarray(zls(data), -4), { i: 2 }, opts, opts);
      }
      function decompressSync(data, opts) {
        return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
      }
      var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
      var tds = 0;
      try {
        td.decode(et, { stream: true });
        tds = 1;
      } catch (e) {
      }
      var browser = { exports: {} };
      var ms;
      var hasRequiredMs;
      function requireMs() {
        if (hasRequiredMs) return ms;
        hasRequiredMs = 1;
        var s = 1e3;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;
        ms = function(val, options) {
          options = options || {};
          var type = typeof val;
          if (type === "string" && val.length > 0) {
            return parse(val);
          } else if (type === "number" && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error(
            "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
          );
        };
        function parse(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
            str
          );
          if (!match) {
            return;
          }
          var n = parseFloat(match[1]);
          var type = (match[2] || "ms").toLowerCase();
          switch (type) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n * y;
            case "weeks":
            case "week":
            case "w":
              return n * w;
            case "days":
            case "day":
            case "d":
              return n * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n;
            default:
              return void 0;
          }
        }
        function fmtShort(ms2) {
          var msAbs = Math.abs(ms2);
          if (msAbs >= d) {
            return Math.round(ms2 / d) + "d";
          }
          if (msAbs >= h) {
            return Math.round(ms2 / h) + "h";
          }
          if (msAbs >= m) {
            return Math.round(ms2 / m) + "m";
          }
          if (msAbs >= s) {
            return Math.round(ms2 / s) + "s";
          }
          return ms2 + "ms";
        }
        function fmtLong(ms2) {
          var msAbs = Math.abs(ms2);
          if (msAbs >= d) {
            return plural(ms2, msAbs, d, "day");
          }
          if (msAbs >= h) {
            return plural(ms2, msAbs, h, "hour");
          }
          if (msAbs >= m) {
            return plural(ms2, msAbs, m, "minute");
          }
          if (msAbs >= s) {
            return plural(ms2, msAbs, s, "second");
          }
          return ms2 + " ms";
        }
        function plural(ms2, msAbs, n, name2) {
          var isPlural = msAbs >= n * 1.5;
          return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
        }
        return ms;
      }
      var common;
      var hasRequiredCommon;
      function requireCommon() {
        if (hasRequiredCommon) return common;
        hasRequiredCommon = 1;
        function setup(env) {
          createDebug.debug = createDebug;
          createDebug.default = createDebug;
          createDebug.coerce = coerce;
          createDebug.disable = disable;
          createDebug.enable = enable;
          createDebug.enabled = enabled;
          createDebug.humanize = requireMs();
          createDebug.destroy = destroy;
          Object.keys(env).forEach((key) => {
            createDebug[key] = env[key];
          });
          createDebug.names = [];
          createDebug.skips = [];
          createDebug.formatters = {};
          function selectColor(namespace) {
            let hash = 0;
            for (let i = 0; i < namespace.length; i++) {
              hash = (hash << 5) - hash + namespace.charCodeAt(i);
              hash |= 0;
            }
            return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
          }
          createDebug.selectColor = selectColor;
          function createDebug(namespace) {
            let prevTime;
            let enableOverride = null;
            let namespacesCache;
            let enabledCache;
            function debug2(...args) {
              if (!debug2.enabled) {
                return;
              }
              const self2 = debug2;
              const curr = Number(/* @__PURE__ */ new Date());
              const ms2 = curr - (prevTime || curr);
              self2.diff = ms2;
              self2.prev = prevTime;
              self2.curr = curr;
              prevTime = curr;
              args[0] = createDebug.coerce(args[0]);
              if (typeof args[0] !== "string") {
                args.unshift("%O");
              }
              let index2 = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
                if (match === "%%") {
                  return "%";
                }
                index2++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === "function") {
                  const val = args[index2];
                  match = formatter.call(self2, val);
                  args.splice(index2, 1);
                  index2--;
                }
                return match;
              });
              createDebug.formatArgs.call(self2, args);
              const logFn = self2.log || createDebug.log;
              logFn.apply(self2, args);
            }
            debug2.namespace = namespace;
            debug2.useColors = createDebug.useColors();
            debug2.color = createDebug.selectColor(namespace);
            debug2.extend = extend;
            debug2.destroy = createDebug.destroy;
            Object.defineProperty(debug2, "enabled", {
              enumerable: true,
              configurable: false,
              get: () => {
                if (enableOverride !== null) {
                  return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                  namespacesCache = createDebug.namespaces;
                  enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
              },
              set: (v) => {
                enableOverride = v;
              }
            });
            if (typeof createDebug.init === "function") {
              createDebug.init(debug2);
            }
            return debug2;
          }
          function extend(namespace, delimiter) {
            const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
            newDebug.log = this.log;
            return newDebug;
          }
          function enable(namespaces) {
            createDebug.save(namespaces);
            createDebug.namespaces = namespaces;
            createDebug.names = [];
            createDebug.skips = [];
            const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
            for (const ns of split) {
              if (ns[0] === "-") {
                createDebug.skips.push(ns.slice(1));
              } else {
                createDebug.names.push(ns);
              }
            }
          }
          function matchesTemplate(search, template) {
            let searchIndex = 0;
            let templateIndex = 0;
            let starIndex = -1;
            let matchIndex = 0;
            while (searchIndex < search.length) {
              if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
                if (template[templateIndex] === "*") {
                  starIndex = templateIndex;
                  matchIndex = searchIndex;
                  templateIndex++;
                } else {
                  searchIndex++;
                  templateIndex++;
                }
              } else if (starIndex !== -1) {
                templateIndex = starIndex + 1;
                matchIndex++;
                searchIndex = matchIndex;
              } else {
                return false;
              }
            }
            while (templateIndex < template.length && template[templateIndex] === "*") {
              templateIndex++;
            }
            return templateIndex === template.length;
          }
          function disable() {
            const namespaces = [
              ...createDebug.names,
              ...createDebug.skips.map((namespace) => "-" + namespace)
            ].join(",");
            createDebug.enable("");
            return namespaces;
          }
          function enabled(name2) {
            for (const skip of createDebug.skips) {
              if (matchesTemplate(name2, skip)) {
                return false;
              }
            }
            for (const ns of createDebug.names) {
              if (matchesTemplate(name2, ns)) {
                return true;
              }
            }
            return false;
          }
          function coerce(val) {
            if (val instanceof Error) {
              return val.stack || val.message;
            }
            return val;
          }
          function destroy() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
          createDebug.enable(createDebug.load());
          return createDebug;
        }
        common = setup;
        return common;
      }
      var hasRequiredBrowser;
      function requireBrowser() {
        if (hasRequiredBrowser) return browser.exports;
        hasRequiredBrowser = 1;
        (function(module, exports) {
          var define_process_env_default = {};
          exports.formatArgs = formatArgs;
          exports.save = save;
          exports.load = load;
          exports.useColors = useColors;
          exports.storage = localstorage();
          exports.destroy = /* @__PURE__ */ (() => {
            let warned = false;
            return () => {
              if (!warned) {
                warned = true;
                console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
              }
            };
          })();
          exports.colors = [
            "#0000CC",
            "#0000FF",
            "#0033CC",
            "#0033FF",
            "#0066CC",
            "#0066FF",
            "#0099CC",
            "#0099FF",
            "#00CC00",
            "#00CC33",
            "#00CC66",
            "#00CC99",
            "#00CCCC",
            "#00CCFF",
            "#3300CC",
            "#3300FF",
            "#3333CC",
            "#3333FF",
            "#3366CC",
            "#3366FF",
            "#3399CC",
            "#3399FF",
            "#33CC00",
            "#33CC33",
            "#33CC66",
            "#33CC99",
            "#33CCCC",
            "#33CCFF",
            "#6600CC",
            "#6600FF",
            "#6633CC",
            "#6633FF",
            "#66CC00",
            "#66CC33",
            "#9900CC",
            "#9900FF",
            "#9933CC",
            "#9933FF",
            "#99CC00",
            "#99CC33",
            "#CC0000",
            "#CC0033",
            "#CC0066",
            "#CC0099",
            "#CC00CC",
            "#CC00FF",
            "#CC3300",
            "#CC3333",
            "#CC3366",
            "#CC3399",
            "#CC33CC",
            "#CC33FF",
            "#CC6600",
            "#CC6633",
            "#CC9900",
            "#CC9933",
            "#CCCC00",
            "#CCCC33",
            "#FF0000",
            "#FF0033",
            "#FF0066",
            "#FF0099",
            "#FF00CC",
            "#FF00FF",
            "#FF3300",
            "#FF3333",
            "#FF3366",
            "#FF3399",
            "#FF33CC",
            "#FF33FF",
            "#FF6600",
            "#FF6633",
            "#FF9900",
            "#FF9933",
            "#FFCC00",
            "#FFCC33"
          ];
          function useColors() {
            if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
              return true;
            }
            if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
              return false;
            }
            let m;
            return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
            typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
            // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
            typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
            typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
          }
          function formatArgs(args) {
            args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
            if (!this.useColors) {
              return;
            }
            const c = "color: " + this.color;
            args.splice(1, 0, c, "color: inherit");
            let index2 = 0;
            let lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, (match) => {
              if (match === "%%") {
                return;
              }
              index2++;
              if (match === "%c") {
                lastC = index2;
              }
            });
            args.splice(lastC, 0, c);
          }
          exports.log = console.debug || console.log || (() => {
          });
          function save(namespaces) {
            try {
              if (namespaces) {
                exports.storage.setItem("debug", namespaces);
              } else {
                exports.storage.removeItem("debug");
              }
            } catch (error) {
            }
          }
          function load() {
            let r;
            try {
              r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
            } catch (error) {
            }
            if (!r && typeof process !== "undefined" && "env" in process) {
              r = define_process_env_default.DEBUG;
            }
            return r;
          }
          function localstorage() {
            try {
              return localStorage;
            } catch (error) {
            }
          }
          module.exports = requireCommon()(exports);
          const { formatters } = module.exports;
          formatters.j = function(v) {
            try {
              return JSON.stringify(v);
            } catch (error) {
              return "[UnexpectedJSONParseError]: " + error.message;
            }
          };
        })(browser, browser.exports);
        return browser.exports;
      }
      var browserExports = requireBrowser();
      const initDebug = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
      const Signature = {
        LocalFileHeader: 67324752,
        DataDescriptor: 134695760,
        CentralFileHeader: 33639248,
        EndOfCentralDirectory: 101010256
      };
      const DataDescriptor = {
        get(array) {
          UINT16_LE.get(array, 6);
          return {
            signature: UINT32_LE.get(array, 0),
            compressedSize: UINT32_LE.get(array, 8),
            uncompressedSize: UINT32_LE.get(array, 12)
          };
        },
        len: 16
      };
      const LocalFileHeaderToken = {
        get(array) {
          const flags = UINT16_LE.get(array, 6);
          return {
            signature: UINT32_LE.get(array, 0),
            minVersion: UINT16_LE.get(array, 4),
            dataDescriptor: !!(flags & 8),
            compressedMethod: UINT16_LE.get(array, 8),
            compressedSize: UINT32_LE.get(array, 18),
            uncompressedSize: UINT32_LE.get(array, 22),
            filenameLength: UINT16_LE.get(array, 26),
            extraFieldLength: UINT16_LE.get(array, 28),
            filename: null
          };
        },
        len: 30
      };
      const EndOfCentralDirectoryRecordToken = {
        get(array) {
          return {
            signature: UINT32_LE.get(array, 0),
            nrOfThisDisk: UINT16_LE.get(array, 4),
            nrOfThisDiskWithTheStart: UINT16_LE.get(array, 6),
            nrOfEntriesOnThisDisk: UINT16_LE.get(array, 8),
            nrOfEntriesOfSize: UINT16_LE.get(array, 10),
            sizeOfCd: UINT32_LE.get(array, 12),
            offsetOfStartOfCd: UINT32_LE.get(array, 16),
            zipFileCommentLength: UINT16_LE.get(array, 20)
          };
        },
        len: 22
      };
      const FileHeader = {
        get(array) {
          const flags = UINT16_LE.get(array, 8);
          return {
            signature: UINT32_LE.get(array, 0),
            minVersion: UINT16_LE.get(array, 6),
            dataDescriptor: !!(flags & 8),
            compressedMethod: UINT16_LE.get(array, 10),
            compressedSize: UINT32_LE.get(array, 20),
            uncompressedSize: UINT32_LE.get(array, 24),
            filenameLength: UINT16_LE.get(array, 28),
            extraFieldLength: UINT16_LE.get(array, 30),
            fileCommentLength: UINT16_LE.get(array, 32),
            relativeOffsetOfLocalHeader: UINT32_LE.get(array, 42),
            filename: null
          };
        },
        len: 46
      };
      function signatureToArray(signature) {
        const signatureBytes = new Uint8Array(UINT32_LE.len);
        UINT32_LE.put(signatureBytes, 0, signature);
        return signatureBytes;
      }
      const debug$4 = initDebug("tokenizer:inflate");
      const syncBufferSize = 256 * 1024;
      const ddSignatureArray = signatureToArray(Signature.DataDescriptor);
      const eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);
      class ZipHandler {
        constructor(tokenizer) {
          this.tokenizer = tokenizer;
          this.syncBuffer = new Uint8Array(syncBufferSize);
        }
        async isZip() {
          return await this.peekSignature() === Signature.LocalFileHeader;
        }
        peekSignature() {
          return this.tokenizer.peekToken(UINT32_LE);
        }
        async findEndOfCentralDirectoryLocator() {
          const randomReadTokenizer = this.tokenizer;
          const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
          const buffer = this.syncBuffer.subarray(0, chunkLength);
          await this.tokenizer.readBuffer(buffer, { position: randomReadTokenizer.fileInfo.size - chunkLength });
          for (let i = buffer.length - 4; i >= 0; i--) {
            if (buffer[i] === eocdSignatureBytes[0] && buffer[i + 1] === eocdSignatureBytes[1] && buffer[i + 2] === eocdSignatureBytes[2] && buffer[i + 3] === eocdSignatureBytes[3]) {
              return randomReadTokenizer.fileInfo.size - chunkLength + i;
            }
          }
          return -1;
        }
        async readCentralDirectory() {
          if (!this.tokenizer.supportsRandomAccess()) {
            debug$4("Cannot reading central-directory without random-read support");
            return;
          }
          debug$4("Reading central-directory...");
          const pos = this.tokenizer.position;
          const offset = await this.findEndOfCentralDirectoryLocator();
          if (offset > 0) {
            debug$4("Central-directory 32-bit signature found");
            const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
            const files = [];
            this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
            for (let n = 0; n < eocdHeader.nrOfEntriesOfSize; ++n) {
              const entry = await this.tokenizer.readToken(FileHeader);
              if (entry.signature !== Signature.CentralFileHeader) {
                throw new Error("Expected Central-File-Header signature");
              }
              entry.filename = await this.tokenizer.readToken(new StringType(entry.filenameLength, "utf-8"));
              await this.tokenizer.ignore(entry.extraFieldLength);
              await this.tokenizer.ignore(entry.fileCommentLength);
              files.push(entry);
              debug$4(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);
            }
            this.tokenizer.setPosition(pos);
            return files;
          }
          this.tokenizer.setPosition(pos);
        }
        async unzip(fileCb) {
          const entries = await this.readCentralDirectory();
          if (entries) {
            return this.iterateOverCentralDirectory(entries, fileCb);
          }
          let stop = false;
          do {
            const zipHeader = await this.readLocalFileHeader();
            if (!zipHeader)
              break;
            const next = fileCb(zipHeader);
            stop = !!next.stop;
            let fileData = void 0;
            await this.tokenizer.ignore(zipHeader.extraFieldLength);
            if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
              const chunks = [];
              let len = syncBufferSize;
              debug$4("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
              let nextHeaderIndex = -1;
              while (nextHeaderIndex < 0 && len === syncBufferSize) {
                len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
                nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
                const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
                if (next.handler) {
                  const data = new Uint8Array(size);
                  await this.tokenizer.readBuffer(data);
                  chunks.push(data);
                } else {
                  await this.tokenizer.ignore(size);
                }
              }
              debug$4(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
              if (next.handler) {
                await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
              }
            } else {
              if (next.handler) {
                debug$4(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
                fileData = new Uint8Array(zipHeader.compressedSize);
                await this.tokenizer.readBuffer(fileData);
                await this.inflate(zipHeader, fileData, next.handler);
              } else {
                debug$4(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
                await this.tokenizer.ignore(zipHeader.compressedSize);
              }
            }
            debug$4(`Reading data-descriptor at pos=${this.tokenizer.position}`);
            if (zipHeader.dataDescriptor) {
              const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
              if (dataDescriptor.signature !== 134695760) {
                throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
              }
            }
          } while (!stop);
        }
        async iterateOverCentralDirectory(entries, fileCb) {
          for (const fileHeader of entries) {
            const next = fileCb(fileHeader);
            if (next.handler) {
              this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
              const zipHeader = await this.readLocalFileHeader();
              if (zipHeader) {
                await this.tokenizer.ignore(zipHeader.extraFieldLength);
                const fileData = new Uint8Array(fileHeader.compressedSize);
                await this.tokenizer.readBuffer(fileData);
                await this.inflate(zipHeader, fileData, next.handler);
              }
            }
            if (next.stop)
              break;
          }
        }
        inflate(zipHeader, fileData, cb) {
          if (zipHeader.compressedMethod === 0) {
            return cb(fileData);
          }
          debug$4(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
          const uncompressedData = decompressSync(fileData);
          return cb(uncompressedData);
        }
        async readLocalFileHeader() {
          const signature = await this.tokenizer.peekToken(UINT32_LE);
          if (signature === Signature.LocalFileHeader) {
            const header = await this.tokenizer.readToken(LocalFileHeaderToken);
            header.filename = await this.tokenizer.readToken(new StringType(header.filenameLength, "utf-8"));
            return header;
          }
          if (signature === Signature.CentralFileHeader) {
            return false;
          }
          if (signature === 3759263696) {
            throw new Error("Encrypted ZIP");
          }
          throw new Error("Unexpected signature");
        }
      }
      function indexOf(buffer, portion) {
        const bufferLength = buffer.length;
        const portionLength = portion.length;
        if (portionLength > bufferLength)
          return -1;
        for (let i = 0; i <= bufferLength - portionLength; i++) {
          let found = true;
          for (let j = 0; j < portionLength; j++) {
            if (buffer[i + j] !== portion[j]) {
              found = false;
              break;
            }
          }
          if (found) {
            return i;
          }
        }
        return -1;
      }
      function mergeArrays(chunks) {
        const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
        const mergedArray = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
          mergedArray.set(chunk, offset);
          offset += chunk.length;
        }
        return mergedArray;
      }
      ({
        utf8: new globalThis.TextDecoder("utf8")
      });
      new globalThis.TextEncoder();
      Array.from({ length: 256 }, (_, index2) => index2.toString(16).padStart(2, "0"));
      function getUintBE(view) {
        const { byteLength } = view;
        if (byteLength === 6) {
          return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
        }
        if (byteLength === 5) {
          return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
        }
        if (byteLength === 4) {
          return view.getUint32(0);
        }
        if (byteLength === 3) {
          return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
        }
        if (byteLength === 2) {
          return view.getUint16(0);
        }
        if (byteLength === 1) {
          return view.getUint8(0);
        }
      }
      function stringToBytes$1(string) {
        return [...string].map((character) => character.charCodeAt(0));
      }
      function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
        const readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
        if (Number.isNaN(readSum)) {
          return false;
        }
        let sum = 8 * 32;
        for (let index2 = offset; index2 < offset + 148; index2++) {
          sum += arrayBuffer[index2];
        }
        for (let index2 = offset + 156; index2 < offset + 512; index2++) {
          sum += arrayBuffer[index2];
        }
        return readSum === sum;
      }
      const uint32SyncSafeToken = {
        get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
        len: 4
      };
      const extensions = [
        "jpg",
        "png",
        "apng",
        "gif",
        "webp",
        "flif",
        "xcf",
        "cr2",
        "cr3",
        "orf",
        "arw",
        "dng",
        "nef",
        "rw2",
        "raf",
        "tif",
        "bmp",
        "icns",
        "jxr",
        "psd",
        "indd",
        "zip",
        "tar",
        "rar",
        "gz",
        "bz2",
        "7z",
        "dmg",
        "mp4",
        "mid",
        "mkv",
        "webm",
        "mov",
        "avi",
        "mpg",
        "mp2",
        "mp3",
        "m4a",
        "oga",
        "ogg",
        "ogv",
        "opus",
        "flac",
        "wav",
        "spx",
        "amr",
        "pdf",
        "epub",
        "elf",
        "macho",
        "exe",
        "swf",
        "rtf",
        "wasm",
        "woff",
        "woff2",
        "eot",
        "ttf",
        "otf",
        "ttc",
        "ico",
        "flv",
        "ps",
        "xz",
        "sqlite",
        "nes",
        "crx",
        "xpi",
        "cab",
        "deb",
        "ar",
        "rpm",
        "Z",
        "lz",
        "cfb",
        "mxf",
        "mts",
        "blend",
        "bpg",
        "docx",
        "pptx",
        "xlsx",
        "3gp",
        "3g2",
        "j2c",
        "jp2",
        "jpm",
        "jpx",
        "mj2",
        "aif",
        "qcp",
        "odt",
        "ods",
        "odp",
        "xml",
        "mobi",
        "heic",
        "cur",
        "ktx",
        "ape",
        "wv",
        "dcm",
        "ics",
        "glb",
        "pcap",
        "dsf",
        "lnk",
        "alias",
        "voc",
        "ac3",
        "m4v",
        "m4p",
        "m4b",
        "f4v",
        "f4p",
        "f4b",
        "f4a",
        "mie",
        "asf",
        "ogm",
        "ogx",
        "mpc",
        "arrow",
        "shp",
        "aac",
        "mp1",
        "it",
        "s3m",
        "xm",
        "skp",
        "avif",
        "eps",
        "lzh",
        "pgp",
        "asar",
        "stl",
        "chm",
        "3mf",
        "zst",
        "jxl",
        "vcf",
        "jls",
        "pst",
        "dwg",
        "parquet",
        "class",
        "arj",
        "cpio",
        "ace",
        "avro",
        "icc",
        "fbx",
        "vsdx",
        "vtt",
        "apk",
        "drc",
        "lz4",
        "potx",
        "xltx",
        "dotx",
        "xltm",
        "ott",
        "ots",
        "otp",
        "odg",
        "otg",
        "xlsm",
        "docm",
        "dotm",
        "potm",
        "pptm",
        "jar",
        "rm",
        "ppsm",
        "ppsx"
      ];
      const mimeTypes = [
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/webp",
        "image/flif",
        "image/x-xcf",
        "image/x-canon-cr2",
        "image/x-canon-cr3",
        "image/tiff",
        "image/bmp",
        "image/vnd.ms-photo",
        "image/vnd.adobe.photoshop",
        "application/x-indesign",
        "application/epub+zip",
        "application/x-xpinstall",
        "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
        "application/vnd.oasis.opendocument.text",
        "application/vnd.oasis.opendocument.spreadsheet",
        "application/vnd.oasis.opendocument.presentation",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
        "application/zip",
        "application/x-tar",
        "application/x-rar-compressed",
        "application/gzip",
        "application/x-bzip2",
        "application/x-7z-compressed",
        "application/x-apple-diskimage",
        "application/vnd.apache.arrow.file",
        "video/mp4",
        "audio/midi",
        "video/matroska",
        "video/webm",
        "video/quicktime",
        "video/vnd.avi",
        "audio/wav",
        "audio/qcelp",
        "audio/x-ms-asf",
        "video/x-ms-asf",
        "application/vnd.ms-asf",
        "video/mpeg",
        "video/3gpp",
        "audio/mpeg",
        "audio/mp4",
        // RFC 4337
        "video/ogg",
        "audio/ogg",
        "audio/ogg; codecs=opus",
        "application/ogg",
        "audio/flac",
        "audio/ape",
        "audio/wavpack",
        "audio/amr",
        "application/pdf",
        "application/x-elf",
        "application/x-mach-binary",
        "application/x-msdownload",
        "application/x-shockwave-flash",
        "application/rtf",
        "application/wasm",
        "font/woff",
        "font/woff2",
        "application/vnd.ms-fontobject",
        "font/ttf",
        "font/otf",
        "font/collection",
        "image/x-icon",
        "video/x-flv",
        "application/postscript",
        "application/eps",
        "application/x-xz",
        "application/x-sqlite3",
        "application/x-nintendo-nes-rom",
        "application/x-google-chrome-extension",
        "application/vnd.ms-cab-compressed",
        "application/x-deb",
        "application/x-unix-archive",
        "application/x-rpm",
        "application/x-compress",
        "application/x-lzip",
        "application/x-cfb",
        "application/x-mie",
        "application/mxf",
        "video/mp2t",
        "application/x-blender",
        "image/bpg",
        "image/j2c",
        "image/jp2",
        "image/jpx",
        "image/jpm",
        "image/mj2",
        "audio/aiff",
        "application/xml",
        "application/x-mobipocket-ebook",
        "image/heif",
        "image/heif-sequence",
        "image/heic",
        "image/heic-sequence",
        "image/icns",
        "image/ktx",
        "application/dicom",
        "audio/x-musepack",
        "text/calendar",
        "text/vcard",
        "text/vtt",
        "model/gltf-binary",
        "application/vnd.tcpdump.pcap",
        "audio/x-dsf",
        // Non-standard
        "application/x.ms.shortcut",
        // Invented by us
        "application/x.apple.alias",
        // Invented by us
        "audio/x-voc",
        "audio/vnd.dolby.dd-raw",
        "audio/x-m4a",
        "image/apng",
        "image/x-olympus-orf",
        "image/x-sony-arw",
        "image/x-adobe-dng",
        "image/x-nikon-nef",
        "image/x-panasonic-rw2",
        "image/x-fujifilm-raf",
        "video/x-m4v",
        "video/3gpp2",
        "application/x-esri-shape",
        "audio/aac",
        "audio/x-it",
        "audio/x-s3m",
        "audio/x-xm",
        "video/MP1S",
        "video/MP2P",
        "application/vnd.sketchup.skp",
        "image/avif",
        "application/x-lzh-compressed",
        "application/pgp-encrypted",
        "application/x-asar",
        "model/stl",
        "application/vnd.ms-htmlhelp",
        "model/3mf",
        "image/jxl",
        "application/zstd",
        "image/jls",
        "application/vnd.ms-outlook",
        "image/vnd.dwg",
        "application/vnd.apache.parquet",
        "application/java-vm",
        "application/x-arj",
        "application/x-cpio",
        "application/x-ace-compressed",
        "application/avro",
        "application/vnd.iccprofile",
        "application/x.autodesk.fbx",
        // Invented by us
        "application/vnd.visio",
        "application/vnd.android.package-archive",
        "application/vnd.google.draco",
        // Invented by us
        "application/x-lz4",
        // Invented by us
        "application/vnd.openxmlformats-officedocument.presentationml.template",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
        "application/vnd.ms-excel.template.macroenabled.12",
        "application/vnd.oasis.opendocument.text-template",
        "application/vnd.oasis.opendocument.spreadsheet-template",
        "application/vnd.oasis.opendocument.presentation-template",
        "application/vnd.oasis.opendocument.graphics",
        "application/vnd.oasis.opendocument.graphics-template",
        "application/vnd.ms-excel.sheet.macroenabled.12",
        "application/vnd.ms-word.document.macroenabled.12",
        "application/vnd.ms-word.template.macroenabled.12",
        "application/vnd.ms-powerpoint.template.macroenabled.12",
        "application/vnd.ms-powerpoint.presentation.macroenabled.12",
        "application/java-archive",
        "application/vnd.rn-realmedia"
      ];
      const reasonableDetectionSizeInBytes = 4100;
      async function fileTypeFromBuffer(input, options) {
        return new FileTypeParser(options).fromBuffer(input);
      }
      function getFileTypeFromMimeType(mimeType) {
        mimeType = mimeType.toLowerCase();
        switch (mimeType) {
          case "application/epub+zip":
            return {
              ext: "epub",
              mime: mimeType
            };
          case "application/vnd.oasis.opendocument.text":
            return {
              ext: "odt",
              mime: mimeType
            };
          case "application/vnd.oasis.opendocument.text-template":
            return {
              ext: "ott",
              mime: mimeType
            };
          case "application/vnd.oasis.opendocument.spreadsheet":
            return {
              ext: "ods",
              mime: mimeType
            };
          case "application/vnd.oasis.opendocument.spreadsheet-template":
            return {
              ext: "ots",
              mime: mimeType
            };
          case "application/vnd.oasis.opendocument.presentation":
            return {
              ext: "odp",
              mime: mimeType
            };
          case "application/vnd.oasis.opendocument.presentation-template":
            return {
              ext: "otp",
              mime: mimeType
            };
          case "application/vnd.oasis.opendocument.graphics":
            return {
              ext: "odg",
              mime: mimeType
            };
          case "application/vnd.oasis.opendocument.graphics-template":
            return {
              ext: "otg",
              mime: mimeType
            };
          case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
            return {
              ext: "ppsx",
              mime: mimeType
            };
          case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
            return {
              ext: "xlsx",
              mime: mimeType
            };
          case "application/vnd.ms-excel.sheet.macroenabled":
            return {
              ext: "xlsm",
              mime: "application/vnd.ms-excel.sheet.macroenabled.12"
            };
          case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
            return {
              ext: "xltx",
              mime: mimeType
            };
          case "application/vnd.ms-excel.template.macroenabled":
            return {
              ext: "xltm",
              mime: "application/vnd.ms-excel.template.macroenabled.12"
            };
          case "application/vnd.ms-powerpoint.slideshow.macroenabled":
            return {
              ext: "ppsm",
              mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
            };
          case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
            return {
              ext: "docx",
              mime: mimeType
            };
          case "application/vnd.ms-word.document.macroenabled":
            return {
              ext: "docm",
              mime: "application/vnd.ms-word.document.macroenabled.12"
            };
          case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
            return {
              ext: "dotx",
              mime: mimeType
            };
          case "application/vnd.ms-word.template.macroenabledtemplate":
            return {
              ext: "dotm",
              mime: "application/vnd.ms-word.template.macroenabled.12"
            };
          case "application/vnd.openxmlformats-officedocument.presentationml.template":
            return {
              ext: "potx",
              mime: mimeType
            };
          case "application/vnd.ms-powerpoint.template.macroenabled":
            return {
              ext: "potm",
              mime: "application/vnd.ms-powerpoint.template.macroenabled.12"
            };
          case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
            return {
              ext: "pptx",
              mime: mimeType
            };
          case "application/vnd.ms-powerpoint.presentation.macroenabled":
            return {
              ext: "pptm",
              mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12"
            };
          case "application/vnd.ms-visio.drawing":
            return {
              ext: "vsdx",
              mime: "application/vnd.visio"
            };
          case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
            return {
              ext: "3mf",
              mime: "model/3mf"
            };
        }
      }
      function _check(buffer, headers, options) {
        options = {
          offset: 0,
          ...options
        };
        for (const [index2, header] of headers.entries()) {
          if (options.mask) {
            if (header !== (options.mask[index2] & buffer[index2 + options.offset])) {
              return false;
            }
          } else if (header !== buffer[index2 + options.offset]) {
            return false;
          }
        }
        return true;
      }
      class FileTypeParser {
        constructor(options) {
          this.options = {
            mpegOffsetTolerance: 0,
            ...options
          };
          this.detectors = [
            ...options?.customDetectors ?? [],
            { id: "core", detect: this.detectConfident },
            { id: "core.imprecise", detect: this.detectImprecise }
          ];
          this.tokenizerOptions = {
            abortSignal: options?.signal
          };
        }
        async fromTokenizer(tokenizer) {
          const initialPosition = tokenizer.position;
          for (const detector of this.detectors) {
            const fileType = await detector.detect(tokenizer);
            if (fileType) {
              return fileType;
            }
            if (initialPosition !== tokenizer.position) {
              return void 0;
            }
          }
        }
        async fromBuffer(input) {
          if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
            throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
          }
          const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
          if (!(buffer?.length > 1)) {
            return;
          }
          return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
        }
        async fromBlob(blob) {
          return this.fromStream(blob.stream());
        }
        async fromStream(stream) {
          const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
          try {
            return await this.fromTokenizer(tokenizer);
          } finally {
            await tokenizer.close();
          }
        }
        async toDetectionStream(stream, options) {
          const { sampleSize = reasonableDetectionSizeInBytes } = options;
          let detectedFileType;
          let firstChunk;
          const reader = stream.getReader({ mode: "byob" });
          try {
            const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
            firstChunk = chunk;
            if (!done && chunk) {
              try {
                detectedFileType = await this.fromBuffer(chunk.subarray(0, sampleSize));
              } catch (error) {
                if (!(error instanceof EndOfStreamError)) {
                  throw error;
                }
                detectedFileType = void 0;
              }
            }
            firstChunk = chunk;
          } finally {
            reader.releaseLock();
          }
          const transformStream = new TransformStream({
            async start(controller) {
              controller.enqueue(firstChunk);
            },
            transform(chunk, controller) {
              controller.enqueue(chunk);
            }
          });
          const newStream = stream.pipeThrough(transformStream);
          newStream.fileType = detectedFileType;
          return newStream;
        }
        check(header, options) {
          return _check(this.buffer, header, options);
        }
        checkString(header, options) {
          return this.check(stringToBytes$1(header), options);
        }
        // Detections with a high degree of certainty in identifying the correct file type
        detectConfident = async (tokenizer) => {
          this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
          if (tokenizer.fileInfo.size === void 0) {
            tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
          }
          this.tokenizer = tokenizer;
          await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
          if (this.check([66, 77])) {
            return {
              ext: "bmp",
              mime: "image/bmp"
            };
          }
          if (this.check([11, 119])) {
            return {
              ext: "ac3",
              mime: "audio/vnd.dolby.dd-raw"
            };
          }
          if (this.check([120, 1])) {
            return {
              ext: "dmg",
              mime: "application/x-apple-diskimage"
            };
          }
          if (this.check([77, 90])) {
            return {
              ext: "exe",
              mime: "application/x-msdownload"
            };
          }
          if (this.check([37, 33])) {
            await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
            if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
              return {
                ext: "eps",
                mime: "application/eps"
              };
            }
            return {
              ext: "ps",
              mime: "application/postscript"
            };
          }
          if (this.check([31, 160]) || this.check([31, 157])) {
            return {
              ext: "Z",
              mime: "application/x-compress"
            };
          }
          if (this.check([199, 113])) {
            return {
              ext: "cpio",
              mime: "application/x-cpio"
            };
          }
          if (this.check([96, 234])) {
            return {
              ext: "arj",
              mime: "application/x-arj"
            };
          }
          if (this.check([239, 187, 191])) {
            this.tokenizer.ignore(3);
            return this.detectConfident(tokenizer);
          }
          if (this.check([71, 73, 70])) {
            return {
              ext: "gif",
              mime: "image/gif"
            };
          }
          if (this.check([73, 73, 188])) {
            return {
              ext: "jxr",
              mime: "image/vnd.ms-photo"
            };
          }
          if (this.check([31, 139, 8])) {
            return {
              ext: "gz",
              mime: "application/gzip"
            };
          }
          if (this.check([66, 90, 104])) {
            return {
              ext: "bz2",
              mime: "application/x-bzip2"
            };
          }
          if (this.checkString("ID3")) {
            await tokenizer.ignore(6);
            const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
            if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
              return {
                ext: "mp3",
                mime: "audio/mpeg"
              };
            }
            await tokenizer.ignore(id3HeaderLength);
            return this.fromTokenizer(tokenizer);
          }
          if (this.checkString("MP+")) {
            return {
              ext: "mpc",
              mime: "audio/x-musepack"
            };
          }
          if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
            return {
              ext: "swf",
              mime: "application/x-shockwave-flash"
            };
          }
          if (this.check([255, 216, 255])) {
            if (this.check([247], { offset: 3 })) {
              return {
                ext: "jls",
                mime: "image/jls"
              };
            }
            return {
              ext: "jpg",
              mime: "image/jpeg"
            };
          }
          if (this.check([79, 98, 106, 1])) {
            return {
              ext: "avro",
              mime: "application/avro"
            };
          }
          if (this.checkString("FLIF")) {
            return {
              ext: "flif",
              mime: "image/flif"
            };
          }
          if (this.checkString("8BPS")) {
            return {
              ext: "psd",
              mime: "image/vnd.adobe.photoshop"
            };
          }
          if (this.checkString("MPCK")) {
            return {
              ext: "mpc",
              mime: "audio/x-musepack"
            };
          }
          if (this.checkString("FORM")) {
            return {
              ext: "aif",
              mime: "audio/aiff"
            };
          }
          if (this.checkString("icns", { offset: 0 })) {
            return {
              ext: "icns",
              mime: "image/icns"
            };
          }
          if (this.check([80, 75, 3, 4])) {
            let fileType;
            await new ZipHandler(tokenizer).unzip((zipHeader) => {
              switch (zipHeader.filename) {
                case "META-INF/mozilla.rsa":
                  fileType = {
                    ext: "xpi",
                    mime: "application/x-xpinstall"
                  };
                  return {
                    stop: true
                  };
                case "META-INF/MANIFEST.MF":
                  fileType = {
                    ext: "jar",
                    mime: "application/java-archive"
                  };
                  return {
                    stop: true
                  };
                case "mimetype":
                  return {
                    async handler(fileData) {
                      const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
                      fileType = getFileTypeFromMimeType(mimeType);
                    },
                    stop: true
                  };
                case "[Content_Types].xml":
                  return {
                    async handler(fileData) {
                      let xmlContent = new TextDecoder("utf-8").decode(fileData);
                      const endPos = xmlContent.indexOf('.main+xml"');
                      if (endPos === -1) {
                        const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                        if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                          fileType = getFileTypeFromMimeType(mimeType);
                        }
                      } else {
                        xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                        const firstPos = xmlContent.lastIndexOf('"');
                        const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                        fileType = getFileTypeFromMimeType(mimeType);
                      }
                    },
                    stop: true
                  };
                default:
                  if (/classes\d*\.dex/.test(zipHeader.filename)) {
                    fileType = {
                      ext: "apk",
                      mime: "application/vnd.android.package-archive"
                    };
                    return { stop: true };
                  }
                  return {};
              }
            });
            return fileType ?? {
              ext: "zip",
              mime: "application/zip"
            };
          }
          if (this.checkString("OggS")) {
            await tokenizer.ignore(28);
            const type = new Uint8Array(8);
            await tokenizer.readBuffer(type);
            if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
              return {
                ext: "opus",
                mime: "audio/ogg; codecs=opus"
              };
            }
            if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
              return {
                ext: "ogv",
                mime: "video/ogg"
              };
            }
            if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
              return {
                ext: "ogm",
                mime: "video/ogg"
              };
            }
            if (_check(type, [127, 70, 76, 65, 67])) {
              return {
                ext: "oga",
                mime: "audio/ogg"
              };
            }
            if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
              return {
                ext: "spx",
                mime: "audio/ogg"
              };
            }
            if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
              return {
                ext: "ogg",
                mime: "audio/ogg"
              };
            }
            return {
              ext: "ogx",
              mime: "application/ogg"
            };
          }
          if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
            return {
              ext: "zip",
              mime: "application/zip"
            };
          }
          if (this.checkString("MThd")) {
            return {
              ext: "mid",
              mime: "audio/midi"
            };
          }
          if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
            return {
              ext: "woff",
              mime: "font/woff"
            };
          }
          if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
            return {
              ext: "woff2",
              mime: "font/woff2"
            };
          }
          if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
            return {
              ext: "pcap",
              mime: "application/vnd.tcpdump.pcap"
            };
          }
          if (this.checkString("DSD ")) {
            return {
              ext: "dsf",
              mime: "audio/x-dsf"
              // Non-standard
            };
          }
          if (this.checkString("LZIP")) {
            return {
              ext: "lz",
              mime: "application/x-lzip"
            };
          }
          if (this.checkString("fLaC")) {
            return {
              ext: "flac",
              mime: "audio/flac"
            };
          }
          if (this.check([66, 80, 71, 251])) {
            return {
              ext: "bpg",
              mime: "image/bpg"
            };
          }
          if (this.checkString("wvpk")) {
            return {
              ext: "wv",
              mime: "audio/wavpack"
            };
          }
          if (this.checkString("%PDF")) {
            return {
              ext: "pdf",
              mime: "application/pdf"
            };
          }
          if (this.check([0, 97, 115, 109])) {
            return {
              ext: "wasm",
              mime: "application/wasm"
            };
          }
          if (this.check([73, 73])) {
            const fileType = await this.readTiffHeader(false);
            if (fileType) {
              return fileType;
            }
          }
          if (this.check([77, 77])) {
            const fileType = await this.readTiffHeader(true);
            if (fileType) {
              return fileType;
            }
          }
          if (this.checkString("MAC ")) {
            return {
              ext: "ape",
              mime: "audio/ape"
            };
          }
          if (this.check([26, 69, 223, 163])) {
            async function readField() {
              const msb = await tokenizer.peekNumber(UINT8);
              let mask = 128;
              let ic = 0;
              while ((msb & mask) === 0 && mask !== 0) {
                ++ic;
                mask >>= 1;
              }
              const id = new Uint8Array(ic + 1);
              await tokenizer.readBuffer(id);
              return id;
            }
            async function readElement() {
              const idField = await readField();
              const lengthField = await readField();
              lengthField[0] ^= 128 >> lengthField.length - 1;
              const nrLength = Math.min(6, lengthField.length);
              const idView = new DataView(idField.buffer);
              const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
              return {
                id: getUintBE(idView),
                len: getUintBE(lengthView)
              };
            }
            async function readChildren(children) {
              while (children > 0) {
                const element = await readElement();
                if (element.id === 17026) {
                  const rawValue = await tokenizer.readToken(new StringType(element.len));
                  return rawValue.replaceAll(/\00.*$/g, "");
                }
                await tokenizer.ignore(element.len);
                --children;
              }
            }
            const re = await readElement();
            const documentType = await readChildren(re.len);
            switch (documentType) {
              case "webm":
                return {
                  ext: "webm",
                  mime: "video/webm"
                };
              case "matroska":
                return {
                  ext: "mkv",
                  mime: "video/matroska"
                };
              default:
                return;
            }
          }
          if (this.checkString("SQLi")) {
            return {
              ext: "sqlite",
              mime: "application/x-sqlite3"
            };
          }
          if (this.check([78, 69, 83, 26])) {
            return {
              ext: "nes",
              mime: "application/x-nintendo-nes-rom"
            };
          }
          if (this.checkString("Cr24")) {
            return {
              ext: "crx",
              mime: "application/x-google-chrome-extension"
            };
          }
          if (this.checkString("MSCF") || this.checkString("ISc(")) {
            return {
              ext: "cab",
              mime: "application/vnd.ms-cab-compressed"
            };
          }
          if (this.check([237, 171, 238, 219])) {
            return {
              ext: "rpm",
              mime: "application/x-rpm"
            };
          }
          if (this.check([197, 208, 211, 198])) {
            return {
              ext: "eps",
              mime: "application/eps"
            };
          }
          if (this.check([40, 181, 47, 253])) {
            return {
              ext: "zst",
              mime: "application/zstd"
            };
          }
          if (this.check([127, 69, 76, 70])) {
            return {
              ext: "elf",
              mime: "application/x-elf"
            };
          }
          if (this.check([33, 66, 68, 78])) {
            return {
              ext: "pst",
              mime: "application/vnd.ms-outlook"
            };
          }
          if (this.checkString("PAR1") || this.checkString("PARE")) {
            return {
              ext: "parquet",
              mime: "application/vnd.apache.parquet"
            };
          }
          if (this.checkString("ttcf")) {
            return {
              ext: "ttc",
              mime: "font/collection"
            };
          }
          if (this.check([207, 250, 237, 254])) {
            return {
              ext: "macho",
              mime: "application/x-mach-binary"
            };
          }
          if (this.check([4, 34, 77, 24])) {
            return {
              ext: "lz4",
              mime: "application/x-lz4"
              // Invented by us
            };
          }
          if (this.check([79, 84, 84, 79, 0])) {
            return {
              ext: "otf",
              mime: "font/otf"
            };
          }
          if (this.checkString("#!AMR")) {
            return {
              ext: "amr",
              mime: "audio/amr"
            };
          }
          if (this.checkString("{\\rtf")) {
            return {
              ext: "rtf",
              mime: "application/rtf"
            };
          }
          if (this.check([70, 76, 86, 1])) {
            return {
              ext: "flv",
              mime: "video/x-flv"
            };
          }
          if (this.checkString("IMPM")) {
            return {
              ext: "it",
              mime: "audio/x-it"
            };
          }
          if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
            return {
              ext: "lzh",
              mime: "application/x-lzh-compressed"
            };
          }
          if (this.check([0, 0, 1, 186])) {
            if (this.check([33], { offset: 4, mask: [241] })) {
              return {
                ext: "mpg",
                // May also be .ps, .mpeg
                mime: "video/MP1S"
              };
            }
            if (this.check([68], { offset: 4, mask: [196] })) {
              return {
                ext: "mpg",
                // May also be .mpg, .m2p, .vob or .sub
                mime: "video/MP2P"
              };
            }
          }
          if (this.checkString("ITSF")) {
            return {
              ext: "chm",
              mime: "application/vnd.ms-htmlhelp"
            };
          }
          if (this.check([202, 254, 186, 190])) {
            return {
              ext: "class",
              mime: "application/java-vm"
            };
          }
          if (this.checkString(".RMF")) {
            return {
              ext: "rm",
              mime: "application/vnd.rn-realmedia"
            };
          }
          if (this.checkString("DRACO")) {
            return {
              ext: "drc",
              mime: "application/vnd.google.draco"
              // Invented by us
            };
          }
          if (this.check([253, 55, 122, 88, 90, 0])) {
            return {
              ext: "xz",
              mime: "application/x-xz"
            };
          }
          if (this.checkString("<?xml ")) {
            return {
              ext: "xml",
              mime: "application/xml"
            };
          }
          if (this.check([55, 122, 188, 175, 39, 28])) {
            return {
              ext: "7z",
              mime: "application/x-7z-compressed"
            };
          }
          if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
            return {
              ext: "rar",
              mime: "application/x-rar-compressed"
            };
          }
          if (this.checkString("solid ")) {
            return {
              ext: "stl",
              mime: "model/stl"
            };
          }
          if (this.checkString("AC")) {
            const version = new StringType(4, "latin1").get(this.buffer, 2);
            if (version.match("^d*") && version >= 1e3 && version <= 1050) {
              return {
                ext: "dwg",
                mime: "image/vnd.dwg"
              };
            }
          }
          if (this.checkString("070707")) {
            return {
              ext: "cpio",
              mime: "application/x-cpio"
            };
          }
          if (this.checkString("BLENDER")) {
            return {
              ext: "blend",
              mime: "application/x-blender"
            };
          }
          if (this.checkString("!<arch>")) {
            await tokenizer.ignore(8);
            const string = await tokenizer.readToken(new StringType(13, "ascii"));
            if (string === "debian-binary") {
              return {
                ext: "deb",
                mime: "application/x-deb"
              };
            }
            return {
              ext: "ar",
              mime: "application/x-unix-archive"
            };
          }
          if (this.checkString("WEBVTT") && // One of LF, CR, tab, space, or end of file must follow "WEBVTT" per the spec (see `fixture/fixture-vtt-*.vtt` for examples). Note that `\0` is technically the null character (there is no such thing as an EOF character). However, checking for `\0` gives us the same result as checking for the end of the stream.
          ["\n", "\r", "	", " ", "\0"].some((char7) => this.checkString(char7, { offset: 6 }))) {
            return {
              ext: "vtt",
              mime: "text/vtt"
            };
          }
          if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
            await tokenizer.ignore(8);
            async function readChunkHeader() {
              return {
                length: await tokenizer.readToken(INT32_BE),
                type: await tokenizer.readToken(new StringType(4, "latin1"))
              };
            }
            do {
              const chunk = await readChunkHeader();
              if (chunk.length < 0) {
                return;
              }
              switch (chunk.type) {
                case "IDAT":
                  return {
                    ext: "png",
                    mime: "image/png"
                  };
                case "acTL":
                  return {
                    ext: "apng",
                    mime: "image/apng"
                  };
                default:
                  await tokenizer.ignore(chunk.length + 4);
              }
            } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
            return {
              ext: "png",
              mime: "image/png"
            };
          }
          if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
            return {
              ext: "arrow",
              mime: "application/vnd.apache.arrow.file"
            };
          }
          if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
            return {
              ext: "glb",
              mime: "model/gltf-binary"
            };
          }
          if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
            return {
              ext: "mov",
              mime: "video/quicktime"
            };
          }
          if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
            return {
              ext: "orf",
              mime: "image/x-olympus-orf"
            };
          }
          if (this.checkString("gimp xcf ")) {
            return {
              ext: "xcf",
              mime: "image/x-xcf"
            };
          }
          if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
            const brandMajor = new StringType(4, "latin1").get(this.buffer, 8).replace("\0", " ").trim();
            switch (brandMajor) {
              case "avif":
              case "avis":
                return { ext: "avif", mime: "image/avif" };
              case "mif1":
                return { ext: "heic", mime: "image/heif" };
              case "msf1":
                return { ext: "heic", mime: "image/heif-sequence" };
              case "heic":
              case "heix":
                return { ext: "heic", mime: "image/heic" };
              case "hevc":
              case "hevx":
                return { ext: "heic", mime: "image/heic-sequence" };
              case "qt":
                return { ext: "mov", mime: "video/quicktime" };
              case "M4V":
              case "M4VH":
              case "M4VP":
                return { ext: "m4v", mime: "video/x-m4v" };
              case "M4P":
                return { ext: "m4p", mime: "video/mp4" };
              case "M4B":
                return { ext: "m4b", mime: "audio/mp4" };
              case "M4A":
                return { ext: "m4a", mime: "audio/x-m4a" };
              case "F4V":
                return { ext: "f4v", mime: "video/mp4" };
              case "F4P":
                return { ext: "f4p", mime: "video/mp4" };
              case "F4A":
                return { ext: "f4a", mime: "audio/mp4" };
              case "F4B":
                return { ext: "f4b", mime: "audio/mp4" };
              case "crx":
                return { ext: "cr3", mime: "image/x-canon-cr3" };
              default:
                if (brandMajor.startsWith("3g")) {
                  if (brandMajor.startsWith("3g2")) {
                    return { ext: "3g2", mime: "video/3gpp2" };
                  }
                  return { ext: "3gp", mime: "video/3gpp" };
                }
                return { ext: "mp4", mime: "video/mp4" };
            }
          }
          if (this.check([82, 73, 70, 70])) {
            if (this.checkString("WEBP", { offset: 8 })) {
              return {
                ext: "webp",
                mime: "image/webp"
              };
            }
            if (this.check([65, 86, 73], { offset: 8 })) {
              return {
                ext: "avi",
                mime: "video/vnd.avi"
              };
            }
            if (this.check([87, 65, 86, 69], { offset: 8 })) {
              return {
                ext: "wav",
                mime: "audio/wav"
              };
            }
            if (this.check([81, 76, 67, 77], { offset: 8 })) {
              return {
                ext: "qcp",
                mime: "audio/qcelp"
              };
            }
          }
          if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
            return {
              ext: "rw2",
              mime: "image/x-panasonic-rw2"
            };
          }
          if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
            async function readHeader() {
              const guid = new Uint8Array(16);
              await tokenizer.readBuffer(guid);
              return {
                id: guid,
                size: Number(await tokenizer.readToken(UINT64_LE))
              };
            }
            await tokenizer.ignore(30);
            while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
              const header = await readHeader();
              let payload = header.size - 24;
              if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
                const typeId = new Uint8Array(16);
                payload -= await tokenizer.readBuffer(typeId);
                if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
                  return {
                    ext: "asf",
                    mime: "audio/x-ms-asf"
                  };
                }
                if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
                  return {
                    ext: "asf",
                    mime: "video/x-ms-asf"
                  };
                }
                break;
              }
              await tokenizer.ignore(payload);
            }
            return {
              ext: "asf",
              mime: "application/vnd.ms-asf"
            };
          }
          if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
            return {
              ext: "ktx",
              mime: "image/ktx"
            };
          }
          if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
            return {
              ext: "mie",
              mime: "application/x-mie"
            };
          }
          if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
            return {
              ext: "shp",
              mime: "application/x-esri-shape"
            };
          }
          if (this.check([255, 79, 255, 81])) {
            return {
              ext: "j2c",
              mime: "image/j2c"
            };
          }
          if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
            await tokenizer.ignore(20);
            const type = await tokenizer.readToken(new StringType(4, "ascii"));
            switch (type) {
              case "jp2 ":
                return {
                  ext: "jp2",
                  mime: "image/jp2"
                };
              case "jpx ":
                return {
                  ext: "jpx",
                  mime: "image/jpx"
                };
              case "jpm ":
                return {
                  ext: "jpm",
                  mime: "image/jpm"
                };
              case "mjp2":
                return {
                  ext: "mj2",
                  mime: "image/mj2"
                };
              default:
                return;
            }
          }
          if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
            return {
              ext: "jxl",
              mime: "image/jxl"
            };
          }
          if (this.check([254, 255])) {
            if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
              return {
                ext: "xml",
                mime: "application/xml"
              };
            }
            return void 0;
          }
          if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
            return {
              ext: "cfb",
              mime: "application/x-cfb"
            };
          }
          await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
          if (this.check([97, 99, 115, 112], { offset: 36 })) {
            return {
              ext: "icc",
              mime: "application/vnd.iccprofile"
            };
          }
          if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
            return {
              ext: "ace",
              mime: "application/x-ace-compressed"
            };
          }
          if (this.checkString("BEGIN:")) {
            if (this.checkString("VCARD", { offset: 6 })) {
              return {
                ext: "vcf",
                mime: "text/vcard"
              };
            }
            if (this.checkString("VCALENDAR", { offset: 6 })) {
              return {
                ext: "ics",
                mime: "text/calendar"
              };
            }
          }
          if (this.checkString("FUJIFILMCCD-RAW")) {
            return {
              ext: "raf",
              mime: "image/x-fujifilm-raf"
            };
          }
          if (this.checkString("Extended Module:")) {
            return {
              ext: "xm",
              mime: "audio/x-xm"
            };
          }
          if (this.checkString("Creative Voice File")) {
            return {
              ext: "voc",
              mime: "audio/x-voc"
            };
          }
          if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
            const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
            if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
              try {
                const header = new TextDecoder().decode(this.buffer.subarray(16, jsonSize + 16));
                const json = JSON.parse(header);
                if (json.files) {
                  return {
                    ext: "asar",
                    mime: "application/x-asar"
                  };
                }
              } catch {
              }
            }
          }
          if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
            return {
              ext: "mxf",
              mime: "application/mxf"
            };
          }
          if (this.checkString("SCRM", { offset: 44 })) {
            return {
              ext: "s3m",
              mime: "audio/x-s3m"
            };
          }
          if (this.check([71]) && this.check([71], { offset: 188 })) {
            return {
              ext: "mts",
              mime: "video/mp2t"
            };
          }
          if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
            return {
              ext: "mts",
              mime: "video/mp2t"
            };
          }
          if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
            return {
              ext: "mobi",
              mime: "application/x-mobipocket-ebook"
            };
          }
          if (this.check([68, 73, 67, 77], { offset: 128 })) {
            return {
              ext: "dcm",
              mime: "application/dicom"
            };
          }
          if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
            return {
              ext: "lnk",
              mime: "application/x.ms.shortcut"
              // Invented by us
            };
          }
          if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
            return {
              ext: "alias",
              mime: "application/x.apple.alias"
              // Invented by us
            };
          }
          if (this.checkString("Kaydara FBX Binary  \0")) {
            return {
              ext: "fbx",
              mime: "application/x.autodesk.fbx"
              // Invented by us
            };
          }
          if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
            return {
              ext: "eot",
              mime: "application/vnd.ms-fontobject"
            };
          }
          if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
            return {
              ext: "indd",
              mime: "application/x-indesign"
            };
          }
          await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
          if (this.checkString("ustar", { offset: 257 }) && (this.checkString("\0", { offset: 262 }) || this.checkString(" ", { offset: 262 })) || this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && tarHeaderChecksumMatches(this.buffer)) {
            return {
              ext: "tar",
              mime: "application/x-tar"
            };
          }
          if (this.check([255, 254])) {
            if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
              return {
                ext: "xml",
                mime: "application/xml"
              };
            }
            if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
              return {
                ext: "skp",
                mime: "application/vnd.sketchup.skp"
              };
            }
            return void 0;
          }
          if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
            return {
              ext: "pgp",
              mime: "application/pgp-encrypted"
            };
          }
        };
        // Detections with limited supporting data, resulting in a higher likelihood of false positives
        detectImprecise = async (tokenizer) => {
          this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
          await tokenizer.peekBuffer(this.buffer, { length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true });
          if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
            return {
              ext: "mpg",
              mime: "video/mpeg"
            };
          }
          if (this.check([0, 1, 0, 0, 0])) {
            return {
              ext: "ttf",
              mime: "font/ttf"
            };
          }
          if (this.check([0, 0, 1, 0])) {
            return {
              ext: "ico",
              mime: "image/x-icon"
            };
          }
          if (this.check([0, 0, 2, 0])) {
            return {
              ext: "cur",
              mime: "image/x-icon"
            };
          }
          await tokenizer.peekBuffer(this.buffer, { length: Math.min(2 + this.options.mpegOffsetTolerance, tokenizer.fileInfo.size), mayBeLess: true });
          if (this.buffer.length >= 2 + this.options.mpegOffsetTolerance) {
            for (let depth = 0; depth <= this.options.mpegOffsetTolerance; ++depth) {
              const type = this.scanMpeg(depth);
              if (type) {
                return type;
              }
            }
          }
        };
        async readTiffTag(bigEndian) {
          const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
          this.tokenizer.ignore(10);
          switch (tagId) {
            case 50341:
              return {
                ext: "arw",
                mime: "image/x-sony-arw"
              };
            case 50706:
              return {
                ext: "dng",
                mime: "image/x-adobe-dng"
              };
          }
        }
        async readTiffIFD(bigEndian) {
          const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
          for (let n = 0; n < numberOfTags; ++n) {
            const fileType = await this.readTiffTag(bigEndian);
            if (fileType) {
              return fileType;
            }
          }
        }
        async readTiffHeader(bigEndian) {
          const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
          const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
          if (version === 42) {
            if (ifdOffset >= 6) {
              if (this.checkString("CR", { offset: 8 })) {
                return {
                  ext: "cr2",
                  mime: "image/x-canon-cr2"
                };
              }
              if (ifdOffset >= 8) {
                const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
                const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
                if (someId1 === 28 && someId2 === 254 || someId1 === 31 && someId2 === 11) {
                  return {
                    ext: "nef",
                    mime: "image/x-nikon-nef"
                  };
                }
              }
            }
            await this.tokenizer.ignore(ifdOffset);
            const fileType = await this.readTiffIFD(bigEndian);
            return fileType ?? {
              ext: "tif",
              mime: "image/tiff"
            };
          }
          if (version === 43) {
            return {
              ext: "tif",
              mime: "image/tiff"
            };
          }
        }
        /**
        	Scan check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE).
        
        	@param offset - Offset to scan for sync-preamble.
        	@returns {{ext: string, mime: string}}
        	*/
        scanMpeg(offset) {
          if (this.check([255, 224], { offset, mask: [255, 224] })) {
            if (this.check([16], { offset: offset + 1, mask: [22] })) {
              if (this.check([8], { offset: offset + 1, mask: [8] })) {
                return {
                  ext: "aac",
                  mime: "audio/aac"
                };
              }
              return {
                ext: "aac",
                mime: "audio/aac"
              };
            }
            if (this.check([2], { offset: offset + 1, mask: [6] })) {
              return {
                ext: "mp3",
                mime: "audio/mpeg"
              };
            }
            if (this.check([4], { offset: offset + 1, mask: [6] })) {
              return {
                ext: "mp2",
                mime: "audio/mpeg"
              };
            }
            if (this.check([6], { offset: offset + 1, mask: [6] })) {
              return {
                ext: "mp1",
                mime: "audio/mpeg"
              };
            }
          }
        }
      }
      new Set(extensions);
      new Set(mimeTypes);
      var contentType = {};
      /*!
       * content-type
       * Copyright(c) 2015 Douglas Christopher Wilson
       * MIT Licensed
       */
      var hasRequiredContentType;
      function requireContentType() {
        if (hasRequiredContentType) return contentType;
        hasRequiredContentType = 1;
        var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
        var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
        var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
        var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
        var QUOTE_REGEXP = /([\\"])/g;
        var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
        contentType.format = format;
        contentType.parse = parse;
        function format(obj) {
          if (!obj || typeof obj !== "object") {
            throw new TypeError("argument obj is required");
          }
          var parameters = obj.parameters;
          var type = obj.type;
          if (!type || !TYPE_REGEXP.test(type)) {
            throw new TypeError("invalid type");
          }
          var string = type;
          if (parameters && typeof parameters === "object") {
            var param;
            var params = Object.keys(parameters).sort();
            for (var i = 0; i < params.length; i++) {
              param = params[i];
              if (!TOKEN_REGEXP.test(param)) {
                throw new TypeError("invalid parameter name");
              }
              string += "; " + param + "=" + qstring(parameters[param]);
            }
          }
          return string;
        }
        function parse(string) {
          if (!string) {
            throw new TypeError("argument string is required");
          }
          var header = typeof string === "object" ? getcontenttype(string) : string;
          if (typeof header !== "string") {
            throw new TypeError("argument string is required to be a string");
          }
          var index2 = header.indexOf(";");
          var type = index2 !== -1 ? header.slice(0, index2).trim() : header.trim();
          if (!TYPE_REGEXP.test(type)) {
            throw new TypeError("invalid media type");
          }
          var obj = new ContentType2(type.toLowerCase());
          if (index2 !== -1) {
            var key;
            var match;
            var value;
            PARAM_REGEXP.lastIndex = index2;
            while (match = PARAM_REGEXP.exec(header)) {
              if (match.index !== index2) {
                throw new TypeError("invalid parameter format");
              }
              index2 += match[0].length;
              key = match[1].toLowerCase();
              value = match[2];
              if (value.charCodeAt(0) === 34) {
                value = value.slice(1, -1);
                if (value.indexOf("\\") !== -1) {
                  value = value.replace(QESC_REGEXP, "$1");
                }
              }
              obj.parameters[key] = value;
            }
            if (index2 !== header.length) {
              throw new TypeError("invalid parameter format");
            }
          }
          return obj;
        }
        function getcontenttype(obj) {
          var header;
          if (typeof obj.getHeader === "function") {
            header = obj.getHeader("content-type");
          } else if (typeof obj.headers === "object") {
            header = obj.headers && obj.headers["content-type"];
          }
          if (typeof header !== "string") {
            throw new TypeError("content-type header is missing from object");
          }
          return header;
        }
        function qstring(val) {
          var str = String(val);
          if (TOKEN_REGEXP.test(str)) {
            return str;
          }
          if (str.length > 0 && !TEXT_REGEXP.test(str)) {
            throw new TypeError("invalid parameter value");
          }
          return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
        }
        function ContentType2(type) {
          this.parameters = /* @__PURE__ */ Object.create(null);
          this.type = type;
        }
        return contentType;
      }
      var contentTypeExports = requireContentType();
      const ContentType = /* @__PURE__ */ getDefaultExportFromCjs(contentTypeExports);
      var mediaTyper = {};
      /*!
       * media-typer
       * Copyright(c) 2014-2017 Douglas Christopher Wilson
       * MIT Licensed
       */
      var hasRequiredMediaTyper;
      function requireMediaTyper() {
        if (hasRequiredMediaTyper) return mediaTyper;
        hasRequiredMediaTyper = 1;
        var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
        var TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
        var TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
        mediaTyper.format = format;
        mediaTyper.parse = parse;
        mediaTyper.test = test;
        function format(obj) {
          if (!obj || typeof obj !== "object") {
            throw new TypeError("argument obj is required");
          }
          var subtype = obj.subtype;
          var suffix = obj.suffix;
          var type = obj.type;
          if (!type || !TYPE_NAME_REGEXP.test(type)) {
            throw new TypeError("invalid type");
          }
          if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype)) {
            throw new TypeError("invalid subtype");
          }
          var string = type + "/" + subtype;
          if (suffix) {
            if (!TYPE_NAME_REGEXP.test(suffix)) {
              throw new TypeError("invalid suffix");
            }
            string += "+" + suffix;
          }
          return string;
        }
        function test(string) {
          if (!string) {
            throw new TypeError("argument string is required");
          }
          if (typeof string !== "string") {
            throw new TypeError("argument string is required to be a string");
          }
          return TYPE_REGEXP.test(string.toLowerCase());
        }
        function parse(string) {
          if (!string) {
            throw new TypeError("argument string is required");
          }
          if (typeof string !== "string") {
            throw new TypeError("argument string is required to be a string");
          }
          var match = TYPE_REGEXP.exec(string.toLowerCase());
          if (!match) {
            throw new TypeError("invalid media type");
          }
          var type = match[1];
          var subtype = match[2];
          var suffix;
          var index2 = subtype.lastIndexOf("+");
          if (index2 !== -1) {
            suffix = subtype.substr(index2 + 1);
            subtype = subtype.substr(0, index2);
          }
          return new MediaType(type, subtype, suffix);
        }
        function MediaType(type, subtype, suffix) {
          this.type = type;
          this.subtype = subtype;
          this.suffix = suffix;
        }
        return mediaTyper;
      }
      var mediaTyperExports = requireMediaTyper();
      const TrackType = {
        video: 1,
        audio: 2,
        complex: 3,
        logo: 4,
        subtitle: 17,
        button: 18,
        control: 32
      };
      const TrackTypeValueToKeyMap = {
        [TrackType.video]: "video",
        [TrackType.audio]: "audio",
        [TrackType.complex]: "complex",
        [TrackType.logo]: "logo",
        [TrackType.subtitle]: "subtitle",
        [TrackType.button]: "button",
        [TrackType.control]: "control"
      };
      const makeParseError = (name2) => {
        return class ParseError extends Error {
          constructor(message2) {
            super(message2);
            this.name = name2;
          }
        };
      };
      class CouldNotDetermineFileTypeError extends makeParseError("CouldNotDetermineFileTypeError") {
      }
      class UnsupportedFileTypeError extends makeParseError("UnsupportedFileTypeError") {
      }
      class UnexpectedFileContentError extends makeParseError("UnexpectedFileContentError") {
        constructor(fileType, message2) {
          super(message2);
          this.fileType = fileType;
        }
        // Override toString to include file type information.
        toString() {
          return `${this.name} (FileType: ${this.fileType}): ${this.message}`;
        }
      }
      class FieldDecodingError extends makeParseError("FieldDecodingError") {
      }
      class InternalParserError extends makeParseError("InternalParserError") {
      }
      const makeUnexpectedFileContentError = (fileType) => {
        return class extends UnexpectedFileContentError {
          constructor(message2) {
            super(fileType, message2);
          }
        };
      };
      function findZero(uint8Array, start, end, encoding) {
        let i = start;
        while (uint8Array[i] !== 0) {
          if (i >= end)
            return end;
          i++;
        }
        return i;
      }
      function decodeString(uint8Array, encoding) {
        if (uint8Array[0] === 255 && uint8Array[1] === 254) {
          return decodeString(uint8Array.subarray(2), encoding);
        }
        return new StringType(uint8Array.length, encoding).get(uint8Array, 0);
      }
      function a2hex(str) {
        const arr = [];
        for (let i = 0, l = str.length; i < l; i++) {
          const hex = Number(str.charCodeAt(i)).toString(16);
          arr.push(hex.length === 1 ? `0${hex}` : hex);
        }
        return arr.join(" ");
      }
      function ratioToDb(ratio) {
        return 10 * Math.log10(ratio);
      }
      function dbToRatio(dB) {
        return 10 ** (dB / 10);
      }
      function toRatio(value) {
        const ps = value.split(" ").map((p) => p.trim().toLowerCase());
        if (ps.length >= 1) {
          const v = Number.parseFloat(ps[0]);
          return ps.length === 2 && ps[1] === "db" ? {
            dB: v,
            ratio: dbToRatio(v)
          } : {
            dB: ratioToDb(v),
            ratio: v
          };
        }
      }
      const LyricsContentType = {
        lyrics: 1
      };
      const TimestampFormat = {
        milliseconds: 2
      };
      const defaultTagInfo = {
        multiple: false
      };
      const commonTags = {
        year: defaultTagInfo,
        track: defaultTagInfo,
        disk: defaultTagInfo,
        title: defaultTagInfo,
        artist: defaultTagInfo,
        artists: { multiple: true, unique: true },
        albumartist: defaultTagInfo,
        album: defaultTagInfo,
        date: defaultTagInfo,
        originaldate: defaultTagInfo,
        originalyear: defaultTagInfo,
        releasedate: defaultTagInfo,
        comment: { multiple: true, unique: false },
        genre: { multiple: true, unique: true },
        picture: { multiple: true, unique: true },
        composer: { multiple: true, unique: true },
        lyrics: { multiple: true, unique: false },
        albumsort: { multiple: false, unique: true },
        titlesort: { multiple: false, unique: true },
        work: { multiple: false, unique: true },
        artistsort: { multiple: false, unique: true },
        albumartistsort: { multiple: false, unique: true },
        composersort: { multiple: false, unique: true },
        lyricist: { multiple: true, unique: true },
        writer: { multiple: true, unique: true },
        conductor: { multiple: true, unique: true },
        remixer: { multiple: true, unique: true },
        arranger: { multiple: true, unique: true },
        engineer: { multiple: true, unique: true },
        producer: { multiple: true, unique: true },
        technician: { multiple: true, unique: true },
        djmixer: { multiple: true, unique: true },
        mixer: { multiple: true, unique: true },
        label: { multiple: true, unique: true },
        grouping: defaultTagInfo,
        subtitle: { multiple: true },
        discsubtitle: defaultTagInfo,
        totaltracks: defaultTagInfo,
        totaldiscs: defaultTagInfo,
        compilation: defaultTagInfo,
        rating: { multiple: true },
        bpm: defaultTagInfo,
        mood: defaultTagInfo,
        media: defaultTagInfo,
        catalognumber: { multiple: true, unique: true },
        tvShow: defaultTagInfo,
        tvShowSort: defaultTagInfo,
        tvSeason: defaultTagInfo,
        tvEpisode: defaultTagInfo,
        tvEpisodeId: defaultTagInfo,
        tvNetwork: defaultTagInfo,
        podcast: defaultTagInfo,
        podcasturl: defaultTagInfo,
        releasestatus: defaultTagInfo,
        releasetype: { multiple: true },
        releasecountry: defaultTagInfo,
        script: defaultTagInfo,
        language: defaultTagInfo,
        copyright: defaultTagInfo,
        license: defaultTagInfo,
        encodedby: defaultTagInfo,
        encodersettings: defaultTagInfo,
        gapless: defaultTagInfo,
        barcode: defaultTagInfo,
        isrc: { multiple: true },
        asin: defaultTagInfo,
        musicbrainz_recordingid: defaultTagInfo,
        musicbrainz_trackid: defaultTagInfo,
        musicbrainz_albumid: defaultTagInfo,
        musicbrainz_artistid: { multiple: true },
        musicbrainz_albumartistid: { multiple: true },
        musicbrainz_releasegroupid: defaultTagInfo,
        musicbrainz_workid: defaultTagInfo,
        musicbrainz_trmid: defaultTagInfo,
        musicbrainz_discid: defaultTagInfo,
        acoustid_id: defaultTagInfo,
        acoustid_fingerprint: defaultTagInfo,
        musicip_puid: defaultTagInfo,
        musicip_fingerprint: defaultTagInfo,
        website: defaultTagInfo,
        "performer:instrument": { multiple: true, unique: true },
        averageLevel: defaultTagInfo,
        peakLevel: defaultTagInfo,
        notes: { multiple: true, unique: false },
        key: defaultTagInfo,
        originalalbum: defaultTagInfo,
        originalartist: defaultTagInfo,
        discogs_artist_id: { multiple: true, unique: true },
        discogs_release_id: defaultTagInfo,
        discogs_label_id: defaultTagInfo,
        discogs_master_release_id: defaultTagInfo,
        discogs_votes: defaultTagInfo,
        discogs_rating: defaultTagInfo,
        replaygain_track_peak: defaultTagInfo,
        replaygain_track_gain: defaultTagInfo,
        replaygain_album_peak: defaultTagInfo,
        replaygain_album_gain: defaultTagInfo,
        replaygain_track_minmax: defaultTagInfo,
        replaygain_album_minmax: defaultTagInfo,
        replaygain_undo: defaultTagInfo,
        description: { multiple: true },
        longDescription: defaultTagInfo,
        category: { multiple: true },
        hdVideo: defaultTagInfo,
        keywords: { multiple: true },
        movement: defaultTagInfo,
        movementIndex: defaultTagInfo,
        movementTotal: defaultTagInfo,
        podcastId: defaultTagInfo,
        showMovement: defaultTagInfo,
        stik: defaultTagInfo
      };
      function isSingleton(alias) {
        return commonTags[alias] && !commonTags[alias].multiple;
      }
      function isUnique(alias) {
        return !commonTags[alias].multiple || commonTags[alias].unique || false;
      }
      class CommonTagMapper {
        static toIntOrNull(str) {
          const cleaned = Number.parseInt(str, 10);
          return Number.isNaN(cleaned) ? null : cleaned;
        }
        // TODO: a string of 1of1 would fail to be converted
        // converts 1/10 to no : 1, of : 10
        // or 1 to no : 1, of : 0
        static normalizeTrack(origVal) {
          const split = origVal.toString().split("/");
          return {
            no: Number.parseInt(split[0], 10) || null,
            of: Number.parseInt(split[1], 10) || null
          };
        }
        constructor(tagTypes, tagMap2) {
          this.tagTypes = tagTypes;
          this.tagMap = tagMap2;
        }
        /**
         * Process and set common tags
         * write common tags to
         * @param tag Native tag
         * @param warnings Register warnings
         * @return common name
         */
        mapGenericTag(tag, warnings) {
          tag = { id: tag.id, value: tag.value };
          this.postMap(tag, warnings);
          const id = this.getCommonName(tag.id);
          return id ? { id, value: tag.value } : null;
        }
        /**
         * Convert native tag key to common tag key
         * @param tag Native header tag
         * @return common tag name (alias)
         */
        getCommonName(tag) {
          return this.tagMap[tag];
        }
        /**
         * Handle post mapping exceptions / correction
         * @param tag Tag e.g. {"©alb", "Buena Vista Social Club")
         * @param warnings Used to register warnings
         */
        postMap(_tag, _warnings) {
          return;
        }
      }
      CommonTagMapper.maxRatingScore = 1;
      const id3v1TagMap = {
        title: "title",
        artist: "artist",
        album: "album",
        year: "year",
        comment: "comment",
        track: "track",
        genre: "genre"
      };
      class ID3v1TagMapper extends CommonTagMapper {
        constructor() {
          super(["ID3v1"], id3v1TagMap);
        }
      }
      class CaseInsensitiveTagMap extends CommonTagMapper {
        constructor(tagTypes, tagMap2) {
          const upperCaseMap = {};
          for (const tag of Object.keys(tagMap2)) {
            upperCaseMap[tag.toUpperCase()] = tagMap2[tag];
          }
          super(tagTypes, upperCaseMap);
        }
        /**
         * @tag  Native header tag
         * @return common tag name (alias)
         */
        getCommonName(tag) {
          return this.tagMap[tag.toUpperCase()];
        }
      }
      const id3v24TagMap = {
        // id3v2.3
        TIT2: "title",
        TPE1: "artist",
        "TXXX:Artists": "artists",
        TPE2: "albumartist",
        TALB: "album",
        TDRV: "date",
        // [ 'date', 'year' ] ToDo: improve 'year' mapping
        /**
         * Original release year
         */
        TORY: "originalyear",
        TPOS: "disk",
        TCON: "genre",
        APIC: "picture",
        TCOM: "composer",
        USLT: "lyrics",
        TSOA: "albumsort",
        TSOT: "titlesort",
        TOAL: "originalalbum",
        TSOP: "artistsort",
        TSO2: "albumartistsort",
        TSOC: "composersort",
        TEXT: "lyricist",
        "TXXX:Writer": "writer",
        TPE3: "conductor",
        // 'IPLS:instrument': 'performer:instrument', // ToDo
        TPE4: "remixer",
        "IPLS:arranger": "arranger",
        "IPLS:engineer": "engineer",
        "IPLS:producer": "producer",
        "IPLS:DJ-mix": "djmixer",
        "IPLS:mix": "mixer",
        TPUB: "label",
        TIT1: "grouping",
        TIT3: "subtitle",
        TRCK: "track",
        TCMP: "compilation",
        POPM: "rating",
        TBPM: "bpm",
        TMED: "media",
        "TXXX:CATALOGNUMBER": "catalognumber",
        "TXXX:MusicBrainz Album Status": "releasestatus",
        "TXXX:MusicBrainz Album Type": "releasetype",
        /**
         * Release country as documented: https://picard.musicbrainz.org/docs/mappings/#cite_note-0
         */
        "TXXX:MusicBrainz Album Release Country": "releasecountry",
        /**
         * Release country as implemented // ToDo: report
         */
        "TXXX:RELEASECOUNTRY": "releasecountry",
        "TXXX:SCRIPT": "script",
        TLAN: "language",
        TCOP: "copyright",
        WCOP: "license",
        TENC: "encodedby",
        TSSE: "encodersettings",
        "TXXX:BARCODE": "barcode",
        "TXXX:ISRC": "isrc",
        TSRC: "isrc",
        "TXXX:ASIN": "asin",
        "TXXX:originalyear": "originalyear",
        "UFID:http://musicbrainz.org": "musicbrainz_recordingid",
        "TXXX:MusicBrainz Release Track Id": "musicbrainz_trackid",
        "TXXX:MusicBrainz Album Id": "musicbrainz_albumid",
        "TXXX:MusicBrainz Artist Id": "musicbrainz_artistid",
        "TXXX:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
        "TXXX:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
        "TXXX:MusicBrainz Work Id": "musicbrainz_workid",
        "TXXX:MusicBrainz TRM Id": "musicbrainz_trmid",
        "TXXX:MusicBrainz Disc Id": "musicbrainz_discid",
        "TXXX:ACOUSTID_ID": "acoustid_id",
        "TXXX:Acoustid Id": "acoustid_id",
        "TXXX:Acoustid Fingerprint": "acoustid_fingerprint",
        "TXXX:MusicIP PUID": "musicip_puid",
        "TXXX:MusicMagic Fingerprint": "musicip_fingerprint",
        WOAR: "website",
        // id3v2.4
        // ToDo: In same sequence as defined at http://id3.org/id3v2.4.0-frames
        TDRC: "date",
        // date YYYY-MM-DD
        TYER: "year",
        TDOR: "originaldate",
        // 'TMCL:instrument': 'performer:instrument',
        "TIPL:arranger": "arranger",
        "TIPL:engineer": "engineer",
        "TIPL:producer": "producer",
        "TIPL:DJ-mix": "djmixer",
        "TIPL:mix": "mixer",
        TMOO: "mood",
        // additional mappings:
        SYLT: "lyrics",
        TSST: "discsubtitle",
        TKEY: "key",
        COMM: "comment",
        TOPE: "originalartist",
        // Windows Media Player
        "PRIV:AverageLevel": "averageLevel",
        "PRIV:PeakLevel": "peakLevel",
        // Discogs
        "TXXX:DISCOGS_ARTIST_ID": "discogs_artist_id",
        "TXXX:DISCOGS_ARTISTS": "artists",
        "TXXX:DISCOGS_ARTIST_NAME": "artists",
        "TXXX:DISCOGS_ALBUM_ARTISTS": "albumartist",
        "TXXX:DISCOGS_CATALOG": "catalognumber",
        "TXXX:DISCOGS_COUNTRY": "releasecountry",
        "TXXX:DISCOGS_DATE": "originaldate",
        "TXXX:DISCOGS_LABEL": "label",
        "TXXX:DISCOGS_LABEL_ID": "discogs_label_id",
        "TXXX:DISCOGS_MASTER_RELEASE_ID": "discogs_master_release_id",
        "TXXX:DISCOGS_RATING": "discogs_rating",
        "TXXX:DISCOGS_RELEASED": "date",
        "TXXX:DISCOGS_RELEASE_ID": "discogs_release_id",
        "TXXX:DISCOGS_VOTES": "discogs_votes",
        "TXXX:CATALOGID": "catalognumber",
        "TXXX:STYLE": "genre",
        "TXXX:REPLAYGAIN_TRACK_PEAK": "replaygain_track_peak",
        "TXXX:REPLAYGAIN_TRACK_GAIN": "replaygain_track_gain",
        "TXXX:REPLAYGAIN_ALBUM_PEAK": "replaygain_album_peak",
        "TXXX:REPLAYGAIN_ALBUM_GAIN": "replaygain_album_gain",
        "TXXX:MP3GAIN_MINMAX": "replaygain_track_minmax",
        "TXXX:MP3GAIN_ALBUM_MINMAX": "replaygain_album_minmax",
        "TXXX:MP3GAIN_UNDO": "replaygain_undo",
        MVNM: "movement",
        MVIN: "movementIndex",
        PCST: "podcast",
        TCAT: "category",
        TDES: "description",
        TDRL: "releasedate",
        TGID: "podcastId",
        TKWD: "keywords",
        WFED: "podcasturl",
        GRP1: "grouping"
      };
      class ID3v24TagMapper extends CaseInsensitiveTagMap {
        static toRating(popm) {
          return {
            source: popm.email,
            rating: popm.rating > 0 ? (popm.rating - 1) / 254 * CommonTagMapper.maxRatingScore : void 0
          };
        }
        constructor() {
          super(["ID3v2.3", "ID3v2.4"], id3v24TagMap);
        }
        /**
         * Handle post mapping exceptions / correction
         * @param tag to post map
         * @param warnings Wil be used to register (collect) warnings
         */
        postMap(tag, warnings) {
          switch (tag.id) {
            case "UFID":
              {
                const idTag = tag.value;
                if (idTag.owner_identifier === "http://musicbrainz.org") {
                  tag.id += `:${idTag.owner_identifier}`;
                  tag.value = decodeString(idTag.identifier, "latin1");
                }
              }
              break;
            case "PRIV":
              {
                const customTag = tag.value;
                switch (customTag.owner_identifier) {
                  // decode Windows Media Player
                  case "AverageLevel":
                  case "PeakValue":
                    tag.id += `:${customTag.owner_identifier}`;
                    tag.value = customTag.data.length === 4 ? UINT32_LE.get(customTag.data, 0) : null;
                    if (tag.value === null) {
                      warnings.addWarning("Failed to parse PRIV:PeakValue");
                    }
                    break;
                  default:
                    warnings.addWarning(`Unknown PRIV owner-identifier: ${customTag.data}`);
                }
              }
              break;
            case "POPM":
              tag.value = ID3v24TagMapper.toRating(tag.value);
              break;
          }
        }
      }
      const asfTagMap = {
        Title: "title",
        Author: "artist",
        "WM/AlbumArtist": "albumartist",
        "WM/AlbumTitle": "album",
        "WM/Year": "date",
        // changed to 'year' to 'date' based on Picard mappings; ToDo: check me
        "WM/OriginalReleaseTime": "originaldate",
        "WM/OriginalReleaseYear": "originalyear",
        Description: "comment",
        "WM/TrackNumber": "track",
        "WM/PartOfSet": "disk",
        "WM/Genre": "genre",
        "WM/Composer": "composer",
        "WM/Lyrics": "lyrics",
        "WM/AlbumSortOrder": "albumsort",
        "WM/TitleSortOrder": "titlesort",
        "WM/ArtistSortOrder": "artistsort",
        "WM/AlbumArtistSortOrder": "albumartistsort",
        "WM/ComposerSortOrder": "composersort",
        "WM/Writer": "lyricist",
        "WM/Conductor": "conductor",
        "WM/ModifiedBy": "remixer",
        "WM/Engineer": "engineer",
        "WM/Producer": "producer",
        "WM/DJMixer": "djmixer",
        "WM/Mixer": "mixer",
        "WM/Publisher": "label",
        "WM/ContentGroupDescription": "grouping",
        "WM/SubTitle": "subtitle",
        "WM/SetSubTitle": "discsubtitle",
        // 'WM/PartOfSet': 'totaldiscs',
        "WM/IsCompilation": "compilation",
        "WM/SharedUserRating": "rating",
        "WM/BeatsPerMinute": "bpm",
        "WM/Mood": "mood",
        "WM/Media": "media",
        "WM/CatalogNo": "catalognumber",
        "MusicBrainz/Album Status": "releasestatus",
        "MusicBrainz/Album Type": "releasetype",
        "MusicBrainz/Album Release Country": "releasecountry",
        "WM/Script": "script",
        "WM/Language": "language",
        Copyright: "copyright",
        LICENSE: "license",
        "WM/EncodedBy": "encodedby",
        "WM/EncodingSettings": "encodersettings",
        "WM/Barcode": "barcode",
        "WM/ISRC": "isrc",
        "MusicBrainz/Track Id": "musicbrainz_recordingid",
        "MusicBrainz/Release Track Id": "musicbrainz_trackid",
        "MusicBrainz/Album Id": "musicbrainz_albumid",
        "MusicBrainz/Artist Id": "musicbrainz_artistid",
        "MusicBrainz/Album Artist Id": "musicbrainz_albumartistid",
        "MusicBrainz/Release Group Id": "musicbrainz_releasegroupid",
        "MusicBrainz/Work Id": "musicbrainz_workid",
        "MusicBrainz/TRM Id": "musicbrainz_trmid",
        "MusicBrainz/Disc Id": "musicbrainz_discid",
        "Acoustid/Id": "acoustid_id",
        "Acoustid/Fingerprint": "acoustid_fingerprint",
        "MusicIP/PUID": "musicip_puid",
        "WM/ARTISTS": "artists",
        "WM/InitialKey": "key",
        ASIN: "asin",
        "WM/Work": "work",
        "WM/AuthorURL": "website",
        "WM/Picture": "picture"
      };
      class AsfTagMapper extends CommonTagMapper {
        static toRating(rating) {
          return {
            rating: Number.parseFloat(rating + 1) / 5
          };
        }
        constructor() {
          super(["asf"], asfTagMap);
        }
        postMap(tag) {
          switch (tag.id) {
            case "WM/SharedUserRating": {
              const keys = tag.id.split(":");
              tag.value = AsfTagMapper.toRating(tag.value);
              tag.id = keys[0];
              break;
            }
          }
        }
      }
      const id3v22TagMap = {
        TT2: "title",
        TP1: "artist",
        TP2: "albumartist",
        TAL: "album",
        TYE: "year",
        COM: "comment",
        TRK: "track",
        TPA: "disk",
        TCO: "genre",
        PIC: "picture",
        TCM: "composer",
        TOR: "originaldate",
        TOT: "originalalbum",
        TXT: "lyricist",
        TP3: "conductor",
        TPB: "label",
        TT1: "grouping",
        TT3: "subtitle",
        TLA: "language",
        TCR: "copyright",
        WCP: "license",
        TEN: "encodedby",
        TSS: "encodersettings",
        WAR: "website",
        PCS: "podcast",
        TCP: "compilation",
        TDR: "date",
        TS2: "albumartistsort",
        TSA: "albumsort",
        TSC: "composersort",
        TSP: "artistsort",
        TST: "titlesort",
        WFD: "podcasturl",
        TBP: "bpm"
      };
      class ID3v22TagMapper extends CaseInsensitiveTagMap {
        constructor() {
          super(["ID3v2.2"], id3v22TagMap);
        }
      }
      const apev2TagMap = {
        Title: "title",
        Artist: "artist",
        Artists: "artists",
        "Album Artist": "albumartist",
        Album: "album",
        Year: "date",
        Originalyear: "originalyear",
        Originaldate: "originaldate",
        Releasedate: "releasedate",
        Comment: "comment",
        Track: "track",
        Disc: "disk",
        DISCNUMBER: "disk",
        // ToDo: backwards compatibility', valid tag?
        Genre: "genre",
        "Cover Art (Front)": "picture",
        "Cover Art (Back)": "picture",
        Composer: "composer",
        Lyrics: "lyrics",
        ALBUMSORT: "albumsort",
        TITLESORT: "titlesort",
        WORK: "work",
        ARTISTSORT: "artistsort",
        ALBUMARTISTSORT: "albumartistsort",
        COMPOSERSORT: "composersort",
        Lyricist: "lyricist",
        Writer: "writer",
        Conductor: "conductor",
        // 'Performer=artist (instrument)': 'performer:instrument',
        MixArtist: "remixer",
        Arranger: "arranger",
        Engineer: "engineer",
        Producer: "producer",
        DJMixer: "djmixer",
        Mixer: "mixer",
        Label: "label",
        Grouping: "grouping",
        Subtitle: "subtitle",
        DiscSubtitle: "discsubtitle",
        Compilation: "compilation",
        BPM: "bpm",
        Mood: "mood",
        Media: "media",
        CatalogNumber: "catalognumber",
        MUSICBRAINZ_ALBUMSTATUS: "releasestatus",
        MUSICBRAINZ_ALBUMTYPE: "releasetype",
        RELEASECOUNTRY: "releasecountry",
        Script: "script",
        Language: "language",
        Copyright: "copyright",
        LICENSE: "license",
        EncodedBy: "encodedby",
        EncoderSettings: "encodersettings",
        Barcode: "barcode",
        ISRC: "isrc",
        ASIN: "asin",
        musicbrainz_trackid: "musicbrainz_recordingid",
        musicbrainz_releasetrackid: "musicbrainz_trackid",
        MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
        MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
        MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
        MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
        MUSICBRAINZ_WORKID: "musicbrainz_workid",
        MUSICBRAINZ_TRMID: "musicbrainz_trmid",
        MUSICBRAINZ_DISCID: "musicbrainz_discid",
        Acoustid_Id: "acoustid_id",
        ACOUSTID_FINGERPRINT: "acoustid_fingerprint",
        MUSICIP_PUID: "musicip_puid",
        Weblink: "website",
        REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
        REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
        MP3GAIN_MINMAX: "replaygain_track_minmax",
        MP3GAIN_UNDO: "replaygain_undo"
      };
      class APEv2TagMapper extends CaseInsensitiveTagMap {
        constructor() {
          super(["APEv2"], apev2TagMap);
        }
      }
      const mp4TagMap = {
        "©nam": "title",
        "©ART": "artist",
        aART: "albumartist",
        /**
         * ToDo: Album artist seems to be stored here while Picard documentation says: aART
         */
        "----:com.apple.iTunes:Band": "albumartist",
        "©alb": "album",
        "©day": "date",
        "©cmt": "comment",
        "©com": "comment",
        trkn: "track",
        disk: "disk",
        "©gen": "genre",
        covr: "picture",
        "©wrt": "composer",
        "©lyr": "lyrics",
        soal: "albumsort",
        sonm: "titlesort",
        soar: "artistsort",
        soaa: "albumartistsort",
        soco: "composersort",
        "----:com.apple.iTunes:LYRICIST": "lyricist",
        "----:com.apple.iTunes:CONDUCTOR": "conductor",
        "----:com.apple.iTunes:REMIXER": "remixer",
        "----:com.apple.iTunes:ENGINEER": "engineer",
        "----:com.apple.iTunes:PRODUCER": "producer",
        "----:com.apple.iTunes:DJMIXER": "djmixer",
        "----:com.apple.iTunes:MIXER": "mixer",
        "----:com.apple.iTunes:LABEL": "label",
        "©grp": "grouping",
        "----:com.apple.iTunes:SUBTITLE": "subtitle",
        "----:com.apple.iTunes:DISCSUBTITLE": "discsubtitle",
        cpil: "compilation",
        tmpo: "bpm",
        "----:com.apple.iTunes:MOOD": "mood",
        "----:com.apple.iTunes:MEDIA": "media",
        "----:com.apple.iTunes:CATALOGNUMBER": "catalognumber",
        tvsh: "tvShow",
        tvsn: "tvSeason",
        tves: "tvEpisode",
        sosn: "tvShowSort",
        tven: "tvEpisodeId",
        tvnn: "tvNetwork",
        pcst: "podcast",
        purl: "podcasturl",
        "----:com.apple.iTunes:MusicBrainz Album Status": "releasestatus",
        "----:com.apple.iTunes:MusicBrainz Album Type": "releasetype",
        "----:com.apple.iTunes:MusicBrainz Album Release Country": "releasecountry",
        "----:com.apple.iTunes:SCRIPT": "script",
        "----:com.apple.iTunes:LANGUAGE": "language",
        cprt: "copyright",
        "©cpy": "copyright",
        "----:com.apple.iTunes:LICENSE": "license",
        "©too": "encodedby",
        pgap: "gapless",
        "----:com.apple.iTunes:BARCODE": "barcode",
        "----:com.apple.iTunes:ISRC": "isrc",
        "----:com.apple.iTunes:ASIN": "asin",
        "----:com.apple.iTunes:NOTES": "comment",
        "----:com.apple.iTunes:MusicBrainz Track Id": "musicbrainz_recordingid",
        "----:com.apple.iTunes:MusicBrainz Release Track Id": "musicbrainz_trackid",
        "----:com.apple.iTunes:MusicBrainz Album Id": "musicbrainz_albumid",
        "----:com.apple.iTunes:MusicBrainz Artist Id": "musicbrainz_artistid",
        "----:com.apple.iTunes:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
        "----:com.apple.iTunes:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
        "----:com.apple.iTunes:MusicBrainz Work Id": "musicbrainz_workid",
        "----:com.apple.iTunes:MusicBrainz TRM Id": "musicbrainz_trmid",
        "----:com.apple.iTunes:MusicBrainz Disc Id": "musicbrainz_discid",
        "----:com.apple.iTunes:Acoustid Id": "acoustid_id",
        "----:com.apple.iTunes:Acoustid Fingerprint": "acoustid_fingerprint",
        "----:com.apple.iTunes:MusicIP PUID": "musicip_puid",
        "----:com.apple.iTunes:fingerprint": "musicip_fingerprint",
        "----:com.apple.iTunes:replaygain_track_gain": "replaygain_track_gain",
        "----:com.apple.iTunes:replaygain_track_peak": "replaygain_track_peak",
        "----:com.apple.iTunes:replaygain_album_gain": "replaygain_album_gain",
        "----:com.apple.iTunes:replaygain_album_peak": "replaygain_album_peak",
        "----:com.apple.iTunes:replaygain_track_minmax": "replaygain_track_minmax",
        "----:com.apple.iTunes:replaygain_album_minmax": "replaygain_album_minmax",
        "----:com.apple.iTunes:replaygain_undo": "replaygain_undo",
        // Additional mappings:
        gnre: "genre",
        // ToDo: check mapping
        "----:com.apple.iTunes:ALBUMARTISTSORT": "albumartistsort",
        "----:com.apple.iTunes:ARTISTS": "artists",
        "----:com.apple.iTunes:ORIGINALDATE": "originaldate",
        "----:com.apple.iTunes:ORIGINALYEAR": "originalyear",
        "----:com.apple.iTunes:RELEASEDATE": "releasedate",
        // '----:com.apple.iTunes:PERFORMER': 'performer'
        desc: "description",
        ldes: "longDescription",
        "©mvn": "movement",
        "©mvi": "movementIndex",
        "©mvc": "movementTotal",
        "©wrk": "work",
        catg: "category",
        egid: "podcastId",
        hdvd: "hdVideo",
        keyw: "keywords",
        shwm: "showMovement",
        stik: "stik",
        rate: "rating"
      };
      const tagType = "iTunes";
      class MP4TagMapper extends CaseInsensitiveTagMap {
        constructor() {
          super([tagType], mp4TagMap);
        }
        postMap(tag, _warnings) {
          switch (tag.id) {
            case "rate":
              tag.value = {
                source: void 0,
                rating: Number.parseFloat(tag.value) / 100
              };
              break;
          }
        }
      }
      const vorbisTagMap = {
        TITLE: "title",
        ARTIST: "artist",
        ARTISTS: "artists",
        ALBUMARTIST: "albumartist",
        "ALBUM ARTIST": "albumartist",
        ALBUM: "album",
        DATE: "date",
        ORIGINALDATE: "originaldate",
        ORIGINALYEAR: "originalyear",
        RELEASEDATE: "releasedate",
        COMMENT: "comment",
        TRACKNUMBER: "track",
        DISCNUMBER: "disk",
        GENRE: "genre",
        METADATA_BLOCK_PICTURE: "picture",
        COMPOSER: "composer",
        LYRICS: "lyrics",
        ALBUMSORT: "albumsort",
        TITLESORT: "titlesort",
        WORK: "work",
        ARTISTSORT: "artistsort",
        ALBUMARTISTSORT: "albumartistsort",
        COMPOSERSORT: "composersort",
        LYRICIST: "lyricist",
        WRITER: "writer",
        CONDUCTOR: "conductor",
        // 'PERFORMER=artist (instrument)': 'performer:instrument', // ToDo
        REMIXER: "remixer",
        ARRANGER: "arranger",
        ENGINEER: "engineer",
        PRODUCER: "producer",
        DJMIXER: "djmixer",
        MIXER: "mixer",
        LABEL: "label",
        GROUPING: "grouping",
        SUBTITLE: "subtitle",
        DISCSUBTITLE: "discsubtitle",
        TRACKTOTAL: "totaltracks",
        DISCTOTAL: "totaldiscs",
        COMPILATION: "compilation",
        RATING: "rating",
        BPM: "bpm",
        KEY: "key",
        MOOD: "mood",
        MEDIA: "media",
        CATALOGNUMBER: "catalognumber",
        RELEASESTATUS: "releasestatus",
        RELEASETYPE: "releasetype",
        RELEASECOUNTRY: "releasecountry",
        SCRIPT: "script",
        LANGUAGE: "language",
        COPYRIGHT: "copyright",
        LICENSE: "license",
        ENCODEDBY: "encodedby",
        ENCODERSETTINGS: "encodersettings",
        BARCODE: "barcode",
        ISRC: "isrc",
        ASIN: "asin",
        MUSICBRAINZ_TRACKID: "musicbrainz_recordingid",
        MUSICBRAINZ_RELEASETRACKID: "musicbrainz_trackid",
        MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
        MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
        MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
        MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
        MUSICBRAINZ_WORKID: "musicbrainz_workid",
        MUSICBRAINZ_TRMID: "musicbrainz_trmid",
        MUSICBRAINZ_DISCID: "musicbrainz_discid",
        ACOUSTID_ID: "acoustid_id",
        ACOUSTID_ID_FINGERPRINT: "acoustid_fingerprint",
        MUSICIP_PUID: "musicip_puid",
        // 'FINGERPRINT=MusicMagic Fingerprint {fingerprint}': 'musicip_fingerprint', // ToDo
        WEBSITE: "website",
        NOTES: "notes",
        TOTALTRACKS: "totaltracks",
        TOTALDISCS: "totaldiscs",
        // Discogs
        DISCOGS_ARTIST_ID: "discogs_artist_id",
        DISCOGS_ARTISTS: "artists",
        DISCOGS_ARTIST_NAME: "artists",
        DISCOGS_ALBUM_ARTISTS: "albumartist",
        DISCOGS_CATALOG: "catalognumber",
        DISCOGS_COUNTRY: "releasecountry",
        DISCOGS_DATE: "originaldate",
        DISCOGS_LABEL: "label",
        DISCOGS_LABEL_ID: "discogs_label_id",
        DISCOGS_MASTER_RELEASE_ID: "discogs_master_release_id",
        DISCOGS_RATING: "discogs_rating",
        DISCOGS_RELEASED: "date",
        DISCOGS_RELEASE_ID: "discogs_release_id",
        DISCOGS_VOTES: "discogs_votes",
        CATALOGID: "catalognumber",
        STYLE: "genre",
        //
        REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
        REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
        REPLAYGAIN_ALBUM_GAIN: "replaygain_album_gain",
        REPLAYGAIN_ALBUM_PEAK: "replaygain_album_peak",
        // To Sure if these (REPLAYGAIN_MINMAX, REPLAYGAIN_ALBUM_MINMAX & REPLAYGAIN_UNDO) are used for Vorbis:
        REPLAYGAIN_MINMAX: "replaygain_track_minmax",
        REPLAYGAIN_ALBUM_MINMAX: "replaygain_album_minmax",
        REPLAYGAIN_UNDO: "replaygain_undo"
      };
      class VorbisTagMapper extends CommonTagMapper {
        static toRating(email, rating, maxScore) {
          return {
            source: email ? email.toLowerCase() : void 0,
            rating: Number.parseFloat(rating) / maxScore * CommonTagMapper.maxRatingScore
          };
        }
        constructor() {
          super(["vorbis"], vorbisTagMap);
        }
        postMap(tag) {
          if (tag.id === "RATING") {
            tag.value = VorbisTagMapper.toRating(void 0, tag.value, 100);
          } else if (tag.id.indexOf("RATING:") === 0) {
            const keys = tag.id.split(":");
            tag.value = VorbisTagMapper.toRating(keys[1], tag.value, 1);
            tag.id = keys[0];
          }
        }
      }
      const riffInfoTagMap = {
        IART: "artist",
        // Artist
        ICRD: "date",
        // DateCreated
        INAM: "title",
        // Title
        TITL: "title",
        IPRD: "album",
        // Product
        ITRK: "track",
        IPRT: "track",
        // Additional tag for track index
        COMM: "comment",
        // Comments
        ICMT: "comment",
        // Country
        ICNT: "releasecountry",
        GNRE: "genre",
        // Genre
        IWRI: "writer",
        // WrittenBy
        RATE: "rating",
        YEAR: "year",
        ISFT: "encodedby",
        // Software
        CODE: "encodedby",
        // EncodedBy
        TURL: "website",
        // URL,
        IGNR: "genre",
        // Genre
        IENG: "engineer",
        // Engineer
        ITCH: "technician",
        // Technician
        IMED: "media",
        // Original Media
        IRPD: "album"
        // Product, where the file was intended for
      };
      class RiffInfoTagMapper extends CommonTagMapper {
        constructor() {
          super(["exif"], riffInfoTagMap);
        }
      }
      const ebmlTagMap = {
        "segment:title": "title",
        "album:ARTIST": "albumartist",
        "album:ARTISTSORT": "albumartistsort",
        "album:TITLE": "album",
        "album:DATE_RECORDED": "originaldate",
        "album:DATE_RELEASED": "releasedate",
        "album:PART_NUMBER": "disk",
        "album:TOTAL_PARTS": "totaltracks",
        "track:ARTIST": "artist",
        "track:ARTISTSORT": "artistsort",
        "track:TITLE": "title",
        "track:PART_NUMBER": "track",
        "track:MUSICBRAINZ_TRACKID": "musicbrainz_recordingid",
        "track:MUSICBRAINZ_ALBUMID": "musicbrainz_albumid",
        "track:MUSICBRAINZ_ARTISTID": "musicbrainz_artistid",
        "track:PUBLISHER": "label",
        "track:GENRE": "genre",
        "track:ENCODER": "encodedby",
        "track:ENCODER_OPTIONS": "encodersettings",
        "edition:TOTAL_PARTS": "totaldiscs",
        picture: "picture"
      };
      class MatroskaTagMapper extends CaseInsensitiveTagMap {
        constructor() {
          super(["matroska"], ebmlTagMap);
        }
      }
      const tagMap = {
        NAME: "title",
        AUTH: "artist",
        "(c) ": "copyright",
        ANNO: "comment"
      };
      class AiffTagMapper extends CommonTagMapper {
        constructor() {
          super(["AIFF"], tagMap);
        }
      }
      class CombinedTagMapper {
        constructor() {
          this.tagMappers = {};
          [
            new ID3v1TagMapper(),
            new ID3v22TagMapper(),
            new ID3v24TagMapper(),
            new MP4TagMapper(),
            new MP4TagMapper(),
            new VorbisTagMapper(),
            new APEv2TagMapper(),
            new AsfTagMapper(),
            new RiffInfoTagMapper(),
            new MatroskaTagMapper(),
            new AiffTagMapper()
          ].forEach((mapper) => {
            this.registerTagMapper(mapper);
          });
        }
        /**
         * Convert native to generic (common) tags
         * @param tagType Originating tag format
         * @param tag     Native tag to map to a generic tag id
         * @param warnings
         * @return Generic tag result (output of this function)
         */
        mapTag(tagType2, tag, warnings) {
          const tagMapper = this.tagMappers[tagType2];
          if (tagMapper) {
            return this.tagMappers[tagType2].mapGenericTag(tag, warnings);
          }
          throw new InternalParserError(`No generic tag mapper defined for tag-format: ${tagType2}`);
        }
        registerTagMapper(genericTagMapper) {
          for (const tagType2 of genericTagMapper.tagTypes) {
            this.tagMappers[tagType2] = genericTagMapper;
          }
        }
      }
      function parseLrc(lrcString) {
        const lines = lrcString.split("\n");
        const syncText = [];
        const timestampRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
        for (const line of lines) {
          const match = line.match(timestampRegex);
          if (match) {
            const minutes = Number.parseInt(match[1], 10);
            const seconds = Number.parseInt(match[2], 10);
            const millisecondsStr = match[3];
            let milliseconds;
            if (millisecondsStr.length === 3) {
              milliseconds = Number.parseInt(millisecondsStr, 10);
            } else {
              milliseconds = Number.parseInt(millisecondsStr, 10) * 10;
            }
            const timestamp = (minutes * 60 + seconds) * 1e3 + milliseconds;
            const text = line.replace(timestampRegex, "").trim();
            syncText.push({ timestamp, text });
          }
        }
        return {
          contentType: LyricsContentType.lyrics,
          timeStampFormat: TimestampFormat.milliseconds,
          syncText
        };
      }
      const debug$3 = initDebug("music-metadata:collector");
      const TagPriority = ["matroska", "APEv2", "vorbis", "ID3v2.4", "ID3v2.3", "ID3v2.2", "exif", "asf", "iTunes", "AIFF", "ID3v1"];
      class MetadataCollector {
        constructor(opts) {
          this.format = {
            tagTypes: [],
            trackInfo: []
          };
          this.native = {};
          this.common = {
            track: { no: null, of: null },
            disk: { no: null, of: null },
            movementIndex: { no: null, of: null }
          };
          this.quality = {
            warnings: []
          };
          this.commonOrigin = {};
          this.originPriority = {};
          this.tagMapper = new CombinedTagMapper();
          this.opts = opts;
          let priority = 1;
          for (const tagType2 of TagPriority) {
            this.originPriority[tagType2] = priority++;
          }
          this.originPriority.artificial = 500;
          this.originPriority.id3v1 = 600;
        }
        /**
         * @returns {boolean} true if one or more tags have been found
         */
        hasAny() {
          return Object.keys(this.native).length > 0;
        }
        addStreamInfo(streamInfo) {
          debug$3(`streamInfo: type=${streamInfo.type ? TrackTypeValueToKeyMap[streamInfo.type] : "?"}, codec=${streamInfo.codecName}`);
          this.format.trackInfo.push(streamInfo);
        }
        setFormat(key, value) {
          debug$3(`format: ${key} = ${value}`);
          this.format[key] = value;
          if (this.opts?.observer) {
            this.opts.observer({ metadata: this, tag: { type: "format", id: key, value } });
          }
        }
        setAudioOnly() {
          this.setFormat("hasAudio", true);
          this.setFormat("hasVideo", false);
        }
        async addTag(tagType2, tagId, value) {
          debug$3(`tag ${tagType2}.${tagId} = ${value}`);
          if (!this.native[tagType2]) {
            this.format.tagTypes.push(tagType2);
            this.native[tagType2] = [];
          }
          this.native[tagType2].push({ id: tagId, value });
          await this.toCommon(tagType2, tagId, value);
        }
        addWarning(warning) {
          this.quality.warnings.push({ message: warning });
        }
        async postMap(tagType2, tag) {
          switch (tag.id) {
            case "artist":
              if (this.commonOrigin.artist === this.originPriority[tagType2]) {
                return this.postMap("artificial", { id: "artists", value: tag.value });
              }
              if (!this.common.artists) {
                this.setGenericTag("artificial", { id: "artists", value: tag.value });
              }
              break;
            case "artists":
              if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {
                if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {
                  const artists = (this.common.artists || []).concat([tag.value]);
                  const value = joinArtists(artists);
                  const artistTag = { id: "artist", value };
                  this.setGenericTag("artificial", artistTag);
                }
              }
              break;
            case "picture":
              return this.postFixPicture(tag.value).then((picture) => {
                if (picture !== null) {
                  tag.value = picture;
                  this.setGenericTag(tagType2, tag);
                }
              });
            case "totaltracks":
              this.common.track.of = CommonTagMapper.toIntOrNull(tag.value);
              return;
            case "totaldiscs":
              this.common.disk.of = CommonTagMapper.toIntOrNull(tag.value);
              return;
            case "movementTotal":
              this.common.movementIndex.of = CommonTagMapper.toIntOrNull(tag.value);
              return;
            case "track":
            case "disk":
            case "movementIndex": {
              const of = this.common[tag.id].of;
              this.common[tag.id] = CommonTagMapper.normalizeTrack(tag.value);
              this.common[tag.id].of = of != null ? of : this.common[tag.id].of;
              return;
            }
            case "bpm":
            case "year":
            case "originalyear":
              tag.value = Number.parseInt(tag.value, 10);
              break;
            case "date": {
              const year = Number.parseInt(tag.value.substr(0, 4), 10);
              if (!Number.isNaN(year)) {
                this.common.year = year;
              }
              break;
            }
            case "discogs_label_id":
            case "discogs_release_id":
            case "discogs_master_release_id":
            case "discogs_artist_id":
            case "discogs_votes":
              tag.value = typeof tag.value === "string" ? Number.parseInt(tag.value, 10) : tag.value;
              break;
            case "replaygain_track_gain":
            case "replaygain_track_peak":
            case "replaygain_album_gain":
            case "replaygain_album_peak":
              tag.value = toRatio(tag.value);
              break;
            case "replaygain_track_minmax":
              tag.value = tag.value.split(",").map((v) => Number.parseInt(v, 10));
              break;
            case "replaygain_undo": {
              const minMix = tag.value.split(",").map((v) => Number.parseInt(v, 10));
              tag.value = {
                leftChannel: minMix[0],
                rightChannel: minMix[1]
              };
              break;
            }
            case "gapless":
            // iTunes gap-less flag
            case "compilation":
            case "podcast":
            case "showMovement":
              tag.value = tag.value === "1" || tag.value === 1;
              break;
            case "isrc": {
              const commonTag = this.common[tag.id];
              if (commonTag && commonTag.indexOf(tag.value) !== -1)
                return;
              break;
            }
            case "comment":
              if (typeof tag.value === "string") {
                tag.value = { text: tag.value };
              }
              if (tag.value.descriptor === "iTunPGAP") {
                this.setGenericTag(tagType2, { id: "gapless", value: tag.value.text === "1" });
              }
              break;
            case "lyrics":
              if (typeof tag.value === "string") {
                tag.value = parseLrc(tag.value);
              }
              break;
          }
          if (tag.value !== null) {
            this.setGenericTag(tagType2, tag);
          }
        }
        /**
         * Convert native tags to common tags
         * @returns {IAudioMetadata} Native + common tags
         */
        toCommonMetadata() {
          return {
            format: this.format,
            native: this.native,
            quality: this.quality,
            common: this.common
          };
        }
        /**
         * Fix some common issues with picture object
         * @param picture Picture
         */
        async postFixPicture(picture) {
          if (picture.data && picture.data.length > 0) {
            if (!picture.format) {
              const fileType = await fileTypeFromBuffer(Uint8Array.from(picture.data));
              if (fileType) {
                picture.format = fileType.mime;
              } else {
                return null;
              }
            }
            picture.format = picture.format.toLocaleLowerCase();
            switch (picture.format) {
              case "image/jpg":
                picture.format = "image/jpeg";
            }
            return picture;
          }
          this.addWarning("Empty picture tag found");
          return null;
        }
        /**
         * Convert native tag to common tags
         */
        async toCommon(tagType2, tagId, value) {
          const tag = { id: tagId, value };
          const genericTag = this.tagMapper.mapTag(tagType2, tag, this);
          if (genericTag) {
            await this.postMap(tagType2, genericTag);
          }
        }
        /**
         * Set generic tag
         */
        setGenericTag(tagType2, tag) {
          debug$3(`common.${tag.id} = ${tag.value}`);
          const prio0 = this.commonOrigin[tag.id] || 1e3;
          const prio1 = this.originPriority[tagType2];
          if (isSingleton(tag.id)) {
            if (prio1 <= prio0) {
              this.common[tag.id] = tag.value;
              this.commonOrigin[tag.id] = prio1;
            } else {
              return debug$3(`Ignore native tag (singleton): ${tagType2}.${tag.id} = ${tag.value}`);
            }
          } else {
            if (prio1 === prio0) {
              if (!isUnique(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {
                this.common[tag.id].push(tag.value);
              } else {
                debug$3(`Ignore duplicate value: ${tagType2}.${tag.id} = ${tag.value}`);
              }
            } else if (prio1 < prio0) {
              this.common[tag.id] = [tag.value];
              this.commonOrigin[tag.id] = prio1;
            } else {
              return debug$3(`Ignore native tag (list): ${tagType2}.${tag.id} = ${tag.value}`);
            }
          }
          if (this.opts?.observer) {
            this.opts.observer({ metadata: this, tag: { type: "common", id: tag.id, value: tag.value } });
          }
        }
      }
      function joinArtists(artists) {
        if (artists.length > 2) {
          return `${artists.slice(0, artists.length - 1).join(", ")} & ${artists[artists.length - 1]}`;
        }
        return artists.join(" & ");
      }
      const scriptRel = /* @__PURE__ */ (function detectScriptRel() {
        const relList = typeof document !== "undefined" && document.createElement("link").relList;
        return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
      })();
      const assetsURL = function(dep) {
        return "/" + dep;
      };
      const seen = {};
      const __vitePreload = function preload(baseModule, deps, importerUrl) {
        let promise = Promise.resolve();
        if (deps && deps.length > 0) {
          let allSettled = function(promises$2) {
            return Promise.all(promises$2.map((p) => Promise.resolve(p).then((value$1) => ({
              status: "fulfilled",
              value: value$1
            }), (reason) => ({
              status: "rejected",
              reason
            }))));
          };
          document.getElementsByTagName("link");
          const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
          const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
          promise = allSettled(deps.map((dep) => {
            dep = assetsURL(dep);
            if (dep in seen) return;
            seen[dep] = true;
            const isCss = dep.endsWith(".css");
            const cssSelector = isCss ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
            const link = document.createElement("link");
            link.rel = isCss ? "stylesheet" : scriptRel;
            if (!isCss) link.as = "script";
            link.crossOrigin = "";
            link.href = dep;
            if (cspNonce) link.setAttribute("nonce", cspNonce);
            document.head.appendChild(link);
            if (isCss) return new Promise((res, rej) => {
              link.addEventListener("load", res);
              link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
            });
          }));
        }
        function handlePreloadError(err$2) {
          const e$1 = new Event("vite:preloadError", { cancelable: true });
          e$1.payload = err$2;
          window.dispatchEvent(e$1);
          if (!e$1.defaultPrevented) throw err$2;
        }
        return promise.then((res) => {
          for (const item of res || []) {
            if (item.status !== "rejected") continue;
            handlePreloadError(item.reason);
          }
          return baseModule().catch(handlePreloadError);
        });
      };
      const mpegParserLoader = {
        parserType: "mpeg",
        extensions: [".mp2", ".mp3", ".m2a", ".aac", "aacp"],
        mimeTypes: ["audio/mpeg", "audio/mp3", "audio/aacs", "audio/aacp"],
        async load() {
          return (await __vitePreload(async () => {
            const { MpegParser } = await module.import('./MpegParser-DyX8Q9zG-DQ-hFEy_.js');
            return { MpegParser };
          }, void 0 )).MpegParser;
        }
      };
      const apeParserLoader = {
        parserType: "apev2",
        extensions: [".ape"],
        mimeTypes: ["audio/ape", "audio/monkeys-audio"],
        async load() {
          return (await __vitePreload(async () => {
            const { APEv2Parser: APEv2Parser2 } = await Promise.resolve().then(() => APEv2Parser$1);
            return { APEv2Parser: APEv2Parser2 };
          }, void 0 )).APEv2Parser;
        }
      };
      const asfParserLoader = {
        parserType: "asf",
        extensions: [".asf"],
        mimeTypes: ["audio/ms-wma", "video/ms-wmv", "audio/ms-asf", "video/ms-asf", "application/vnd.ms-asf"],
        async load() {
          return (await __vitePreload(async () => {
            const { AsfParser } = await module.import('./AsfParser-kBS_Jzzd--TJ98UiQ.js');
            return { AsfParser };
          }, void 0 )).AsfParser;
        }
      };
      const dsdiffParserLoader = {
        parserType: "dsdiff",
        extensions: [".dff"],
        mimeTypes: ["audio/dsf", "audio/dsd"],
        async load() {
          return (await __vitePreload(async () => {
            const { DsdiffParser } = await module.import('./DsdiffParser-Cj-IrqyX-XWY5qgSL.js');
            return { DsdiffParser };
          }, void 0 )).DsdiffParser;
        }
      };
      const aiffParserLoader = {
        parserType: "aiff",
        extensions: [".aif", "aiff", "aifc"],
        mimeTypes: ["audio/aiff", "audio/aif", "audio/aifc", "application/aiff"],
        async load() {
          return (await __vitePreload(async () => {
            const { AIFFParser } = await module.import('./AiffParser-D5_3j2lV-CIoGOP9Z.js');
            return { AIFFParser };
          }, void 0 )).AIFFParser;
        }
      };
      const dsfParserLoader = {
        parserType: "dsf",
        extensions: [".dsf"],
        mimeTypes: ["audio/dsf"],
        async load() {
          return (await __vitePreload(async () => {
            const { DsfParser } = await module.import('./DsfParser-CXpMW3TW-C2hKRmVY.js');
            return { DsfParser };
          }, void 0 )).DsfParser;
        }
      };
      const flacParserLoader = {
        parserType: "flac",
        extensions: [".flac"],
        mimeTypes: ["audio/flac"],
        async load() {
          return (await __vitePreload(async () => {
            const { FlacParser } = await module.import('./FlacParser-CAsVRrMV-DZB68qaX.js').then((n) => n.d);
            return { FlacParser };
          }, void 0 )).FlacParser;
        }
      };
      const matroskaParserLoader = {
        parserType: "matroska",
        extensions: [".mka", ".mkv", ".mk3d", ".mks", "webm"],
        mimeTypes: ["audio/matroska", "video/matroska", "audio/webm", "video/webm"],
        async load() {
          return (await __vitePreload(async () => {
            const { MatroskaParser } = await module.import('./MatroskaParser-CS7zPSHf-BBAz_su7.js');
            return { MatroskaParser };
          }, void 0 )).MatroskaParser;
        }
      };
      const mp4ParserLoader = {
        parserType: "mp4",
        extensions: [".mp4", ".m4a", ".m4b", ".m4pa", "m4v", "m4r", "3gp"],
        mimeTypes: ["audio/mp4", "audio/m4a", "video/m4v", "video/mp4"],
        async load() {
          return (await __vitePreload(async () => {
            const { MP4Parser } = await module.import('./MP4Parser-D4esQf31-DVt6cbno.js');
            return { MP4Parser };
          }, void 0 )).MP4Parser;
        }
      };
      const musepackParserLoader = {
        parserType: "musepack",
        extensions: [".mpc"],
        mimeTypes: ["audio/musepack"],
        async load() {
          return (await __vitePreload(async () => {
            const { MusepackParser } = await module.import('./MusepackParser-DjtwqjaL-D_aeNfDv.js');
            return { MusepackParser };
          }, void 0 )).MusepackParser;
        }
      };
      const oggParserLoader = {
        parserType: "ogg",
        extensions: [".ogg", ".ogv", ".oga", ".ogm", ".ogx", ".opus", ".spx"],
        mimeTypes: ["audio/ogg", "audio/opus", "audio/speex", "video/ogg"],
        // RFC 7845, RFC 6716, RFC 5574
        async load() {
          return (await __vitePreload(async () => {
            const { OggParser } = await module.import('./OggParser-ClkMM5gt-DEny-a2U.js');
            return { OggParser };
          }, void 0 )).OggParser;
        }
      };
      const wavpackParserLoader = {
        parserType: "wavpack",
        extensions: [".wv", ".wvp"],
        mimeTypes: ["audio/wavpack"],
        async load() {
          return (await __vitePreload(async () => {
            const { WavPackParser } = await module.import('./WavPackParser-BLGhkLPg-CrOWnE7a.js');
            return { WavPackParser };
          }, void 0 )).WavPackParser;
        }
      };
      const riffParserLoader = {
        parserType: "riff",
        extensions: [".wav", "wave", ".bwf"],
        mimeTypes: ["audio/vnd.wave", "audio/wav", "audio/wave"],
        async load() {
          return (await __vitePreload(async () => {
            const { WaveParser } = await module.import('./WaveParser-C8tUW5CK--zKdjNgH.js');
            return { WaveParser };
          }, void 0 )).WaveParser;
        }
      };
      const debug$2 = initDebug("music-metadata:parser:factory");
      function parseHttpContentType(contentType2) {
        const type = ContentType.parse(contentType2);
        const mime = mediaTyperExports.parse(type.type);
        return {
          type: mime.type,
          subtype: mime.subtype,
          suffix: mime.suffix,
          parameters: type.parameters
        };
      }
      class ParserFactory {
        constructor() {
          this.parsers = [];
          [
            flacParserLoader,
            mpegParserLoader,
            apeParserLoader,
            mp4ParserLoader,
            matroskaParserLoader,
            riffParserLoader,
            oggParserLoader,
            asfParserLoader,
            aiffParserLoader,
            wavpackParserLoader,
            musepackParserLoader,
            dsfParserLoader,
            dsdiffParserLoader
          ].forEach((parser) => {
            this.registerParser(parser);
          });
        }
        registerParser(parser) {
          this.parsers.push(parser);
        }
        async parse(tokenizer, parserLoader, opts) {
          if (tokenizer.supportsRandomAccess()) {
            debug$2("tokenizer supports random-access, scanning for appending headers");
            await scanAppendingHeaders(tokenizer, opts);
          } else {
            debug$2("tokenizer does not support random-access, cannot scan for appending headers");
          }
          if (!parserLoader) {
            const buf = new Uint8Array(4100);
            if (tokenizer.fileInfo.mimeType) {
              parserLoader = this.findLoaderForContentType(tokenizer.fileInfo.mimeType);
            }
            if (!parserLoader && tokenizer.fileInfo.path) {
              parserLoader = this.findLoaderForExtension(tokenizer.fileInfo.path);
            }
            if (!parserLoader) {
              debug$2("Guess parser on content...");
              await tokenizer.peekBuffer(buf, { mayBeLess: true });
              const guessedType = await fileTypeFromBuffer(buf, { mpegOffsetTolerance: 10 });
              if (!guessedType || !guessedType.mime) {
                throw new CouldNotDetermineFileTypeError("Failed to determine audio format");
              }
              debug$2(`Guessed file type is mime=${guessedType.mime}, extension=${guessedType.ext}`);
              parserLoader = this.findLoaderForContentType(guessedType.mime);
              if (!parserLoader) {
                throw new UnsupportedFileTypeError(`Guessed MIME-type not supported: ${guessedType.mime}`);
              }
            }
          }
          debug$2(`Loading ${parserLoader.parserType} parser...`);
          const metadata = new MetadataCollector(opts);
          const ParserImpl = await parserLoader.load();
          const parser = new ParserImpl(metadata, tokenizer, opts ?? {});
          debug$2(`Parser ${parserLoader.parserType} loaded`);
          await parser.parse();
          if (metadata.format.trackInfo) {
            if (metadata.format.hasAudio === void 0) {
              metadata.setFormat("hasAudio", !!metadata.format.trackInfo.find((track) => track.type === TrackType.audio));
            }
            if (metadata.format.hasVideo === void 0) {
              metadata.setFormat("hasVideo", !!metadata.format.trackInfo.find((track) => track.type === TrackType.video));
            }
          }
          return metadata.toCommonMetadata();
        }
        /**
         * @param filePath - Path, filename or extension to audio file
         * @return Parser submodule name
         */
        findLoaderForExtension(filePath) {
          if (!filePath)
            return;
          const extension = getExtension(filePath).toLocaleLowerCase() || filePath;
          return this.parsers.find((parser) => parser.extensions.indexOf(extension) !== -1);
        }
        findLoaderForContentType(httpContentType) {
          let mime;
          if (!httpContentType)
            return;
          try {
            mime = parseHttpContentType(httpContentType);
          } catch (_err) {
            debug$2(`Invalid HTTP Content-Type header value: ${httpContentType}`);
            return;
          }
          const subType = mime.subtype.indexOf("x-") === 0 ? mime.subtype.substring(2) : mime.subtype;
          return this.parsers.find((parser) => parser.mimeTypes.find((loader) => loader.indexOf(`${mime.type}/${subType}`) !== -1));
        }
        getSupportedMimeTypes() {
          const mimeTypeSet = /* @__PURE__ */ new Set();
          this.parsers.forEach((loader) => {
            loader.mimeTypes.forEach((mimeType) => {
              mimeTypeSet.add(mimeType);
              mimeTypeSet.add(mimeType.replace("/", "/x-"));
            });
          });
          return Array.from(mimeTypeSet);
        }
      }
      function getExtension(fname) {
        const i = fname.lastIndexOf(".");
        return i === -1 ? "" : fname.slice(i);
      }
      class BasicParser {
        /**
         * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
         * @param {INativeMetadataCollector} metadata Output
         * @param {ITokenizer} tokenizer Input
         * @param {IOptions} options Parsing options
         */
        constructor(metadata, tokenizer, options) {
          this.metadata = metadata;
          this.tokenizer = tokenizer;
          this.options = options;
        }
      }
      const WINDOWS_1252_EXTRA = {
        128: "€",
        130: "‚",
        131: "ƒ",
        132: "„",
        133: "…",
        134: "†",
        135: "‡",
        136: "ˆ",
        137: "‰",
        138: "Š",
        139: "‹",
        140: "Œ",
        142: "Ž",
        145: "‘",
        146: "’",
        147: "“",
        148: "”",
        149: "•",
        150: "–",
        151: "—",
        152: "˜",
        153: "™",
        154: "š",
        155: "›",
        156: "œ",
        158: "ž",
        159: "Ÿ"
      };
      const WINDOWS_1252_REVERSE = {};
      for (const [code, char] of Object.entries(WINDOWS_1252_EXTRA)) {
        WINDOWS_1252_REVERSE[char] = Number.parseInt(code);
      }
      function textDecode(bytes, encoding = "utf-8") {
        switch (encoding.toLowerCase()) {
          case "utf-8":
          case "utf8":
            if (typeof globalThis.TextDecoder !== "undefined") {
              return new globalThis.TextDecoder("utf-8").decode(bytes);
            }
            return decodeUTF8(bytes);
          case "utf-16le":
            return decodeUTF16LE(bytes);
          case "ascii":
            return decodeASCII(bytes);
          case "latin1":
          case "iso-8859-1":
            return decodeLatin1(bytes);
          case "windows-1252":
            return decodeWindows1252(bytes);
          default:
            throw new RangeError(`Encoding '${encoding}' not supported`);
        }
      }
      function textEncode(input = "", encoding = "utf-8") {
        switch (encoding.toLowerCase()) {
          case "utf-8":
          case "utf8":
            if (typeof globalThis.TextEncoder !== "undefined") {
              return new globalThis.TextEncoder().encode(input);
            }
            return encodeUTF8(input);
          case "utf-16le":
            return encodeUTF16LE(input);
          case "ascii":
            return encodeASCII(input);
          case "latin1":
          case "iso-8859-1":
            return encodeLatin1(input);
          case "windows-1252":
            return encodeWindows1252(input);
          default:
            throw new RangeError(`Encoding '${encoding}' not supported`);
        }
      }
      function decodeUTF8(bytes) {
        let out = "";
        let i = 0;
        while (i < bytes.length) {
          const b1 = bytes[i++];
          if (b1 < 128) {
            out += String.fromCharCode(b1);
          } else if (b1 < 224) {
            const b2 = bytes[i++] & 63;
            out += String.fromCharCode((b1 & 31) << 6 | b2);
          } else if (b1 < 240) {
            const b2 = bytes[i++] & 63;
            const b3 = bytes[i++] & 63;
            out += String.fromCharCode((b1 & 15) << 12 | b2 << 6 | b3);
          } else {
            const b2 = bytes[i++] & 63;
            const b3 = bytes[i++] & 63;
            const b4 = bytes[i++] & 63;
            let cp = (b1 & 7) << 18 | b2 << 12 | b3 << 6 | b4;
            cp -= 65536;
            out += String.fromCharCode(55296 + (cp >> 10 & 1023), 56320 + (cp & 1023));
          }
        }
        return out;
      }
      function decodeUTF16LE(bytes) {
        let out = "";
        for (let i = 0; i < bytes.length; i += 2) {
          out += String.fromCharCode(bytes[i] | bytes[i + 1] << 8);
        }
        return out;
      }
      function decodeASCII(bytes) {
        return String.fromCharCode(...bytes.map((b) => b & 127));
      }
      function decodeLatin1(bytes) {
        return String.fromCharCode(...bytes);
      }
      function decodeWindows1252(bytes) {
        let out = "";
        for (const b of bytes) {
          if (b >= 128 && b <= 159 && WINDOWS_1252_EXTRA[b]) {
            out += WINDOWS_1252_EXTRA[b];
          } else {
            out += String.fromCharCode(b);
          }
        }
        return out;
      }
      function encodeUTF8(str) {
        const out = [];
        for (let i = 0; i < str.length; i++) {
          const cp = str.charCodeAt(i);
          if (cp < 128) {
            out.push(cp);
          } else if (cp < 2048) {
            out.push(192 | cp >> 6, 128 | cp & 63);
          } else if (cp < 65536) {
            out.push(224 | cp >> 12, 128 | cp >> 6 & 63, 128 | cp & 63);
          } else {
            out.push(240 | cp >> 18, 128 | cp >> 12 & 63, 128 | cp >> 6 & 63, 128 | cp & 63);
          }
        }
        return new Uint8Array(out);
      }
      function encodeUTF16LE(str) {
        const out = new Uint8Array(str.length * 2);
        for (let i = 0; i < str.length; i++) {
          const code = str.charCodeAt(i);
          out[i * 2] = code & 255;
          out[i * 2 + 1] = code >> 8;
        }
        return out;
      }
      function encodeASCII(str) {
        return new Uint8Array([...str].map((ch) => ch.charCodeAt(0) & 127));
      }
      function encodeLatin1(str) {
        return new Uint8Array([...str].map((ch) => ch.charCodeAt(0) & 255));
      }
      function encodeWindows1252(str) {
        return new Uint8Array([...str].map((ch) => {
          const code = ch.charCodeAt(0);
          if (code <= 255)
            return code;
          if (WINDOWS_1252_REVERSE[ch] !== void 0)
            return WINDOWS_1252_REVERSE[ch];
          return 63;
        }));
      }
      const validFourCC = /^[\x21-\x7e©][\x20-\x7e\x00()]{3}/;
      const FourCcToken = {
        len: 4,
        get: (buf, off) => {
          const id = textDecode(buf.slice(off, off + FourCcToken.len), "latin1");
          if (!id.match(validFourCC)) {
            throw new FieldDecodingError(`FourCC contains invalid characters: ${a2hex(id)} "${id}"`);
          }
          return id;
        },
        put: (buffer, offset, id) => {
          const str = textEncode(id, "latin1");
          if (str.length !== 4)
            throw new InternalParserError("Invalid length");
          buffer.set(str, offset);
          return offset + 4;
        }
      };
      const DataType = {
        text_utf8: 0,
        binary: 1,
        external_info: 2,
        reserved: 3
      };
      const DescriptorParser = {
        len: 52,
        get: (buf, off) => {
          return {
            // should equal 'MAC '
            ID: FourCcToken.get(buf, off),
            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
            version: UINT32_LE.get(buf, off + 4) / 1e3,
            // the number of descriptor bytes (allows later expansion of this header)
            descriptorBytes: UINT32_LE.get(buf, off + 8),
            // the number of header APE_HEADER bytes
            headerBytes: UINT32_LE.get(buf, off + 12),
            // the number of header APE_HEADER bytes
            seekTableBytes: UINT32_LE.get(buf, off + 16),
            // the number of header data bytes (from original file)
            headerDataBytes: UINT32_LE.get(buf, off + 20),
            // the number of bytes of APE frame data
            apeFrameDataBytes: UINT32_LE.get(buf, off + 24),
            // the high order number of APE frame data bytes
            apeFrameDataBytesHigh: UINT32_LE.get(buf, off + 28),
            // the terminating data of the file (not including tag data)
            terminatingDataBytes: UINT32_LE.get(buf, off + 32),
            // the MD5 hash of the file (see notes for usage... it's a little tricky)
            fileMD5: new Uint8ArrayType(16).get(buf, off + 36)
          };
        }
      };
      const Header = {
        len: 24,
        get: (buf, off) => {
          return {
            // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)
            compressionLevel: UINT16_LE.get(buf, off),
            // any format flags (for future use)
            formatFlags: UINT16_LE.get(buf, off + 2),
            // the number of audio blocks in one frame
            blocksPerFrame: UINT32_LE.get(buf, off + 4),
            // the number of audio blocks in the final frame
            finalFrameBlocks: UINT32_LE.get(buf, off + 8),
            // the total number of frames
            totalFrames: UINT32_LE.get(buf, off + 12),
            // the bits per sample (typically 16)
            bitsPerSample: UINT16_LE.get(buf, off + 16),
            // the number of channels (1 or 2)
            channel: UINT16_LE.get(buf, off + 18),
            // the sample rate (typically 44100)
            sampleRate: UINT32_LE.get(buf, off + 20)
          };
        }
      };
      const TagFooter = {
        len: 32,
        get: (buf, off) => {
          return {
            // should equal 'APETAGEX'
            ID: new StringType(8, "ascii").get(buf, off),
            // equals CURRENT_APE_TAG_VERSION
            version: UINT32_LE.get(buf, off + 8),
            // the complete size of the tag, including this footer (excludes header)
            size: UINT32_LE.get(buf, off + 12),
            // the number of fields in the tag
            fields: UINT32_LE.get(buf, off + 16),
            // reserved for later use (must be zero),
            flags: parseTagFlags(UINT32_LE.get(buf, off + 20))
          };
        }
      };
      const TagItemHeader = {
        len: 8,
        get: (buf, off) => {
          return {
            // Length of assigned value in bytes
            size: UINT32_LE.get(buf, off),
            // reserved for later use (must be zero),
            flags: parseTagFlags(UINT32_LE.get(buf, off + 4))
          };
        }
      };
      function parseTagFlags(flags) {
        return {
          containsHeader: isBitSet(flags, 31),
          containsFooter: isBitSet(flags, 30),
          isHeader: isBitSet(flags, 29),
          readOnly: isBitSet(flags, 0),
          dataType: (flags & 6) >> 1
        };
      }
      function isBitSet(num, bit) {
        return (num & 1 << bit) !== 0;
      }
      const debug$1 = initDebug("music-metadata:parser:APEv2");
      const tagFormat = "APEv2";
      const preamble = "APETAGEX";
      class ApeContentError extends makeUnexpectedFileContentError("APEv2") {
      }
      function tryParseApeHeader(metadata, tokenizer, options) {
        const apeParser = new APEv2Parser(metadata, tokenizer, options);
        return apeParser.tryParseApeHeader();
      }
      class APEv2Parser extends BasicParser {
        constructor() {
          super(...arguments);
          this.ape = {};
        }
        /**
         * Calculate the media file duration
         * @param ah ApeHeader
         * @return {number} duration in seconds
         */
        static calculateDuration(ah) {
          let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;
          duration += ah.finalFrameBlocks;
          return duration / ah.sampleRate;
        }
        /**
         * Calculates the APEv1 / APEv2 first field offset
         * @param tokenizer
         * @param offset
         */
        static async findApeFooterOffset(tokenizer, offset) {
          const apeBuf = new Uint8Array(TagFooter.len);
          const position = tokenizer.position;
          if (offset <= TagFooter.len) {
            debug$1(`Offset is too small to read APE footer: offset=${offset}`);
            return void 0;
          }
          if (offset > TagFooter.len) {
            await tokenizer.readBuffer(apeBuf, { position: offset - TagFooter.len });
            tokenizer.setPosition(position);
            const tagFooter = TagFooter.get(apeBuf, 0);
            if (tagFooter.ID === "APETAGEX") {
              if (tagFooter.flags.isHeader) {
                debug$1(`APE Header found at offset=${offset - TagFooter.len}`);
              } else {
                debug$1(`APE Footer found at offset=${offset - TagFooter.len}`);
                offset -= tagFooter.size;
              }
              return { footer: tagFooter, offset };
            }
          }
        }
        static parseTagFooter(metadata, buffer, options) {
          const footer2 = TagFooter.get(buffer, buffer.length - TagFooter.len);
          if (footer2.ID !== preamble)
            throw new ApeContentError("Unexpected APEv2 Footer ID preamble value");
          fromBuffer(buffer);
          const apeParser = new APEv2Parser(metadata, fromBuffer(buffer), options);
          return apeParser.parseTags(footer2);
        }
        /**
         * Parse APEv1 / APEv2 header if header signature found
         */
        async tryParseApeHeader() {
          if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < TagFooter.len) {
            debug$1("No APEv2 header found, end-of-file reached");
            return;
          }
          const footer2 = await this.tokenizer.peekToken(TagFooter);
          if (footer2.ID === preamble) {
            await this.tokenizer.ignore(TagFooter.len);
            return this.parseTags(footer2);
          }
          debug$1(`APEv2 header not found at offset=${this.tokenizer.position}`);
          if (this.tokenizer.fileInfo.size) {
            const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position;
            const buffer = new Uint8Array(remaining);
            await this.tokenizer.readBuffer(buffer);
            return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);
          }
        }
        async parse() {
          const descriptor = await this.tokenizer.readToken(DescriptorParser);
          if (descriptor.ID !== "MAC ")
            throw new ApeContentError("Unexpected descriptor ID");
          this.ape.descriptor = descriptor;
          const lenExp = descriptor.descriptorBytes - DescriptorParser.len;
          const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());
          this.metadata.setAudioOnly();
          await this.tokenizer.ignore(header.forwardBytes);
          return this.tryParseApeHeader();
        }
        async parseTags(footer2) {
          const keyBuffer = new Uint8Array(256);
          let bytesRemaining = footer2.size - TagFooter.len;
          debug$1(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);
          for (let i = 0; i < footer2.fields; i++) {
            if (bytesRemaining < TagItemHeader.len) {
              this.metadata.addWarning(`APEv2 Tag-header: ${footer2.fields - i} items remaining, but no more tag data to read.`);
              break;
            }
            const tagItemHeader = await this.tokenizer.readToken(TagItemHeader);
            bytesRemaining -= TagItemHeader.len + tagItemHeader.size;
            await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });
            let zero = findZero(keyBuffer, 0, keyBuffer.length);
            const key = await this.tokenizer.readToken(new StringType(zero, "ascii"));
            await this.tokenizer.ignore(1);
            bytesRemaining -= key.length + 1;
            switch (tagItemHeader.flags.dataType) {
              case DataType.text_utf8: {
                const value = await this.tokenizer.readToken(new StringType(tagItemHeader.size, "utf8"));
                const values = value.split(/\x00/g);
                await Promise.all(values.map((val) => this.metadata.addTag(tagFormat, key, val)));
                break;
              }
              case DataType.binary:
                if (this.options.skipCovers) {
                  await this.tokenizer.ignore(tagItemHeader.size);
                } else {
                  const picData = new Uint8Array(tagItemHeader.size);
                  await this.tokenizer.readBuffer(picData);
                  zero = findZero(picData, 0, picData.length);
                  const description = textDecode(picData.slice(0, zero), "utf-8");
                  const data = picData.slice(zero + 1);
                  await this.metadata.addTag(tagFormat, key, {
                    description,
                    data
                  });
                }
                break;
              case DataType.external_info:
                debug$1(`Ignore external info ${key}`);
                await this.tokenizer.ignore(tagItemHeader.size);
                break;
              case DataType.reserved:
                debug$1(`Ignore external info ${key}`);
                this.metadata.addWarning(`APEv2 header declares a reserved datatype for "${key}"`);
                await this.tokenizer.ignore(tagItemHeader.size);
                break;
            }
          }
        }
        async parseDescriptorExpansion(lenExp) {
          await this.tokenizer.ignore(lenExp);
          return this.parseHeader();
        }
        async parseHeader() {
          const header = await this.tokenizer.readToken(Header);
          this.metadata.setFormat("lossless", true);
          this.metadata.setFormat("container", "Monkey's Audio");
          this.metadata.setFormat("bitsPerSample", header.bitsPerSample);
          this.metadata.setFormat("sampleRate", header.sampleRate);
          this.metadata.setFormat("numberOfChannels", header.channel);
          this.metadata.setFormat("duration", APEv2Parser.calculateDuration(header));
          if (!this.ape.descriptor) {
            throw new ApeContentError("Missing APE descriptor");
          }
          return {
            forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes + this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes
          };
        }
      }
      const APEv2Parser$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        APEv2Parser,
        ApeContentError,
        tryParseApeHeader
      }, Symbol.toStringTag, { value: "Module" }));
      initDebug("music-metadata:parser:ID3v1");
      async function hasID3v1Header(tokenizer) {
        if (tokenizer.fileInfo.size >= 128) {
          const tag = new Uint8Array(3);
          const position = tokenizer.position;
          await tokenizer.readBuffer(tag, { position: tokenizer.fileInfo.size - 128 });
          tokenizer.setPosition(position);
          return textDecode(tag, "latin1") === "TAG";
        }
        return false;
      }
      const endTag2 = "LYRICS200";
      async function getLyricsHeaderLength(tokenizer) {
        const fileSize = tokenizer.fileInfo.size;
        if (fileSize >= 143) {
          const buf = new Uint8Array(15);
          const position = tokenizer.position;
          await tokenizer.readBuffer(buf, { position: fileSize - 143 });
          tokenizer.setPosition(position);
          const txt = textDecode(buf, "latin1");
          const tag = txt.slice(6);
          if (tag === endTag2) {
            return Number.parseInt(txt.slice(0, 6), 10) + 15;
          }
        }
        return 0;
      }
      async function parseBlob(blob, options = {}) {
        const tokenizer = fromBlob(blob);
        try {
          return await parseFromTokenizer(tokenizer, options);
        } finally {
          await tokenizer.close();
        }
      }
      function parseFromTokenizer(tokenizer, options) {
        const parserFactory = new ParserFactory();
        return parserFactory.parse(tokenizer, void 0, options);
      }
      async function scanAppendingHeaders(tokenizer, options = {}) {
        let apeOffset = tokenizer.fileInfo.size;
        if (await hasID3v1Header(tokenizer)) {
          apeOffset -= 128;
          const lyricsLen = await getLyricsHeaderLength(tokenizer);
          apeOffset -= lyricsLen;
        }
        options.apeHeader = await APEv2Parser.findApeFooterOffset(tokenizer, apeOffset);
      }
      const uniqueArrayByKey = (arr, key) => {
        if (!Array.isArray(arr)) return [];
        if (!key) return arr;
        const seen2 = /* @__PURE__ */ new Map();
        return arr.filter((item) => {
          if (!item || typeof item !== "object") return false;
          const val = item[key];
          if (seen2.has(val)) return false;
          seen2.set(val, true);
          return true;
        });
      };
      const promiseLimit = (promiseArray, limit = 6) => {
        if (!Array.isArray(promiseArray)) {
          throw new Error("第一个参数必须是数组");
        }
        if (!Number.isInteger(limit) || limit < 1) {
          throw new Error("并发限制必须是正整数");
        }
        if (promiseArray.length === 0) {
          return Promise.resolve([]);
        }
        return new Promise((resolve, reject) => {
          const results = new Array(promiseArray.length);
          let completed = 0;
          let currentIndex = 0;
          const runTask = async () => {
            const index2 = currentIndex++;
            if (index2 >= promiseArray.length) {
              return;
            }
            try {
              const promise = promiseArray[index2];
              if (typeof promise !== "function") {
                throw new Error(`数组中索引为 ${index2} 的元素不是函数`);
              }
              results[index2] = await promise();
            } catch (error) {
              results[index2] = error;
            }
            completed++;
            if (currentIndex < promiseArray.length) {
              runTask();
            } else if (completed === promiseArray.length) {
              resolve(results);
            }
          };
          const tasksToStart = Math.min(limit, promiseArray.length);
          for (let i = 0; i < tasksToStart; i++) {
            try {
              runTask();
            } catch (error) {
              reject(error);
            }
          }
        });
      };
      const getCookie = (key) => {
        const cookie = document.cookie;
        const cookieMap = {};
        cookie.split("; ").forEach((row) => {
          const [key2, value] = row.split("=");
          cookieMap[key2] = value;
        });
        return cookieMap[key];
      };
      const getFile_qualityList = (file) => {
        const qualityList = [];
        if (file.size_flac) qualityList.push("flac");
        if (file.size_ape) qualityList.push("ape");
        if (file.size_320mp3) qualityList.push(320);
        if (file.size_192aac) qualityList.push("m4a");
        if (file.size_128mp3) qualityList.push(128);
        return qualityList;
      };
      const getFileQualityList = (file) => {
        const qualityList = [];
        if (file.size128) qualityList.push(128);
        if (file.size320) qualityList.push(320);
        if (file.sizeflac) qualityList.push("flac");
        return qualityList;
      };
      async function getFileMD5(file) {
        const arrayBuffer = await file.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);
        return md5$1(uint8Array);
      }
      async function getAudioMetadata(file) {
        try {
          const metadata = await parseBlob(file);
          console.log("metadata.common", metadata, metadata.common);
          const { album, artist, artists, title } = metadata.common || {};
          const { bitrate = 0 } = metadata.format || {};
          return {
            title: title || "",
            artist: artist || artists?.[0] || "",
            artists: artists || (artist ? [artist] : []),
            album: album || "",
            duration: metadata.format?.duration || 0,
            sampleRate: metadata.format?.sampleRate || 0,
            format: metadata.format?.container || "",
            bitrate: Math.floor(bitrate / 1e3) || 0
          };
        } catch (error) {
          console.error("Failed to parse audio metadata:", error);
          return {
            title: "",
            artist: "",
            artists: [],
            album: "",
            duration: 0,
            bitrate: 0,
            sampleRate: 0,
            format: ""
          };
        }
      }
      const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
      let nanoid = (size = 21) => {
        let id = "";
        let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
        while (size--) {
          id += urlAlphabet[bytes[size] & 63];
        }
        return id;
      };
      let message;
      const ModalUtils = () => {
        const staticFunction = App$1.useApp();
        message = staticFunction.message;
        staticFunction.modal;
        staticFunction.notification;
        return null;
      };
      const msgSuccess = (content) => {
        return message.success(content);
      };
      const msgWarning = (content) => {
        return message.warning(content);
      };
      const msgError = (content) => {
        return message.error(content);
      };
      const msgLoading = (loadingContent, completeCallBack) => {
        const key = nanoid();
        message.loading({
          key,
          content: loadingContent
        }).then(() => {
        });
        return () => message.destroy(key);
      };
      var forge$1;
      var hasRequiredForge;
      function requireForge() {
        if (hasRequiredForge) return forge$1;
        hasRequiredForge = 1;
        forge$1 = {
          // default options
          options: {
            usePureJavaScript: false
          }
        };
        return forge$1;
      }
      var util = { exports: {} };
      var baseN;
      var hasRequiredBaseN;
      function requireBaseN() {
        if (hasRequiredBaseN) return baseN;
        hasRequiredBaseN = 1;
        var api = {};
        baseN = api;
        var _reverseAlphabets = {};
        api.encode = function(input, alphabet, maxline) {
          if (typeof alphabet !== "string") {
            throw new TypeError('"alphabet" must be a string.');
          }
          if (maxline !== void 0 && typeof maxline !== "number") {
            throw new TypeError('"maxline" must be a number.');
          }
          var output = "";
          if (!(input instanceof Uint8Array)) {
            output = _encodeWithByteBuffer(input, alphabet);
          } else {
            var i = 0;
            var base = alphabet.length;
            var first = alphabet.charAt(0);
            var digits = [0];
            for (i = 0; i < input.length; ++i) {
              for (var j = 0, carry = input[i]; j < digits.length; ++j) {
                carry += digits[j] << 8;
                digits[j] = carry % base;
                carry = carry / base | 0;
              }
              while (carry > 0) {
                digits.push(carry % base);
                carry = carry / base | 0;
              }
            }
            for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
              output += first;
            }
            for (i = digits.length - 1; i >= 0; --i) {
              output += alphabet[digits[i]];
            }
          }
          if (maxline) {
            var regex = new RegExp(".{1," + maxline + "}", "g");
            output = output.match(regex).join("\r\n");
          }
          return output;
        };
        api.decode = function(input, alphabet) {
          if (typeof input !== "string") {
            throw new TypeError('"input" must be a string.');
          }
          if (typeof alphabet !== "string") {
            throw new TypeError('"alphabet" must be a string.');
          }
          var table = _reverseAlphabets[alphabet];
          if (!table) {
            table = _reverseAlphabets[alphabet] = [];
            for (var i = 0; i < alphabet.length; ++i) {
              table[alphabet.charCodeAt(i)] = i;
            }
          }
          input = input.replace(/\s/g, "");
          var base = alphabet.length;
          var first = alphabet.charAt(0);
          var bytes = [0];
          for (var i = 0; i < input.length; i++) {
            var value = table[input.charCodeAt(i)];
            if (value === void 0) {
              return;
            }
            for (var j = 0, carry = value; j < bytes.length; ++j) {
              carry += bytes[j] * base;
              bytes[j] = carry & 255;
              carry >>= 8;
            }
            while (carry > 0) {
              bytes.push(carry & 255);
              carry >>= 8;
            }
          }
          for (var k = 0; input[k] === first && k < input.length - 1; ++k) {
            bytes.push(0);
          }
          if (typeof Buffer !== "undefined") {
            return Buffer.from(bytes.reverse());
          }
          return new Uint8Array(bytes.reverse());
        };
        function _encodeWithByteBuffer(input, alphabet) {
          var i = 0;
          var base = alphabet.length;
          var first = alphabet.charAt(0);
          var digits = [0];
          for (i = 0; i < input.length(); ++i) {
            for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
              carry += digits[j] << 8;
              digits[j] = carry % base;
              carry = carry / base | 0;
            }
            while (carry > 0) {
              digits.push(carry % base);
              carry = carry / base | 0;
            }
          }
          var output = "";
          for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
            output += first;
          }
          for (i = digits.length - 1; i >= 0; --i) {
            output += alphabet[digits[i]];
          }
          return output;
        }
        return baseN;
      }
      var hasRequiredUtil;
      function requireUtil() {
        if (hasRequiredUtil) return util.exports;
        hasRequiredUtil = 1;
        var forge2 = requireForge();
        var baseN2 = requireBaseN();
        var util$1 = util.exports = forge2.util = forge2.util || {};
        (function() {
          if (typeof process !== "undefined" && process.nextTick && !process.browser) {
            util$1.nextTick = process.nextTick;
            if (typeof setImmediate === "function") {
              util$1.setImmediate = setImmediate;
            } else {
              util$1.setImmediate = util$1.nextTick;
            }
            return;
          }
          if (typeof setImmediate === "function") {
            util$1.setImmediate = function() {
              return setImmediate.apply(void 0, arguments);
            };
            util$1.nextTick = function(callback) {
              return setImmediate(callback);
            };
            return;
          }
          util$1.setImmediate = function(callback) {
            setTimeout(callback, 0);
          };
          if (typeof window !== "undefined" && typeof window.postMessage === "function") {
            let handler = function(event) {
              if (event.source === window && event.data === msg) {
                event.stopPropagation();
                var copy2 = callbacks.slice();
                callbacks.length = 0;
                copy2.forEach(function(callback) {
                  callback();
                });
              }
            };
            var msg = "forge.setImmediate";
            var callbacks = [];
            util$1.setImmediate = function(callback) {
              callbacks.push(callback);
              if (callbacks.length === 1) {
                window.postMessage(msg, "*");
              }
            };
            window.addEventListener("message", handler, true);
          }
          if (typeof MutationObserver !== "undefined") {
            var now = Date.now();
            var attr = true;
            var div = document.createElement("div");
            var callbacks = [];
            new MutationObserver(function() {
              var copy2 = callbacks.slice();
              callbacks.length = 0;
              copy2.forEach(function(callback) {
                callback();
              });
            }).observe(div, { attributes: true });
            var oldSetImmediate = util$1.setImmediate;
            util$1.setImmediate = function(callback) {
              if (Date.now() - now > 15) {
                now = Date.now();
                oldSetImmediate(callback);
              } else {
                callbacks.push(callback);
                if (callbacks.length === 1) {
                  div.setAttribute("a", attr = !attr);
                }
              }
            };
          }
          util$1.nextTick = util$1.setImmediate;
        })();
        util$1.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
        util$1.globalScope = (function() {
          if (util$1.isNodejs) {
            return commonjsGlobal;
          }
          return typeof self === "undefined" ? window : self;
        })();
        util$1.isArray = Array.isArray || function(x) {
          return Object.prototype.toString.call(x) === "[object Array]";
        };
        util$1.isArrayBuffer = function(x) {
          return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
        };
        util$1.isArrayBufferView = function(x) {
          return x && util$1.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
        };
        function _checkBitsParam(n) {
          if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
            throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
          }
        }
        util$1.ByteBuffer = ByteStringBuffer;
        function ByteStringBuffer(b) {
          this.data = "";
          this.read = 0;
          if (typeof b === "string") {
            this.data = b;
          } else if (util$1.isArrayBuffer(b) || util$1.isArrayBufferView(b)) {
            if (typeof Buffer !== "undefined" && b instanceof Buffer) {
              this.data = b.toString("binary");
            } else {
              var arr = new Uint8Array(b);
              try {
                this.data = String.fromCharCode.apply(null, arr);
              } catch (e) {
                for (var i = 0; i < arr.length; ++i) {
                  this.putByte(arr[i]);
                }
              }
            }
          } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
            this.data = b.data;
            this.read = b.read;
          }
          this._constructedStringLength = 0;
        }
        util$1.ByteStringBuffer = ByteStringBuffer;
        var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
        util$1.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
          this._constructedStringLength += x;
          if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
            this.data.substr(0, 1);
            this._constructedStringLength = 0;
          }
        };
        util$1.ByteStringBuffer.prototype.length = function() {
          return this.data.length - this.read;
        };
        util$1.ByteStringBuffer.prototype.isEmpty = function() {
          return this.length() <= 0;
        };
        util$1.ByteStringBuffer.prototype.putByte = function(b) {
          return this.putBytes(String.fromCharCode(b));
        };
        util$1.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
          b = String.fromCharCode(b);
          var d = this.data;
          while (n > 0) {
            if (n & 1) {
              d += b;
            }
            n >>>= 1;
            if (n > 0) {
              b += b;
            }
          }
          this.data = d;
          this._optimizeConstructedString(n);
          return this;
        };
        util$1.ByteStringBuffer.prototype.putBytes = function(bytes) {
          this.data += bytes;
          this._optimizeConstructedString(bytes.length);
          return this;
        };
        util$1.ByteStringBuffer.prototype.putString = function(str) {
          return this.putBytes(util$1.encodeUtf8(str));
        };
        util$1.ByteStringBuffer.prototype.putInt16 = function(i) {
          return this.putBytes(
            String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
          );
        };
        util$1.ByteStringBuffer.prototype.putInt24 = function(i) {
          return this.putBytes(
            String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
          );
        };
        util$1.ByteStringBuffer.prototype.putInt32 = function(i) {
          return this.putBytes(
            String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
          );
        };
        util$1.ByteStringBuffer.prototype.putInt16Le = function(i) {
          return this.putBytes(
            String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255)
          );
        };
        util$1.ByteStringBuffer.prototype.putInt24Le = function(i) {
          return this.putBytes(
            String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255)
          );
        };
        util$1.ByteStringBuffer.prototype.putInt32Le = function(i) {
          return this.putBytes(
            String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255)
          );
        };
        util$1.ByteStringBuffer.prototype.putInt = function(i, n) {
          _checkBitsParam(n);
          var bytes = "";
          do {
            n -= 8;
            bytes += String.fromCharCode(i >> n & 255);
          } while (n > 0);
          return this.putBytes(bytes);
        };
        util$1.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
          if (i < 0) {
            i += 2 << n - 1;
          }
          return this.putInt(i, n);
        };
        util$1.ByteStringBuffer.prototype.putBuffer = function(buffer) {
          return this.putBytes(buffer.getBytes());
        };
        util$1.ByteStringBuffer.prototype.getByte = function() {
          return this.data.charCodeAt(this.read++);
        };
        util$1.ByteStringBuffer.prototype.getInt16 = function() {
          var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
          this.read += 2;
          return rval;
        };
        util$1.ByteStringBuffer.prototype.getInt24 = function() {
          var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
          this.read += 3;
          return rval;
        };
        util$1.ByteStringBuffer.prototype.getInt32 = function() {
          var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
          this.read += 4;
          return rval;
        };
        util$1.ByteStringBuffer.prototype.getInt16Le = function() {
          var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
          this.read += 2;
          return rval;
        };
        util$1.ByteStringBuffer.prototype.getInt24Le = function() {
          var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
          this.read += 3;
          return rval;
        };
        util$1.ByteStringBuffer.prototype.getInt32Le = function() {
          var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
          this.read += 4;
          return rval;
        };
        util$1.ByteStringBuffer.prototype.getInt = function(n) {
          _checkBitsParam(n);
          var rval = 0;
          do {
            rval = (rval << 8) + this.data.charCodeAt(this.read++);
            n -= 8;
          } while (n > 0);
          return rval;
        };
        util$1.ByteStringBuffer.prototype.getSignedInt = function(n) {
          var x = this.getInt(n);
          var max2 = 2 << n - 2;
          if (x >= max2) {
            x -= max2 << 1;
          }
          return x;
        };
        util$1.ByteStringBuffer.prototype.getBytes = function(count) {
          var rval;
          if (count) {
            count = Math.min(this.length(), count);
            rval = this.data.slice(this.read, this.read + count);
            this.read += count;
          } else if (count === 0) {
            rval = "";
          } else {
            rval = this.read === 0 ? this.data : this.data.slice(this.read);
            this.clear();
          }
          return rval;
        };
        util$1.ByteStringBuffer.prototype.bytes = function(count) {
          return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
        };
        util$1.ByteStringBuffer.prototype.at = function(i) {
          return this.data.charCodeAt(this.read + i);
        };
        util$1.ByteStringBuffer.prototype.setAt = function(i, b) {
          this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
          return this;
        };
        util$1.ByteStringBuffer.prototype.last = function() {
          return this.data.charCodeAt(this.data.length - 1);
        };
        util$1.ByteStringBuffer.prototype.copy = function() {
          var c = util$1.createBuffer(this.data);
          c.read = this.read;
          return c;
        };
        util$1.ByteStringBuffer.prototype.compact = function() {
          if (this.read > 0) {
            this.data = this.data.slice(this.read);
            this.read = 0;
          }
          return this;
        };
        util$1.ByteStringBuffer.prototype.clear = function() {
          this.data = "";
          this.read = 0;
          return this;
        };
        util$1.ByteStringBuffer.prototype.truncate = function(count) {
          var len = Math.max(0, this.length() - count);
          this.data = this.data.substr(this.read, len);
          this.read = 0;
          return this;
        };
        util$1.ByteStringBuffer.prototype.toHex = function() {
          var rval = "";
          for (var i = this.read; i < this.data.length; ++i) {
            var b = this.data.charCodeAt(i);
            if (b < 16) {
              rval += "0";
            }
            rval += b.toString(16);
          }
          return rval;
        };
        util$1.ByteStringBuffer.prototype.toString = function() {
          return util$1.decodeUtf8(this.bytes());
        };
        function DataBuffer(b, options) {
          options = options || {};
          this.read = options.readOffset || 0;
          this.growSize = options.growSize || 1024;
          var isArrayBuffer = util$1.isArrayBuffer(b);
          var isArrayBufferView = util$1.isArrayBufferView(b);
          if (isArrayBuffer || isArrayBufferView) {
            if (isArrayBuffer) {
              this.data = new DataView(b);
            } else {
              this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
            }
            this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
            return;
          }
          this.data = new DataView(new ArrayBuffer(0));
          this.write = 0;
          if (b !== null && b !== void 0) {
            this.putBytes(b);
          }
          if ("writeOffset" in options) {
            this.write = options.writeOffset;
          }
        }
        util$1.DataBuffer = DataBuffer;
        util$1.DataBuffer.prototype.length = function() {
          return this.write - this.read;
        };
        util$1.DataBuffer.prototype.isEmpty = function() {
          return this.length() <= 0;
        };
        util$1.DataBuffer.prototype.accommodate = function(amount, growSize) {
          if (this.length() >= amount) {
            return this;
          }
          growSize = Math.max(growSize || this.growSize, amount);
          var src = new Uint8Array(
            this.data.buffer,
            this.data.byteOffset,
            this.data.byteLength
          );
          var dst = new Uint8Array(this.length() + growSize);
          dst.set(src);
          this.data = new DataView(dst.buffer);
          return this;
        };
        util$1.DataBuffer.prototype.putByte = function(b) {
          this.accommodate(1);
          this.data.setUint8(this.write++, b);
          return this;
        };
        util$1.DataBuffer.prototype.fillWithByte = function(b, n) {
          this.accommodate(n);
          for (var i = 0; i < n; ++i) {
            this.data.setUint8(b);
          }
          return this;
        };
        util$1.DataBuffer.prototype.putBytes = function(bytes, encoding) {
          if (util$1.isArrayBufferView(bytes)) {
            var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
            var len = src.byteLength - src.byteOffset;
            this.accommodate(len);
            var dst = new Uint8Array(this.data.buffer, this.write);
            dst.set(src);
            this.write += len;
            return this;
          }
          if (util$1.isArrayBuffer(bytes)) {
            var src = new Uint8Array(bytes);
            this.accommodate(src.byteLength);
            var dst = new Uint8Array(this.data.buffer);
            dst.set(src, this.write);
            this.write += src.byteLength;
            return this;
          }
          if (bytes instanceof util$1.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util$1.isArrayBufferView(bytes.data)) {
            var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
            this.accommodate(src.byteLength);
            var dst = new Uint8Array(bytes.data.byteLength, this.write);
            dst.set(src);
            this.write += src.byteLength;
            return this;
          }
          if (bytes instanceof util$1.ByteStringBuffer) {
            bytes = bytes.data;
            encoding = "binary";
          }
          encoding = encoding || "binary";
          if (typeof bytes === "string") {
            var view;
            if (encoding === "hex") {
              this.accommodate(Math.ceil(bytes.length / 2));
              view = new Uint8Array(this.data.buffer, this.write);
              this.write += util$1.binary.hex.decode(bytes, view, this.write);
              return this;
            }
            if (encoding === "base64") {
              this.accommodate(Math.ceil(bytes.length / 4) * 3);
              view = new Uint8Array(this.data.buffer, this.write);
              this.write += util$1.binary.base64.decode(bytes, view, this.write);
              return this;
            }
            if (encoding === "utf8") {
              bytes = util$1.encodeUtf8(bytes);
              encoding = "binary";
            }
            if (encoding === "binary" || encoding === "raw") {
              this.accommodate(bytes.length);
              view = new Uint8Array(this.data.buffer, this.write);
              this.write += util$1.binary.raw.decode(view);
              return this;
            }
            if (encoding === "utf16") {
              this.accommodate(bytes.length * 2);
              view = new Uint16Array(this.data.buffer, this.write);
              this.write += util$1.text.utf16.encode(view);
              return this;
            }
            throw new Error("Invalid encoding: " + encoding);
          }
          throw Error("Invalid parameter: " + bytes);
        };
        util$1.DataBuffer.prototype.putBuffer = function(buffer) {
          this.putBytes(buffer);
          buffer.clear();
          return this;
        };
        util$1.DataBuffer.prototype.putString = function(str) {
          return this.putBytes(str, "utf16");
        };
        util$1.DataBuffer.prototype.putInt16 = function(i) {
          this.accommodate(2);
          this.data.setInt16(this.write, i);
          this.write += 2;
          return this;
        };
        util$1.DataBuffer.prototype.putInt24 = function(i) {
          this.accommodate(3);
          this.data.setInt16(this.write, i >> 8 & 65535);
          this.data.setInt8(this.write, i >> 16 & 255);
          this.write += 3;
          return this;
        };
        util$1.DataBuffer.prototype.putInt32 = function(i) {
          this.accommodate(4);
          this.data.setInt32(this.write, i);
          this.write += 4;
          return this;
        };
        util$1.DataBuffer.prototype.putInt16Le = function(i) {
          this.accommodate(2);
          this.data.setInt16(this.write, i, true);
          this.write += 2;
          return this;
        };
        util$1.DataBuffer.prototype.putInt24Le = function(i) {
          this.accommodate(3);
          this.data.setInt8(this.write, i >> 16 & 255);
          this.data.setInt16(this.write, i >> 8 & 65535, true);
          this.write += 3;
          return this;
        };
        util$1.DataBuffer.prototype.putInt32Le = function(i) {
          this.accommodate(4);
          this.data.setInt32(this.write, i, true);
          this.write += 4;
          return this;
        };
        util$1.DataBuffer.prototype.putInt = function(i, n) {
          _checkBitsParam(n);
          this.accommodate(n / 8);
          do {
            n -= 8;
            this.data.setInt8(this.write++, i >> n & 255);
          } while (n > 0);
          return this;
        };
        util$1.DataBuffer.prototype.putSignedInt = function(i, n) {
          _checkBitsParam(n);
          this.accommodate(n / 8);
          if (i < 0) {
            i += 2 << n - 1;
          }
          return this.putInt(i, n);
        };
        util$1.DataBuffer.prototype.getByte = function() {
          return this.data.getInt8(this.read++);
        };
        util$1.DataBuffer.prototype.getInt16 = function() {
          var rval = this.data.getInt16(this.read);
          this.read += 2;
          return rval;
        };
        util$1.DataBuffer.prototype.getInt24 = function() {
          var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
          this.read += 3;
          return rval;
        };
        util$1.DataBuffer.prototype.getInt32 = function() {
          var rval = this.data.getInt32(this.read);
          this.read += 4;
          return rval;
        };
        util$1.DataBuffer.prototype.getInt16Le = function() {
          var rval = this.data.getInt16(this.read, true);
          this.read += 2;
          return rval;
        };
        util$1.DataBuffer.prototype.getInt24Le = function() {
          var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
          this.read += 3;
          return rval;
        };
        util$1.DataBuffer.prototype.getInt32Le = function() {
          var rval = this.data.getInt32(this.read, true);
          this.read += 4;
          return rval;
        };
        util$1.DataBuffer.prototype.getInt = function(n) {
          _checkBitsParam(n);
          var rval = 0;
          do {
            rval = (rval << 8) + this.data.getInt8(this.read++);
            n -= 8;
          } while (n > 0);
          return rval;
        };
        util$1.DataBuffer.prototype.getSignedInt = function(n) {
          var x = this.getInt(n);
          var max2 = 2 << n - 2;
          if (x >= max2) {
            x -= max2 << 1;
          }
          return x;
        };
        util$1.DataBuffer.prototype.getBytes = function(count) {
          var rval;
          if (count) {
            count = Math.min(this.length(), count);
            rval = this.data.slice(this.read, this.read + count);
            this.read += count;
          } else if (count === 0) {
            rval = "";
          } else {
            rval = this.read === 0 ? this.data : this.data.slice(this.read);
            this.clear();
          }
          return rval;
        };
        util$1.DataBuffer.prototype.bytes = function(count) {
          return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
        };
        util$1.DataBuffer.prototype.at = function(i) {
          return this.data.getUint8(this.read + i);
        };
        util$1.DataBuffer.prototype.setAt = function(i, b) {
          this.data.setUint8(i, b);
          return this;
        };
        util$1.DataBuffer.prototype.last = function() {
          return this.data.getUint8(this.write - 1);
        };
        util$1.DataBuffer.prototype.copy = function() {
          return new util$1.DataBuffer(this);
        };
        util$1.DataBuffer.prototype.compact = function() {
          if (this.read > 0) {
            var src = new Uint8Array(this.data.buffer, this.read);
            var dst = new Uint8Array(src.byteLength);
            dst.set(src);
            this.data = new DataView(dst);
            this.write -= this.read;
            this.read = 0;
          }
          return this;
        };
        util$1.DataBuffer.prototype.clear = function() {
          this.data = new DataView(new ArrayBuffer(0));
          this.read = this.write = 0;
          return this;
        };
        util$1.DataBuffer.prototype.truncate = function(count) {
          this.write = Math.max(0, this.length() - count);
          this.read = Math.min(this.read, this.write);
          return this;
        };
        util$1.DataBuffer.prototype.toHex = function() {
          var rval = "";
          for (var i = this.read; i < this.data.byteLength; ++i) {
            var b = this.data.getUint8(i);
            if (b < 16) {
              rval += "0";
            }
            rval += b.toString(16);
          }
          return rval;
        };
        util$1.DataBuffer.prototype.toString = function(encoding) {
          var view = new Uint8Array(this.data, this.read, this.length());
          encoding = encoding || "utf8";
          if (encoding === "binary" || encoding === "raw") {
            return util$1.binary.raw.encode(view);
          }
          if (encoding === "hex") {
            return util$1.binary.hex.encode(view);
          }
          if (encoding === "base64") {
            return util$1.binary.base64.encode(view);
          }
          if (encoding === "utf8") {
            return util$1.text.utf8.decode(view);
          }
          if (encoding === "utf16") {
            return util$1.text.utf16.decode(view);
          }
          throw new Error("Invalid encoding: " + encoding);
        };
        util$1.createBuffer = function(input, encoding) {
          encoding = encoding || "raw";
          if (input !== void 0 && encoding === "utf8") {
            input = util$1.encodeUtf8(input);
          }
          return new util$1.ByteBuffer(input);
        };
        util$1.fillString = function(c, n) {
          var s = "";
          while (n > 0) {
            if (n & 1) {
              s += c;
            }
            n >>>= 1;
            if (n > 0) {
              c += c;
            }
          }
          return s;
        };
        util$1.xorBytes = function(s1, s2, n) {
          var s3 = "";
          var b = "";
          var t = "";
          var i = 0;
          var c = 0;
          for (; n > 0; --n, ++i) {
            b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
            if (c >= 10) {
              s3 += t;
              t = "";
              c = 0;
            }
            t += String.fromCharCode(b);
            ++c;
          }
          s3 += t;
          return s3;
        };
        util$1.hexToBytes = function(hex) {
          var rval = "";
          var i = 0;
          if (hex.length & true) {
            i = 1;
            rval += String.fromCharCode(parseInt(hex[0], 16));
          }
          for (; i < hex.length; i += 2) {
            rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
          }
          return rval;
        };
        util$1.bytesToHex = function(bytes) {
          return util$1.createBuffer(bytes).toHex();
        };
        util$1.int32ToBytes = function(i) {
          return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
        };
        var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var _base64Idx = [
          /*43 -43 = 0*/
          /*'+',  1,  2,  3,'/' */
          62,
          -1,
          -1,
          -1,
          63,
          /*'0','1','2','3','4','5','6','7','8','9' */
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          /*15, 16, 17,'=', 19, 20, 21 */
          -1,
          -1,
          -1,
          64,
          -1,
          -1,
          -1,
          /*65 - 43 = 22*/
          /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          /*91 - 43 = 48 */
          /*48, 49, 50, 51, 52, 53 */
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          /*97 - 43 = 54*/
          /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51
        ];
        var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
        util$1.encode64 = function(input, maxline) {
          var line = "";
          var output = "";
          var chr1, chr2, chr3;
          var i = 0;
          while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            line += _base64.charAt(chr1 >> 2);
            line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
            if (isNaN(chr2)) {
              line += "==";
            } else {
              line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
              line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
            }
            if (maxline && line.length > maxline) {
              output += line.substr(0, maxline) + "\r\n";
              line = line.substr(maxline);
            }
          }
          output += line;
          return output;
        };
        util$1.decode64 = function(input) {
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
          var output = "";
          var enc1, enc2, enc3, enc4;
          var i = 0;
          while (i < input.length) {
            enc1 = _base64Idx[input.charCodeAt(i++) - 43];
            enc2 = _base64Idx[input.charCodeAt(i++) - 43];
            enc3 = _base64Idx[input.charCodeAt(i++) - 43];
            enc4 = _base64Idx[input.charCodeAt(i++) - 43];
            output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
            if (enc3 !== 64) {
              output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
              if (enc4 !== 64) {
                output += String.fromCharCode((enc3 & 3) << 6 | enc4);
              }
            }
          }
          return output;
        };
        util$1.encodeUtf8 = function(str) {
          return unescape(encodeURIComponent(str));
        };
        util$1.decodeUtf8 = function(str) {
          return decodeURIComponent(escape(str));
        };
        util$1.binary = {
          raw: {},
          hex: {},
          base64: {},
          base58: {},
          baseN: {
            encode: baseN2.encode,
            decode: baseN2.decode
          }
        };
        util$1.binary.raw.encode = function(bytes) {
          return String.fromCharCode.apply(null, bytes);
        };
        util$1.binary.raw.decode = function(str, output, offset) {
          var out = output;
          if (!out) {
            out = new Uint8Array(str.length);
          }
          offset = offset || 0;
          var j = offset;
          for (var i = 0; i < str.length; ++i) {
            out[j++] = str.charCodeAt(i);
          }
          return output ? j - offset : out;
        };
        util$1.binary.hex.encode = util$1.bytesToHex;
        util$1.binary.hex.decode = function(hex, output, offset) {
          var out = output;
          if (!out) {
            out = new Uint8Array(Math.ceil(hex.length / 2));
          }
          offset = offset || 0;
          var i = 0, j = offset;
          if (hex.length & 1) {
            i = 1;
            out[j++] = parseInt(hex[0], 16);
          }
          for (; i < hex.length; i += 2) {
            out[j++] = parseInt(hex.substr(i, 2), 16);
          }
          return output ? j - offset : out;
        };
        util$1.binary.base64.encode = function(input, maxline) {
          var line = "";
          var output = "";
          var chr1, chr2, chr3;
          var i = 0;
          while (i < input.byteLength) {
            chr1 = input[i++];
            chr2 = input[i++];
            chr3 = input[i++];
            line += _base64.charAt(chr1 >> 2);
            line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
            if (isNaN(chr2)) {
              line += "==";
            } else {
              line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
              line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
            }
            if (maxline && line.length > maxline) {
              output += line.substr(0, maxline) + "\r\n";
              line = line.substr(maxline);
            }
          }
          output += line;
          return output;
        };
        util$1.binary.base64.decode = function(input, output, offset) {
          var out = output;
          if (!out) {
            out = new Uint8Array(Math.ceil(input.length / 4) * 3);
          }
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
          offset = offset || 0;
          var enc1, enc2, enc3, enc4;
          var i = 0, j = offset;
          while (i < input.length) {
            enc1 = _base64Idx[input.charCodeAt(i++) - 43];
            enc2 = _base64Idx[input.charCodeAt(i++) - 43];
            enc3 = _base64Idx[input.charCodeAt(i++) - 43];
            enc4 = _base64Idx[input.charCodeAt(i++) - 43];
            out[j++] = enc1 << 2 | enc2 >> 4;
            if (enc3 !== 64) {
              out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
              if (enc4 !== 64) {
                out[j++] = (enc3 & 3) << 6 | enc4;
              }
            }
          }
          return output ? j - offset : out.subarray(0, j);
        };
        util$1.binary.base58.encode = function(input, maxline) {
          return util$1.binary.baseN.encode(input, _base58, maxline);
        };
        util$1.binary.base58.decode = function(input, maxline) {
          return util$1.binary.baseN.decode(input, _base58, maxline);
        };
        util$1.text = {
          utf8: {},
          utf16: {}
        };
        util$1.text.utf8.encode = function(str, output, offset) {
          str = util$1.encodeUtf8(str);
          var out = output;
          if (!out) {
            out = new Uint8Array(str.length);
          }
          offset = offset || 0;
          var j = offset;
          for (var i = 0; i < str.length; ++i) {
            out[j++] = str.charCodeAt(i);
          }
          return output ? j - offset : out;
        };
        util$1.text.utf8.decode = function(bytes) {
          return util$1.decodeUtf8(String.fromCharCode.apply(null, bytes));
        };
        util$1.text.utf16.encode = function(str, output, offset) {
          var out = output;
          if (!out) {
            out = new Uint8Array(str.length * 2);
          }
          var view = new Uint16Array(out.buffer);
          offset = offset || 0;
          var j = offset;
          var k = offset;
          for (var i = 0; i < str.length; ++i) {
            view[k++] = str.charCodeAt(i);
            j += 2;
          }
          return output ? j - offset : out;
        };
        util$1.text.utf16.decode = function(bytes) {
          return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
        };
        util$1.deflate = function(api, bytes, raw) {
          bytes = util$1.decode64(api.deflate(util$1.encode64(bytes)).rval);
          if (raw) {
            var start = 2;
            var flg = bytes.charCodeAt(1);
            if (flg & 32) {
              start = 6;
            }
            bytes = bytes.substring(start, bytes.length - 4);
          }
          return bytes;
        };
        util$1.inflate = function(api, bytes, raw) {
          var rval = api.inflate(util$1.encode64(bytes)).rval;
          return rval === null ? null : util$1.decode64(rval);
        };
        var _setStorageObject = function(api, id, obj) {
          if (!api) {
            throw new Error("WebStorage not available.");
          }
          var rval;
          if (obj === null) {
            rval = api.removeItem(id);
          } else {
            obj = util$1.encode64(JSON.stringify(obj));
            rval = api.setItem(id, obj);
          }
          if (typeof rval !== "undefined" && rval.rval !== true) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
        };
        var _getStorageObject = function(api, id) {
          if (!api) {
            throw new Error("WebStorage not available.");
          }
          var rval = api.getItem(id);
          if (api.init) {
            if (rval.rval === null) {
              if (rval.error) {
                var error = new Error(rval.error.message);
                error.id = rval.error.id;
                error.name = rval.error.name;
                throw error;
              }
              rval = null;
            } else {
              rval = rval.rval;
            }
          }
          if (rval !== null) {
            rval = JSON.parse(util$1.decode64(rval));
          }
          return rval;
        };
        var _setItem = function(api, id, key, data) {
          var obj = _getStorageObject(api, id);
          if (obj === null) {
            obj = {};
          }
          obj[key] = data;
          _setStorageObject(api, id, obj);
        };
        var _getItem = function(api, id, key) {
          var rval = _getStorageObject(api, id);
          if (rval !== null) {
            rval = key in rval ? rval[key] : null;
          }
          return rval;
        };
        var _removeItem = function(api, id, key) {
          var obj = _getStorageObject(api, id);
          if (obj !== null && key in obj) {
            delete obj[key];
            var empty = true;
            for (var prop in obj) {
              empty = false;
              break;
            }
            if (empty) {
              obj = null;
            }
            _setStorageObject(api, id, obj);
          }
        };
        var _clearItems = function(api, id) {
          _setStorageObject(api, id, null);
        };
        var _callStorageFunction = function(func, args, location) {
          var rval = null;
          if (typeof location === "undefined") {
            location = ["web", "flash"];
          }
          var type;
          var done = false;
          var exception = null;
          for (var idx in location) {
            type = location[idx];
            try {
              if (type === "flash" || type === "both") {
                if (args[0] === null) {
                  throw new Error("Flash local storage not available.");
                }
                rval = func.apply(this, args);
                done = type === "flash";
              }
              if (type === "web" || type === "both") {
                args[0] = localStorage;
                rval = func.apply(this, args);
                done = true;
              }
            } catch (ex) {
              exception = ex;
            }
            if (done) {
              break;
            }
          }
          if (!done) {
            throw exception;
          }
          return rval;
        };
        util$1.setItem = function(api, id, key, data, location) {
          _callStorageFunction(_setItem, arguments, location);
        };
        util$1.getItem = function(api, id, key, location) {
          return _callStorageFunction(_getItem, arguments, location);
        };
        util$1.removeItem = function(api, id, key, location) {
          _callStorageFunction(_removeItem, arguments, location);
        };
        util$1.clearItems = function(api, id, location) {
          _callStorageFunction(_clearItems, arguments, location);
        };
        util$1.isEmpty = function(obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
          return true;
        };
        util$1.format = function(format) {
          var re = /%./g;
          var match;
          var part;
          var argi = 0;
          var parts = [];
          var last = 0;
          while (match = re.exec(format)) {
            part = format.substring(last, re.lastIndex - 2);
            if (part.length > 0) {
              parts.push(part);
            }
            last = re.lastIndex;
            var code = match[0][1];
            switch (code) {
              case "s":
              case "o":
                if (argi < arguments.length) {
                  parts.push(arguments[argi++ + 1]);
                } else {
                  parts.push("<?>");
                }
                break;
              // FIXME: do proper formatting for numbers, etc
              //case 'f':
              //case 'd':
              case "%":
                parts.push("%");
                break;
              default:
                parts.push("<%" + code + "?>");
            }
          }
          parts.push(format.substring(last));
          return parts.join("");
        };
        util$1.formatNumber = function(number, decimals, dec_point, thousands_sep) {
          var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
          var d = dec_point === void 0 ? "," : dec_point;
          var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
          var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
          var j = i.length > 3 ? i.length % 3 : 0;
          return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
        };
        util$1.formatSize = function(size) {
          if (size >= 1073741824) {
            size = util$1.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
          } else if (size >= 1048576) {
            size = util$1.formatNumber(size / 1048576, 2, ".", "") + " MiB";
          } else if (size >= 1024) {
            size = util$1.formatNumber(size / 1024, 0) + " KiB";
          } else {
            size = util$1.formatNumber(size, 0) + " bytes";
          }
          return size;
        };
        util$1.bytesFromIP = function(ip) {
          if (ip.indexOf(".") !== -1) {
            return util$1.bytesFromIPv4(ip);
          }
          if (ip.indexOf(":") !== -1) {
            return util$1.bytesFromIPv6(ip);
          }
          return null;
        };
        util$1.bytesFromIPv4 = function(ip) {
          ip = ip.split(".");
          if (ip.length !== 4) {
            return null;
          }
          var b = util$1.createBuffer();
          for (var i = 0; i < ip.length; ++i) {
            var num = parseInt(ip[i], 10);
            if (isNaN(num)) {
              return null;
            }
            b.putByte(num);
          }
          return b.getBytes();
        };
        util$1.bytesFromIPv6 = function(ip) {
          var blanks = 0;
          ip = ip.split(":").filter(function(e) {
            if (e.length === 0) ++blanks;
            return true;
          });
          var zeros = (8 - ip.length + blanks) * 2;
          var b = util$1.createBuffer();
          for (var i = 0; i < 8; ++i) {
            if (!ip[i] || ip[i].length === 0) {
              b.fillWithByte(0, zeros);
              zeros = 0;
              continue;
            }
            var bytes = util$1.hexToBytes(ip[i]);
            if (bytes.length < 2) {
              b.putByte(0);
            }
            b.putBytes(bytes);
          }
          return b.getBytes();
        };
        util$1.bytesToIP = function(bytes) {
          if (bytes.length === 4) {
            return util$1.bytesToIPv4(bytes);
          }
          if (bytes.length === 16) {
            return util$1.bytesToIPv6(bytes);
          }
          return null;
        };
        util$1.bytesToIPv4 = function(bytes) {
          if (bytes.length !== 4) {
            return null;
          }
          var ip = [];
          for (var i = 0; i < bytes.length; ++i) {
            ip.push(bytes.charCodeAt(i));
          }
          return ip.join(".");
        };
        util$1.bytesToIPv6 = function(bytes) {
          if (bytes.length !== 16) {
            return null;
          }
          var ip = [];
          var zeroGroups = [];
          var zeroMaxGroup = 0;
          for (var i = 0; i < bytes.length; i += 2) {
            var hex = util$1.bytesToHex(bytes[i] + bytes[i + 1]);
            while (hex[0] === "0" && hex !== "0") {
              hex = hex.substr(1);
            }
            if (hex === "0") {
              var last = zeroGroups[zeroGroups.length - 1];
              var idx = ip.length;
              if (!last || idx !== last.end + 1) {
                zeroGroups.push({ start: idx, end: idx });
              } else {
                last.end = idx;
                if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
                  zeroMaxGroup = zeroGroups.length - 1;
                }
              }
            }
            ip.push(hex);
          }
          if (zeroGroups.length > 0) {
            var group = zeroGroups[zeroMaxGroup];
            if (group.end - group.start > 0) {
              ip.splice(group.start, group.end - group.start + 1, "");
              if (group.start === 0) {
                ip.unshift("");
              }
              if (group.end === 7) {
                ip.push("");
              }
            }
          }
          return ip.join(":");
        };
        util$1.estimateCores = function(options, callback) {
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          options = options || {};
          if ("cores" in util$1 && !options.update) {
            return callback(null, util$1.cores);
          }
          if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
            util$1.cores = navigator.hardwareConcurrency;
            return callback(null, util$1.cores);
          }
          if (typeof Worker === "undefined") {
            util$1.cores = 1;
            return callback(null, util$1.cores);
          }
          if (typeof Blob === "undefined") {
            util$1.cores = 2;
            return callback(null, util$1.cores);
          }
          var blobUrl = URL.createObjectURL(new Blob([
            "(",
            (function() {
              self.addEventListener("message", function(e) {
                var st = Date.now();
                var et2 = st + 4;
                self.postMessage({ st, et: et2 });
              });
            }).toString(),
            ")()"
          ], { type: "application/javascript" }));
          sample([], 5, 16);
          function sample(max2, samples, numWorkers) {
            if (samples === 0) {
              var avg = Math.floor(max2.reduce(function(avg2, x) {
                return avg2 + x;
              }, 0) / max2.length);
              util$1.cores = Math.max(1, avg);
              URL.revokeObjectURL(blobUrl);
              return callback(null, util$1.cores);
            }
            map(numWorkers, function(err2, results) {
              max2.push(reduce(numWorkers, results));
              sample(max2, samples - 1, numWorkers);
            });
          }
          function map(numWorkers, callback2) {
            var workers = [];
            var results = [];
            for (var i = 0; i < numWorkers; ++i) {
              var worker = new Worker(blobUrl);
              worker.addEventListener("message", function(e) {
                results.push(e.data);
                if (results.length === numWorkers) {
                  for (var i2 = 0; i2 < numWorkers; ++i2) {
                    workers[i2].terminate();
                  }
                  callback2(null, results);
                }
              });
              workers.push(worker);
            }
            for (var i = 0; i < numWorkers; ++i) {
              workers[i].postMessage(i);
            }
          }
          function reduce(numWorkers, results) {
            var overlaps = [];
            for (var n = 0; n < numWorkers; ++n) {
              var r1 = results[n];
              var overlap = overlaps[n] = [];
              for (var i = 0; i < numWorkers; ++i) {
                if (n === i) {
                  continue;
                }
                var r2 = results[i];
                if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
                  overlap.push(i);
                }
              }
            }
            return overlaps.reduce(function(max2, overlap2) {
              return Math.max(max2, overlap2.length);
            }, 0);
          }
        };
        return util.exports;
      }
      var cipher;
      var hasRequiredCipher;
      function requireCipher() {
        if (hasRequiredCipher) return cipher;
        hasRequiredCipher = 1;
        var forge2 = requireForge();
        requireUtil();
        cipher = forge2.cipher = forge2.cipher || {};
        forge2.cipher.algorithms = forge2.cipher.algorithms || {};
        forge2.cipher.createCipher = function(algorithm, key) {
          var api = algorithm;
          if (typeof api === "string") {
            api = forge2.cipher.getAlgorithm(api);
            if (api) {
              api = api();
            }
          }
          if (!api) {
            throw new Error("Unsupported algorithm: " + algorithm);
          }
          return new forge2.cipher.BlockCipher({
            algorithm: api,
            key,
            decrypt: false
          });
        };
        forge2.cipher.createDecipher = function(algorithm, key) {
          var api = algorithm;
          if (typeof api === "string") {
            api = forge2.cipher.getAlgorithm(api);
            if (api) {
              api = api();
            }
          }
          if (!api) {
            throw new Error("Unsupported algorithm: " + algorithm);
          }
          return new forge2.cipher.BlockCipher({
            algorithm: api,
            key,
            decrypt: true
          });
        };
        forge2.cipher.registerAlgorithm = function(name2, algorithm) {
          name2 = name2.toUpperCase();
          forge2.cipher.algorithms[name2] = algorithm;
        };
        forge2.cipher.getAlgorithm = function(name2) {
          name2 = name2.toUpperCase();
          if (name2 in forge2.cipher.algorithms) {
            return forge2.cipher.algorithms[name2];
          }
          return null;
        };
        var BlockCipher = forge2.cipher.BlockCipher = function(options) {
          this.algorithm = options.algorithm;
          this.mode = this.algorithm.mode;
          this.blockSize = this.mode.blockSize;
          this._finish = false;
          this._input = null;
          this.output = null;
          this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
          this._decrypt = options.decrypt;
          this.algorithm.initialize(options);
        };
        BlockCipher.prototype.start = function(options) {
          options = options || {};
          var opts = {};
          for (var key in options) {
            opts[key] = options[key];
          }
          opts.decrypt = this._decrypt;
          this._finish = false;
          this._input = forge2.util.createBuffer();
          this.output = options.output || forge2.util.createBuffer();
          this.mode.start(opts);
        };
        BlockCipher.prototype.update = function(input) {
          if (input) {
            this._input.putBuffer(input);
          }
          while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
          }
          this._input.compact();
        };
        BlockCipher.prototype.finish = function(pad) {
          if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
            this.mode.pad = function(input) {
              return pad(this.blockSize, input, false);
            };
            this.mode.unpad = function(output) {
              return pad(this.blockSize, output, true);
            };
          }
          var options = {};
          options.decrypt = this._decrypt;
          options.overflow = this._input.length() % this.blockSize;
          if (!this._decrypt && this.mode.pad) {
            if (!this.mode.pad(this._input, options)) {
              return false;
            }
          }
          this._finish = true;
          this.update();
          if (this._decrypt && this.mode.unpad) {
            if (!this.mode.unpad(this.output, options)) {
              return false;
            }
          }
          if (this.mode.afterFinish) {
            if (!this.mode.afterFinish(this.output, options)) {
              return false;
            }
          }
          return true;
        };
        return cipher;
      }
      var cipherModes = { exports: {} };
      var hasRequiredCipherModes;
      function requireCipherModes() {
        if (hasRequiredCipherModes) return cipherModes.exports;
        hasRequiredCipherModes = 1;
        var forge2 = requireForge();
        requireUtil();
        forge2.cipher = forge2.cipher || {};
        var modes = cipherModes.exports = forge2.cipher.modes = forge2.cipher.modes || {};
        modes.ecb = function(options) {
          options = options || {};
          this.name = "ECB";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = new Array(this._ints);
          this._outBlock = new Array(this._ints);
        };
        modes.ecb.prototype.start = function(options) {
        };
        modes.ecb.prototype.encrypt = function(input, output, finish) {
          if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
            return true;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = input.getInt32();
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          for (var i = 0; i < this._ints; ++i) {
            output.putInt32(this._outBlock[i]);
          }
        };
        modes.ecb.prototype.decrypt = function(input, output, finish) {
          if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
            return true;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = input.getInt32();
          }
          this.cipher.decrypt(this._inBlock, this._outBlock);
          for (var i = 0; i < this._ints; ++i) {
            output.putInt32(this._outBlock[i]);
          }
        };
        modes.ecb.prototype.pad = function(input, options) {
          var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
          input.fillWithByte(padding, padding);
          return true;
        };
        modes.ecb.prototype.unpad = function(output, options) {
          if (options.overflow > 0) {
            return false;
          }
          var len = output.length();
          var count = output.at(len - 1);
          if (count > this.blockSize << 2) {
            return false;
          }
          output.truncate(count);
          return true;
        };
        modes.cbc = function(options) {
          options = options || {};
          this.name = "CBC";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = new Array(this._ints);
          this._outBlock = new Array(this._ints);
        };
        modes.cbc.prototype.start = function(options) {
          if (options.iv === null) {
            if (!this._prev) {
              throw new Error("Invalid IV parameter.");
            }
            this._iv = this._prev.slice(0);
          } else if (!("iv" in options)) {
            throw new Error("Invalid IV parameter.");
          } else {
            this._iv = transformIV(options.iv, this.blockSize);
            this._prev = this._iv.slice(0);
          }
        };
        modes.cbc.prototype.encrypt = function(input, output, finish) {
          if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
            return true;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = this._prev[i] ^ input.getInt32();
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          for (var i = 0; i < this._ints; ++i) {
            output.putInt32(this._outBlock[i]);
          }
          this._prev = this._outBlock;
        };
        modes.cbc.prototype.decrypt = function(input, output, finish) {
          if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
            return true;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = input.getInt32();
          }
          this.cipher.decrypt(this._inBlock, this._outBlock);
          for (var i = 0; i < this._ints; ++i) {
            output.putInt32(this._prev[i] ^ this._outBlock[i]);
          }
          this._prev = this._inBlock.slice(0);
        };
        modes.cbc.prototype.pad = function(input, options) {
          var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
          input.fillWithByte(padding, padding);
          return true;
        };
        modes.cbc.prototype.unpad = function(output, options) {
          if (options.overflow > 0) {
            return false;
          }
          var len = output.length();
          var count = output.at(len - 1);
          if (count > this.blockSize << 2) {
            return false;
          }
          output.truncate(count);
          return true;
        };
        modes.cfb = function(options) {
          options = options || {};
          this.name = "CFB";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = null;
          this._outBlock = new Array(this._ints);
          this._partialBlock = new Array(this._ints);
          this._partialOutput = forge2.util.createBuffer();
          this._partialBytes = 0;
        };
        modes.cfb.prototype.start = function(options) {
          if (!("iv" in options)) {
            throw new Error("Invalid IV parameter.");
          }
          this._iv = transformIV(options.iv, this.blockSize);
          this._inBlock = this._iv.slice(0);
          this._partialBytes = 0;
        };
        modes.cfb.prototype.encrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (inputLength === 0) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          if (this._partialBytes === 0 && inputLength >= this.blockSize) {
            for (var i = 0; i < this._ints; ++i) {
              this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
              output.putInt32(this._inBlock[i]);
            }
            return;
          }
          var partialBytes = (this.blockSize - inputLength) % this.blockSize;
          if (partialBytes > 0) {
            partialBytes = this.blockSize - partialBytes;
          }
          this._partialOutput.clear();
          for (var i = 0; i < this._ints; ++i) {
            this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
            this._partialOutput.putInt32(this._partialBlock[i]);
          }
          if (partialBytes > 0) {
            input.read -= this.blockSize;
          } else {
            for (var i = 0; i < this._ints; ++i) {
              this._inBlock[i] = this._partialBlock[i];
            }
          }
          if (this._partialBytes > 0) {
            this._partialOutput.getBytes(this._partialBytes);
          }
          if (partialBytes > 0 && !finish) {
            output.putBytes(this._partialOutput.getBytes(
              partialBytes - this._partialBytes
            ));
            this._partialBytes = partialBytes;
            return true;
          }
          output.putBytes(this._partialOutput.getBytes(
            inputLength - this._partialBytes
          ));
          this._partialBytes = 0;
        };
        modes.cfb.prototype.decrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (inputLength === 0) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          if (this._partialBytes === 0 && inputLength >= this.blockSize) {
            for (var i = 0; i < this._ints; ++i) {
              this._inBlock[i] = input.getInt32();
              output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
            }
            return;
          }
          var partialBytes = (this.blockSize - inputLength) % this.blockSize;
          if (partialBytes > 0) {
            partialBytes = this.blockSize - partialBytes;
          }
          this._partialOutput.clear();
          for (var i = 0; i < this._ints; ++i) {
            this._partialBlock[i] = input.getInt32();
            this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
          }
          if (partialBytes > 0) {
            input.read -= this.blockSize;
          } else {
            for (var i = 0; i < this._ints; ++i) {
              this._inBlock[i] = this._partialBlock[i];
            }
          }
          if (this._partialBytes > 0) {
            this._partialOutput.getBytes(this._partialBytes);
          }
          if (partialBytes > 0 && !finish) {
            output.putBytes(this._partialOutput.getBytes(
              partialBytes - this._partialBytes
            ));
            this._partialBytes = partialBytes;
            return true;
          }
          output.putBytes(this._partialOutput.getBytes(
            inputLength - this._partialBytes
          ));
          this._partialBytes = 0;
        };
        modes.ofb = function(options) {
          options = options || {};
          this.name = "OFB";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = null;
          this._outBlock = new Array(this._ints);
          this._partialOutput = forge2.util.createBuffer();
          this._partialBytes = 0;
        };
        modes.ofb.prototype.start = function(options) {
          if (!("iv" in options)) {
            throw new Error("Invalid IV parameter.");
          }
          this._iv = transformIV(options.iv, this.blockSize);
          this._inBlock = this._iv.slice(0);
          this._partialBytes = 0;
        };
        modes.ofb.prototype.encrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (input.length() === 0) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          if (this._partialBytes === 0 && inputLength >= this.blockSize) {
            for (var i = 0; i < this._ints; ++i) {
              output.putInt32(input.getInt32() ^ this._outBlock[i]);
              this._inBlock[i] = this._outBlock[i];
            }
            return;
          }
          var partialBytes = (this.blockSize - inputLength) % this.blockSize;
          if (partialBytes > 0) {
            partialBytes = this.blockSize - partialBytes;
          }
          this._partialOutput.clear();
          for (var i = 0; i < this._ints; ++i) {
            this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
          }
          if (partialBytes > 0) {
            input.read -= this.blockSize;
          } else {
            for (var i = 0; i < this._ints; ++i) {
              this._inBlock[i] = this._outBlock[i];
            }
          }
          if (this._partialBytes > 0) {
            this._partialOutput.getBytes(this._partialBytes);
          }
          if (partialBytes > 0 && !finish) {
            output.putBytes(this._partialOutput.getBytes(
              partialBytes - this._partialBytes
            ));
            this._partialBytes = partialBytes;
            return true;
          }
          output.putBytes(this._partialOutput.getBytes(
            inputLength - this._partialBytes
          ));
          this._partialBytes = 0;
        };
        modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
        modes.ctr = function(options) {
          options = options || {};
          this.name = "CTR";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = null;
          this._outBlock = new Array(this._ints);
          this._partialOutput = forge2.util.createBuffer();
          this._partialBytes = 0;
        };
        modes.ctr.prototype.start = function(options) {
          if (!("iv" in options)) {
            throw new Error("Invalid IV parameter.");
          }
          this._iv = transformIV(options.iv, this.blockSize);
          this._inBlock = this._iv.slice(0);
          this._partialBytes = 0;
        };
        modes.ctr.prototype.encrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (inputLength === 0) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          if (this._partialBytes === 0 && inputLength >= this.blockSize) {
            for (var i = 0; i < this._ints; ++i) {
              output.putInt32(input.getInt32() ^ this._outBlock[i]);
            }
          } else {
            var partialBytes = (this.blockSize - inputLength) % this.blockSize;
            if (partialBytes > 0) {
              partialBytes = this.blockSize - partialBytes;
            }
            this._partialOutput.clear();
            for (var i = 0; i < this._ints; ++i) {
              this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
            }
            if (partialBytes > 0) {
              input.read -= this.blockSize;
            }
            if (this._partialBytes > 0) {
              this._partialOutput.getBytes(this._partialBytes);
            }
            if (partialBytes > 0 && !finish) {
              output.putBytes(this._partialOutput.getBytes(
                partialBytes - this._partialBytes
              ));
              this._partialBytes = partialBytes;
              return true;
            }
            output.putBytes(this._partialOutput.getBytes(
              inputLength - this._partialBytes
            ));
            this._partialBytes = 0;
          }
          inc32(this._inBlock);
        };
        modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
        modes.gcm = function(options) {
          options = options || {};
          this.name = "GCM";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = new Array(this._ints);
          this._outBlock = new Array(this._ints);
          this._partialOutput = forge2.util.createBuffer();
          this._partialBytes = 0;
          this._R = 3774873600;
        };
        modes.gcm.prototype.start = function(options) {
          if (!("iv" in options)) {
            throw new Error("Invalid IV parameter.");
          }
          var iv = forge2.util.createBuffer(options.iv);
          this._cipherLength = 0;
          var additionalData;
          if ("additionalData" in options) {
            additionalData = forge2.util.createBuffer(options.additionalData);
          } else {
            additionalData = forge2.util.createBuffer();
          }
          if ("tagLength" in options) {
            this._tagLength = options.tagLength;
          } else {
            this._tagLength = 128;
          }
          this._tag = null;
          if (options.decrypt) {
            this._tag = forge2.util.createBuffer(options.tag).getBytes();
            if (this._tag.length !== this._tagLength / 8) {
              throw new Error("Authentication tag does not match tag length.");
            }
          }
          this._hashBlock = new Array(this._ints);
          this.tag = null;
          this._hashSubkey = new Array(this._ints);
          this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
          this.componentBits = 4;
          this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
          var ivLength = iv.length();
          if (ivLength === 12) {
            this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
          } else {
            this._j0 = [0, 0, 0, 0];
            while (iv.length() > 0) {
              this._j0 = this.ghash(
                this._hashSubkey,
                this._j0,
                [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]
              );
            }
            this._j0 = this.ghash(
              this._hashSubkey,
              this._j0,
              [0, 0].concat(from64To32(ivLength * 8))
            );
          }
          this._inBlock = this._j0.slice(0);
          inc32(this._inBlock);
          this._partialBytes = 0;
          additionalData = forge2.util.createBuffer(additionalData);
          this._aDataLength = from64To32(additionalData.length() * 8);
          var overflow = additionalData.length() % this.blockSize;
          if (overflow) {
            additionalData.fillWithByte(0, this.blockSize - overflow);
          }
          this._s = [0, 0, 0, 0];
          while (additionalData.length() > 0) {
            this._s = this.ghash(this._hashSubkey, this._s, [
              additionalData.getInt32(),
              additionalData.getInt32(),
              additionalData.getInt32(),
              additionalData.getInt32()
            ]);
          }
        };
        modes.gcm.prototype.encrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (inputLength === 0) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          if (this._partialBytes === 0 && inputLength >= this.blockSize) {
            for (var i = 0; i < this._ints; ++i) {
              output.putInt32(this._outBlock[i] ^= input.getInt32());
            }
            this._cipherLength += this.blockSize;
          } else {
            var partialBytes = (this.blockSize - inputLength) % this.blockSize;
            if (partialBytes > 0) {
              partialBytes = this.blockSize - partialBytes;
            }
            this._partialOutput.clear();
            for (var i = 0; i < this._ints; ++i) {
              this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
            }
            if (partialBytes <= 0 || finish) {
              if (finish) {
                var overflow = inputLength % this.blockSize;
                this._cipherLength += overflow;
                this._partialOutput.truncate(this.blockSize - overflow);
              } else {
                this._cipherLength += this.blockSize;
              }
              for (var i = 0; i < this._ints; ++i) {
                this._outBlock[i] = this._partialOutput.getInt32();
              }
              this._partialOutput.read -= this.blockSize;
            }
            if (this._partialBytes > 0) {
              this._partialOutput.getBytes(this._partialBytes);
            }
            if (partialBytes > 0 && !finish) {
              input.read -= this.blockSize;
              output.putBytes(this._partialOutput.getBytes(
                partialBytes - this._partialBytes
              ));
              this._partialBytes = partialBytes;
              return true;
            }
            output.putBytes(this._partialOutput.getBytes(
              inputLength - this._partialBytes
            ));
            this._partialBytes = 0;
          }
          this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
          inc32(this._inBlock);
        };
        modes.gcm.prototype.decrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          inc32(this._inBlock);
          this._hashBlock[0] = input.getInt32();
          this._hashBlock[1] = input.getInt32();
          this._hashBlock[2] = input.getInt32();
          this._hashBlock[3] = input.getInt32();
          this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
          for (var i = 0; i < this._ints; ++i) {
            output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
          }
          if (inputLength < this.blockSize) {
            this._cipherLength += inputLength % this.blockSize;
          } else {
            this._cipherLength += this.blockSize;
          }
        };
        modes.gcm.prototype.afterFinish = function(output, options) {
          var rval = true;
          if (options.decrypt && options.overflow) {
            output.truncate(this.blockSize - options.overflow);
          }
          this.tag = forge2.util.createBuffer();
          var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
          this._s = this.ghash(this._hashSubkey, this._s, lengths);
          var tag = [];
          this.cipher.encrypt(this._j0, tag);
          for (var i = 0; i < this._ints; ++i) {
            this.tag.putInt32(this._s[i] ^ tag[i]);
          }
          this.tag.truncate(this.tag.length() % (this._tagLength / 8));
          if (options.decrypt && this.tag.bytes() !== this._tag) {
            rval = false;
          }
          return rval;
        };
        modes.gcm.prototype.multiply = function(x, y) {
          var z_i = [0, 0, 0, 0];
          var v_i = y.slice(0);
          for (var i = 0; i < 128; ++i) {
            var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
            if (x_i) {
              z_i[0] ^= v_i[0];
              z_i[1] ^= v_i[1];
              z_i[2] ^= v_i[2];
              z_i[3] ^= v_i[3];
            }
            this.pow(v_i, v_i);
          }
          return z_i;
        };
        modes.gcm.prototype.pow = function(x, out) {
          var lsb = x[3] & 1;
          for (var i = 3; i > 0; --i) {
            out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
          }
          out[0] = x[0] >>> 1;
          if (lsb) {
            out[0] ^= this._R;
          }
        };
        modes.gcm.prototype.tableMultiply = function(x) {
          var z = [0, 0, 0, 0];
          for (var i = 0; i < 32; ++i) {
            var idx = i / 8 | 0;
            var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;
            var ah = this._m[i][x_i];
            z[0] ^= ah[0];
            z[1] ^= ah[1];
            z[2] ^= ah[2];
            z[3] ^= ah[3];
          }
          return z;
        };
        modes.gcm.prototype.ghash = function(h, y, x) {
          y[0] ^= x[0];
          y[1] ^= x[1];
          y[2] ^= x[2];
          y[3] ^= x[3];
          return this.tableMultiply(y);
        };
        modes.gcm.prototype.generateHashTable = function(h, bits2) {
          var multiplier = 8 / bits2;
          var perInt = 4 * multiplier;
          var size = 16 * multiplier;
          var m = new Array(size);
          for (var i = 0; i < size; ++i) {
            var tmp = [0, 0, 0, 0];
            var idx = i / perInt | 0;
            var shft2 = (perInt - 1 - i % perInt) * bits2;
            tmp[idx] = 1 << bits2 - 1 << shft2;
            m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits2);
          }
          return m;
        };
        modes.gcm.prototype.generateSubHashTable = function(mid, bits2) {
          var size = 1 << bits2;
          var half = size >>> 1;
          var m = new Array(size);
          m[half] = mid.slice(0);
          var i = half >>> 1;
          while (i > 0) {
            this.pow(m[2 * i], m[i] = []);
            i >>= 1;
          }
          i = 2;
          while (i < half) {
            for (var j = 1; j < i; ++j) {
              var m_i = m[i];
              var m_j = m[j];
              m[i + j] = [
                m_i[0] ^ m_j[0],
                m_i[1] ^ m_j[1],
                m_i[2] ^ m_j[2],
                m_i[3] ^ m_j[3]
              ];
            }
            i *= 2;
          }
          m[0] = [0, 0, 0, 0];
          for (i = half + 1; i < size; ++i) {
            var c = m[i ^ half];
            m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
          }
          return m;
        };
        function transformIV(iv, blockSize) {
          if (typeof iv === "string") {
            iv = forge2.util.createBuffer(iv);
          }
          if (forge2.util.isArray(iv) && iv.length > 4) {
            var tmp = iv;
            iv = forge2.util.createBuffer();
            for (var i = 0; i < tmp.length; ++i) {
              iv.putByte(tmp[i]);
            }
          }
          if (iv.length() < blockSize) {
            throw new Error(
              "Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes."
            );
          }
          if (!forge2.util.isArray(iv)) {
            var ints = [];
            var blocks = blockSize / 4;
            for (var i = 0; i < blocks; ++i) {
              ints.push(iv.getInt32());
            }
            iv = ints;
          }
          return iv;
        }
        function inc32(block) {
          block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
        }
        function from64To32(num) {
          return [num / 4294967296 | 0, num & 4294967295];
        }
        return cipherModes.exports;
      }
      var aes;
      var hasRequiredAes;
      function requireAes() {
        if (hasRequiredAes) return aes;
        hasRequiredAes = 1;
        var forge2 = requireForge();
        requireCipher();
        requireCipherModes();
        requireUtil();
        aes = forge2.aes = forge2.aes || {};
        forge2.aes.startEncrypting = function(key, iv, output, mode) {
          var cipher2 = _createCipher({
            key,
            output,
            decrypt: false,
            mode
          });
          cipher2.start(iv);
          return cipher2;
        };
        forge2.aes.createEncryptionCipher = function(key, mode) {
          return _createCipher({
            key,
            output: null,
            decrypt: false,
            mode
          });
        };
        forge2.aes.startDecrypting = function(key, iv, output, mode) {
          var cipher2 = _createCipher({
            key,
            output,
            decrypt: true,
            mode
          });
          cipher2.start(iv);
          return cipher2;
        };
        forge2.aes.createDecryptionCipher = function(key, mode) {
          return _createCipher({
            key,
            output: null,
            decrypt: true,
            mode
          });
        };
        forge2.aes.Algorithm = function(name2, mode) {
          if (!init) {
            initialize();
          }
          var self2 = this;
          self2.name = name2;
          self2.mode = new mode({
            blockSize: 16,
            cipher: {
              encrypt: function(inBlock, outBlock) {
                return _updateBlock(self2._w, inBlock, outBlock, false);
              },
              decrypt: function(inBlock, outBlock) {
                return _updateBlock(self2._w, inBlock, outBlock, true);
              }
            }
          });
          self2._init = false;
        };
        forge2.aes.Algorithm.prototype.initialize = function(options) {
          if (this._init) {
            return;
          }
          var key = options.key;
          var tmp;
          if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
            key = forge2.util.createBuffer(key);
          } else if (forge2.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
            tmp = key;
            key = forge2.util.createBuffer();
            for (var i = 0; i < tmp.length; ++i) {
              key.putByte(tmp[i]);
            }
          }
          if (!forge2.util.isArray(key)) {
            tmp = key;
            key = [];
            var len = tmp.length();
            if (len === 16 || len === 24 || len === 32) {
              len = len >>> 2;
              for (var i = 0; i < len; ++i) {
                key.push(tmp.getInt32());
              }
            }
          }
          if (!forge2.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
            throw new Error("Invalid key parameter.");
          }
          var mode = this.mode.name;
          var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
          this._w = _expandKey(key, options.decrypt && !encryptOp);
          this._init = true;
        };
        forge2.aes._expandKey = function(key, decrypt) {
          if (!init) {
            initialize();
          }
          return _expandKey(key, decrypt);
        };
        forge2.aes._updateBlock = _updateBlock;
        registerAlgorithm("AES-ECB", forge2.cipher.modes.ecb);
        registerAlgorithm("AES-CBC", forge2.cipher.modes.cbc);
        registerAlgorithm("AES-CFB", forge2.cipher.modes.cfb);
        registerAlgorithm("AES-OFB", forge2.cipher.modes.ofb);
        registerAlgorithm("AES-CTR", forge2.cipher.modes.ctr);
        registerAlgorithm("AES-GCM", forge2.cipher.modes.gcm);
        function registerAlgorithm(name2, mode) {
          var factory = function() {
            return new forge2.aes.Algorithm(name2, mode);
          };
          forge2.cipher.registerAlgorithm(name2, factory);
        }
        var init = false;
        var Nb = 4;
        var sbox;
        var isbox;
        var rcon;
        var mix;
        var imix;
        function initialize() {
          init = true;
          rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
          var xtime = new Array(256);
          for (var i = 0; i < 128; ++i) {
            xtime[i] = i << 1;
            xtime[i + 128] = i + 128 << 1 ^ 283;
          }
          sbox = new Array(256);
          isbox = new Array(256);
          mix = new Array(4);
          imix = new Array(4);
          for (var i = 0; i < 4; ++i) {
            mix[i] = new Array(256);
            imix[i] = new Array(256);
          }
          var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
          for (var i = 0; i < 256; ++i) {
            sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
            sx = sx >> 8 ^ sx & 255 ^ 99;
            sbox[e] = sx;
            isbox[sx] = e;
            sx2 = xtime[sx];
            e2 = xtime[e];
            e4 = xtime[e2];
            e8 = xtime[e4];
            me = sx2 << 24 ^ // 2
            sx << 16 ^ // 1
            sx << 8 ^ // 1
            (sx ^ sx2);
            ime = (e2 ^ e4 ^ e8) << 24 ^ // E (14)
            (e ^ e8) << 16 ^ // 9
            (e ^ e4 ^ e8) << 8 ^ // D (13)
            (e ^ e2 ^ e8);
            for (var n = 0; n < 4; ++n) {
              mix[n][e] = me;
              imix[n][sx] = ime;
              me = me << 24 | me >>> 8;
              ime = ime << 24 | ime >>> 8;
            }
            if (e === 0) {
              e = ei = 1;
            } else {
              e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
              ei ^= xtime[xtime[ei]];
            }
          }
        }
        function _expandKey(key, decrypt) {
          var w = key.slice(0);
          var temp, iNk = 1;
          var Nk = w.length;
          var Nr1 = Nk + 6 + 1;
          var end = Nb * Nr1;
          for (var i = Nk; i < end; ++i) {
            temp = w[i - 1];
            if (i % Nk === 0) {
              temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
              iNk++;
            } else if (Nk > 6 && i % Nk === 4) {
              temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
            }
            w[i] = w[i - Nk] ^ temp;
          }
          if (decrypt) {
            var tmp;
            var m0 = imix[0];
            var m1 = imix[1];
            var m2 = imix[2];
            var m3 = imix[3];
            var wnew = w.slice(0);
            end = w.length;
            for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
              if (i === 0 || i === end - Nb) {
                wnew[i] = w[wi];
                wnew[i + 1] = w[wi + 3];
                wnew[i + 2] = w[wi + 2];
                wnew[i + 3] = w[wi + 1];
              } else {
                for (var n = 0; n < Nb; ++n) {
                  tmp = w[wi + n];
                  wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
                }
              }
            }
            w = wnew;
          }
          return w;
        }
        function _updateBlock(w, input, output, decrypt) {
          var Nr = w.length / 4 - 1;
          var m0, m1, m2, m3, sub;
          if (decrypt) {
            m0 = imix[0];
            m1 = imix[1];
            m2 = imix[2];
            m3 = imix[3];
            sub = isbox;
          } else {
            m0 = mix[0];
            m1 = mix[1];
            m2 = mix[2];
            m3 = mix[3];
            sub = sbox;
          }
          var a, b, c, d, a2, b2, c2;
          a = input[0] ^ w[0];
          b = input[decrypt ? 3 : 1] ^ w[1];
          c = input[2] ^ w[2];
          d = input[decrypt ? 1 : 3] ^ w[3];
          var i = 3;
          for (var round = 1; round < Nr; ++round) {
            a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
            b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
            c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
            d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
            a = a2;
            b = b2;
            c = c2;
          }
          output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];
          output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];
          output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];
          output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];
        }
        function _createCipher(options) {
          options = options || {};
          var mode = (options.mode || "CBC").toUpperCase();
          var algorithm = "AES-" + mode;
          var cipher2;
          if (options.decrypt) {
            cipher2 = forge2.cipher.createDecipher(algorithm, options.key);
          } else {
            cipher2 = forge2.cipher.createCipher(algorithm, options.key);
          }
          var start = cipher2.start;
          cipher2.start = function(iv, options2) {
            var output = null;
            if (options2 instanceof forge2.util.ByteBuffer) {
              output = options2;
              options2 = {};
            }
            options2 = options2 || {};
            options2.output = output;
            options2.iv = iv;
            start.call(cipher2, options2);
          };
          return cipher2;
        }
        return aes;
      }
      var aesCipherSuites = { exports: {} };
      var asn1 = { exports: {} };
      var oids = { exports: {} };
      var hasRequiredOids;
      function requireOids() {
        if (hasRequiredOids) return oids.exports;
        hasRequiredOids = 1;
        var forge2 = requireForge();
        forge2.pki = forge2.pki || {};
        var oids$1 = oids.exports = forge2.pki.oids = forge2.oids = forge2.oids || {};
        function _IN(id, name2) {
          oids$1[id] = name2;
          oids$1[name2] = id;
        }
        function _I_(id, name2) {
          oids$1[id] = name2;
        }
        _IN("1.2.840.113549.1.1.1", "rsaEncryption");
        _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
        _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
        _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
        _IN("1.2.840.113549.1.1.8", "mgf1");
        _IN("1.2.840.113549.1.1.9", "pSpecified");
        _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
        _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
        _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
        _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
        _IN("1.3.101.112", "EdDSA25519");
        _IN("1.2.840.10040.4.3", "dsa-with-sha1");
        _IN("1.3.14.3.2.7", "desCBC");
        _IN("1.3.14.3.2.26", "sha1");
        _IN("1.3.14.3.2.29", "sha1WithRSASignature");
        _IN("2.16.840.1.101.3.4.2.1", "sha256");
        _IN("2.16.840.1.101.3.4.2.2", "sha384");
        _IN("2.16.840.1.101.3.4.2.3", "sha512");
        _IN("2.16.840.1.101.3.4.2.4", "sha224");
        _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
        _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
        _IN("1.2.840.113549.2.2", "md2");
        _IN("1.2.840.113549.2.5", "md5");
        _IN("1.2.840.113549.1.7.1", "data");
        _IN("1.2.840.113549.1.7.2", "signedData");
        _IN("1.2.840.113549.1.7.3", "envelopedData");
        _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
        _IN("1.2.840.113549.1.7.5", "digestedData");
        _IN("1.2.840.113549.1.7.6", "encryptedData");
        _IN("1.2.840.113549.1.9.1", "emailAddress");
        _IN("1.2.840.113549.1.9.2", "unstructuredName");
        _IN("1.2.840.113549.1.9.3", "contentType");
        _IN("1.2.840.113549.1.9.4", "messageDigest");
        _IN("1.2.840.113549.1.9.5", "signingTime");
        _IN("1.2.840.113549.1.9.6", "counterSignature");
        _IN("1.2.840.113549.1.9.7", "challengePassword");
        _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
        _IN("1.2.840.113549.1.9.14", "extensionRequest");
        _IN("1.2.840.113549.1.9.20", "friendlyName");
        _IN("1.2.840.113549.1.9.21", "localKeyId");
        _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
        _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
        _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
        _IN("1.2.840.113549.1.12.10.1.3", "certBag");
        _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
        _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
        _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
        _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
        _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
        _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
        _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
        _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
        _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
        _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
        _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
        _IN("1.2.840.113549.2.7", "hmacWithSHA1");
        _IN("1.2.840.113549.2.8", "hmacWithSHA224");
        _IN("1.2.840.113549.2.9", "hmacWithSHA256");
        _IN("1.2.840.113549.2.10", "hmacWithSHA384");
        _IN("1.2.840.113549.2.11", "hmacWithSHA512");
        _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
        _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
        _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
        _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
        _IN("2.5.4.3", "commonName");
        _IN("2.5.4.4", "surname");
        _IN("2.5.4.5", "serialNumber");
        _IN("2.5.4.6", "countryName");
        _IN("2.5.4.7", "localityName");
        _IN("2.5.4.8", "stateOrProvinceName");
        _IN("2.5.4.9", "streetAddress");
        _IN("2.5.4.10", "organizationName");
        _IN("2.5.4.11", "organizationalUnitName");
        _IN("2.5.4.12", "title");
        _IN("2.5.4.13", "description");
        _IN("2.5.4.15", "businessCategory");
        _IN("2.5.4.17", "postalCode");
        _IN("2.5.4.42", "givenName");
        _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
        _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
        _IN("2.16.840.1.113730.1.1", "nsCertType");
        _IN("2.16.840.1.113730.1.13", "nsComment");
        _I_("2.5.29.1", "authorityKeyIdentifier");
        _I_("2.5.29.2", "keyAttributes");
        _I_("2.5.29.3", "certificatePolicies");
        _I_("2.5.29.4", "keyUsageRestriction");
        _I_("2.5.29.5", "policyMapping");
        _I_("2.5.29.6", "subtreesConstraint");
        _I_("2.5.29.7", "subjectAltName");
        _I_("2.5.29.8", "issuerAltName");
        _I_("2.5.29.9", "subjectDirectoryAttributes");
        _I_("2.5.29.10", "basicConstraints");
        _I_("2.5.29.11", "nameConstraints");
        _I_("2.5.29.12", "policyConstraints");
        _I_("2.5.29.13", "basicConstraints");
        _IN("2.5.29.14", "subjectKeyIdentifier");
        _IN("2.5.29.15", "keyUsage");
        _I_("2.5.29.16", "privateKeyUsagePeriod");
        _IN("2.5.29.17", "subjectAltName");
        _IN("2.5.29.18", "issuerAltName");
        _IN("2.5.29.19", "basicConstraints");
        _I_("2.5.29.20", "cRLNumber");
        _I_("2.5.29.21", "cRLReason");
        _I_("2.5.29.22", "expirationDate");
        _I_("2.5.29.23", "instructionCode");
        _I_("2.5.29.24", "invalidityDate");
        _I_("2.5.29.25", "cRLDistributionPoints");
        _I_("2.5.29.26", "issuingDistributionPoint");
        _I_("2.5.29.27", "deltaCRLIndicator");
        _I_("2.5.29.28", "issuingDistributionPoint");
        _I_("2.5.29.29", "certificateIssuer");
        _I_("2.5.29.30", "nameConstraints");
        _IN("2.5.29.31", "cRLDistributionPoints");
        _IN("2.5.29.32", "certificatePolicies");
        _I_("2.5.29.33", "policyMappings");
        _I_("2.5.29.34", "policyConstraints");
        _IN("2.5.29.35", "authorityKeyIdentifier");
        _I_("2.5.29.36", "policyConstraints");
        _IN("2.5.29.37", "extKeyUsage");
        _I_("2.5.29.46", "freshestCRL");
        _I_("2.5.29.54", "inhibitAnyPolicy");
        _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
        _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
        _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
        _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
        _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
        _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
        _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
        return oids.exports;
      }
      var hasRequiredAsn1;
      function requireAsn1() {
        if (hasRequiredAsn1) return asn1.exports;
        hasRequiredAsn1 = 1;
        var forge2 = requireForge();
        requireUtil();
        requireOids();
        var asn1$1 = asn1.exports = forge2.asn1 = forge2.asn1 || {};
        asn1$1.Class = {
          UNIVERSAL: 0,
          APPLICATION: 64,
          CONTEXT_SPECIFIC: 128,
          PRIVATE: 192
        };
        asn1$1.Type = {
          NONE: 0,
          BOOLEAN: 1,
          INTEGER: 2,
          BITSTRING: 3,
          OCTETSTRING: 4,
          NULL: 5,
          OID: 6,
          ODESC: 7,
          EXTERNAL: 8,
          REAL: 9,
          ENUMERATED: 10,
          EMBEDDED: 11,
          UTF8: 12,
          ROID: 13,
          SEQUENCE: 16,
          SET: 17,
          PRINTABLESTRING: 19,
          IA5STRING: 22,
          UTCTIME: 23,
          GENERALIZEDTIME: 24,
          BMPSTRING: 30
        };
        asn1$1.maxDepth = 256;
        asn1$1.create = function(tagClass, type, constructed, value, options) {
          if (forge2.util.isArray(value)) {
            var tmp = [];
            for (var i = 0; i < value.length; ++i) {
              if (value[i] !== void 0) {
                tmp.push(value[i]);
              }
            }
            value = tmp;
          }
          var obj = {
            tagClass,
            type,
            constructed,
            composed: constructed || forge2.util.isArray(value),
            value
          };
          if (options && "bitStringContents" in options) {
            obj.bitStringContents = options.bitStringContents;
            obj.original = asn1$1.copy(obj);
          }
          return obj;
        };
        asn1$1.copy = function(obj, options) {
          var copy2;
          if (forge2.util.isArray(obj)) {
            copy2 = [];
            for (var i = 0; i < obj.length; ++i) {
              copy2.push(asn1$1.copy(obj[i], options));
            }
            return copy2;
          }
          if (typeof obj === "string") {
            return obj;
          }
          copy2 = {
            tagClass: obj.tagClass,
            type: obj.type,
            constructed: obj.constructed,
            composed: obj.composed,
            value: asn1$1.copy(obj.value, options)
          };
          if (options && !options.excludeBitStringContents) {
            copy2.bitStringContents = obj.bitStringContents;
          }
          return copy2;
        };
        asn1$1.equals = function(obj1, obj2, options) {
          if (forge2.util.isArray(obj1)) {
            if (!forge2.util.isArray(obj2)) {
              return false;
            }
            if (obj1.length !== obj2.length) {
              return false;
            }
            for (var i = 0; i < obj1.length; ++i) {
              if (!asn1$1.equals(obj1[i], obj2[i])) {
                return false;
              }
            }
            return true;
          }
          if (typeof obj1 !== typeof obj2) {
            return false;
          }
          if (typeof obj1 === "string") {
            return obj1 === obj2;
          }
          var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1$1.equals(obj1.value, obj2.value);
          if (options && options.includeBitStringContents) {
            equal = equal && obj1.bitStringContents === obj2.bitStringContents;
          }
          return equal;
        };
        asn1$1.getBerValueLength = function(b) {
          var b2 = b.getByte();
          if (b2 === 128) {
            return void 0;
          }
          var length;
          var longForm = b2 & 128;
          if (!longForm) {
            length = b2;
          } else {
            length = b.getInt((b2 & 127) << 3);
          }
          return length;
        };
        function _checkBufferLength(bytes, remaining, n) {
          if (n > remaining) {
            var error = new Error("Too few bytes to parse DER.");
            error.available = bytes.length();
            error.remaining = remaining;
            error.requested = n;
            throw error;
          }
        }
        var _getValueLength = function(bytes, remaining) {
          var b2 = bytes.getByte();
          remaining--;
          if (b2 === 128) {
            return void 0;
          }
          var length;
          var longForm = b2 & 128;
          if (!longForm) {
            length = b2;
          } else {
            var longFormBytes = b2 & 127;
            _checkBufferLength(bytes, remaining, longFormBytes);
            length = bytes.getInt(longFormBytes << 3);
          }
          if (length < 0) {
            throw new Error("Negative length: " + length);
          }
          return length;
        };
        asn1$1.fromDer = function(bytes, options) {
          if (options === void 0) {
            options = {
              strict: true,
              parseAllBytes: true,
              decodeBitStrings: true
            };
          }
          if (typeof options === "boolean") {
            options = {
              strict: options,
              parseAllBytes: true,
              decodeBitStrings: true
            };
          }
          if (!("strict" in options)) {
            options.strict = true;
          }
          if (!("parseAllBytes" in options)) {
            options.parseAllBytes = true;
          }
          if (!("decodeBitStrings" in options)) {
            options.decodeBitStrings = true;
          }
          if (!("maxDepth" in options)) {
            options.maxDepth = asn1$1.maxDepth;
          }
          if (typeof bytes === "string") {
            bytes = forge2.util.createBuffer(bytes);
          }
          var byteCount = bytes.length();
          var value = _fromDer(bytes, bytes.length(), 0, options);
          if (options.parseAllBytes && bytes.length() !== 0) {
            var error = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
            error.byteCount = byteCount;
            error.remaining = bytes.length();
            throw error;
          }
          return value;
        };
        function _fromDer(bytes, remaining, depth, options) {
          if (depth >= options.maxDepth) {
            throw new Error("ASN.1 parsing error: Max depth exceeded.");
          }
          var start;
          _checkBufferLength(bytes, remaining, 2);
          var b1 = bytes.getByte();
          remaining--;
          var tagClass = b1 & 192;
          var type = b1 & 31;
          start = bytes.length();
          var length = _getValueLength(bytes, remaining);
          remaining -= start - bytes.length();
          if (length !== void 0 && length > remaining) {
            if (options.strict) {
              var error = new Error("Too few bytes to read ASN.1 value.");
              error.available = bytes.length();
              error.remaining = remaining;
              error.requested = length;
              throw error;
            }
            length = remaining;
          }
          var value;
          var bitStringContents;
          var constructed = (b1 & 32) === 32;
          if (constructed) {
            value = [];
            if (length === void 0) {
              for (; ; ) {
                _checkBufferLength(bytes, remaining, 2);
                if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
                  bytes.getBytes(2);
                  remaining -= 2;
                  break;
                }
                start = bytes.length();
                value.push(_fromDer(bytes, remaining, depth + 1, options));
                remaining -= start - bytes.length();
              }
            } else {
              while (length > 0) {
                start = bytes.length();
                value.push(_fromDer(bytes, length, depth + 1, options));
                remaining -= start - bytes.length();
                length -= start - bytes.length();
              }
            }
          }
          if (value === void 0 && tagClass === asn1$1.Class.UNIVERSAL && type === asn1$1.Type.BITSTRING) {
            bitStringContents = bytes.bytes(length);
          }
          if (value === void 0 && options.decodeBitStrings && tagClass === asn1$1.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
          // .. other parts of forge expect to decode OCTET STRINGs manually
          type === asn1$1.Type.BITSTRING && length > 1) {
            var savedRead = bytes.read;
            var savedRemaining = remaining;
            var unused = 0;
            if (type === asn1$1.Type.BITSTRING) {
              _checkBufferLength(bytes, remaining, 1);
              unused = bytes.getByte();
              remaining--;
            }
            if (unused === 0) {
              try {
                start = bytes.length();
                var subOptions = {
                  // enforce strict mode to avoid parsing ASN.1 from plain data
                  strict: true,
                  decodeBitStrings: true
                };
                var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
                var used = start - bytes.length();
                remaining -= used;
                if (type == asn1$1.Type.BITSTRING) {
                  used++;
                }
                var tc = composed.tagClass;
                if (used === length && (tc === asn1$1.Class.UNIVERSAL || tc === asn1$1.Class.CONTEXT_SPECIFIC)) {
                  value = [composed];
                }
              } catch (ex) {
              }
            }
            if (value === void 0) {
              bytes.read = savedRead;
              remaining = savedRemaining;
            }
          }
          if (value === void 0) {
            if (length === void 0) {
              if (options.strict) {
                throw new Error("Non-constructed ASN.1 object of indefinite length.");
              }
              length = remaining;
            }
            if (type === asn1$1.Type.BMPSTRING) {
              value = "";
              for (; length > 0; length -= 2) {
                _checkBufferLength(bytes, remaining, 2);
                value += String.fromCharCode(bytes.getInt16());
                remaining -= 2;
              }
            } else {
              value = bytes.getBytes(length);
              remaining -= length;
            }
          }
          var asn1Options = bitStringContents === void 0 ? null : {
            bitStringContents
          };
          return asn1$1.create(tagClass, type, constructed, value, asn1Options);
        }
        asn1$1.toDer = function(obj) {
          var bytes = forge2.util.createBuffer();
          var b1 = obj.tagClass | obj.type;
          var value = forge2.util.createBuffer();
          var useBitStringContents = false;
          if ("bitStringContents" in obj) {
            useBitStringContents = true;
            if (obj.original) {
              useBitStringContents = asn1$1.equals(obj, obj.original);
            }
          }
          if (useBitStringContents) {
            value.putBytes(obj.bitStringContents);
          } else if (obj.composed) {
            if (obj.constructed) {
              b1 |= 32;
            } else {
              value.putByte(0);
            }
            for (var i = 0; i < obj.value.length; ++i) {
              if (obj.value[i] !== void 0) {
                value.putBuffer(asn1$1.toDer(obj.value[i]));
              }
            }
          } else {
            if (obj.type === asn1$1.Type.BMPSTRING) {
              for (var i = 0; i < obj.value.length; ++i) {
                value.putInt16(obj.value.charCodeAt(i));
              }
            } else {
              if (obj.type === asn1$1.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer
              (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
              obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
                value.putBytes(obj.value.substr(1));
              } else {
                value.putBytes(obj.value);
              }
            }
          }
          bytes.putByte(b1);
          if (value.length() <= 127) {
            bytes.putByte(value.length() & 127);
          } else {
            var len = value.length();
            var lenBytes = "";
            do {
              lenBytes += String.fromCharCode(len & 255);
              len = len >>> 8;
            } while (len > 0);
            bytes.putByte(lenBytes.length | 128);
            for (var i = lenBytes.length - 1; i >= 0; --i) {
              bytes.putByte(lenBytes.charCodeAt(i));
            }
          }
          bytes.putBuffer(value);
          return bytes;
        };
        asn1$1.oidToDer = function(oid) {
          var values = oid.split(".");
          var bytes = forge2.util.createBuffer();
          bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
          var last, valueBytes, value, b;
          for (var i = 2; i < values.length; ++i) {
            last = true;
            valueBytes = [];
            value = parseInt(values[i], 10);
            if (value > 4294967295) {
              throw new Error("OID value too large; max is 32-bits.");
            }
            do {
              b = value & 127;
              value = value >>> 7;
              if (!last) {
                b |= 128;
              }
              valueBytes.push(b);
              last = false;
            } while (value > 0);
            for (var n = valueBytes.length - 1; n >= 0; --n) {
              bytes.putByte(valueBytes[n]);
            }
          }
          return bytes;
        };
        asn1$1.derToOid = function(bytes) {
          var oid;
          if (typeof bytes === "string") {
            bytes = forge2.util.createBuffer(bytes);
          }
          var b = bytes.getByte();
          oid = Math.floor(b / 40) + "." + b % 40;
          var value = 0;
          while (bytes.length() > 0) {
            if (value > 70368744177663) {
              throw new Error("OID value too large; max is 53-bits.");
            }
            b = bytes.getByte();
            value = value * 128;
            if (b & 128) {
              value += b & 127;
            } else {
              oid += "." + (value + b);
              value = 0;
            }
          }
          return oid;
        };
        asn1$1.utcTimeToDate = function(utc) {
          var date = /* @__PURE__ */ new Date();
          var year = parseInt(utc.substr(0, 2), 10);
          year = year >= 50 ? 1900 + year : 2e3 + year;
          var MM = parseInt(utc.substr(2, 2), 10) - 1;
          var DD = parseInt(utc.substr(4, 2), 10);
          var hh = parseInt(utc.substr(6, 2), 10);
          var mm = parseInt(utc.substr(8, 2), 10);
          var ss = 0;
          if (utc.length > 11) {
            var c = utc.charAt(10);
            var end = 10;
            if (c !== "+" && c !== "-") {
              ss = parseInt(utc.substr(10, 2), 10);
              end += 2;
            }
          }
          date.setUTCFullYear(year, MM, DD);
          date.setUTCHours(hh, mm, ss, 0);
          if (end) {
            c = utc.charAt(end);
            if (c === "+" || c === "-") {
              var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
              var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
              var offset = hhoffset * 60 + mmoffset;
              offset *= 6e4;
              if (c === "+") {
                date.setTime(+date - offset);
              } else {
                date.setTime(+date + offset);
              }
            }
          }
          return date;
        };
        asn1$1.generalizedTimeToDate = function(gentime) {
          var date = /* @__PURE__ */ new Date();
          var YYYY = parseInt(gentime.substr(0, 4), 10);
          var MM = parseInt(gentime.substr(4, 2), 10) - 1;
          var DD = parseInt(gentime.substr(6, 2), 10);
          var hh = parseInt(gentime.substr(8, 2), 10);
          var mm = parseInt(gentime.substr(10, 2), 10);
          var ss = parseInt(gentime.substr(12, 2), 10);
          var fff = 0;
          var offset = 0;
          var isUTC = false;
          if (gentime.charAt(gentime.length - 1) === "Z") {
            isUTC = true;
          }
          var end = gentime.length - 5, c = gentime.charAt(end);
          if (c === "+" || c === "-") {
            var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
            var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
            offset = hhoffset * 60 + mmoffset;
            offset *= 6e4;
            if (c === "+") {
              offset *= -1;
            }
            isUTC = true;
          }
          if (gentime.charAt(14) === ".") {
            fff = parseFloat(gentime.substr(14), 10) * 1e3;
          }
          if (isUTC) {
            date.setUTCFullYear(YYYY, MM, DD);
            date.setUTCHours(hh, mm, ss, fff);
            date.setTime(+date + offset);
          } else {
            date.setFullYear(YYYY, MM, DD);
            date.setHours(hh, mm, ss, fff);
          }
          return date;
        };
        asn1$1.dateToUtcTime = function(date) {
          if (typeof date === "string") {
            return date;
          }
          var rval = "";
          var format = [];
          format.push(("" + date.getUTCFullYear()).substr(2));
          format.push("" + (date.getUTCMonth() + 1));
          format.push("" + date.getUTCDate());
          format.push("" + date.getUTCHours());
          format.push("" + date.getUTCMinutes());
          format.push("" + date.getUTCSeconds());
          for (var i = 0; i < format.length; ++i) {
            if (format[i].length < 2) {
              rval += "0";
            }
            rval += format[i];
          }
          rval += "Z";
          return rval;
        };
        asn1$1.dateToGeneralizedTime = function(date) {
          if (typeof date === "string") {
            return date;
          }
          var rval = "";
          var format = [];
          format.push("" + date.getUTCFullYear());
          format.push("" + (date.getUTCMonth() + 1));
          format.push("" + date.getUTCDate());
          format.push("" + date.getUTCHours());
          format.push("" + date.getUTCMinutes());
          format.push("" + date.getUTCSeconds());
          for (var i = 0; i < format.length; ++i) {
            if (format[i].length < 2) {
              rval += "0";
            }
            rval += format[i];
          }
          rval += "Z";
          return rval;
        };
        asn1$1.integerToDer = function(x) {
          var rval = forge2.util.createBuffer();
          if (x >= -128 && x < 128) {
            return rval.putSignedInt(x, 8);
          }
          if (x >= -32768 && x < 32768) {
            return rval.putSignedInt(x, 16);
          }
          if (x >= -8388608 && x < 8388608) {
            return rval.putSignedInt(x, 24);
          }
          if (x >= -2147483648 && x < 2147483648) {
            return rval.putSignedInt(x, 32);
          }
          var error = new Error("Integer too large; max is 32-bits.");
          error.integer = x;
          throw error;
        };
        asn1$1.derToInteger = function(bytes) {
          if (typeof bytes === "string") {
            bytes = forge2.util.createBuffer(bytes);
          }
          var n = bytes.length() * 8;
          if (n > 32) {
            throw new Error("Integer too large; max is 32-bits.");
          }
          return bytes.getSignedInt(n);
        };
        asn1$1.validate = function(obj, v, capture, errors) {
          var rval = false;
          if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
            if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
              rval = true;
              if (v.value && forge2.util.isArray(v.value)) {
                var j = 0;
                for (var i = 0; rval && i < v.value.length; ++i) {
                  var schemaItem = v.value[i];
                  rval = !!schemaItem.optional;
                  var objChild = obj.value[j];
                  if (!objChild) {
                    if (!schemaItem.optional) {
                      rval = false;
                      if (errors) {
                        errors.push("[" + v.name + '] Missing required element. Expected tag class "' + schemaItem.tagClass + '", type "' + schemaItem.type + '"');
                      }
                    }
                    continue;
                  }
                  var schemaHasTag = typeof schemaItem.tagClass !== "undefined" && typeof schemaItem.type !== "undefined";
                  if (schemaHasTag && (objChild.tagClass !== schemaItem.tagClass || objChild.type !== schemaItem.type)) {
                    if (schemaItem.optional) {
                      rval = true;
                      continue;
                    } else {
                      rval = false;
                      if (errors) {
                        errors.push("[" + v.name + "] Tag mismatch. Expected (" + schemaItem.tagClass + "," + schemaItem.type + "), got (" + objChild.tagClass + "," + objChild.type + ")");
                      }
                      break;
                    }
                  }
                  var childRval = asn1$1.validate(objChild, schemaItem, capture, errors);
                  if (childRval) {
                    ++j;
                    rval = true;
                  } else if (schemaItem.optional) {
                    rval = true;
                  } else {
                    rval = false;
                    break;
                  }
                }
              }
              if (rval && capture) {
                if (v.capture) {
                  capture[v.capture] = obj.value;
                }
                if (v.captureAsn1) {
                  capture[v.captureAsn1] = obj;
                }
                if (v.captureBitStringContents && "bitStringContents" in obj) {
                  capture[v.captureBitStringContents] = obj.bitStringContents;
                }
                if (v.captureBitStringValue && "bitStringContents" in obj) {
                  if (obj.bitStringContents.length < 2) {
                    capture[v.captureBitStringValue] = "";
                  } else {
                    var unused = obj.bitStringContents.charCodeAt(0);
                    if (unused !== 0) {
                      throw new Error(
                        "captureBitStringValue only supported for zero unused bits"
                      );
                    }
                    capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
                  }
                }
              }
            } else if (errors) {
              errors.push(
                "[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"'
              );
            }
          } else if (errors) {
            if (obj.tagClass !== v.tagClass) {
              errors.push(
                "[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"'
              );
            }
            if (obj.type !== v.type) {
              errors.push(
                "[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"'
              );
            }
          }
          return rval;
        };
        var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
        asn1$1.prettyPrint = function(obj, level, indentation) {
          var rval = "";
          level = level || 0;
          indentation = indentation || 2;
          if (level > 0) {
            rval += "\n";
          }
          var indent = "";
          for (var i = 0; i < level * indentation; ++i) {
            indent += " ";
          }
          rval += indent + "Tag: ";
          switch (obj.tagClass) {
            case asn1$1.Class.UNIVERSAL:
              rval += "Universal:";
              break;
            case asn1$1.Class.APPLICATION:
              rval += "Application:";
              break;
            case asn1$1.Class.CONTEXT_SPECIFIC:
              rval += "Context-Specific:";
              break;
            case asn1$1.Class.PRIVATE:
              rval += "Private:";
              break;
          }
          if (obj.tagClass === asn1$1.Class.UNIVERSAL) {
            rval += obj.type;
            switch (obj.type) {
              case asn1$1.Type.NONE:
                rval += " (None)";
                break;
              case asn1$1.Type.BOOLEAN:
                rval += " (Boolean)";
                break;
              case asn1$1.Type.INTEGER:
                rval += " (Integer)";
                break;
              case asn1$1.Type.BITSTRING:
                rval += " (Bit string)";
                break;
              case asn1$1.Type.OCTETSTRING:
                rval += " (Octet string)";
                break;
              case asn1$1.Type.NULL:
                rval += " (Null)";
                break;
              case asn1$1.Type.OID:
                rval += " (Object Identifier)";
                break;
              case asn1$1.Type.ODESC:
                rval += " (Object Descriptor)";
                break;
              case asn1$1.Type.EXTERNAL:
                rval += " (External or Instance of)";
                break;
              case asn1$1.Type.REAL:
                rval += " (Real)";
                break;
              case asn1$1.Type.ENUMERATED:
                rval += " (Enumerated)";
                break;
              case asn1$1.Type.EMBEDDED:
                rval += " (Embedded PDV)";
                break;
              case asn1$1.Type.UTF8:
                rval += " (UTF8)";
                break;
              case asn1$1.Type.ROID:
                rval += " (Relative Object Identifier)";
                break;
              case asn1$1.Type.SEQUENCE:
                rval += " (Sequence)";
                break;
              case asn1$1.Type.SET:
                rval += " (Set)";
                break;
              case asn1$1.Type.PRINTABLESTRING:
                rval += " (Printable String)";
                break;
              case asn1$1.Type.IA5String:
                rval += " (IA5String (ASCII))";
                break;
              case asn1$1.Type.UTCTIME:
                rval += " (UTC time)";
                break;
              case asn1$1.Type.GENERALIZEDTIME:
                rval += " (Generalized time)";
                break;
              case asn1$1.Type.BMPSTRING:
                rval += " (BMP String)";
                break;
            }
          } else {
            rval += obj.type;
          }
          rval += "\n";
          rval += indent + "Constructed: " + obj.constructed + "\n";
          if (obj.composed) {
            var subvalues = 0;
            var sub = "";
            for (var i = 0; i < obj.value.length; ++i) {
              if (obj.value[i] !== void 0) {
                subvalues += 1;
                sub += asn1$1.prettyPrint(obj.value[i], level + 1, indentation);
                if (i + 1 < obj.value.length) {
                  sub += ",";
                }
              }
            }
            rval += indent + "Sub values: " + subvalues + sub;
          } else {
            rval += indent + "Value: ";
            if (obj.type === asn1$1.Type.OID) {
              var oid = asn1$1.derToOid(obj.value);
              rval += oid;
              if (forge2.pki && forge2.pki.oids) {
                if (oid in forge2.pki.oids) {
                  rval += " (" + forge2.pki.oids[oid] + ") ";
                }
              }
            }
            if (obj.type === asn1$1.Type.INTEGER) {
              try {
                rval += asn1$1.derToInteger(obj.value);
              } catch (ex) {
                rval += "0x" + forge2.util.bytesToHex(obj.value);
              }
            } else if (obj.type === asn1$1.Type.BITSTRING) {
              if (obj.value.length > 1) {
                rval += "0x" + forge2.util.bytesToHex(obj.value.slice(1));
              } else {
                rval += "(none)";
              }
              if (obj.value.length > 0) {
                var unused = obj.value.charCodeAt(0);
                if (unused == 1) {
                  rval += " (1 unused bit shown)";
                } else if (unused > 1) {
                  rval += " (" + unused + " unused bits shown)";
                }
              }
            } else if (obj.type === asn1$1.Type.OCTETSTRING) {
              if (!_nonLatinRegex.test(obj.value)) {
                rval += "(" + obj.value + ") ";
              }
              rval += "0x" + forge2.util.bytesToHex(obj.value);
            } else if (obj.type === asn1$1.Type.UTF8) {
              try {
                rval += forge2.util.decodeUtf8(obj.value);
              } catch (e) {
                if (e.message === "URI malformed") {
                  rval += "0x" + forge2.util.bytesToHex(obj.value) + " (malformed UTF8)";
                } else {
                  throw e;
                }
              }
            } else if (obj.type === asn1$1.Type.PRINTABLESTRING || obj.type === asn1$1.Type.IA5String) {
              rval += obj.value;
            } else if (_nonLatinRegex.test(obj.value)) {
              rval += "0x" + forge2.util.bytesToHex(obj.value);
            } else if (obj.value.length === 0) {
              rval += "[null]";
            } else {
              rval += obj.value;
            }
          }
          return rval;
        };
        return asn1.exports;
      }
      var hmac = { exports: {} };
      var md;
      var hasRequiredMd;
      function requireMd() {
        if (hasRequiredMd) return md;
        hasRequiredMd = 1;
        var forge2 = requireForge();
        md = forge2.md = forge2.md || {};
        forge2.md.algorithms = forge2.md.algorithms || {};
        return md;
      }
      var hasRequiredHmac;
      function requireHmac() {
        if (hasRequiredHmac) return hmac.exports;
        hasRequiredHmac = 1;
        var forge2 = requireForge();
        requireMd();
        requireUtil();
        var hmac$1 = hmac.exports = forge2.hmac = forge2.hmac || {};
        hmac$1.create = function() {
          var _key = null;
          var _md = null;
          var _ipadding = null;
          var _opadding = null;
          var ctx = {};
          ctx.start = function(md2, key) {
            if (md2 !== null) {
              if (typeof md2 === "string") {
                md2 = md2.toLowerCase();
                if (md2 in forge2.md.algorithms) {
                  _md = forge2.md.algorithms[md2].create();
                } else {
                  throw new Error('Unknown hash algorithm "' + md2 + '"');
                }
              } else {
                _md = md2;
              }
            }
            if (key === null) {
              key = _key;
            } else {
              if (typeof key === "string") {
                key = forge2.util.createBuffer(key);
              } else if (forge2.util.isArray(key)) {
                var tmp = key;
                key = forge2.util.createBuffer();
                for (var i = 0; i < tmp.length; ++i) {
                  key.putByte(tmp[i]);
                }
              }
              var keylen = key.length();
              if (keylen > _md.blockLength) {
                _md.start();
                _md.update(key.bytes());
                key = _md.digest();
              }
              _ipadding = forge2.util.createBuffer();
              _opadding = forge2.util.createBuffer();
              keylen = key.length();
              for (var i = 0; i < keylen; ++i) {
                var tmp = key.at(i);
                _ipadding.putByte(54 ^ tmp);
                _opadding.putByte(92 ^ tmp);
              }
              if (keylen < _md.blockLength) {
                var tmp = _md.blockLength - keylen;
                for (var i = 0; i < tmp; ++i) {
                  _ipadding.putByte(54);
                  _opadding.putByte(92);
                }
              }
              _key = key;
              _ipadding = _ipadding.bytes();
              _opadding = _opadding.bytes();
            }
            _md.start();
            _md.update(_ipadding);
          };
          ctx.update = function(bytes) {
            _md.update(bytes);
          };
          ctx.getMac = function() {
            var inner = _md.digest().bytes();
            _md.start();
            _md.update(_opadding);
            _md.update(inner);
            return _md.digest();
          };
          ctx.digest = ctx.getMac;
          return ctx;
        };
        return hmac.exports;
      }
      var md5 = { exports: {} };
      var hasRequiredMd5;
      function requireMd5() {
        if (hasRequiredMd5) return md5.exports;
        hasRequiredMd5 = 1;
        var forge2 = requireForge();
        requireMd();
        requireUtil();
        var md5$12 = md5.exports = forge2.md5 = forge2.md5 || {};
        forge2.md.md5 = forge2.md.algorithms.md5 = md5$12;
        md5$12.create = function() {
          if (!_initialized) {
            _init();
          }
          var _state = null;
          var _input = forge2.util.createBuffer();
          var _w = new Array(16);
          var md2 = {
            algorithm: "md5",
            blockLength: 64,
            digestLength: 16,
            // 56-bit length of message so far (does not including padding)
            messageLength: 0,
            // true message length
            fullMessageLength: null,
            // size of message length in bytes
            messageLengthSize: 8
          };
          md2.start = function() {
            md2.messageLength = 0;
            md2.fullMessageLength = md2.messageLength64 = [];
            var int32s = md2.messageLengthSize / 4;
            for (var i = 0; i < int32s; ++i) {
              md2.fullMessageLength.push(0);
            }
            _input = forge2.util.createBuffer();
            _state = {
              h0: 1732584193,
              h1: 4023233417,
              h2: 2562383102,
              h3: 271733878
            };
            return md2;
          };
          md2.start();
          md2.update = function(msg, encoding) {
            if (encoding === "utf8") {
              msg = forge2.util.encodeUtf8(msg);
            }
            var len = msg.length;
            md2.messageLength += len;
            len = [len / 4294967296 >>> 0, len >>> 0];
            for (var i = md2.fullMessageLength.length - 1; i >= 0; --i) {
              md2.fullMessageLength[i] += len[1];
              len[1] = len[0] + (md2.fullMessageLength[i] / 4294967296 >>> 0);
              md2.fullMessageLength[i] = md2.fullMessageLength[i] >>> 0;
              len[0] = len[1] / 4294967296 >>> 0;
            }
            _input.putBytes(msg);
            _update(_state, _w, _input);
            if (_input.read > 2048 || _input.length() === 0) {
              _input.compact();
            }
            return md2;
          };
          md2.digest = function() {
            var finalBlock = forge2.util.createBuffer();
            finalBlock.putBytes(_input.bytes());
            var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
            var overflow = remaining & md2.blockLength - 1;
            finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
            var bits2, carry = 0;
            for (var i = md2.fullMessageLength.length - 1; i >= 0; --i) {
              bits2 = md2.fullMessageLength[i] * 8 + carry;
              carry = bits2 / 4294967296 >>> 0;
              finalBlock.putInt32Le(bits2 >>> 0);
            }
            var s2 = {
              h0: _state.h0,
              h1: _state.h1,
              h2: _state.h2,
              h3: _state.h3
            };
            _update(s2, _w, finalBlock);
            var rval = forge2.util.createBuffer();
            rval.putInt32Le(s2.h0);
            rval.putInt32Le(s2.h1);
            rval.putInt32Le(s2.h2);
            rval.putInt32Le(s2.h3);
            return rval;
          };
          return md2;
        };
        var _padding = null;
        var _g = null;
        var _r = null;
        var _k = null;
        var _initialized = false;
        function _init() {
          _padding = String.fromCharCode(128);
          _padding += forge2.util.fillString(String.fromCharCode(0), 64);
          _g = [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            1,
            6,
            11,
            0,
            5,
            10,
            15,
            4,
            9,
            14,
            3,
            8,
            13,
            2,
            7,
            12,
            5,
            8,
            11,
            14,
            1,
            4,
            7,
            10,
            13,
            0,
            3,
            6,
            9,
            12,
            15,
            2,
            0,
            7,
            14,
            5,
            12,
            3,
            10,
            1,
            8,
            15,
            6,
            13,
            4,
            11,
            2,
            9
          ];
          _r = [
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21
          ];
          _k = new Array(64);
          for (var i = 0; i < 64; ++i) {
            _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 4294967296);
          }
          _initialized = true;
        }
        function _update(s, w, bytes) {
          var t, a, b, c, d, f, r, i;
          var len = bytes.length();
          while (len >= 64) {
            a = s.h0;
            b = s.h1;
            c = s.h2;
            d = s.h3;
            for (i = 0; i < 16; ++i) {
              w[i] = bytes.getInt32Le();
              f = d ^ b & (c ^ d);
              t = a + f + _k[i] + w[i];
              r = _r[i];
              a = d;
              d = c;
              c = b;
              b += t << r | t >>> 32 - r;
            }
            for (; i < 32; ++i) {
              f = c ^ d & (b ^ c);
              t = a + f + _k[i] + w[_g[i]];
              r = _r[i];
              a = d;
              d = c;
              c = b;
              b += t << r | t >>> 32 - r;
            }
            for (; i < 48; ++i) {
              f = b ^ c ^ d;
              t = a + f + _k[i] + w[_g[i]];
              r = _r[i];
              a = d;
              d = c;
              c = b;
              b += t << r | t >>> 32 - r;
            }
            for (; i < 64; ++i) {
              f = c ^ (b | ~d);
              t = a + f + _k[i] + w[_g[i]];
              r = _r[i];
              a = d;
              d = c;
              c = b;
              b += t << r | t >>> 32 - r;
            }
            s.h0 = s.h0 + a | 0;
            s.h1 = s.h1 + b | 0;
            s.h2 = s.h2 + c | 0;
            s.h3 = s.h3 + d | 0;
            len -= 64;
          }
        }
        return md5.exports;
      }
      var pem = { exports: {} };
      var hasRequiredPem;
      function requirePem() {
        if (hasRequiredPem) return pem.exports;
        hasRequiredPem = 1;
        var forge2 = requireForge();
        requireUtil();
        var pem$1 = pem.exports = forge2.pem = forge2.pem || {};
        pem$1.encode = function(msg, options) {
          options = options || {};
          var rval = "-----BEGIN " + msg.type + "-----\r\n";
          var header;
          if (msg.procType) {
            header = {
              name: "Proc-Type",
              values: [String(msg.procType.version), msg.procType.type]
            };
            rval += foldHeader(header);
          }
          if (msg.contentDomain) {
            header = { name: "Content-Domain", values: [msg.contentDomain] };
            rval += foldHeader(header);
          }
          if (msg.dekInfo) {
            header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
            if (msg.dekInfo.parameters) {
              header.values.push(msg.dekInfo.parameters);
            }
            rval += foldHeader(header);
          }
          if (msg.headers) {
            for (var i = 0; i < msg.headers.length; ++i) {
              rval += foldHeader(msg.headers[i]);
            }
          }
          if (msg.procType) {
            rval += "\r\n";
          }
          rval += forge2.util.encode64(msg.body, options.maxline || 64) + "\r\n";
          rval += "-----END " + msg.type + "-----\r\n";
          return rval;
        };
        pem$1.decode = function(str) {
          var rval = [];
          var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
          var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
          var rCRLF = /\r?\n/;
          var match;
          while (true) {
            match = rMessage.exec(str);
            if (!match) {
              break;
            }
            var type = match[1];
            if (type === "NEW CERTIFICATE REQUEST") {
              type = "CERTIFICATE REQUEST";
            }
            var msg = {
              type,
              procType: null,
              contentDomain: null,
              dekInfo: null,
              headers: [],
              body: forge2.util.decode64(match[3])
            };
            rval.push(msg);
            if (!match[2]) {
              continue;
            }
            var lines = match[2].split(rCRLF);
            var li = 0;
            while (match && li < lines.length) {
              var line = lines[li].replace(/\s+$/, "");
              for (var nl = li + 1; nl < lines.length; ++nl) {
                var next = lines[nl];
                if (!/\s/.test(next[0])) {
                  break;
                }
                line += next;
                li = nl;
              }
              match = line.match(rHeader);
              if (match) {
                var header = { name: match[1], values: [] };
                var values = match[2].split(",");
                for (var vi = 0; vi < values.length; ++vi) {
                  header.values.push(ltrim(values[vi]));
                }
                if (!msg.procType) {
                  if (header.name !== "Proc-Type") {
                    throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
                  } else if (header.values.length !== 2) {
                    throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
                  }
                  msg.procType = { version: values[0], type: values[1] };
                } else if (!msg.contentDomain && header.name === "Content-Domain") {
                  msg.contentDomain = values[0] || "";
                } else if (!msg.dekInfo && header.name === "DEK-Info") {
                  if (header.values.length === 0) {
                    throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
                  }
                  msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
                } else {
                  msg.headers.push(header);
                }
              }
              ++li;
            }
            if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
              throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
            }
          }
          if (rval.length === 0) {
            throw new Error("Invalid PEM formatted message.");
          }
          return rval;
        };
        function foldHeader(header) {
          var rval = header.name + ": ";
          var values = [];
          var insertSpace = function(match, $1) {
            return " " + $1;
          };
          for (var i = 0; i < header.values.length; ++i) {
            values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
          }
          rval += values.join(",") + "\r\n";
          var length = 0;
          var candidate = -1;
          for (var i = 0; i < rval.length; ++i, ++length) {
            if (length > 65 && candidate !== -1) {
              var insert = rval[candidate];
              if (insert === ",") {
                ++candidate;
                rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
              } else {
                rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
              }
              length = i - candidate - 1;
              candidate = -1;
              ++i;
            } else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") {
              candidate = i;
            }
          }
          return rval;
        }
        function ltrim(str) {
          return str.replace(/^\s+/, "");
        }
        return pem.exports;
      }
      var pki = { exports: {} };
      var des;
      var hasRequiredDes;
      function requireDes() {
        if (hasRequiredDes) return des;
        hasRequiredDes = 1;
        var forge2 = requireForge();
        requireCipher();
        requireCipherModes();
        requireUtil();
        des = forge2.des = forge2.des || {};
        forge2.des.startEncrypting = function(key, iv, output, mode) {
          var cipher2 = _createCipher({
            key,
            output,
            decrypt: false,
            mode: mode || (iv === null ? "ECB" : "CBC")
          });
          cipher2.start(iv);
          return cipher2;
        };
        forge2.des.createEncryptionCipher = function(key, mode) {
          return _createCipher({
            key,
            output: null,
            decrypt: false,
            mode
          });
        };
        forge2.des.startDecrypting = function(key, iv, output, mode) {
          var cipher2 = _createCipher({
            key,
            output,
            decrypt: true,
            mode: mode || (iv === null ? "ECB" : "CBC")
          });
          cipher2.start(iv);
          return cipher2;
        };
        forge2.des.createDecryptionCipher = function(key, mode) {
          return _createCipher({
            key,
            output: null,
            decrypt: true,
            mode
          });
        };
        forge2.des.Algorithm = function(name2, mode) {
          var self2 = this;
          self2.name = name2;
          self2.mode = new mode({
            blockSize: 8,
            cipher: {
              encrypt: function(inBlock, outBlock) {
                return _updateBlock(self2._keys, inBlock, outBlock, false);
              },
              decrypt: function(inBlock, outBlock) {
                return _updateBlock(self2._keys, inBlock, outBlock, true);
              }
            }
          });
          self2._init = false;
        };
        forge2.des.Algorithm.prototype.initialize = function(options) {
          if (this._init) {
            return;
          }
          var key = forge2.util.createBuffer(options.key);
          if (this.name.indexOf("3DES") === 0) {
            if (key.length() !== 24) {
              throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
            }
          }
          this._keys = _createKeys(key);
          this._init = true;
        };
        registerAlgorithm("DES-ECB", forge2.cipher.modes.ecb);
        registerAlgorithm("DES-CBC", forge2.cipher.modes.cbc);
        registerAlgorithm("DES-CFB", forge2.cipher.modes.cfb);
        registerAlgorithm("DES-OFB", forge2.cipher.modes.ofb);
        registerAlgorithm("DES-CTR", forge2.cipher.modes.ctr);
        registerAlgorithm("3DES-ECB", forge2.cipher.modes.ecb);
        registerAlgorithm("3DES-CBC", forge2.cipher.modes.cbc);
        registerAlgorithm("3DES-CFB", forge2.cipher.modes.cfb);
        registerAlgorithm("3DES-OFB", forge2.cipher.modes.ofb);
        registerAlgorithm("3DES-CTR", forge2.cipher.modes.ctr);
        function registerAlgorithm(name2, mode) {
          var factory = function() {
            return new forge2.des.Algorithm(name2, mode);
          };
          forge2.cipher.registerAlgorithm(name2, factory);
        }
        var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
        var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
        var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
        var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
        var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
        var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
        var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
        var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
        function _createKeys(key) {
          var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
          var iterations = key.length() > 8 ? 3 : 1;
          var keys = [];
          var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
          var n = 0, tmp;
          for (var j = 0; j < iterations; j++) {
            var left = key.getInt32();
            var right = key.getInt32();
            tmp = (left >>> 4 ^ right) & 252645135;
            right ^= tmp;
            left ^= tmp << 4;
            tmp = (right >>> -16 ^ left) & 65535;
            left ^= tmp;
            right ^= tmp << -16;
            tmp = (left >>> 2 ^ right) & 858993459;
            right ^= tmp;
            left ^= tmp << 2;
            tmp = (right >>> -16 ^ left) & 65535;
            left ^= tmp;
            right ^= tmp << -16;
            tmp = (left >>> 1 ^ right) & 1431655765;
            right ^= tmp;
            left ^= tmp << 1;
            tmp = (right >>> 8 ^ left) & 16711935;
            left ^= tmp;
            right ^= tmp << 8;
            tmp = (left >>> 1 ^ right) & 1431655765;
            right ^= tmp;
            left ^= tmp << 1;
            tmp = left << 8 | right >>> 20 & 240;
            left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
            right = tmp;
            for (var i = 0; i < shifts.length; ++i) {
              if (shifts[i]) {
                left = left << 2 | left >>> 26;
                right = right << 2 | right >>> 26;
              } else {
                left = left << 1 | left >>> 27;
                right = right << 1 | right >>> 27;
              }
              left &= -15;
              right &= -15;
              var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
              var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
              tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
              keys[n++] = lefttmp ^ tmp;
              keys[n++] = righttmp ^ tmp << 16;
            }
          }
          return keys;
        }
        function _updateBlock(keys, input, output, decrypt) {
          var iterations = keys.length === 32 ? 3 : 9;
          var looping;
          if (iterations === 3) {
            looping = decrypt ? [30, -2, -2] : [0, 32, 2];
          } else {
            looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
          }
          var tmp;
          var left = input[0];
          var right = input[1];
          tmp = (left >>> 4 ^ right) & 252645135;
          right ^= tmp;
          left ^= tmp << 4;
          tmp = (left >>> 16 ^ right) & 65535;
          right ^= tmp;
          left ^= tmp << 16;
          tmp = (right >>> 2 ^ left) & 858993459;
          left ^= tmp;
          right ^= tmp << 2;
          tmp = (right >>> 8 ^ left) & 16711935;
          left ^= tmp;
          right ^= tmp << 8;
          tmp = (left >>> 1 ^ right) & 1431655765;
          right ^= tmp;
          left ^= tmp << 1;
          left = left << 1 | left >>> 31;
          right = right << 1 | right >>> 31;
          for (var j = 0; j < iterations; j += 3) {
            var endloop = looping[j + 1];
            var loopinc = looping[j + 2];
            for (var i = looping[j]; i != endloop; i += loopinc) {
              var right1 = right ^ keys[i];
              var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];
              tmp = left;
              left = right;
              right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
            }
            tmp = left;
            left = right;
            right = tmp;
          }
          left = left >>> 1 | left << 31;
          right = right >>> 1 | right << 31;
          tmp = (left >>> 1 ^ right) & 1431655765;
          right ^= tmp;
          left ^= tmp << 1;
          tmp = (right >>> 8 ^ left) & 16711935;
          left ^= tmp;
          right ^= tmp << 8;
          tmp = (right >>> 2 ^ left) & 858993459;
          left ^= tmp;
          right ^= tmp << 2;
          tmp = (left >>> 16 ^ right) & 65535;
          right ^= tmp;
          left ^= tmp << 16;
          tmp = (left >>> 4 ^ right) & 252645135;
          right ^= tmp;
          left ^= tmp << 4;
          output[0] = left;
          output[1] = right;
        }
        function _createCipher(options) {
          options = options || {};
          var mode = (options.mode || "CBC").toUpperCase();
          var algorithm = "DES-" + mode;
          var cipher2;
          if (options.decrypt) {
            cipher2 = forge2.cipher.createDecipher(algorithm, options.key);
          } else {
            cipher2 = forge2.cipher.createCipher(algorithm, options.key);
          }
          var start = cipher2.start;
          cipher2.start = function(iv, options2) {
            var output = null;
            if (options2 instanceof forge2.util.ByteBuffer) {
              output = options2;
              options2 = {};
            }
            options2 = options2 || {};
            options2.output = output;
            options2.iv = iv;
            start.call(cipher2, options2);
          };
          return cipher2;
        }
        return des;
      }
      const __viteBrowserExternal = {};
      const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        default: __viteBrowserExternal
      }, Symbol.toStringTag, { value: "Module" }));
      const require$$8 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
      var pbkdf2;
      var hasRequiredPbkdf2;
      function requirePbkdf2() {
        if (hasRequiredPbkdf2) return pbkdf2;
        hasRequiredPbkdf2 = 1;
        var forge2 = requireForge();
        requireHmac();
        requireMd();
        requireUtil();
        var pkcs5 = forge2.pkcs5 = forge2.pkcs5 || {};
        var crypto2;
        if (forge2.util.isNodejs && !forge2.options.usePureJavaScript) {
          crypto2 = require$$8;
        }
        pbkdf2 = forge2.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md2, callback) {
          if (typeof md2 === "function") {
            callback = md2;
            md2 = null;
          }
          if (forge2.util.isNodejs && !forge2.options.usePureJavaScript && crypto2.pbkdf2 && (md2 === null || typeof md2 !== "object") && (crypto2.pbkdf2Sync.length > 4 || (!md2 || md2 === "sha1"))) {
            if (typeof md2 !== "string") {
              md2 = "sha1";
            }
            p = Buffer.from(p, "binary");
            s = Buffer.from(s, "binary");
            if (!callback) {
              if (crypto2.pbkdf2Sync.length === 4) {
                return crypto2.pbkdf2Sync(p, s, c, dkLen).toString("binary");
              }
              return crypto2.pbkdf2Sync(p, s, c, dkLen, md2).toString("binary");
            }
            if (crypto2.pbkdf2Sync.length === 4) {
              return crypto2.pbkdf2(p, s, c, dkLen, function(err3, key) {
                if (err3) {
                  return callback(err3);
                }
                callback(null, key.toString("binary"));
              });
            }
            return crypto2.pbkdf2(p, s, c, dkLen, md2, function(err3, key) {
              if (err3) {
                return callback(err3);
              }
              callback(null, key.toString("binary"));
            });
          }
          if (typeof md2 === "undefined" || md2 === null) {
            md2 = "sha1";
          }
          if (typeof md2 === "string") {
            if (!(md2 in forge2.md.algorithms)) {
              throw new Error("Unknown hash algorithm: " + md2);
            }
            md2 = forge2.md[md2].create();
          }
          var hLen = md2.digestLength;
          if (dkLen > 4294967295 * hLen) {
            var err2 = new Error("Derived key is too long.");
            if (callback) {
              return callback(err2);
            }
            throw err2;
          }
          var len = Math.ceil(dkLen / hLen);
          var r = dkLen - (len - 1) * hLen;
          var prf = forge2.hmac.create();
          prf.start(md2, p);
          var dk = "";
          var xor, u_c, u_c1;
          if (!callback) {
            for (var i = 1; i <= len; ++i) {
              prf.start(null, null);
              prf.update(s);
              prf.update(forge2.util.int32ToBytes(i));
              xor = u_c1 = prf.digest().getBytes();
              for (var j = 2; j <= c; ++j) {
                prf.start(null, null);
                prf.update(u_c1);
                u_c = prf.digest().getBytes();
                xor = forge2.util.xorBytes(xor, u_c, hLen);
                u_c1 = u_c;
              }
              dk += i < len ? xor : xor.substr(0, r);
            }
            return dk;
          }
          var i = 1, j;
          function outer() {
            if (i > len) {
              return callback(null, dk);
            }
            prf.start(null, null);
            prf.update(s);
            prf.update(forge2.util.int32ToBytes(i));
            xor = u_c1 = prf.digest().getBytes();
            j = 2;
            inner();
          }
          function inner() {
            if (j <= c) {
              prf.start(null, null);
              prf.update(u_c1);
              u_c = prf.digest().getBytes();
              xor = forge2.util.xorBytes(xor, u_c, hLen);
              u_c1 = u_c;
              ++j;
              return forge2.util.setImmediate(inner);
            }
            dk += i < len ? xor : xor.substr(0, r);
            ++i;
            outer();
          }
          outer();
        };
        return pbkdf2;
      }
      var random = { exports: {} };
      var sha256 = { exports: {} };
      var hasRequiredSha256;
      function requireSha256() {
        if (hasRequiredSha256) return sha256.exports;
        hasRequiredSha256 = 1;
        var forge2 = requireForge();
        requireMd();
        requireUtil();
        var sha256$1 = sha256.exports = forge2.sha256 = forge2.sha256 || {};
        forge2.md.sha256 = forge2.md.algorithms.sha256 = sha256$1;
        sha256$1.create = function() {
          if (!_initialized) {
            _init();
          }
          var _state = null;
          var _input = forge2.util.createBuffer();
          var _w = new Array(64);
          var md2 = {
            algorithm: "sha256",
            blockLength: 64,
            digestLength: 32,
            // 56-bit length of message so far (does not including padding)
            messageLength: 0,
            // true message length
            fullMessageLength: null,
            // size of message length in bytes
            messageLengthSize: 8
          };
          md2.start = function() {
            md2.messageLength = 0;
            md2.fullMessageLength = md2.messageLength64 = [];
            var int32s = md2.messageLengthSize / 4;
            for (var i = 0; i < int32s; ++i) {
              md2.fullMessageLength.push(0);
            }
            _input = forge2.util.createBuffer();
            _state = {
              h0: 1779033703,
              h1: 3144134277,
              h2: 1013904242,
              h3: 2773480762,
              h4: 1359893119,
              h5: 2600822924,
              h6: 528734635,
              h7: 1541459225
            };
            return md2;
          };
          md2.start();
          md2.update = function(msg, encoding) {
            if (encoding === "utf8") {
              msg = forge2.util.encodeUtf8(msg);
            }
            var len = msg.length;
            md2.messageLength += len;
            len = [len / 4294967296 >>> 0, len >>> 0];
            for (var i = md2.fullMessageLength.length - 1; i >= 0; --i) {
              md2.fullMessageLength[i] += len[1];
              len[1] = len[0] + (md2.fullMessageLength[i] / 4294967296 >>> 0);
              md2.fullMessageLength[i] = md2.fullMessageLength[i] >>> 0;
              len[0] = len[1] / 4294967296 >>> 0;
            }
            _input.putBytes(msg);
            _update(_state, _w, _input);
            if (_input.read > 2048 || _input.length() === 0) {
              _input.compact();
            }
            return md2;
          };
          md2.digest = function() {
            var finalBlock = forge2.util.createBuffer();
            finalBlock.putBytes(_input.bytes());
            var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
            var overflow = remaining & md2.blockLength - 1;
            finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
            var next, carry;
            var bits2 = md2.fullMessageLength[0] * 8;
            for (var i = 0; i < md2.fullMessageLength.length - 1; ++i) {
              next = md2.fullMessageLength[i + 1] * 8;
              carry = next / 4294967296 >>> 0;
              bits2 += carry;
              finalBlock.putInt32(bits2 >>> 0);
              bits2 = next >>> 0;
            }
            finalBlock.putInt32(bits2);
            var s2 = {
              h0: _state.h0,
              h1: _state.h1,
              h2: _state.h2,
              h3: _state.h3,
              h4: _state.h4,
              h5: _state.h5,
              h6: _state.h6,
              h7: _state.h7
            };
            _update(s2, _w, finalBlock);
            var rval = forge2.util.createBuffer();
            rval.putInt32(s2.h0);
            rval.putInt32(s2.h1);
            rval.putInt32(s2.h2);
            rval.putInt32(s2.h3);
            rval.putInt32(s2.h4);
            rval.putInt32(s2.h5);
            rval.putInt32(s2.h6);
            rval.putInt32(s2.h7);
            return rval;
          };
          return md2;
        };
        var _padding = null;
        var _initialized = false;
        var _k = null;
        function _init() {
          _padding = String.fromCharCode(128);
          _padding += forge2.util.fillString(String.fromCharCode(0), 64);
          _k = [
            1116352408,
            1899447441,
            3049323471,
            3921009573,
            961987163,
            1508970993,
            2453635748,
            2870763221,
            3624381080,
            310598401,
            607225278,
            1426881987,
            1925078388,
            2162078206,
            2614888103,
            3248222580,
            3835390401,
            4022224774,
            264347078,
            604807628,
            770255983,
            1249150122,
            1555081692,
            1996064986,
            2554220882,
            2821834349,
            2952996808,
            3210313671,
            3336571891,
            3584528711,
            113926993,
            338241895,
            666307205,
            773529912,
            1294757372,
            1396182291,
            1695183700,
            1986661051,
            2177026350,
            2456956037,
            2730485921,
            2820302411,
            3259730800,
            3345764771,
            3516065817,
            3600352804,
            4094571909,
            275423344,
            430227734,
            506948616,
            659060556,
            883997877,
            958139571,
            1322822218,
            1537002063,
            1747873779,
            1955562222,
            2024104815,
            2227730452,
            2361852424,
            2428436474,
            2756734187,
            3204031479,
            3329325298
          ];
          _initialized = true;
        }
        function _update(s, w, bytes) {
          var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
          var len = bytes.length();
          while (len >= 64) {
            for (i = 0; i < 16; ++i) {
              w[i] = bytes.getInt32();
            }
            for (; i < 64; ++i) {
              t1 = w[i - 2];
              t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
              t2 = w[i - 15];
              t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
              w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
            }
            a = s.h0;
            b = s.h1;
            c = s.h2;
            d = s.h3;
            e = s.h4;
            f = s.h5;
            g = s.h6;
            h = s.h7;
            for (i = 0; i < 64; ++i) {
              s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
              ch = g ^ e & (f ^ g);
              s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
              maj = a & b | c & (a ^ b);
              t1 = h + s1 + ch + _k[i] + w[i];
              t2 = s0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 >>> 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 >>> 0;
            }
            s.h0 = s.h0 + a | 0;
            s.h1 = s.h1 + b | 0;
            s.h2 = s.h2 + c | 0;
            s.h3 = s.h3 + d | 0;
            s.h4 = s.h4 + e | 0;
            s.h5 = s.h5 + f | 0;
            s.h6 = s.h6 + g | 0;
            s.h7 = s.h7 + h | 0;
            len -= 64;
          }
        }
        return sha256.exports;
      }
      var prng = { exports: {} };
      var hasRequiredPrng;
      function requirePrng() {
        if (hasRequiredPrng) return prng.exports;
        hasRequiredPrng = 1;
        var forge2 = requireForge();
        requireUtil();
        var _crypto = null;
        if (forge2.util.isNodejs && !forge2.options.usePureJavaScript && !process.versions["node-webkit"]) {
          _crypto = require$$8;
        }
        var prng$1 = prng.exports = forge2.prng = forge2.prng || {};
        prng$1.create = function(plugin) {
          var ctx = {
            plugin,
            key: null,
            seed: null,
            time: null,
            // number of reseeds so far
            reseeds: 0,
            // amount of data generated so far
            generated: 0,
            // no initial key bytes
            keyBytes: ""
          };
          var md2 = plugin.md;
          var pools = new Array(32);
          for (var i = 0; i < 32; ++i) {
            pools[i] = md2.create();
          }
          ctx.pools = pools;
          ctx.pool = 0;
          ctx.generate = function(count, callback) {
            if (!callback) {
              return ctx.generateSync(count);
            }
            var cipher2 = ctx.plugin.cipher;
            var increment = ctx.plugin.increment;
            var formatKey = ctx.plugin.formatKey;
            var formatSeed = ctx.plugin.formatSeed;
            var b = forge2.util.createBuffer();
            ctx.key = null;
            generate();
            function generate(err2) {
              if (err2) {
                return callback(err2);
              }
              if (b.length() >= count) {
                return callback(null, b.getBytes(count));
              }
              if (ctx.generated > 1048575) {
                ctx.key = null;
              }
              if (ctx.key === null) {
                return forge2.util.nextTick(function() {
                  _reseed(generate);
                });
              }
              var bytes = cipher2(ctx.key, ctx.seed);
              ctx.generated += bytes.length;
              b.putBytes(bytes);
              ctx.key = formatKey(cipher2(ctx.key, increment(ctx.seed)));
              ctx.seed = formatSeed(cipher2(ctx.key, ctx.seed));
              forge2.util.setImmediate(generate);
            }
          };
          ctx.generateSync = function(count) {
            var cipher2 = ctx.plugin.cipher;
            var increment = ctx.plugin.increment;
            var formatKey = ctx.plugin.formatKey;
            var formatSeed = ctx.plugin.formatSeed;
            ctx.key = null;
            var b = forge2.util.createBuffer();
            while (b.length() < count) {
              if (ctx.generated > 1048575) {
                ctx.key = null;
              }
              if (ctx.key === null) {
                _reseedSync();
              }
              var bytes = cipher2(ctx.key, ctx.seed);
              ctx.generated += bytes.length;
              b.putBytes(bytes);
              ctx.key = formatKey(cipher2(ctx.key, increment(ctx.seed)));
              ctx.seed = formatSeed(cipher2(ctx.key, ctx.seed));
            }
            return b.getBytes(count);
          };
          function _reseed(callback) {
            if (ctx.pools[0].messageLength >= 32) {
              _seed();
              return callback();
            }
            var needed = 32 - ctx.pools[0].messageLength << 5;
            ctx.seedFile(needed, function(err2, bytes) {
              if (err2) {
                return callback(err2);
              }
              ctx.collect(bytes);
              _seed();
              callback();
            });
          }
          function _reseedSync() {
            if (ctx.pools[0].messageLength >= 32) {
              return _seed();
            }
            var needed = 32 - ctx.pools[0].messageLength << 5;
            ctx.collect(ctx.seedFileSync(needed));
            _seed();
          }
          function _seed() {
            ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
            var md3 = ctx.plugin.md.create();
            md3.update(ctx.keyBytes);
            var _2powK = 1;
            for (var k = 0; k < 32; ++k) {
              if (ctx.reseeds % _2powK === 0) {
                md3.update(ctx.pools[k].digest().getBytes());
                ctx.pools[k].start();
              }
              _2powK = _2powK << 1;
            }
            ctx.keyBytes = md3.digest().getBytes();
            md3.start();
            md3.update(ctx.keyBytes);
            var seedBytes = md3.digest().getBytes();
            ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
            ctx.seed = ctx.plugin.formatSeed(seedBytes);
            ctx.generated = 0;
          }
          function defaultSeedFile(needed) {
            var getRandomValues = null;
            var globalScope = forge2.util.globalScope;
            var _crypto2 = globalScope.crypto || globalScope.msCrypto;
            if (_crypto2 && _crypto2.getRandomValues) {
              getRandomValues = function(arr) {
                return _crypto2.getRandomValues(arr);
              };
            }
            var b = forge2.util.createBuffer();
            if (getRandomValues) {
              while (b.length() < needed) {
                var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
                var entropy = new Uint32Array(Math.floor(count));
                try {
                  getRandomValues(entropy);
                  for (var i2 = 0; i2 < entropy.length; ++i2) {
                    b.putInt32(entropy[i2]);
                  }
                } catch (e) {
                  if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
                    throw e;
                  }
                }
              }
            }
            if (b.length() < needed) {
              var hi, lo, next;
              var seed = Math.floor(Math.random() * 65536);
              while (b.length() < needed) {
                lo = 16807 * (seed & 65535);
                hi = 16807 * (seed >> 16);
                lo += (hi & 32767) << 16;
                lo += hi >> 15;
                lo = (lo & 2147483647) + (lo >> 31);
                seed = lo & 4294967295;
                for (var i2 = 0; i2 < 3; ++i2) {
                  next = seed >>> (i2 << 3);
                  next ^= Math.floor(Math.random() * 256);
                  b.putByte(next & 255);
                }
              }
            }
            return b.getBytes(needed);
          }
          if (_crypto) {
            ctx.seedFile = function(needed, callback) {
              _crypto.randomBytes(needed, function(err2, bytes) {
                if (err2) {
                  return callback(err2);
                }
                callback(null, bytes.toString());
              });
            };
            ctx.seedFileSync = function(needed) {
              return _crypto.randomBytes(needed).toString();
            };
          } else {
            ctx.seedFile = function(needed, callback) {
              try {
                callback(null, defaultSeedFile(needed));
              } catch (e) {
                callback(e);
              }
            };
            ctx.seedFileSync = defaultSeedFile;
          }
          ctx.collect = function(bytes) {
            var count = bytes.length;
            for (var i2 = 0; i2 < count; ++i2) {
              ctx.pools[ctx.pool].update(bytes.substr(i2, 1));
              ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
            }
          };
          ctx.collectInt = function(i2, n) {
            var bytes = "";
            for (var x = 0; x < n; x += 8) {
              bytes += String.fromCharCode(i2 >> x & 255);
            }
            ctx.collect(bytes);
          };
          ctx.registerWorker = function(worker) {
            if (worker === self) {
              ctx.seedFile = function(needed, callback) {
                function listener2(e) {
                  var data = e.data;
                  if (data.forge && data.forge.prng) {
                    self.removeEventListener("message", listener2);
                    callback(data.forge.prng.err, data.forge.prng.bytes);
                  }
                }
                self.addEventListener("message", listener2);
                self.postMessage({ forge: { prng: { needed } } });
              };
            } else {
              var listener = function(e) {
                var data = e.data;
                if (data.forge && data.forge.prng) {
                  ctx.seedFile(data.forge.prng.needed, function(err2, bytes) {
                    worker.postMessage({ forge: { prng: { err: err2, bytes } } });
                  });
                }
              };
              worker.addEventListener("message", listener);
            }
          };
          return ctx;
        };
        return prng.exports;
      }
      var hasRequiredRandom;
      function requireRandom() {
        if (hasRequiredRandom) return random.exports;
        hasRequiredRandom = 1;
        var forge2 = requireForge();
        requireAes();
        requireSha256();
        requirePrng();
        requireUtil();
        (function() {
          if (forge2.random && forge2.random.getBytes) {
            random.exports = forge2.random;
            return;
          }
          (function(jQuery2) {
            var prng_aes = {};
            var _prng_aes_output = new Array(4);
            var _prng_aes_buffer = forge2.util.createBuffer();
            prng_aes.formatKey = function(key2) {
              var tmp = forge2.util.createBuffer(key2);
              key2 = new Array(4);
              key2[0] = tmp.getInt32();
              key2[1] = tmp.getInt32();
              key2[2] = tmp.getInt32();
              key2[3] = tmp.getInt32();
              return forge2.aes._expandKey(key2, false);
            };
            prng_aes.formatSeed = function(seed) {
              var tmp = forge2.util.createBuffer(seed);
              seed = new Array(4);
              seed[0] = tmp.getInt32();
              seed[1] = tmp.getInt32();
              seed[2] = tmp.getInt32();
              seed[3] = tmp.getInt32();
              return seed;
            };
            prng_aes.cipher = function(key2, seed) {
              forge2.aes._updateBlock(key2, seed, _prng_aes_output, false);
              _prng_aes_buffer.putInt32(_prng_aes_output[0]);
              _prng_aes_buffer.putInt32(_prng_aes_output[1]);
              _prng_aes_buffer.putInt32(_prng_aes_output[2]);
              _prng_aes_buffer.putInt32(_prng_aes_output[3]);
              return _prng_aes_buffer.getBytes();
            };
            prng_aes.increment = function(seed) {
              ++seed[3];
              return seed;
            };
            prng_aes.md = forge2.md.sha256;
            function spawnPrng() {
              var ctx = forge2.prng.create(prng_aes);
              ctx.getBytes = function(count, callback) {
                return ctx.generate(count, callback);
              };
              ctx.getBytesSync = function(count) {
                return ctx.generate(count);
              };
              return ctx;
            }
            var _ctx = spawnPrng();
            var getRandomValues = null;
            var globalScope = forge2.util.globalScope;
            var _crypto = globalScope.crypto || globalScope.msCrypto;
            if (_crypto && _crypto.getRandomValues) {
              getRandomValues = function(arr) {
                return _crypto.getRandomValues(arr);
              };
            }
            if (forge2.options.usePureJavaScript || !forge2.util.isNodejs && !getRandomValues) {
              _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
              if (typeof navigator !== "undefined") {
                var _navBytes = "";
                for (var key in navigator) {
                  try {
                    if (typeof navigator[key] == "string") {
                      _navBytes += navigator[key];
                    }
                  } catch (e) {
                  }
                }
                _ctx.collect(_navBytes);
                _navBytes = null;
              }
              if (jQuery2) {
                jQuery2().mousemove(function(e) {
                  _ctx.collectInt(e.clientX, 16);
                  _ctx.collectInt(e.clientY, 16);
                });
                jQuery2().keypress(function(e) {
                  _ctx.collectInt(e.charCode, 8);
                });
              }
            }
            if (!forge2.random) {
              forge2.random = _ctx;
            } else {
              for (var key in _ctx) {
                forge2.random[key] = _ctx[key];
              }
            }
            forge2.random.createInstance = spawnPrng;
            random.exports = forge2.random;
          })(typeof jQuery !== "undefined" ? jQuery : null);
        })();
        return random.exports;
      }
      var rc2;
      var hasRequiredRc2;
      function requireRc2() {
        if (hasRequiredRc2) return rc2;
        hasRequiredRc2 = 1;
        var forge2 = requireForge();
        requireUtil();
        var piTable = [
          217,
          120,
          249,
          196,
          25,
          221,
          181,
          237,
          40,
          233,
          253,
          121,
          74,
          160,
          216,
          157,
          198,
          126,
          55,
          131,
          43,
          118,
          83,
          142,
          98,
          76,
          100,
          136,
          68,
          139,
          251,
          162,
          23,
          154,
          89,
          245,
          135,
          179,
          79,
          19,
          97,
          69,
          109,
          141,
          9,
          129,
          125,
          50,
          189,
          143,
          64,
          235,
          134,
          183,
          123,
          11,
          240,
          149,
          33,
          34,
          92,
          107,
          78,
          130,
          84,
          214,
          101,
          147,
          206,
          96,
          178,
          28,
          115,
          86,
          192,
          20,
          167,
          140,
          241,
          220,
          18,
          117,
          202,
          31,
          59,
          190,
          228,
          209,
          66,
          61,
          212,
          48,
          163,
          60,
          182,
          38,
          111,
          191,
          14,
          218,
          70,
          105,
          7,
          87,
          39,
          242,
          29,
          155,
          188,
          148,
          67,
          3,
          248,
          17,
          199,
          246,
          144,
          239,
          62,
          231,
          6,
          195,
          213,
          47,
          200,
          102,
          30,
          215,
          8,
          232,
          234,
          222,
          128,
          82,
          238,
          247,
          132,
          170,
          114,
          172,
          53,
          77,
          106,
          42,
          150,
          26,
          210,
          113,
          90,
          21,
          73,
          116,
          75,
          159,
          208,
          94,
          4,
          24,
          164,
          236,
          194,
          224,
          65,
          110,
          15,
          81,
          203,
          204,
          36,
          145,
          175,
          80,
          161,
          244,
          112,
          57,
          153,
          124,
          58,
          133,
          35,
          184,
          180,
          122,
          252,
          2,
          54,
          91,
          37,
          85,
          151,
          49,
          45,
          93,
          250,
          152,
          227,
          138,
          146,
          174,
          5,
          223,
          41,
          16,
          103,
          108,
          186,
          201,
          211,
          0,
          230,
          207,
          225,
          158,
          168,
          44,
          99,
          22,
          1,
          63,
          88,
          226,
          137,
          169,
          13,
          56,
          52,
          27,
          171,
          51,
          255,
          176,
          187,
          72,
          12,
          95,
          185,
          177,
          205,
          46,
          197,
          243,
          219,
          71,
          229,
          165,
          156,
          119,
          10,
          166,
          32,
          104,
          254,
          127,
          193,
          173
        ];
        var s = [1, 2, 3, 5];
        var rol = function(word, bits2) {
          return word << bits2 & 65535 | (word & 65535) >> 16 - bits2;
        };
        var ror = function(word, bits2) {
          return (word & 65535) >> bits2 | word << 16 - bits2 & 65535;
        };
        rc2 = forge2.rc2 = forge2.rc2 || {};
        forge2.rc2.expandKey = function(key, effKeyBits) {
          if (typeof key === "string") {
            key = forge2.util.createBuffer(key);
          }
          effKeyBits = effKeyBits || 128;
          var L = key;
          var T = key.length();
          var T1 = effKeyBits;
          var T8 = Math.ceil(T1 / 8);
          var TM = 255 >> (T1 & 7);
          var i;
          for (i = T; i < 128; i++) {
            L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
          }
          L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
          for (i = 127 - T8; i >= 0; i--) {
            L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
          }
          return L;
        };
        var createCipher = function(key, bits2, encrypt) {
          var _finish = false, _input = null, _output = null, _iv = null;
          var mixRound, mashRound;
          var i, j, K = [];
          key = forge2.rc2.expandKey(key, bits2);
          for (i = 0; i < 64; i++) {
            K.push(key.getInt16Le());
          }
          if (encrypt) {
            mixRound = function(R) {
              for (i = 0; i < 4; i++) {
                R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
                R[i] = rol(R[i], s[i]);
                j++;
              }
            };
            mashRound = function(R) {
              for (i = 0; i < 4; i++) {
                R[i] += K[R[(i + 3) % 4] & 63];
              }
            };
          } else {
            mixRound = function(R) {
              for (i = 3; i >= 0; i--) {
                R[i] = ror(R[i], s[i]);
                R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
                j--;
              }
            };
            mashRound = function(R) {
              for (i = 3; i >= 0; i--) {
                R[i] -= K[R[(i + 3) % 4] & 63];
              }
            };
          }
          var runPlan = function(plan) {
            var R = [];
            for (i = 0; i < 4; i++) {
              var val = _input.getInt16Le();
              if (_iv !== null) {
                if (encrypt) {
                  val ^= _iv.getInt16Le();
                } else {
                  _iv.putInt16Le(val);
                }
              }
              R.push(val & 65535);
            }
            j = encrypt ? 0 : 63;
            for (var ptr = 0; ptr < plan.length; ptr++) {
              for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
                plan[ptr][1](R);
              }
            }
            for (i = 0; i < 4; i++) {
              if (_iv !== null) {
                if (encrypt) {
                  _iv.putInt16Le(R[i]);
                } else {
                  R[i] ^= _iv.getInt16Le();
                }
              }
              _output.putInt16Le(R[i]);
            }
          };
          var cipher2 = null;
          cipher2 = {
            /**
             * Starts or restarts the encryption or decryption process, whichever
             * was previously configured.
             *
             * To use the cipher in CBC mode, iv may be given either as a string
             * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
             *
             * @param iv the initialization vector to use, null for ECB mode.
             * @param output the output the buffer to write to, null to create one.
             */
            start: function(iv, output) {
              if (iv) {
                if (typeof iv === "string") {
                  iv = forge2.util.createBuffer(iv);
                }
              }
              _finish = false;
              _input = forge2.util.createBuffer();
              _output = output || new forge2.util.createBuffer();
              _iv = iv;
              cipher2.output = _output;
            },
            /**
             * Updates the next block.
             *
             * @param input the buffer to read from.
             */
            update: function(input) {
              if (!_finish) {
                _input.putBuffer(input);
              }
              while (_input.length() >= 8) {
                runPlan([
                  [5, mixRound],
                  [1, mashRound],
                  [6, mixRound],
                  [1, mashRound],
                  [5, mixRound]
                ]);
              }
            },
            /**
             * Finishes encrypting or decrypting.
             *
             * @param pad a padding function to use, null for PKCS#7 padding,
             *           signature(blockSize, buffer, decrypt).
             *
             * @return true if successful, false on error.
             */
            finish: function(pad) {
              var rval = true;
              if (encrypt) {
                if (pad) {
                  rval = pad(8, _input, !encrypt);
                } else {
                  var padding = _input.length() === 8 ? 8 : 8 - _input.length();
                  _input.fillWithByte(padding, padding);
                }
              }
              if (rval) {
                _finish = true;
                cipher2.update();
              }
              if (!encrypt) {
                rval = _input.length() === 0;
                if (rval) {
                  if (pad) {
                    rval = pad(8, _output, !encrypt);
                  } else {
                    var len = _output.length();
                    var count = _output.at(len - 1);
                    if (count > len) {
                      rval = false;
                    } else {
                      _output.truncate(count);
                    }
                  }
                }
              }
              return rval;
            }
          };
          return cipher2;
        };
        forge2.rc2.startEncrypting = function(key, iv, output) {
          var cipher2 = forge2.rc2.createEncryptionCipher(key, 128);
          cipher2.start(iv, output);
          return cipher2;
        };
        forge2.rc2.createEncryptionCipher = function(key, bits2) {
          return createCipher(key, bits2, true);
        };
        forge2.rc2.startDecrypting = function(key, iv, output) {
          var cipher2 = forge2.rc2.createDecryptionCipher(key, 128);
          cipher2.start(iv, output);
          return cipher2;
        };
        forge2.rc2.createDecryptionCipher = function(key, bits2) {
          return createCipher(key, bits2, false);
        };
        return rc2;
      }
      var jsbn;
      var hasRequiredJsbn;
      function requireJsbn() {
        if (hasRequiredJsbn) return jsbn;
        hasRequiredJsbn = 1;
        var forge2 = requireForge();
        jsbn = forge2.jsbn = forge2.jsbn || {};
        var dbits;
        function BigInteger(a, b, c) {
          this.data = [];
          if (a != null)
            if ("number" == typeof a) this.fromNumber(a, b, c);
            else if (b == null && "string" != typeof a) this.fromString(a, 256);
            else this.fromString(a, b);
        }
        forge2.jsbn.BigInteger = BigInteger;
        function nbi() {
          return new BigInteger(null);
        }
        function am1(i, x, w, j, c, n) {
          while (--n >= 0) {
            var v = x * this.data[i++] + w.data[j] + c;
            c = Math.floor(v / 67108864);
            w.data[j++] = v & 67108863;
          }
          return c;
        }
        function am2(i, x, w, j, c, n) {
          var xl = x & 32767, xh = x >> 15;
          while (--n >= 0) {
            var l = this.data[i] & 32767;
            var h = this.data[i++] >> 15;
            var m = xh * l + h * xl;
            l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
            c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
            w.data[j++] = l & 1073741823;
          }
          return c;
        }
        function am3(i, x, w, j, c, n) {
          var xl = x & 16383, xh = x >> 14;
          while (--n >= 0) {
            var l = this.data[i] & 16383;
            var h = this.data[i++] >> 14;
            var m = xh * l + h * xl;
            l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
            c = (l >> 28) + (m >> 14) + xh * h;
            w.data[j++] = l & 268435455;
          }
          return c;
        }
        if (typeof navigator === "undefined") {
          BigInteger.prototype.am = am3;
          dbits = 28;
        } else if (navigator.appName == "Microsoft Internet Explorer") {
          BigInteger.prototype.am = am2;
          dbits = 30;
        } else if (navigator.appName != "Netscape") {
          BigInteger.prototype.am = am1;
          dbits = 26;
        } else {
          BigInteger.prototype.am = am3;
          dbits = 28;
        }
        BigInteger.prototype.DB = dbits;
        BigInteger.prototype.DM = (1 << dbits) - 1;
        BigInteger.prototype.DV = 1 << dbits;
        var BI_FP = 52;
        BigInteger.prototype.FV = Math.pow(2, BI_FP);
        BigInteger.prototype.F1 = BI_FP - dbits;
        BigInteger.prototype.F2 = 2 * dbits - BI_FP;
        var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
        var BI_RC = new Array();
        var rr, vv;
        rr = "0".charCodeAt(0);
        for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
        rr = "a".charCodeAt(0);
        for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
        rr = "A".charCodeAt(0);
        for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
        function int2char(n) {
          return BI_RM.charAt(n);
        }
        function intAt(s, i) {
          var c = BI_RC[s.charCodeAt(i)];
          return c == null ? -1 : c;
        }
        function bnpCopyTo(r) {
          for (var i = this.t - 1; i >= 0; --i) r.data[i] = this.data[i];
          r.t = this.t;
          r.s = this.s;
        }
        function bnpFromInt(x) {
          this.t = 1;
          this.s = x < 0 ? -1 : 0;
          if (x > 0) this.data[0] = x;
          else if (x < -1) this.data[0] = x + this.DV;
          else this.t = 0;
        }
        function nbv(i) {
          var r = nbi();
          r.fromInt(i);
          return r;
        }
        function bnpFromString(s, b) {
          var k;
          if (b == 16) k = 4;
          else if (b == 8) k = 3;
          else if (b == 256) k = 8;
          else if (b == 2) k = 1;
          else if (b == 32) k = 5;
          else if (b == 4) k = 2;
          else {
            this.fromRadix(s, b);
            return;
          }
          this.t = 0;
          this.s = 0;
          var i = s.length, mi = false, sh = 0;
          while (--i >= 0) {
            var x = k == 8 ? s[i] & 255 : intAt(s, i);
            if (x < 0) {
              if (s.charAt(i) == "-") mi = true;
              continue;
            }
            mi = false;
            if (sh == 0)
              this.data[this.t++] = x;
            else if (sh + k > this.DB) {
              this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
              this.data[this.t++] = x >> this.DB - sh;
            } else
              this.data[this.t - 1] |= x << sh;
            sh += k;
            if (sh >= this.DB) sh -= this.DB;
          }
          if (k == 8 && (s[0] & 128) != 0) {
            this.s = -1;
            if (sh > 0) this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
          }
          this.clamp();
          if (mi) BigInteger.ZERO.subTo(this, this);
        }
        function bnpClamp() {
          var c = this.s & this.DM;
          while (this.t > 0 && this.data[this.t - 1] == c) --this.t;
        }
        function bnToString(b) {
          if (this.s < 0) return "-" + this.negate().toString(b);
          var k;
          if (b == 16) k = 4;
          else if (b == 8) k = 3;
          else if (b == 2) k = 1;
          else if (b == 32) k = 5;
          else if (b == 4) k = 2;
          else return this.toRadix(b);
          var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
          var p = this.DB - i * this.DB % k;
          if (i-- > 0) {
            if (p < this.DB && (d = this.data[i] >> p) > 0) {
              m = true;
              r = int2char(d);
            }
            while (i >= 0) {
              if (p < k) {
                d = (this.data[i] & (1 << p) - 1) << k - p;
                d |= this.data[--i] >> (p += this.DB - k);
              } else {
                d = this.data[i] >> (p -= k) & km;
                if (p <= 0) {
                  p += this.DB;
                  --i;
                }
              }
              if (d > 0) m = true;
              if (m) r += int2char(d);
            }
          }
          return m ? r : "0";
        }
        function bnNegate() {
          var r = nbi();
          BigInteger.ZERO.subTo(this, r);
          return r;
        }
        function bnAbs() {
          return this.s < 0 ? this.negate() : this;
        }
        function bnCompareTo(a) {
          var r = this.s - a.s;
          if (r != 0) return r;
          var i = this.t;
          r = i - a.t;
          if (r != 0) return this.s < 0 ? -r : r;
          while (--i >= 0) if ((r = this.data[i] - a.data[i]) != 0) return r;
          return 0;
        }
        function nbits(x) {
          var r = 1, t;
          if ((t = x >>> 16) != 0) {
            x = t;
            r += 16;
          }
          if ((t = x >> 8) != 0) {
            x = t;
            r += 8;
          }
          if ((t = x >> 4) != 0) {
            x = t;
            r += 4;
          }
          if ((t = x >> 2) != 0) {
            x = t;
            r += 2;
          }
          if ((t = x >> 1) != 0) {
            x = t;
            r += 1;
          }
          return r;
        }
        function bnBitLength() {
          if (this.t <= 0) return 0;
          return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
        }
        function bnpDLShiftTo(n, r) {
          var i;
          for (i = this.t - 1; i >= 0; --i) r.data[i + n] = this.data[i];
          for (i = n - 1; i >= 0; --i) r.data[i] = 0;
          r.t = this.t + n;
          r.s = this.s;
        }
        function bnpDRShiftTo(n, r) {
          for (var i = n; i < this.t; ++i) r.data[i - n] = this.data[i];
          r.t = Math.max(this.t - n, 0);
          r.s = this.s;
        }
        function bnpLShiftTo(n, r) {
          var bs = n % this.DB;
          var cbs = this.DB - bs;
          var bm = (1 << cbs) - 1;
          var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
          for (i = this.t - 1; i >= 0; --i) {
            r.data[i + ds + 1] = this.data[i] >> cbs | c;
            c = (this.data[i] & bm) << bs;
          }
          for (i = ds - 1; i >= 0; --i) r.data[i] = 0;
          r.data[ds] = c;
          r.t = this.t + ds + 1;
          r.s = this.s;
          r.clamp();
        }
        function bnpRShiftTo(n, r) {
          r.s = this.s;
          var ds = Math.floor(n / this.DB);
          if (ds >= this.t) {
            r.t = 0;
            return;
          }
          var bs = n % this.DB;
          var cbs = this.DB - bs;
          var bm = (1 << bs) - 1;
          r.data[0] = this.data[ds] >> bs;
          for (var i = ds + 1; i < this.t; ++i) {
            r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
            r.data[i - ds] = this.data[i] >> bs;
          }
          if (bs > 0) r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
          r.t = this.t - ds;
          r.clamp();
        }
        function bnpSubTo(a, r) {
          var i = 0, c = 0, m = Math.min(a.t, this.t);
          while (i < m) {
            c += this.data[i] - a.data[i];
            r.data[i++] = c & this.DM;
            c >>= this.DB;
          }
          if (a.t < this.t) {
            c -= a.s;
            while (i < this.t) {
              c += this.data[i];
              r.data[i++] = c & this.DM;
              c >>= this.DB;
            }
            c += this.s;
          } else {
            c += this.s;
            while (i < a.t) {
              c -= a.data[i];
              r.data[i++] = c & this.DM;
              c >>= this.DB;
            }
            c -= a.s;
          }
          r.s = c < 0 ? -1 : 0;
          if (c < -1) r.data[i++] = this.DV + c;
          else if (c > 0) r.data[i++] = c;
          r.t = i;
          r.clamp();
        }
        function bnpMultiplyTo(a, r) {
          var x = this.abs(), y = a.abs();
          var i = x.t;
          r.t = i + y.t;
          while (--i >= 0) r.data[i] = 0;
          for (i = 0; i < y.t; ++i) r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
          r.s = 0;
          r.clamp();
          if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
        }
        function bnpSquareTo(r) {
          var x = this.abs();
          var i = r.t = 2 * x.t;
          while (--i >= 0) r.data[i] = 0;
          for (i = 0; i < x.t - 1; ++i) {
            var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
            if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
              r.data[i + x.t] -= x.DV;
              r.data[i + x.t + 1] = 1;
            }
          }
          if (r.t > 0) r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
          r.s = 0;
          r.clamp();
        }
        function bnpDivRemTo(m, q, r) {
          var pm = m.abs();
          if (pm.t <= 0) return;
          var pt = this.abs();
          if (pt.t < pm.t) {
            if (q != null) q.fromInt(0);
            if (r != null) this.copyTo(r);
            return;
          }
          if (r == null) r = nbi();
          var y = nbi(), ts = this.s, ms2 = m.s;
          var nsh = this.DB - nbits(pm.data[pm.t - 1]);
          if (nsh > 0) {
            pm.lShiftTo(nsh, y);
            pt.lShiftTo(nsh, r);
          } else {
            pm.copyTo(y);
            pt.copyTo(r);
          }
          var ys = y.t;
          var y0 = y.data[ys - 1];
          if (y0 == 0) return;
          var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
          var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
          var i = r.t, j = i - ys, t = q == null ? nbi() : q;
          y.dlShiftTo(j, t);
          if (r.compareTo(t) >= 0) {
            r.data[r.t++] = 1;
            r.subTo(t, r);
          }
          BigInteger.ONE.dlShiftTo(ys, t);
          t.subTo(y, y);
          while (y.t < ys) y.data[y.t++] = 0;
          while (--j >= 0) {
            var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
            if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
              y.dlShiftTo(j, t);
              r.subTo(t, r);
              while (r.data[i] < --qd) r.subTo(t, r);
            }
          }
          if (q != null) {
            r.drShiftTo(ys, q);
            if (ts != ms2) BigInteger.ZERO.subTo(q, q);
          }
          r.t = ys;
          r.clamp();
          if (nsh > 0) r.rShiftTo(nsh, r);
          if (ts < 0) BigInteger.ZERO.subTo(r, r);
        }
        function bnMod(a) {
          var r = nbi();
          this.abs().divRemTo(a, null, r);
          if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
          return r;
        }
        function Classic(m) {
          this.m = m;
        }
        function cConvert(x) {
          if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
          else return x;
        }
        function cRevert(x) {
          return x;
        }
        function cReduce(x) {
          x.divRemTo(this.m, null, x);
        }
        function cMulTo(x, y, r) {
          x.multiplyTo(y, r);
          this.reduce(r);
        }
        function cSqrTo(x, r) {
          x.squareTo(r);
          this.reduce(r);
        }
        Classic.prototype.convert = cConvert;
        Classic.prototype.revert = cRevert;
        Classic.prototype.reduce = cReduce;
        Classic.prototype.mulTo = cMulTo;
        Classic.prototype.sqrTo = cSqrTo;
        function bnpInvDigit() {
          if (this.t < 1) return 0;
          var x = this.data[0];
          if ((x & 1) == 0) return 0;
          var y = x & 3;
          y = y * (2 - (x & 15) * y) & 15;
          y = y * (2 - (x & 255) * y) & 255;
          y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
          y = y * (2 - x * y % this.DV) % this.DV;
          return y > 0 ? this.DV - y : -y;
        }
        function Montgomery(m) {
          this.m = m;
          this.mp = m.invDigit();
          this.mpl = this.mp & 32767;
          this.mph = this.mp >> 15;
          this.um = (1 << m.DB - 15) - 1;
          this.mt2 = 2 * m.t;
        }
        function montConvert(x) {
          var r = nbi();
          x.abs().dlShiftTo(this.m.t, r);
          r.divRemTo(this.m, null, r);
          if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
          return r;
        }
        function montRevert(x) {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
        function montReduce(x) {
          while (x.t <= this.mt2)
            x.data[x.t++] = 0;
          for (var i = 0; i < this.m.t; ++i) {
            var j = x.data[i] & 32767;
            var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
            j = i + this.m.t;
            x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
            while (x.data[j] >= x.DV) {
              x.data[j] -= x.DV;
              x.data[++j]++;
            }
          }
          x.clamp();
          x.drShiftTo(this.m.t, x);
          if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
        }
        function montSqrTo(x, r) {
          x.squareTo(r);
          this.reduce(r);
        }
        function montMulTo(x, y, r) {
          x.multiplyTo(y, r);
          this.reduce(r);
        }
        Montgomery.prototype.convert = montConvert;
        Montgomery.prototype.revert = montRevert;
        Montgomery.prototype.reduce = montReduce;
        Montgomery.prototype.mulTo = montMulTo;
        Montgomery.prototype.sqrTo = montSqrTo;
        function bnpIsEven() {
          return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
        }
        function bnpExp(e, z) {
          if (e > 4294967295 || e < 1) return BigInteger.ONE;
          var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
          g.copyTo(r);
          while (--i >= 0) {
            z.sqrTo(r, r2);
            if ((e & 1 << i) > 0) z.mulTo(r2, g, r);
            else {
              var t = r;
              r = r2;
              r2 = t;
            }
          }
          return z.revert(r);
        }
        function bnModPowInt(e, m) {
          var z;
          if (e < 256 || m.isEven()) z = new Classic(m);
          else z = new Montgomery(m);
          return this.exp(e, z);
        }
        BigInteger.prototype.copyTo = bnpCopyTo;
        BigInteger.prototype.fromInt = bnpFromInt;
        BigInteger.prototype.fromString = bnpFromString;
        BigInteger.prototype.clamp = bnpClamp;
        BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
        BigInteger.prototype.drShiftTo = bnpDRShiftTo;
        BigInteger.prototype.lShiftTo = bnpLShiftTo;
        BigInteger.prototype.rShiftTo = bnpRShiftTo;
        BigInteger.prototype.subTo = bnpSubTo;
        BigInteger.prototype.multiplyTo = bnpMultiplyTo;
        BigInteger.prototype.squareTo = bnpSquareTo;
        BigInteger.prototype.divRemTo = bnpDivRemTo;
        BigInteger.prototype.invDigit = bnpInvDigit;
        BigInteger.prototype.isEven = bnpIsEven;
        BigInteger.prototype.exp = bnpExp;
        BigInteger.prototype.toString = bnToString;
        BigInteger.prototype.negate = bnNegate;
        BigInteger.prototype.abs = bnAbs;
        BigInteger.prototype.compareTo = bnCompareTo;
        BigInteger.prototype.bitLength = bnBitLength;
        BigInteger.prototype.mod = bnMod;
        BigInteger.prototype.modPowInt = bnModPowInt;
        BigInteger.ZERO = nbv(0);
        BigInteger.ONE = nbv(1);
        function bnClone() {
          var r = nbi();
          this.copyTo(r);
          return r;
        }
        function bnIntValue() {
          if (this.s < 0) {
            if (this.t == 1) return this.data[0] - this.DV;
            else if (this.t == 0) return -1;
          } else if (this.t == 1) return this.data[0];
          else if (this.t == 0) return 0;
          return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
        }
        function bnByteValue() {
          return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
        }
        function bnShortValue() {
          return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
        }
        function bnpChunkSize(r) {
          return Math.floor(Math.LN2 * this.DB / Math.log(r));
        }
        function bnSigNum() {
          if (this.s < 0) return -1;
          else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0;
          else return 1;
        }
        function bnpToRadix(b) {
          if (b == null) b = 10;
          if (this.signum() == 0 || b < 2 || b > 36) return "0";
          var cs = this.chunkSize(b);
          var a = Math.pow(b, cs);
          var d = nbv(a), y = nbi(), z = nbi(), r = "";
          this.divRemTo(d, y, z);
          while (y.signum() > 0) {
            r = (a + z.intValue()).toString(b).substr(1) + r;
            y.divRemTo(d, y, z);
          }
          return z.intValue().toString(b) + r;
        }
        function bnpFromRadix(s, b) {
          this.fromInt(0);
          if (b == null) b = 10;
          var cs = this.chunkSize(b);
          var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
          for (var i = 0; i < s.length; ++i) {
            var x = intAt(s, i);
            if (x < 0) {
              if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
              continue;
            }
            w = b * w + x;
            if (++j >= cs) {
              this.dMultiply(d);
              this.dAddOffset(w, 0);
              j = 0;
              w = 0;
            }
          }
          if (j > 0) {
            this.dMultiply(Math.pow(b, j));
            this.dAddOffset(w, 0);
          }
          if (mi) BigInteger.ZERO.subTo(this, this);
        }
        function bnpFromNumber(a, b, c) {
          if ("number" == typeof b) {
            if (a < 2) this.fromInt(1);
            else {
              this.fromNumber(a, c);
              if (!this.testBit(a - 1))
                this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
              if (this.isEven()) this.dAddOffset(1, 0);
              while (!this.isProbablePrime(b)) {
                this.dAddOffset(2, 0);
                if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
              }
            }
          } else {
            var x = new Array(), t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) x[0] &= (1 << t) - 1;
            else x[0] = 0;
            this.fromString(x, 256);
          }
        }
        function bnToByteArray() {
          var i = this.t, r = new Array();
          r[0] = this.s;
          var p = this.DB - i * this.DB % 8, d, k = 0;
          if (i-- > 0) {
            if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p)
              r[k++] = d | this.s << this.DB - p;
            while (i >= 0) {
              if (p < 8) {
                d = (this.data[i] & (1 << p) - 1) << 8 - p;
                d |= this.data[--i] >> (p += this.DB - 8);
              } else {
                d = this.data[i] >> (p -= 8) & 255;
                if (p <= 0) {
                  p += this.DB;
                  --i;
                }
              }
              if ((d & 128) != 0) d |= -256;
              if (k == 0 && (this.s & 128) != (d & 128)) ++k;
              if (k > 0 || d != this.s) r[k++] = d;
            }
          }
          return r;
        }
        function bnEquals(a) {
          return this.compareTo(a) == 0;
        }
        function bnMin(a) {
          return this.compareTo(a) < 0 ? this : a;
        }
        function bnMax(a) {
          return this.compareTo(a) > 0 ? this : a;
        }
        function bnpBitwiseTo(a, op, r) {
          var i, f, m = Math.min(a.t, this.t);
          for (i = 0; i < m; ++i) r.data[i] = op(this.data[i], a.data[i]);
          if (a.t < this.t) {
            f = a.s & this.DM;
            for (i = m; i < this.t; ++i) r.data[i] = op(this.data[i], f);
            r.t = this.t;
          } else {
            f = this.s & this.DM;
            for (i = m; i < a.t; ++i) r.data[i] = op(f, a.data[i]);
            r.t = a.t;
          }
          r.s = op(this.s, a.s);
          r.clamp();
        }
        function op_and(x, y) {
          return x & y;
        }
        function bnAnd(a) {
          var r = nbi();
          this.bitwiseTo(a, op_and, r);
          return r;
        }
        function op_or(x, y) {
          return x | y;
        }
        function bnOr(a) {
          var r = nbi();
          this.bitwiseTo(a, op_or, r);
          return r;
        }
        function op_xor(x, y) {
          return x ^ y;
        }
        function bnXor(a) {
          var r = nbi();
          this.bitwiseTo(a, op_xor, r);
          return r;
        }
        function op_andnot(x, y) {
          return x & ~y;
        }
        function bnAndNot(a) {
          var r = nbi();
          this.bitwiseTo(a, op_andnot, r);
          return r;
        }
        function bnNot() {
          var r = nbi();
          for (var i = 0; i < this.t; ++i) r.data[i] = this.DM & ~this.data[i];
          r.t = this.t;
          r.s = ~this.s;
          return r;
        }
        function bnShiftLeft(n) {
          var r = nbi();
          if (n < 0) this.rShiftTo(-n, r);
          else this.lShiftTo(n, r);
          return r;
        }
        function bnShiftRight(n) {
          var r = nbi();
          if (n < 0) this.lShiftTo(-n, r);
          else this.rShiftTo(n, r);
          return r;
        }
        function lbit(x) {
          if (x == 0) return -1;
          var r = 0;
          if ((x & 65535) == 0) {
            x >>= 16;
            r += 16;
          }
          if ((x & 255) == 0) {
            x >>= 8;
            r += 8;
          }
          if ((x & 15) == 0) {
            x >>= 4;
            r += 4;
          }
          if ((x & 3) == 0) {
            x >>= 2;
            r += 2;
          }
          if ((x & 1) == 0) ++r;
          return r;
        }
        function bnGetLowestSetBit() {
          for (var i = 0; i < this.t; ++i)
            if (this.data[i] != 0) return i * this.DB + lbit(this.data[i]);
          if (this.s < 0) return this.t * this.DB;
          return -1;
        }
        function cbit(x) {
          var r = 0;
          while (x != 0) {
            x &= x - 1;
            ++r;
          }
          return r;
        }
        function bnBitCount() {
          var r = 0, x = this.s & this.DM;
          for (var i = 0; i < this.t; ++i) r += cbit(this.data[i] ^ x);
          return r;
        }
        function bnTestBit(n) {
          var j = Math.floor(n / this.DB);
          if (j >= this.t) return this.s != 0;
          return (this.data[j] & 1 << n % this.DB) != 0;
        }
        function bnpChangeBit(n, op) {
          var r = BigInteger.ONE.shiftLeft(n);
          this.bitwiseTo(r, op, r);
          return r;
        }
        function bnSetBit(n) {
          return this.changeBit(n, op_or);
        }
        function bnClearBit(n) {
          return this.changeBit(n, op_andnot);
        }
        function bnFlipBit(n) {
          return this.changeBit(n, op_xor);
        }
        function bnpAddTo(a, r) {
          var i = 0, c = 0, m = Math.min(a.t, this.t);
          while (i < m) {
            c += this.data[i] + a.data[i];
            r.data[i++] = c & this.DM;
            c >>= this.DB;
          }
          if (a.t < this.t) {
            c += a.s;
            while (i < this.t) {
              c += this.data[i];
              r.data[i++] = c & this.DM;
              c >>= this.DB;
            }
            c += this.s;
          } else {
            c += this.s;
            while (i < a.t) {
              c += a.data[i];
              r.data[i++] = c & this.DM;
              c >>= this.DB;
            }
            c += a.s;
          }
          r.s = c < 0 ? -1 : 0;
          if (c > 0) r.data[i++] = c;
          else if (c < -1) r.data[i++] = this.DV + c;
          r.t = i;
          r.clamp();
        }
        function bnAdd(a) {
          var r = nbi();
          this.addTo(a, r);
          return r;
        }
        function bnSubtract(a) {
          var r = nbi();
          this.subTo(a, r);
          return r;
        }
        function bnMultiply(a) {
          var r = nbi();
          this.multiplyTo(a, r);
          return r;
        }
        function bnDivide(a) {
          var r = nbi();
          this.divRemTo(a, r, null);
          return r;
        }
        function bnRemainder(a) {
          var r = nbi();
          this.divRemTo(a, null, r);
          return r;
        }
        function bnDivideAndRemainder(a) {
          var q = nbi(), r = nbi();
          this.divRemTo(a, q, r);
          return new Array(q, r);
        }
        function bnpDMultiply(n) {
          this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
          ++this.t;
          this.clamp();
        }
        function bnpDAddOffset(n, w) {
          if (n == 0) return;
          while (this.t <= w) this.data[this.t++] = 0;
          this.data[w] += n;
          while (this.data[w] >= this.DV) {
            this.data[w] -= this.DV;
            if (++w >= this.t) this.data[this.t++] = 0;
            ++this.data[w];
          }
        }
        function NullExp() {
        }
        function nNop(x) {
          return x;
        }
        function nMulTo(x, y, r) {
          x.multiplyTo(y, r);
        }
        function nSqrTo(x, r) {
          x.squareTo(r);
        }
        NullExp.prototype.convert = nNop;
        NullExp.prototype.revert = nNop;
        NullExp.prototype.mulTo = nMulTo;
        NullExp.prototype.sqrTo = nSqrTo;
        function bnPow(e) {
          return this.exp(e, new NullExp());
        }
        function bnpMultiplyLowerTo(a, n, r) {
          var i = Math.min(this.t + a.t, n);
          r.s = 0;
          r.t = i;
          while (i > 0) r.data[--i] = 0;
          var j;
          for (j = r.t - this.t; i < j; ++i) r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
          for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a.data[i], r, i, 0, n - i);
          r.clamp();
        }
        function bnpMultiplyUpperTo(a, n, r) {
          --n;
          var i = r.t = this.t + a.t - n;
          r.s = 0;
          while (--i >= 0) r.data[i] = 0;
          for (i = Math.max(n - this.t, 0); i < a.t; ++i)
            r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
          r.clamp();
          r.drShiftTo(1, r);
        }
        function Barrett(m) {
          this.r2 = nbi();
          this.q3 = nbi();
          BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
          this.mu = this.r2.divide(m);
          this.m = m;
        }
        function barrettConvert(x) {
          if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
          else if (x.compareTo(this.m) < 0) return x;
          else {
            var r = nbi();
            x.copyTo(r);
            this.reduce(r);
            return r;
          }
        }
        function barrettRevert(x) {
          return x;
        }
        function barrettReduce(x) {
          x.drShiftTo(this.m.t - 1, this.r2);
          if (x.t > this.m.t + 1) {
            x.t = this.m.t + 1;
            x.clamp();
          }
          this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
          this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
          while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
          x.subTo(this.r2, x);
          while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
        }
        function barrettSqrTo(x, r) {
          x.squareTo(r);
          this.reduce(r);
        }
        function barrettMulTo(x, y, r) {
          x.multiplyTo(y, r);
          this.reduce(r);
        }
        Barrett.prototype.convert = barrettConvert;
        Barrett.prototype.revert = barrettRevert;
        Barrett.prototype.reduce = barrettReduce;
        Barrett.prototype.mulTo = barrettMulTo;
        Barrett.prototype.sqrTo = barrettSqrTo;
        function bnModPow(e, m) {
          var i = e.bitLength(), k, r = nbv(1), z;
          if (i <= 0) return r;
          else if (i < 18) k = 1;
          else if (i < 48) k = 3;
          else if (i < 144) k = 4;
          else if (i < 768) k = 5;
          else k = 6;
          if (i < 8)
            z = new Classic(m);
          else if (m.isEven())
            z = new Barrett(m);
          else
            z = new Montgomery(m);
          var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
          g[1] = z.convert(this);
          if (k > 1) {
            var g2 = nbi();
            z.sqrTo(g[1], g2);
            while (n <= km) {
              g[n] = nbi();
              z.mulTo(g2, g[n - 2], g[n]);
              n += 2;
            }
          }
          var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
          i = nbits(e.data[j]) - 1;
          while (j >= 0) {
            if (i >= k1) w = e.data[j] >> i - k1 & km;
            else {
              w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
              if (j > 0) w |= e.data[j - 1] >> this.DB + i - k1;
            }
            n = k;
            while ((w & 1) == 0) {
              w >>= 1;
              --n;
            }
            if ((i -= n) < 0) {
              i += this.DB;
              --j;
            }
            if (is1) {
              g[w].copyTo(r);
              is1 = false;
            } else {
              while (n > 1) {
                z.sqrTo(r, r2);
                z.sqrTo(r2, r);
                n -= 2;
              }
              if (n > 0) z.sqrTo(r, r2);
              else {
                t = r;
                r = r2;
                r2 = t;
              }
              z.mulTo(r2, g[w], r);
            }
            while (j >= 0 && (e.data[j] & 1 << i) == 0) {
              z.sqrTo(r, r2);
              t = r;
              r = r2;
              r2 = t;
              if (--i < 0) {
                i = this.DB - 1;
                --j;
              }
            }
          }
          return z.revert(r);
        }
        function bnGCD(a) {
          var x = this.s < 0 ? this.negate() : this.clone();
          var y = a.s < 0 ? a.negate() : a.clone();
          if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
          }
          var i = x.getLowestSetBit(), g = y.getLowestSetBit();
          if (g < 0) return x;
          if (i < g) g = i;
          if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
          }
          while (x.signum() > 0) {
            if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
            if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
            if (x.compareTo(y) >= 0) {
              x.subTo(y, x);
              x.rShiftTo(1, x);
            } else {
              y.subTo(x, y);
              y.rShiftTo(1, y);
            }
          }
          if (g > 0) y.lShiftTo(g, y);
          return y;
        }
        function bnpModInt(n) {
          if (n <= 0) return 0;
          var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
          if (this.t > 0)
            if (d == 0) r = this.data[0] % n;
            else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this.data[i]) % n;
          return r;
        }
        function bnModInverse(m) {
          var ac = m.isEven();
          if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;
          var u = m.clone(), v = this.clone();
          var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
          while (u.signum() != 0) {
            while (u.isEven()) {
              u.rShiftTo(1, u);
              if (ac) {
                if (!a.isEven() || !b.isEven()) {
                  a.addTo(this, a);
                  b.subTo(m, b);
                }
                a.rShiftTo(1, a);
              } else if (!b.isEven()) b.subTo(m, b);
              b.rShiftTo(1, b);
            }
            while (v.isEven()) {
              v.rShiftTo(1, v);
              if (ac) {
                if (!c.isEven() || !d.isEven()) {
                  c.addTo(this, c);
                  d.subTo(m, d);
                }
                c.rShiftTo(1, c);
              } else if (!d.isEven()) d.subTo(m, d);
              d.rShiftTo(1, d);
            }
            if (u.compareTo(v) >= 0) {
              u.subTo(v, u);
              if (ac) a.subTo(c, a);
              b.subTo(d, b);
            } else {
              v.subTo(u, v);
              if (ac) c.subTo(a, c);
              d.subTo(b, d);
            }
          }
          if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
          if (d.compareTo(m) >= 0) return d.subtract(m);
          if (d.signum() < 0) d.addTo(m, d);
          else return d;
          if (d.signum() < 0) return d.add(m);
          else return d;
        }
        var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
        var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
        function bnIsProbablePrime(t) {
          var i, x = this.abs();
          if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
            for (i = 0; i < lowprimes.length; ++i)
              if (x.data[0] == lowprimes[i]) return true;
            return false;
          }
          if (x.isEven()) return false;
          i = 1;
          while (i < lowprimes.length) {
            var m = lowprimes[i], j = i + 1;
            while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
            m = x.modInt(m);
            while (i < j) if (m % lowprimes[i++] == 0) return false;
          }
          return x.millerRabin(t);
        }
        function bnpMillerRabin(t) {
          var n1 = this.subtract(BigInteger.ONE);
          var k = n1.getLowestSetBit();
          if (k <= 0) return false;
          var r = n1.shiftRight(k);
          var prng2 = bnGetPrng();
          var a;
          for (var i = 0; i < t; ++i) {
            do {
              a = new BigInteger(this.bitLength(), prng2);
            } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
            var y = a.modPow(r, this);
            if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
              var j = 1;
              while (j++ < k && y.compareTo(n1) != 0) {
                y = y.modPowInt(2, this);
                if (y.compareTo(BigInteger.ONE) == 0) return false;
              }
              if (y.compareTo(n1) != 0) return false;
            }
          }
          return true;
        }
        function bnGetPrng() {
          return {
            // x is an array to fill with bytes
            nextBytes: function(x) {
              for (var i = 0; i < x.length; ++i) {
                x[i] = Math.floor(Math.random() * 256);
              }
            }
          };
        }
        BigInteger.prototype.chunkSize = bnpChunkSize;
        BigInteger.prototype.toRadix = bnpToRadix;
        BigInteger.prototype.fromRadix = bnpFromRadix;
        BigInteger.prototype.fromNumber = bnpFromNumber;
        BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
        BigInteger.prototype.changeBit = bnpChangeBit;
        BigInteger.prototype.addTo = bnpAddTo;
        BigInteger.prototype.dMultiply = bnpDMultiply;
        BigInteger.prototype.dAddOffset = bnpDAddOffset;
        BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
        BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
        BigInteger.prototype.modInt = bnpModInt;
        BigInteger.prototype.millerRabin = bnpMillerRabin;
        BigInteger.prototype.clone = bnClone;
        BigInteger.prototype.intValue = bnIntValue;
        BigInteger.prototype.byteValue = bnByteValue;
        BigInteger.prototype.shortValue = bnShortValue;
        BigInteger.prototype.signum = bnSigNum;
        BigInteger.prototype.toByteArray = bnToByteArray;
        BigInteger.prototype.equals = bnEquals;
        BigInteger.prototype.min = bnMin;
        BigInteger.prototype.max = bnMax;
        BigInteger.prototype.and = bnAnd;
        BigInteger.prototype.or = bnOr;
        BigInteger.prototype.xor = bnXor;
        BigInteger.prototype.andNot = bnAndNot;
        BigInteger.prototype.not = bnNot;
        BigInteger.prototype.shiftLeft = bnShiftLeft;
        BigInteger.prototype.shiftRight = bnShiftRight;
        BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
        BigInteger.prototype.bitCount = bnBitCount;
        BigInteger.prototype.testBit = bnTestBit;
        BigInteger.prototype.setBit = bnSetBit;
        BigInteger.prototype.clearBit = bnClearBit;
        BigInteger.prototype.flipBit = bnFlipBit;
        BigInteger.prototype.add = bnAdd;
        BigInteger.prototype.subtract = bnSubtract;
        BigInteger.prototype.multiply = bnMultiply;
        BigInteger.prototype.divide = bnDivide;
        BigInteger.prototype.remainder = bnRemainder;
        BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
        BigInteger.prototype.modPow = bnModPow;
        BigInteger.prototype.modInverse = bnModInverse;
        BigInteger.prototype.pow = bnPow;
        BigInteger.prototype.gcd = bnGCD;
        BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
        return jsbn;
      }
      var pkcs1 = { exports: {} };
      var sha1 = { exports: {} };
      var hasRequiredSha1;
      function requireSha1() {
        if (hasRequiredSha1) return sha1.exports;
        hasRequiredSha1 = 1;
        var forge2 = requireForge();
        requireMd();
        requireUtil();
        var sha1$1 = sha1.exports = forge2.sha1 = forge2.sha1 || {};
        forge2.md.sha1 = forge2.md.algorithms.sha1 = sha1$1;
        sha1$1.create = function() {
          if (!_initialized) {
            _init();
          }
          var _state = null;
          var _input = forge2.util.createBuffer();
          var _w = new Array(80);
          var md2 = {
            algorithm: "sha1",
            blockLength: 64,
            digestLength: 20,
            // 56-bit length of message so far (does not including padding)
            messageLength: 0,
            // true message length
            fullMessageLength: null,
            // size of message length in bytes
            messageLengthSize: 8
          };
          md2.start = function() {
            md2.messageLength = 0;
            md2.fullMessageLength = md2.messageLength64 = [];
            var int32s = md2.messageLengthSize / 4;
            for (var i = 0; i < int32s; ++i) {
              md2.fullMessageLength.push(0);
            }
            _input = forge2.util.createBuffer();
            _state = {
              h0: 1732584193,
              h1: 4023233417,
              h2: 2562383102,
              h3: 271733878,
              h4: 3285377520
            };
            return md2;
          };
          md2.start();
          md2.update = function(msg, encoding) {
            if (encoding === "utf8") {
              msg = forge2.util.encodeUtf8(msg);
            }
            var len = msg.length;
            md2.messageLength += len;
            len = [len / 4294967296 >>> 0, len >>> 0];
            for (var i = md2.fullMessageLength.length - 1; i >= 0; --i) {
              md2.fullMessageLength[i] += len[1];
              len[1] = len[0] + (md2.fullMessageLength[i] / 4294967296 >>> 0);
              md2.fullMessageLength[i] = md2.fullMessageLength[i] >>> 0;
              len[0] = len[1] / 4294967296 >>> 0;
            }
            _input.putBytes(msg);
            _update(_state, _w, _input);
            if (_input.read > 2048 || _input.length() === 0) {
              _input.compact();
            }
            return md2;
          };
          md2.digest = function() {
            var finalBlock = forge2.util.createBuffer();
            finalBlock.putBytes(_input.bytes());
            var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
            var overflow = remaining & md2.blockLength - 1;
            finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
            var next, carry;
            var bits2 = md2.fullMessageLength[0] * 8;
            for (var i = 0; i < md2.fullMessageLength.length - 1; ++i) {
              next = md2.fullMessageLength[i + 1] * 8;
              carry = next / 4294967296 >>> 0;
              bits2 += carry;
              finalBlock.putInt32(bits2 >>> 0);
              bits2 = next >>> 0;
            }
            finalBlock.putInt32(bits2);
            var s2 = {
              h0: _state.h0,
              h1: _state.h1,
              h2: _state.h2,
              h3: _state.h3,
              h4: _state.h4
            };
            _update(s2, _w, finalBlock);
            var rval = forge2.util.createBuffer();
            rval.putInt32(s2.h0);
            rval.putInt32(s2.h1);
            rval.putInt32(s2.h2);
            rval.putInt32(s2.h3);
            rval.putInt32(s2.h4);
            return rval;
          };
          return md2;
        };
        var _padding = null;
        var _initialized = false;
        function _init() {
          _padding = String.fromCharCode(128);
          _padding += forge2.util.fillString(String.fromCharCode(0), 64);
          _initialized = true;
        }
        function _update(s, w, bytes) {
          var t, a, b, c, d, e, f, i;
          var len = bytes.length();
          while (len >= 64) {
            a = s.h0;
            b = s.h1;
            c = s.h2;
            d = s.h3;
            e = s.h4;
            for (i = 0; i < 16; ++i) {
              t = bytes.getInt32();
              w[i] = t;
              f = d ^ b & (c ^ d);
              t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
              e = d;
              d = c;
              c = (b << 30 | b >>> 2) >>> 0;
              b = a;
              a = t;
            }
            for (; i < 20; ++i) {
              t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
              t = t << 1 | t >>> 31;
              w[i] = t;
              f = d ^ b & (c ^ d);
              t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
              e = d;
              d = c;
              c = (b << 30 | b >>> 2) >>> 0;
              b = a;
              a = t;
            }
            for (; i < 32; ++i) {
              t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
              t = t << 1 | t >>> 31;
              w[i] = t;
              f = b ^ c ^ d;
              t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
              e = d;
              d = c;
              c = (b << 30 | b >>> 2) >>> 0;
              b = a;
              a = t;
            }
            for (; i < 40; ++i) {
              t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
              t = t << 2 | t >>> 30;
              w[i] = t;
              f = b ^ c ^ d;
              t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
              e = d;
              d = c;
              c = (b << 30 | b >>> 2) >>> 0;
              b = a;
              a = t;
            }
            for (; i < 60; ++i) {
              t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
              t = t << 2 | t >>> 30;
              w[i] = t;
              f = b & c | d & (b ^ c);
              t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
              e = d;
              d = c;
              c = (b << 30 | b >>> 2) >>> 0;
              b = a;
              a = t;
            }
            for (; i < 80; ++i) {
              t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
              t = t << 2 | t >>> 30;
              w[i] = t;
              f = b ^ c ^ d;
              t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
              e = d;
              d = c;
              c = (b << 30 | b >>> 2) >>> 0;
              b = a;
              a = t;
            }
            s.h0 = s.h0 + a | 0;
            s.h1 = s.h1 + b | 0;
            s.h2 = s.h2 + c | 0;
            s.h3 = s.h3 + d | 0;
            s.h4 = s.h4 + e | 0;
            len -= 64;
          }
        }
        return sha1.exports;
      }
      var hasRequiredPkcs1;
      function requirePkcs1() {
        if (hasRequiredPkcs1) return pkcs1.exports;
        hasRequiredPkcs1 = 1;
        var forge2 = requireForge();
        requireUtil();
        requireRandom();
        requireSha1();
        var pkcs1$1 = pkcs1.exports = forge2.pkcs1 = forge2.pkcs1 || {};
        pkcs1$1.encode_rsa_oaep = function(key, message2, options) {
          var label;
          var seed;
          var md2;
          var mgf1Md;
          if (typeof options === "string") {
            label = options;
            seed = arguments[3] || void 0;
            md2 = arguments[4] || void 0;
          } else if (options) {
            label = options.label || void 0;
            seed = options.seed || void 0;
            md2 = options.md || void 0;
            if (options.mgf1 && options.mgf1.md) {
              mgf1Md = options.mgf1.md;
            }
          }
          if (!md2) {
            md2 = forge2.md.sha1.create();
          } else {
            md2.start();
          }
          if (!mgf1Md) {
            mgf1Md = md2;
          }
          var keyLength = Math.ceil(key.n.bitLength() / 8);
          var maxLength = keyLength - 2 * md2.digestLength - 2;
          if (message2.length > maxLength) {
            var error = new Error("RSAES-OAEP input message length is too long.");
            error.length = message2.length;
            error.maxLength = maxLength;
            throw error;
          }
          if (!label) {
            label = "";
          }
          md2.update(label, "raw");
          var lHash = md2.digest();
          var PS = "";
          var PS_length = maxLength - message2.length;
          for (var i = 0; i < PS_length; i++) {
            PS += "\0";
          }
          var DB = lHash.getBytes() + PS + "" + message2;
          if (!seed) {
            seed = forge2.random.getBytes(md2.digestLength);
          } else if (seed.length !== md2.digestLength) {
            var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
            error.seedLength = seed.length;
            error.digestLength = md2.digestLength;
            throw error;
          }
          var dbMask = rsa_mgf1(seed, keyLength - md2.digestLength - 1, mgf1Md);
          var maskedDB = forge2.util.xorBytes(DB, dbMask, DB.length);
          var seedMask = rsa_mgf1(maskedDB, md2.digestLength, mgf1Md);
          var maskedSeed = forge2.util.xorBytes(seed, seedMask, seed.length);
          return "\0" + maskedSeed + maskedDB;
        };
        pkcs1$1.decode_rsa_oaep = function(key, em, options) {
          var label;
          var md2;
          var mgf1Md;
          if (typeof options === "string") {
            label = options;
            md2 = arguments[3] || void 0;
          } else if (options) {
            label = options.label || void 0;
            md2 = options.md || void 0;
            if (options.mgf1 && options.mgf1.md) {
              mgf1Md = options.mgf1.md;
            }
          }
          var keyLength = Math.ceil(key.n.bitLength() / 8);
          if (em.length !== keyLength) {
            var error = new Error("RSAES-OAEP encoded message length is invalid.");
            error.length = em.length;
            error.expectedLength = keyLength;
            throw error;
          }
          if (md2 === void 0) {
            md2 = forge2.md.sha1.create();
          } else {
            md2.start();
          }
          if (!mgf1Md) {
            mgf1Md = md2;
          }
          if (keyLength < 2 * md2.digestLength + 2) {
            throw new Error("RSAES-OAEP key is too short for the hash function.");
          }
          if (!label) {
            label = "";
          }
          md2.update(label, "raw");
          var lHash = md2.digest().getBytes();
          var y = em.charAt(0);
          var maskedSeed = em.substring(1, md2.digestLength + 1);
          var maskedDB = em.substring(1 + md2.digestLength);
          var seedMask = rsa_mgf1(maskedDB, md2.digestLength, mgf1Md);
          var seed = forge2.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
          var dbMask = rsa_mgf1(seed, keyLength - md2.digestLength - 1, mgf1Md);
          var db = forge2.util.xorBytes(maskedDB, dbMask, maskedDB.length);
          var lHashPrime = db.substring(0, md2.digestLength);
          var error = y !== "\0";
          for (var i = 0; i < md2.digestLength; ++i) {
            error |= lHash.charAt(i) !== lHashPrime.charAt(i);
          }
          var in_ps = 1;
          var index2 = md2.digestLength;
          for (var j = md2.digestLength; j < db.length; j++) {
            var code = db.charCodeAt(j);
            var is_0 = code & 1 ^ 1;
            var error_mask = in_ps ? 65534 : 0;
            error |= code & error_mask;
            in_ps = in_ps & is_0;
            index2 += in_ps;
          }
          if (error || db.charCodeAt(index2) !== 1) {
            throw new Error("Invalid RSAES-OAEP padding.");
          }
          return db.substring(index2 + 1);
        };
        function rsa_mgf1(seed, maskLength, hash) {
          if (!hash) {
            hash = forge2.md.sha1.create();
          }
          var t = "";
          var count = Math.ceil(maskLength / hash.digestLength);
          for (var i = 0; i < count; ++i) {
            var c = String.fromCharCode(
              i >> 24 & 255,
              i >> 16 & 255,
              i >> 8 & 255,
              i & 255
            );
            hash.start();
            hash.update(seed + c);
            t += hash.digest().getBytes();
          }
          return t.substring(0, maskLength);
        }
        return pkcs1.exports;
      }
      var prime = { exports: {} };
      var hasRequiredPrime;
      function requirePrime() {
        if (hasRequiredPrime) return prime.exports;
        hasRequiredPrime = 1;
        var forge2 = requireForge();
        requireUtil();
        requireJsbn();
        requireRandom();
        (function() {
          if (forge2.prime) {
            prime.exports = forge2.prime;
            return;
          }
          var prime$1 = prime.exports = forge2.prime = forge2.prime || {};
          var BigInteger = forge2.jsbn.BigInteger;
          var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
          var THIRTY = new BigInteger(null);
          THIRTY.fromInt(30);
          var op_or = function(x, y) {
            return x | y;
          };
          prime$1.generateProbablePrime = function(bits2, options, callback) {
            if (typeof options === "function") {
              callback = options;
              options = {};
            }
            options = options || {};
            var algorithm = options.algorithm || "PRIMEINC";
            if (typeof algorithm === "string") {
              algorithm = { name: algorithm };
            }
            algorithm.options = algorithm.options || {};
            var prng2 = options.prng || forge2.random;
            var rng = {
              // x is an array to fill with bytes
              nextBytes: function(x) {
                var b = prng2.getBytesSync(x.length);
                for (var i = 0; i < x.length; ++i) {
                  x[i] = b.charCodeAt(i);
                }
              }
            };
            if (algorithm.name === "PRIMEINC") {
              return primeincFindPrime(bits2, rng, algorithm.options, callback);
            }
            throw new Error("Invalid prime generation algorithm: " + algorithm.name);
          };
          function primeincFindPrime(bits2, rng, options, callback) {
            if ("workers" in options) {
              return primeincFindPrimeWithWorkers(bits2, rng, options, callback);
            }
            return primeincFindPrimeWithoutWorkers(bits2, rng, options, callback);
          }
          function primeincFindPrimeWithoutWorkers(bits2, rng, options, callback) {
            var num = generateRandom(bits2, rng);
            var deltaIdx = 0;
            var mrTests = getMillerRabinTests(num.bitLength());
            if ("millerRabinTests" in options) {
              mrTests = options.millerRabinTests;
            }
            var maxBlockTime = 10;
            if ("maxBlockTime" in options) {
              maxBlockTime = options.maxBlockTime;
            }
            _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback);
          }
          function _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback) {
            var start = +/* @__PURE__ */ new Date();
            do {
              if (num.bitLength() > bits2) {
                num = generateRandom(bits2, rng);
              }
              if (num.isProbablePrime(mrTests)) {
                return callback(null, num);
              }
              num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
            forge2.util.setImmediate(function() {
              _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback);
            });
          }
          function primeincFindPrimeWithWorkers(bits2, rng, options, callback) {
            if (typeof Worker === "undefined") {
              return primeincFindPrimeWithoutWorkers(bits2, rng, options, callback);
            }
            var num = generateRandom(bits2, rng);
            var numWorkers = options.workers;
            var workLoad = options.workLoad || 100;
            var range = workLoad * 30 / 8;
            var workerScript = options.workerScript || "forge/prime.worker.js";
            if (numWorkers === -1) {
              return forge2.util.estimateCores(function(err2, cores) {
                if (err2) {
                  cores = 2;
                }
                numWorkers = cores - 1;
                generate();
              });
            }
            generate();
            function generate() {
              numWorkers = Math.max(1, numWorkers);
              var workers = [];
              for (var i = 0; i < numWorkers; ++i) {
                workers[i] = new Worker(workerScript);
              }
              for (var i = 0; i < numWorkers; ++i) {
                workers[i].addEventListener("message", workerMessage);
              }
              var found = false;
              function workerMessage(e) {
                if (found) {
                  return;
                }
                var data = e.data;
                if (data.found) {
                  for (var i2 = 0; i2 < workers.length; ++i2) {
                    workers[i2].terminate();
                  }
                  found = true;
                  return callback(null, new BigInteger(data.prime, 16));
                }
                if (num.bitLength() > bits2) {
                  num = generateRandom(bits2, rng);
                }
                var hex = num.toString(16);
                e.target.postMessage({
                  hex,
                  workLoad
                });
                num.dAddOffset(range, 0);
              }
            }
          }
          function generateRandom(bits2, rng) {
            var num = new BigInteger(bits2, rng);
            var bits1 = bits2 - 1;
            if (!num.testBit(bits1)) {
              num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
            }
            num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
            return num;
          }
          function getMillerRabinTests(bits2) {
            if (bits2 <= 100) return 27;
            if (bits2 <= 150) return 18;
            if (bits2 <= 200) return 15;
            if (bits2 <= 250) return 12;
            if (bits2 <= 300) return 9;
            if (bits2 <= 350) return 8;
            if (bits2 <= 400) return 7;
            if (bits2 <= 500) return 6;
            if (bits2 <= 600) return 5;
            if (bits2 <= 800) return 4;
            if (bits2 <= 1250) return 3;
            return 2;
          }
        })();
        return prime.exports;
      }
      var rsa;
      var hasRequiredRsa;
      function requireRsa() {
        if (hasRequiredRsa) return rsa;
        hasRequiredRsa = 1;
        var forge2 = requireForge();
        requireAsn1();
        requireJsbn();
        requireOids();
        requirePkcs1();
        requirePrime();
        requireRandom();
        requireUtil();
        if (typeof BigInteger === "undefined") {
          var BigInteger = forge2.jsbn.BigInteger;
        }
        var _crypto = forge2.util.isNodejs ? require$$8 : null;
        var asn12 = forge2.asn1;
        var util2 = forge2.util;
        forge2.pki = forge2.pki || {};
        rsa = forge2.pki.rsa = forge2.rsa = forge2.rsa || {};
        var pki2 = forge2.pki;
        var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
        var privateKeyValidator = {
          // PrivateKeyInfo
          name: "PrivateKeyInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            // Version (INTEGER)
            name: "PrivateKeyInfo.version",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyVersion"
          }, {
            // privateKeyAlgorithm
            name: "PrivateKeyInfo.privateKeyAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "privateKeyOid"
            }]
          }, {
            // PrivateKey
            name: "PrivateKeyInfo",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OCTETSTRING,
            constructed: false,
            capture: "privateKey"
          }]
        };
        var rsaPrivateKeyValidator = {
          // RSAPrivateKey
          name: "RSAPrivateKey",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            // Version (INTEGER)
            name: "RSAPrivateKey.version",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyVersion"
          }, {
            // modulus (n)
            name: "RSAPrivateKey.modulus",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyModulus"
          }, {
            // publicExponent (e)
            name: "RSAPrivateKey.publicExponent",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyPublicExponent"
          }, {
            // privateExponent (d)
            name: "RSAPrivateKey.privateExponent",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyPrivateExponent"
          }, {
            // prime1 (p)
            name: "RSAPrivateKey.prime1",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyPrime1"
          }, {
            // prime2 (q)
            name: "RSAPrivateKey.prime2",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyPrime2"
          }, {
            // exponent1 (d mod (p-1))
            name: "RSAPrivateKey.exponent1",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyExponent1"
          }, {
            // exponent2 (d mod (q-1))
            name: "RSAPrivateKey.exponent2",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyExponent2"
          }, {
            // coefficient ((inverse of q) mod p)
            name: "RSAPrivateKey.coefficient",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyCoefficient"
          }]
        };
        var rsaPublicKeyValidator = {
          // RSAPublicKey
          name: "RSAPublicKey",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            // modulus (n)
            name: "RSAPublicKey.modulus",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "publicKeyModulus"
          }, {
            // publicExponent (e)
            name: "RSAPublicKey.exponent",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "publicKeyExponent"
          }]
        };
        var publicKeyValidator = forge2.pki.rsa.publicKeyValidator = {
          name: "SubjectPublicKeyInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "subjectPublicKeyInfo",
          value: [{
            name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "publicKeyOid"
            }]
          }, {
            // subjectPublicKey
            name: "SubjectPublicKeyInfo.subjectPublicKey",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.BITSTRING,
            constructed: false,
            value: [{
              // RSAPublicKey
              name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              optional: true,
              captureAsn1: "rsaPublicKey"
            }]
          }]
        };
        var digestInfoValidator = {
          name: "DigestInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "DigestInfo.DigestAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "algorithmIdentifier"
            }, {
              // NULL parameters
              name: "DigestInfo.DigestAlgorithm.parameters",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.NULL,
              // captured only to check existence for md2 and md5
              capture: "parameters",
              optional: true,
              constructed: false
            }]
          }, {
            // digest
            name: "DigestInfo.digest",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OCTETSTRING,
            constructed: false,
            capture: "digest"
          }]
        };
        var emsaPkcs1v15encode = function(md2) {
          var oid;
          if (md2.algorithm in pki2.oids) {
            oid = pki2.oids[md2.algorithm];
          } else {
            var error = new Error("Unknown message digest algorithm.");
            error.algorithm = md2.algorithm;
            throw error;
          }
          var oidBytes = asn12.oidToDer(oid).getBytes();
          var digestInfo = asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.SEQUENCE,
            true,
            []
          );
          var digestAlgorithm = asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.SEQUENCE,
            true,
            []
          );
          digestAlgorithm.value.push(asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.OID,
            false,
            oidBytes
          ));
          digestAlgorithm.value.push(asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.NULL,
            false,
            ""
          ));
          var digest = asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.OCTETSTRING,
            false,
            md2.digest().getBytes()
          );
          digestInfo.value.push(digestAlgorithm);
          digestInfo.value.push(digest);
          return asn12.toDer(digestInfo).getBytes();
        };
        var _modPow = function(x, key, pub) {
          if (pub) {
            return x.modPow(key.e, key.n);
          }
          if (!key.p || !key.q) {
            return x.modPow(key.d, key.n);
          }
          if (!key.dP) {
            key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
          }
          if (!key.dQ) {
            key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
          }
          if (!key.qInv) {
            key.qInv = key.q.modInverse(key.p);
          }
          var r;
          do {
            r = new BigInteger(
              forge2.util.bytesToHex(forge2.random.getBytes(key.n.bitLength() / 8)),
              16
            );
          } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
          x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
          var xp = x.mod(key.p).modPow(key.dP, key.p);
          var xq = x.mod(key.q).modPow(key.dQ, key.q);
          while (xp.compareTo(xq) < 0) {
            xp = xp.add(key.p);
          }
          var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
          y = y.multiply(r.modInverse(key.n)).mod(key.n);
          return y;
        };
        pki2.rsa.encrypt = function(m, key, bt) {
          var pub = bt;
          var eb;
          var k = Math.ceil(key.n.bitLength() / 8);
          if (bt !== false && bt !== true) {
            pub = bt === 2;
            eb = _encodePkcs1_v1_5(m, key, bt);
          } else {
            eb = forge2.util.createBuffer();
            eb.putBytes(m);
          }
          var x = new BigInteger(eb.toHex(), 16);
          var y = _modPow(x, key, pub);
          var yhex = y.toString(16);
          var ed = forge2.util.createBuffer();
          var zeros = k - Math.ceil(yhex.length / 2);
          while (zeros > 0) {
            ed.putByte(0);
            --zeros;
          }
          ed.putBytes(forge2.util.hexToBytes(yhex));
          return ed.getBytes();
        };
        pki2.rsa.decrypt = function(ed, key, pub, ml) {
          var k = Math.ceil(key.n.bitLength() / 8);
          if (ed.length !== k) {
            var error = new Error("Encrypted message length is invalid.");
            error.length = ed.length;
            error.expected = k;
            throw error;
          }
          var y = new BigInteger(forge2.util.createBuffer(ed).toHex(), 16);
          if (y.compareTo(key.n) >= 0) {
            throw new Error("Encrypted message is invalid.");
          }
          var x = _modPow(y, key, pub);
          var xhex = x.toString(16);
          var eb = forge2.util.createBuffer();
          var zeros = k - Math.ceil(xhex.length / 2);
          while (zeros > 0) {
            eb.putByte(0);
            --zeros;
          }
          eb.putBytes(forge2.util.hexToBytes(xhex));
          if (ml !== false) {
            return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
          }
          return eb.getBytes();
        };
        pki2.rsa.createKeyPairGenerationState = function(bits2, e, options) {
          if (typeof bits2 === "string") {
            bits2 = parseInt(bits2, 10);
          }
          bits2 = bits2 || 2048;
          options = options || {};
          var prng2 = options.prng || forge2.random;
          var rng = {
            // x is an array to fill with bytes
            nextBytes: function(x) {
              var b = prng2.getBytesSync(x.length);
              for (var i = 0; i < x.length; ++i) {
                x[i] = b.charCodeAt(i);
              }
            }
          };
          var algorithm = options.algorithm || "PRIMEINC";
          var rval;
          if (algorithm === "PRIMEINC") {
            rval = {
              algorithm,
              state: 0,
              bits: bits2,
              rng,
              eInt: e || 65537,
              e: new BigInteger(null),
              p: null,
              q: null,
              qBits: bits2 >> 1,
              pBits: bits2 - (bits2 >> 1),
              pqState: 0,
              num: null,
              keys: null
            };
            rval.e.fromInt(rval.eInt);
          } else {
            throw new Error("Invalid key generation algorithm: " + algorithm);
          }
          return rval;
        };
        pki2.rsa.stepKeyPairGenerationState = function(state, n) {
          if (!("algorithm" in state)) {
            state.algorithm = "PRIMEINC";
          }
          var THIRTY = new BigInteger(null);
          THIRTY.fromInt(30);
          var deltaIdx = 0;
          var op_or = function(x, y) {
            return x | y;
          };
          var t1 = +/* @__PURE__ */ new Date();
          var t2;
          var total = 0;
          while (state.keys === null && (n <= 0 || total < n)) {
            if (state.state === 0) {
              var bits2 = state.p === null ? state.pBits : state.qBits;
              var bits1 = bits2 - 1;
              if (state.pqState === 0) {
                state.num = new BigInteger(bits2, state.rng);
                if (!state.num.testBit(bits1)) {
                  state.num.bitwiseTo(
                    BigInteger.ONE.shiftLeft(bits1),
                    op_or,
                    state.num
                  );
                }
                state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
                deltaIdx = 0;
                ++state.pqState;
              } else if (state.pqState === 1) {
                if (state.num.bitLength() > bits2) {
                  state.pqState = 0;
                } else if (state.num.isProbablePrime(
                  _getMillerRabinTests(state.num.bitLength())
                )) {
                  ++state.pqState;
                } else {
                  state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
                }
              } else if (state.pqState === 2) {
                state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
              } else if (state.pqState === 3) {
                state.pqState = 0;
                if (state.p === null) {
                  state.p = state.num;
                } else {
                  state.q = state.num;
                }
                if (state.p !== null && state.q !== null) {
                  ++state.state;
                }
                state.num = null;
              }
            } else if (state.state === 1) {
              if (state.p.compareTo(state.q) < 0) {
                state.num = state.p;
                state.p = state.q;
                state.q = state.num;
              }
              ++state.state;
            } else if (state.state === 2) {
              state.p1 = state.p.subtract(BigInteger.ONE);
              state.q1 = state.q.subtract(BigInteger.ONE);
              state.phi = state.p1.multiply(state.q1);
              ++state.state;
            } else if (state.state === 3) {
              if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
                ++state.state;
              } else {
                state.p = null;
                state.q = null;
                state.state = 0;
              }
            } else if (state.state === 4) {
              state.n = state.p.multiply(state.q);
              if (state.n.bitLength() === state.bits) {
                ++state.state;
              } else {
                state.q = null;
                state.state = 0;
              }
            } else if (state.state === 5) {
              var d = state.e.modInverse(state.phi);
              state.keys = {
                privateKey: pki2.rsa.setPrivateKey(
                  state.n,
                  state.e,
                  d,
                  state.p,
                  state.q,
                  d.mod(state.p1),
                  d.mod(state.q1),
                  state.q.modInverse(state.p)
                ),
                publicKey: pki2.rsa.setPublicKey(state.n, state.e)
              };
            }
            t2 = +/* @__PURE__ */ new Date();
            total += t2 - t1;
            t1 = t2;
          }
          return state.keys !== null;
        };
        pki2.rsa.generateKeyPair = function(bits2, e, options, callback) {
          if (arguments.length === 1) {
            if (typeof bits2 === "object") {
              options = bits2;
              bits2 = void 0;
            } else if (typeof bits2 === "function") {
              callback = bits2;
              bits2 = void 0;
            }
          } else if (arguments.length === 2) {
            if (typeof bits2 === "number") {
              if (typeof e === "function") {
                callback = e;
                e = void 0;
              } else if (typeof e !== "number") {
                options = e;
                e = void 0;
              }
            } else {
              options = bits2;
              callback = e;
              bits2 = void 0;
              e = void 0;
            }
          } else if (arguments.length === 3) {
            if (typeof e === "number") {
              if (typeof options === "function") {
                callback = options;
                options = void 0;
              }
            } else {
              callback = options;
              options = e;
              e = void 0;
            }
          }
          options = options || {};
          if (bits2 === void 0) {
            bits2 = options.bits || 2048;
          }
          if (e === void 0) {
            e = options.e || 65537;
          }
          if (!forge2.options.usePureJavaScript && !options.prng && bits2 >= 256 && bits2 <= 16384 && (e === 65537 || e === 3)) {
            if (callback) {
              if (_detectNodeCrypto("generateKeyPair")) {
                return _crypto.generateKeyPair("rsa", {
                  modulusLength: bits2,
                  publicExponent: e,
                  publicKeyEncoding: {
                    type: "spki",
                    format: "pem"
                  },
                  privateKeyEncoding: {
                    type: "pkcs8",
                    format: "pem"
                  }
                }, function(err2, pub, priv) {
                  if (err2) {
                    return callback(err2);
                  }
                  callback(null, {
                    privateKey: pki2.privateKeyFromPem(priv),
                    publicKey: pki2.publicKeyFromPem(pub)
                  });
                });
              }
              if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
                return util2.globalScope.crypto.subtle.generateKey({
                  name: "RSASSA-PKCS1-v1_5",
                  modulusLength: bits2,
                  publicExponent: _intToUint8Array(e),
                  hash: { name: "SHA-256" }
                }, true, ["sign", "verify"]).then(function(pair) {
                  return util2.globalScope.crypto.subtle.exportKey(
                    "pkcs8",
                    pair.privateKey
                  );
                }).then(void 0, function(err2) {
                  callback(err2);
                }).then(function(pkcs8) {
                  if (pkcs8) {
                    var privateKey = pki2.privateKeyFromAsn1(
                      asn12.fromDer(forge2.util.createBuffer(pkcs8))
                    );
                    callback(null, {
                      privateKey,
                      publicKey: pki2.setRsaPublicKey(privateKey.n, privateKey.e)
                    });
                  }
                });
              }
              if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
                var genOp = util2.globalScope.msCrypto.subtle.generateKey({
                  name: "RSASSA-PKCS1-v1_5",
                  modulusLength: bits2,
                  publicExponent: _intToUint8Array(e),
                  hash: { name: "SHA-256" }
                }, true, ["sign", "verify"]);
                genOp.oncomplete = function(e2) {
                  var pair = e2.target.result;
                  var exportOp = util2.globalScope.msCrypto.subtle.exportKey(
                    "pkcs8",
                    pair.privateKey
                  );
                  exportOp.oncomplete = function(e3) {
                    var pkcs8 = e3.target.result;
                    var privateKey = pki2.privateKeyFromAsn1(
                      asn12.fromDer(forge2.util.createBuffer(pkcs8))
                    );
                    callback(null, {
                      privateKey,
                      publicKey: pki2.setRsaPublicKey(privateKey.n, privateKey.e)
                    });
                  };
                  exportOp.onerror = function(err2) {
                    callback(err2);
                  };
                };
                genOp.onerror = function(err2) {
                  callback(err2);
                };
                return;
              }
            } else {
              if (_detectNodeCrypto("generateKeyPairSync")) {
                var keypair = _crypto.generateKeyPairSync("rsa", {
                  modulusLength: bits2,
                  publicExponent: e,
                  publicKeyEncoding: {
                    type: "spki",
                    format: "pem"
                  },
                  privateKeyEncoding: {
                    type: "pkcs8",
                    format: "pem"
                  }
                });
                return {
                  privateKey: pki2.privateKeyFromPem(keypair.privateKey),
                  publicKey: pki2.publicKeyFromPem(keypair.publicKey)
                };
              }
            }
          }
          var state = pki2.rsa.createKeyPairGenerationState(bits2, e, options);
          if (!callback) {
            pki2.rsa.stepKeyPairGenerationState(state, 0);
            return state.keys;
          }
          _generateKeyPair(state, options, callback);
        };
        pki2.setRsaPublicKey = pki2.rsa.setPublicKey = function(n, e) {
          var key = {
            n,
            e
          };
          key.encrypt = function(data, scheme, schemeOptions) {
            if (typeof scheme === "string") {
              scheme = scheme.toUpperCase();
            } else if (scheme === void 0) {
              scheme = "RSAES-PKCS1-V1_5";
            }
            if (scheme === "RSAES-PKCS1-V1_5") {
              scheme = {
                encode: function(m, key2, pub) {
                  return _encodePkcs1_v1_5(m, key2, 2).getBytes();
                }
              };
            } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
              scheme = {
                encode: function(m, key2) {
                  return forge2.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);
                }
              };
            } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
              scheme = { encode: function(e3) {
                return e3;
              } };
            } else if (typeof scheme === "string") {
              throw new Error('Unsupported encryption scheme: "' + scheme + '".');
            }
            var e2 = scheme.encode(data, key, true);
            return pki2.rsa.encrypt(e2, key, true);
          };
          key.verify = function(digest, signature, scheme, options) {
            if (typeof scheme === "string") {
              scheme = scheme.toUpperCase();
            } else if (scheme === void 0) {
              scheme = "RSASSA-PKCS1-V1_5";
            }
            if (options === void 0) {
              options = {
                _parseAllDigestBytes: true
              };
            }
            if (!("_parseAllDigestBytes" in options)) {
              options._parseAllDigestBytes = true;
            }
            if (scheme === "RSASSA-PKCS1-V1_5") {
              scheme = {
                verify: function(digest2, d2) {
                  d2 = _decodePkcs1_v1_5(d2, key, true);
                  var obj = asn12.fromDer(d2, {
                    parseAllBytes: options._parseAllDigestBytes
                  });
                  var capture = {};
                  var errors = [];
                  if (!asn12.validate(obj, digestInfoValidator, capture, errors)) {
                    var error = new Error(
                      "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
                    );
                    error.errors = errors;
                    throw error;
                  }
                  var oid = asn12.derToOid(capture.algorithmIdentifier);
                  if (!(oid === forge2.oids.md2 || oid === forge2.oids.md5 || oid === forge2.oids.sha1 || oid === forge2.oids.sha224 || oid === forge2.oids.sha256 || oid === forge2.oids.sha384 || oid === forge2.oids.sha512 || oid === forge2.oids["sha512-224"] || oid === forge2.oids["sha512-256"])) {
                    var error = new Error(
                      "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
                    );
                    error.oid = oid;
                    throw error;
                  }
                  if (oid === forge2.oids.md2 || oid === forge2.oids.md5) {
                    if (!("parameters" in capture)) {
                      throw new Error(
                        "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifier NULL parameters."
                      );
                    }
                  }
                  return digest2 === capture.digest;
                }
              };
            } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
              scheme = {
                verify: function(digest2, d2) {
                  d2 = _decodePkcs1_v1_5(d2, key, true);
                  return digest2 === d2;
                }
              };
            }
            var d = pki2.rsa.decrypt(signature, key, true, false);
            return scheme.verify(digest, d, key.n.bitLength());
          };
          return key;
        };
        pki2.setRsaPrivateKey = pki2.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
          var key = {
            n,
            e,
            d,
            p,
            q,
            dP,
            dQ,
            qInv
          };
          key.decrypt = function(data, scheme, schemeOptions) {
            if (typeof scheme === "string") {
              scheme = scheme.toUpperCase();
            } else if (scheme === void 0) {
              scheme = "RSAES-PKCS1-V1_5";
            }
            var d2 = pki2.rsa.decrypt(data, key, false, false);
            if (scheme === "RSAES-PKCS1-V1_5") {
              scheme = { decode: _decodePkcs1_v1_5 };
            } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
              scheme = {
                decode: function(d3, key2) {
                  return forge2.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
                }
              };
            } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
              scheme = { decode: function(d3) {
                return d3;
              } };
            } else {
              throw new Error('Unsupported encryption scheme: "' + scheme + '".');
            }
            return scheme.decode(d2, key, false);
          };
          key.sign = function(md2, scheme) {
            var bt = false;
            if (typeof scheme === "string") {
              scheme = scheme.toUpperCase();
            }
            if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
              scheme = { encode: emsaPkcs1v15encode };
              bt = 1;
            } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
              scheme = { encode: function() {
                return md2;
              } };
              bt = 1;
            }
            var d2 = scheme.encode(md2, key.n.bitLength());
            return pki2.rsa.encrypt(d2, key, bt);
          };
          return key;
        };
        pki2.wrapRsaPrivateKey = function(rsaKey) {
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // version (0)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              asn12.integerToDer(0).getBytes()
            ),
            // privateKeyAlgorithm
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(pki2.oids.rsaEncryption).getBytes()
              ),
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
            ]),
            // PrivateKey
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OCTETSTRING,
              false,
              asn12.toDer(rsaKey).getBytes()
            )
          ]);
        };
        pki2.privateKeyFromAsn1 = function(obj) {
          var capture = {};
          var errors = [];
          if (asn12.validate(obj, privateKeyValidator, capture, errors)) {
            obj = asn12.fromDer(forge2.util.createBuffer(capture.privateKey));
          }
          capture = {};
          errors = [];
          if (!asn12.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
            var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
            error.errors = errors;
            throw error;
          }
          var n, e, d, p, q, dP, dQ, qInv;
          n = forge2.util.createBuffer(capture.privateKeyModulus).toHex();
          e = forge2.util.createBuffer(capture.privateKeyPublicExponent).toHex();
          d = forge2.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
          p = forge2.util.createBuffer(capture.privateKeyPrime1).toHex();
          q = forge2.util.createBuffer(capture.privateKeyPrime2).toHex();
          dP = forge2.util.createBuffer(capture.privateKeyExponent1).toHex();
          dQ = forge2.util.createBuffer(capture.privateKeyExponent2).toHex();
          qInv = forge2.util.createBuffer(capture.privateKeyCoefficient).toHex();
          return pki2.setRsaPrivateKey(
            new BigInteger(n, 16),
            new BigInteger(e, 16),
            new BigInteger(d, 16),
            new BigInteger(p, 16),
            new BigInteger(q, 16),
            new BigInteger(dP, 16),
            new BigInteger(dQ, 16),
            new BigInteger(qInv, 16)
          );
        };
        pki2.privateKeyToAsn1 = pki2.privateKeyToRSAPrivateKey = function(key) {
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // version (0 = only 2 primes, 1 multiple primes)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              asn12.integerToDer(0).getBytes()
            ),
            // modulus (n)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.n)
            ),
            // publicExponent (e)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.e)
            ),
            // privateExponent (d)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.d)
            ),
            // privateKeyPrime1 (p)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.p)
            ),
            // privateKeyPrime2 (q)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.q)
            ),
            // privateKeyExponent1 (dP)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.dP)
            ),
            // privateKeyExponent2 (dQ)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.dQ)
            ),
            // coefficient (qInv)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.qInv)
            )
          ]);
        };
        pki2.publicKeyFromAsn1 = function(obj) {
          var capture = {};
          var errors = [];
          if (asn12.validate(obj, publicKeyValidator, capture, errors)) {
            var oid = asn12.derToOid(capture.publicKeyOid);
            if (oid !== pki2.oids.rsaEncryption) {
              var error = new Error("Cannot read public key. Unknown OID.");
              error.oid = oid;
              throw error;
            }
            obj = capture.rsaPublicKey;
          }
          errors = [];
          if (!asn12.validate(obj, rsaPublicKeyValidator, capture, errors)) {
            var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
            error.errors = errors;
            throw error;
          }
          var n = forge2.util.createBuffer(capture.publicKeyModulus).toHex();
          var e = forge2.util.createBuffer(capture.publicKeyExponent).toHex();
          return pki2.setRsaPublicKey(
            new BigInteger(n, 16),
            new BigInteger(e, 16)
          );
        };
        pki2.publicKeyToAsn1 = pki2.publicKeyToSubjectPublicKeyInfo = function(key) {
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // AlgorithmIdentifier
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // algorithm
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(pki2.oids.rsaEncryption).getBytes()
              ),
              // parameters (null)
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
            ]),
            // subjectPublicKey
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.BITSTRING, false, [
              pki2.publicKeyToRSAPublicKey(key)
            ])
          ]);
        };
        pki2.publicKeyToRSAPublicKey = function(key) {
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // modulus (n)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.n)
            ),
            // publicExponent (e)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.e)
            )
          ]);
        };
        function _encodePkcs1_v1_5(m, key, bt) {
          var eb = forge2.util.createBuffer();
          var k = Math.ceil(key.n.bitLength() / 8);
          if (m.length > k - 11) {
            var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
            error.length = m.length;
            error.max = k - 11;
            throw error;
          }
          eb.putByte(0);
          eb.putByte(bt);
          var padNum = k - 3 - m.length;
          var padByte;
          if (bt === 0 || bt === 1) {
            padByte = bt === 0 ? 0 : 255;
            for (var i = 0; i < padNum; ++i) {
              eb.putByte(padByte);
            }
          } else {
            while (padNum > 0) {
              var numZeros = 0;
              var padBytes = forge2.random.getBytes(padNum);
              for (var i = 0; i < padNum; ++i) {
                padByte = padBytes.charCodeAt(i);
                if (padByte === 0) {
                  ++numZeros;
                } else {
                  eb.putByte(padByte);
                }
              }
              padNum = numZeros;
            }
          }
          eb.putByte(0);
          eb.putBytes(m);
          return eb;
        }
        function _decodePkcs1_v1_5(em, key, pub, ml) {
          var k = Math.ceil(key.n.bitLength() / 8);
          var eb = forge2.util.createBuffer(em);
          var first = eb.getByte();
          var bt = eb.getByte();
          if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
            throw new Error("Encryption block is invalid.");
          }
          var padNum = 0;
          if (bt === 0) {
            padNum = k - 3 - ml;
            for (var i = 0; i < padNum; ++i) {
              if (eb.getByte() !== 0) {
                throw new Error("Encryption block is invalid.");
              }
            }
          } else if (bt === 1) {
            padNum = 0;
            while (eb.length() > 1) {
              if (eb.getByte() !== 255) {
                --eb.read;
                break;
              }
              ++padNum;
            }
          } else if (bt === 2) {
            padNum = 0;
            while (eb.length() > 1) {
              if (eb.getByte() === 0) {
                --eb.read;
                break;
              }
              ++padNum;
            }
          }
          var zero = eb.getByte();
          if (zero !== 0 || padNum !== k - 3 - eb.length()) {
            throw new Error("Encryption block is invalid.");
          }
          return eb.getBytes();
        }
        function _generateKeyPair(state, options, callback) {
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          options = options || {};
          var opts = {
            algorithm: {
              name: options.algorithm || "PRIMEINC",
              options: {
                workers: options.workers || 2,
                workLoad: options.workLoad || 100,
                workerScript: options.workerScript
              }
            }
          };
          if ("prng" in options) {
            opts.prng = options.prng;
          }
          generate();
          function generate() {
            getPrime(state.pBits, function(err2, num) {
              if (err2) {
                return callback(err2);
              }
              state.p = num;
              if (state.q !== null) {
                return finish(err2, state.q);
              }
              getPrime(state.qBits, finish);
            });
          }
          function getPrime(bits2, callback2) {
            forge2.prime.generateProbablePrime(bits2, opts, callback2);
          }
          function finish(err2, num) {
            if (err2) {
              return callback(err2);
            }
            state.q = num;
            if (state.p.compareTo(state.q) < 0) {
              var tmp = state.p;
              state.p = state.q;
              state.q = tmp;
            }
            if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
              state.p = null;
              generate();
              return;
            }
            if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
              state.q = null;
              getPrime(state.qBits, finish);
              return;
            }
            state.p1 = state.p.subtract(BigInteger.ONE);
            state.q1 = state.q.subtract(BigInteger.ONE);
            state.phi = state.p1.multiply(state.q1);
            if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
              state.p = state.q = null;
              generate();
              return;
            }
            state.n = state.p.multiply(state.q);
            if (state.n.bitLength() !== state.bits) {
              state.q = null;
              getPrime(state.qBits, finish);
              return;
            }
            var d = state.e.modInverse(state.phi);
            state.keys = {
              privateKey: pki2.rsa.setPrivateKey(
                state.n,
                state.e,
                d,
                state.p,
                state.q,
                d.mod(state.p1),
                d.mod(state.q1),
                state.q.modInverse(state.p)
              ),
              publicKey: pki2.rsa.setPublicKey(state.n, state.e)
            };
            callback(null, state.keys);
          }
        }
        function _bnToBytes(b) {
          var hex = b.toString(16);
          if (hex[0] >= "8") {
            hex = "00" + hex;
          }
          var bytes = forge2.util.hexToBytes(hex);
          if (bytes.length > 1 && // leading 0x00 for positive integer
          (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
          bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
            return bytes.substr(1);
          }
          return bytes;
        }
        function _getMillerRabinTests(bits2) {
          if (bits2 <= 100) return 27;
          if (bits2 <= 150) return 18;
          if (bits2 <= 200) return 15;
          if (bits2 <= 250) return 12;
          if (bits2 <= 300) return 9;
          if (bits2 <= 350) return 8;
          if (bits2 <= 400) return 7;
          if (bits2 <= 500) return 6;
          if (bits2 <= 600) return 5;
          if (bits2 <= 800) return 4;
          if (bits2 <= 1250) return 3;
          return 2;
        }
        function _detectNodeCrypto(fn) {
          return forge2.util.isNodejs && typeof _crypto[fn] === "function";
        }
        function _detectSubtleCrypto(fn) {
          return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.crypto === "object" && typeof util2.globalScope.crypto.subtle === "object" && typeof util2.globalScope.crypto.subtle[fn] === "function";
        }
        function _detectSubtleMsCrypto(fn) {
          return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.msCrypto === "object" && typeof util2.globalScope.msCrypto.subtle === "object" && typeof util2.globalScope.msCrypto.subtle[fn] === "function";
        }
        function _intToUint8Array(x) {
          var bytes = forge2.util.hexToBytes(x.toString(16));
          var buffer = new Uint8Array(bytes.length);
          for (var i = 0; i < bytes.length; ++i) {
            buffer[i] = bytes.charCodeAt(i);
          }
          return buffer;
        }
        return rsa;
      }
      var pbe;
      var hasRequiredPbe;
      function requirePbe() {
        if (hasRequiredPbe) return pbe;
        hasRequiredPbe = 1;
        var forge2 = requireForge();
        requireAes();
        requireAsn1();
        requireDes();
        requireMd();
        requireOids();
        requirePbkdf2();
        requirePem();
        requireRandom();
        requireRc2();
        requireRsa();
        requireUtil();
        if (typeof BigInteger === "undefined") {
          var BigInteger = forge2.jsbn.BigInteger;
        }
        var asn12 = forge2.asn1;
        var pki2 = forge2.pki = forge2.pki || {};
        pbe = pki2.pbe = forge2.pbe = forge2.pbe || {};
        var oids2 = pki2.oids;
        var encryptedPrivateKeyValidator = {
          name: "EncryptedPrivateKeyInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "encryptionOid"
            }, {
              name: "AlgorithmIdentifier.parameters",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "encryptionParams"
            }]
          }, {
            // encryptedData
            name: "EncryptedPrivateKeyInfo.encryptedData",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OCTETSTRING,
            constructed: false,
            capture: "encryptedData"
          }]
        };
        var PBES2AlgorithmsValidator = {
          name: "PBES2Algorithms",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.keyDerivationFunc",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "PBES2Algorithms.keyDerivationFunc.oid",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "kdfOid"
            }, {
              name: "PBES2Algorithms.params",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "PBES2Algorithms.params.salt",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.OCTETSTRING,
                constructed: false,
                capture: "kdfSalt"
              }, {
                name: "PBES2Algorithms.params.iterationCount",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.INTEGER,
                constructed: false,
                capture: "kdfIterationCount"
              }, {
                name: "PBES2Algorithms.params.keyLength",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.INTEGER,
                constructed: false,
                optional: true,
                capture: "keyLength"
              }, {
                // prf
                name: "PBES2Algorithms.params.prf",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.SEQUENCE,
                constructed: true,
                optional: true,
                value: [{
                  name: "PBES2Algorithms.params.prf.algorithm",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.OID,
                  constructed: false,
                  capture: "prfOid"
                }]
              }]
            }]
          }, {
            name: "PBES2Algorithms.encryptionScheme",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "PBES2Algorithms.encryptionScheme.oid",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "encOid"
            }, {
              name: "PBES2Algorithms.encryptionScheme.iv",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OCTETSTRING,
              constructed: false,
              capture: "encIv"
            }]
          }]
        };
        var pkcs12PbeParamsValidator = {
          name: "pkcs-12PbeParams",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "pkcs-12PbeParams.salt",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OCTETSTRING,
            constructed: false,
            capture: "salt"
          }, {
            name: "pkcs-12PbeParams.iterations",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "iterations"
          }]
        };
        pki2.encryptPrivateKeyInfo = function(obj, password, options) {
          options = options || {};
          options.saltSize = options.saltSize || 8;
          options.count = options.count || 2048;
          options.algorithm = options.algorithm || "aes128";
          options.prfAlgorithm = options.prfAlgorithm || "sha1";
          var salt = forge2.random.getBytesSync(options.saltSize);
          var count = options.count;
          var countBytes = asn12.integerToDer(count);
          var dkLen;
          var encryptionAlgorithm;
          var encryptedData;
          if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
            var ivLen, encOid, cipherFn;
            switch (options.algorithm) {
              case "aes128":
                dkLen = 16;
                ivLen = 16;
                encOid = oids2["aes128-CBC"];
                cipherFn = forge2.aes.createEncryptionCipher;
                break;
              case "aes192":
                dkLen = 24;
                ivLen = 16;
                encOid = oids2["aes192-CBC"];
                cipherFn = forge2.aes.createEncryptionCipher;
                break;
              case "aes256":
                dkLen = 32;
                ivLen = 16;
                encOid = oids2["aes256-CBC"];
                cipherFn = forge2.aes.createEncryptionCipher;
                break;
              case "des":
                dkLen = 8;
                ivLen = 8;
                encOid = oids2["desCBC"];
                cipherFn = forge2.des.createEncryptionCipher;
                break;
              default:
                var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
                error.algorithm = options.algorithm;
                throw error;
            }
            var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
            var md2 = prfAlgorithmToMessageDigest(prfAlgorithm);
            var dk = forge2.pkcs5.pbkdf2(password, salt, count, dkLen, md2);
            var iv = forge2.random.getBytesSync(ivLen);
            var cipher2 = cipherFn(dk);
            cipher2.start(iv);
            cipher2.update(asn12.toDer(obj));
            cipher2.finish();
            encryptedData = cipher2.output.getBytes();
            var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
            encryptionAlgorithm = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.SEQUENCE,
              true,
              [
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(oids2["pkcs5PBES2"]).getBytes()
                ),
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                  // keyDerivationFunc
                  asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.OID,
                      false,
                      asn12.oidToDer(oids2["pkcs5PBKDF2"]).getBytes()
                    ),
                    // PBKDF2-params
                    params
                  ]),
                  // encryptionScheme
                  asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.OID,
                      false,
                      asn12.oidToDer(encOid).getBytes()
                    ),
                    // iv
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.OCTETSTRING,
                      false,
                      iv
                    )
                  ])
                ])
              ]
            );
          } else if (options.algorithm === "3des") {
            dkLen = 24;
            var saltBytes = new forge2.util.ByteBuffer(salt);
            var dk = pki2.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
            var iv = pki2.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
            var cipher2 = forge2.des.createEncryptionCipher(dk);
            cipher2.start(iv);
            cipher2.update(asn12.toDer(obj));
            cipher2.finish();
            encryptedData = cipher2.output.getBytes();
            encryptionAlgorithm = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.SEQUENCE,
              true,
              [
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(oids2["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
                ),
                // pkcs-12PbeParams
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                  // salt
                  asn12.create(asn12.Class.UNIVERSAL, asn12.Type.OCTETSTRING, false, salt),
                  // iteration count
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.INTEGER,
                    false,
                    countBytes.getBytes()
                  )
                ])
              ]
            );
          } else {
            var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error.algorithm = options.algorithm;
            throw error;
          }
          var rval = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // encryptionAlgorithm
            encryptionAlgorithm,
            // encryptedData
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OCTETSTRING,
              false,
              encryptedData
            )
          ]);
          return rval;
        };
        pki2.decryptPrivateKeyInfo = function(obj, password) {
          var rval = null;
          var capture = {};
          var errors = [];
          if (!asn12.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
            var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
            error.errors = errors;
            throw error;
          }
          var oid = asn12.derToOid(capture.encryptionOid);
          var cipher2 = pki2.pbe.getCipher(oid, capture.encryptionParams, password);
          var encrypted = forge2.util.createBuffer(capture.encryptedData);
          cipher2.update(encrypted);
          if (cipher2.finish()) {
            rval = asn12.fromDer(cipher2.output);
          }
          return rval;
        };
        pki2.encryptedPrivateKeyToPem = function(epki, maxline) {
          var msg = {
            type: "ENCRYPTED PRIVATE KEY",
            body: asn12.toDer(epki).getBytes()
          };
          return forge2.pem.encode(msg, { maxline });
        };
        pki2.encryptedPrivateKeyFromPem = function(pem2) {
          var msg = forge2.pem.decode(pem2)[0];
          if (msg.type !== "ENCRYPTED PRIVATE KEY") {
            var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
          }
          return asn12.fromDer(msg.body);
        };
        pki2.encryptRsaPrivateKey = function(rsaKey, password, options) {
          options = options || {};
          if (!options.legacy) {
            var rval = pki2.wrapRsaPrivateKey(pki2.privateKeyToAsn1(rsaKey));
            rval = pki2.encryptPrivateKeyInfo(rval, password, options);
            return pki2.encryptedPrivateKeyToPem(rval);
          }
          var algorithm;
          var iv;
          var dkLen;
          var cipherFn;
          switch (options.algorithm) {
            case "aes128":
              algorithm = "AES-128-CBC";
              dkLen = 16;
              iv = forge2.random.getBytesSync(16);
              cipherFn = forge2.aes.createEncryptionCipher;
              break;
            case "aes192":
              algorithm = "AES-192-CBC";
              dkLen = 24;
              iv = forge2.random.getBytesSync(16);
              cipherFn = forge2.aes.createEncryptionCipher;
              break;
            case "aes256":
              algorithm = "AES-256-CBC";
              dkLen = 32;
              iv = forge2.random.getBytesSync(16);
              cipherFn = forge2.aes.createEncryptionCipher;
              break;
            case "3des":
              algorithm = "DES-EDE3-CBC";
              dkLen = 24;
              iv = forge2.random.getBytesSync(8);
              cipherFn = forge2.des.createEncryptionCipher;
              break;
            case "des":
              algorithm = "DES-CBC";
              dkLen = 8;
              iv = forge2.random.getBytesSync(8);
              cipherFn = forge2.des.createEncryptionCipher;
              break;
            default:
              var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
              error.algorithm = options.algorithm;
              throw error;
          }
          var dk = forge2.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
          var cipher2 = cipherFn(dk);
          cipher2.start(iv);
          cipher2.update(asn12.toDer(pki2.privateKeyToAsn1(rsaKey)));
          cipher2.finish();
          var msg = {
            type: "RSA PRIVATE KEY",
            procType: {
              version: "4",
              type: "ENCRYPTED"
            },
            dekInfo: {
              algorithm,
              parameters: forge2.util.bytesToHex(iv).toUpperCase()
            },
            body: cipher2.output.getBytes()
          };
          return forge2.pem.encode(msg);
        };
        pki2.decryptRsaPrivateKey = function(pem2, password) {
          var rval = null;
          var msg = forge2.pem.decode(pem2)[0];
          if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
            var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
            error.headerType = error;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            var dkLen;
            var cipherFn;
            switch (msg.dekInfo.algorithm) {
              case "DES-CBC":
                dkLen = 8;
                cipherFn = forge2.des.createDecryptionCipher;
                break;
              case "DES-EDE3-CBC":
                dkLen = 24;
                cipherFn = forge2.des.createDecryptionCipher;
                break;
              case "AES-128-CBC":
                dkLen = 16;
                cipherFn = forge2.aes.createDecryptionCipher;
                break;
              case "AES-192-CBC":
                dkLen = 24;
                cipherFn = forge2.aes.createDecryptionCipher;
                break;
              case "AES-256-CBC":
                dkLen = 32;
                cipherFn = forge2.aes.createDecryptionCipher;
                break;
              case "RC2-40-CBC":
                dkLen = 5;
                cipherFn = function(key) {
                  return forge2.rc2.createDecryptionCipher(key, 40);
                };
                break;
              case "RC2-64-CBC":
                dkLen = 8;
                cipherFn = function(key) {
                  return forge2.rc2.createDecryptionCipher(key, 64);
                };
                break;
              case "RC2-128-CBC":
                dkLen = 16;
                cipherFn = function(key) {
                  return forge2.rc2.createDecryptionCipher(key, 128);
                };
                break;
              default:
                var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
                error.algorithm = msg.dekInfo.algorithm;
                throw error;
            }
            var iv = forge2.util.hexToBytes(msg.dekInfo.parameters);
            var dk = forge2.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
            var cipher2 = cipherFn(dk);
            cipher2.start(iv);
            cipher2.update(forge2.util.createBuffer(msg.body));
            if (cipher2.finish()) {
              rval = cipher2.output.getBytes();
            } else {
              return rval;
            }
          } else {
            rval = msg.body;
          }
          if (msg.type === "ENCRYPTED PRIVATE KEY") {
            rval = pki2.decryptPrivateKeyInfo(asn12.fromDer(rval), password);
          } else {
            rval = asn12.fromDer(rval);
          }
          if (rval !== null) {
            rval = pki2.privateKeyFromAsn1(rval);
          }
          return rval;
        };
        pki2.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md2) {
          var j, l;
          if (typeof md2 === "undefined" || md2 === null) {
            if (!("sha1" in forge2.md)) {
              throw new Error('"sha1" hash algorithm unavailable.');
            }
            md2 = forge2.md.sha1.create();
          }
          var u = md2.digestLength;
          var v = md2.blockLength;
          var result = new forge2.util.ByteBuffer();
          var passBuf = new forge2.util.ByteBuffer();
          if (password !== null && password !== void 0) {
            for (l = 0; l < password.length; l++) {
              passBuf.putInt16(password.charCodeAt(l));
            }
            passBuf.putInt16(0);
          }
          var p = passBuf.length();
          var s = salt.length();
          var D = new forge2.util.ByteBuffer();
          D.fillWithByte(id, v);
          var Slen = v * Math.ceil(s / v);
          var S = new forge2.util.ByteBuffer();
          for (l = 0; l < Slen; l++) {
            S.putByte(salt.at(l % s));
          }
          var Plen = v * Math.ceil(p / v);
          var P = new forge2.util.ByteBuffer();
          for (l = 0; l < Plen; l++) {
            P.putByte(passBuf.at(l % p));
          }
          var I = S;
          I.putBuffer(P);
          var c = Math.ceil(n / u);
          for (var i = 1; i <= c; i++) {
            var buf = new forge2.util.ByteBuffer();
            buf.putBytes(D.bytes());
            buf.putBytes(I.bytes());
            for (var round = 0; round < iter; round++) {
              md2.start();
              md2.update(buf.getBytes());
              buf = md2.digest();
            }
            var B = new forge2.util.ByteBuffer();
            for (l = 0; l < v; l++) {
              B.putByte(buf.at(l % u));
            }
            var k = Math.ceil(s / v) + Math.ceil(p / v);
            var Inew = new forge2.util.ByteBuffer();
            for (j = 0; j < k; j++) {
              var chunk = new forge2.util.ByteBuffer(I.getBytes(v));
              var x = 511;
              for (l = B.length() - 1; l >= 0; l--) {
                x = x >> 8;
                x += B.at(l) + chunk.at(l);
                chunk.setAt(l, x & 255);
              }
              Inew.putBuffer(chunk);
            }
            I = Inew;
            result.putBuffer(buf);
          }
          result.truncate(result.length() - n);
          return result;
        };
        pki2.pbe.getCipher = function(oid, params, password) {
          switch (oid) {
            case pki2.oids["pkcs5PBES2"]:
              return pki2.pbe.getCipherForPBES2(oid, params, password);
            case pki2.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
            case pki2.oids["pbewithSHAAnd40BitRC2-CBC"]:
              return pki2.pbe.getCipherForPKCS12PBE(oid, params, password);
            default:
              var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
              error.oid = oid;
              error.supportedOids = [
                "pkcs5PBES2",
                "pbeWithSHAAnd3-KeyTripleDES-CBC",
                "pbewithSHAAnd40BitRC2-CBC"
              ];
              throw error;
          }
        };
        pki2.pbe.getCipherForPBES2 = function(oid, params, password) {
          var capture = {};
          var errors = [];
          if (!asn12.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
            var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
            error.errors = errors;
            throw error;
          }
          oid = asn12.derToOid(capture.kdfOid);
          if (oid !== pki2.oids["pkcs5PBKDF2"]) {
            var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
            error.oid = oid;
            error.supportedOids = ["pkcs5PBKDF2"];
            throw error;
          }
          oid = asn12.derToOid(capture.encOid);
          if (oid !== pki2.oids["aes128-CBC"] && oid !== pki2.oids["aes192-CBC"] && oid !== pki2.oids["aes256-CBC"] && oid !== pki2.oids["des-EDE3-CBC"] && oid !== pki2.oids["desCBC"]) {
            var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
            error.oid = oid;
            error.supportedOids = [
              "aes128-CBC",
              "aes192-CBC",
              "aes256-CBC",
              "des-EDE3-CBC",
              "desCBC"
            ];
            throw error;
          }
          var salt = capture.kdfSalt;
          var count = forge2.util.createBuffer(capture.kdfIterationCount);
          count = count.getInt(count.length() << 3);
          var dkLen;
          var cipherFn;
          switch (pki2.oids[oid]) {
            case "aes128-CBC":
              dkLen = 16;
              cipherFn = forge2.aes.createDecryptionCipher;
              break;
            case "aes192-CBC":
              dkLen = 24;
              cipherFn = forge2.aes.createDecryptionCipher;
              break;
            case "aes256-CBC":
              dkLen = 32;
              cipherFn = forge2.aes.createDecryptionCipher;
              break;
            case "des-EDE3-CBC":
              dkLen = 24;
              cipherFn = forge2.des.createDecryptionCipher;
              break;
            case "desCBC":
              dkLen = 8;
              cipherFn = forge2.des.createDecryptionCipher;
              break;
          }
          var md2 = prfOidToMessageDigest(capture.prfOid);
          var dk = forge2.pkcs5.pbkdf2(password, salt, count, dkLen, md2);
          var iv = capture.encIv;
          var cipher2 = cipherFn(dk);
          cipher2.start(iv);
          return cipher2;
        };
        pki2.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
          var capture = {};
          var errors = [];
          if (!asn12.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
            var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
            error.errors = errors;
            throw error;
          }
          var salt = forge2.util.createBuffer(capture.salt);
          var count = forge2.util.createBuffer(capture.iterations);
          count = count.getInt(count.length() << 3);
          var dkLen, dIvLen, cipherFn;
          switch (oid) {
            case pki2.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
              dkLen = 24;
              dIvLen = 8;
              cipherFn = forge2.des.startDecrypting;
              break;
            case pki2.oids["pbewithSHAAnd40BitRC2-CBC"]:
              dkLen = 5;
              dIvLen = 8;
              cipherFn = function(key2, iv2) {
                var cipher2 = forge2.rc2.createDecryptionCipher(key2, 40);
                cipher2.start(iv2, null);
                return cipher2;
              };
              break;
            default:
              var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
              error.oid = oid;
              throw error;
          }
          var md2 = prfOidToMessageDigest(capture.prfOid);
          var key = pki2.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md2);
          md2.start();
          var iv = pki2.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md2);
          return cipherFn(key, iv);
        };
        pki2.pbe.opensslDeriveBytes = function(password, salt, dkLen, md2) {
          if (typeof md2 === "undefined" || md2 === null) {
            if (!("md5" in forge2.md)) {
              throw new Error('"md5" hash algorithm unavailable.');
            }
            md2 = forge2.md.md5.create();
          }
          if (salt === null) {
            salt = "";
          }
          var digests = [hash(md2, password + salt)];
          for (var length = 16, i = 1; length < dkLen; ++i, length += 16) {
            digests.push(hash(md2, digests[i - 1] + password + salt));
          }
          return digests.join("").substr(0, dkLen);
        };
        function hash(md2, bytes) {
          return md2.start().update(bytes).digest().getBytes();
        }
        function prfOidToMessageDigest(prfOid) {
          var prfAlgorithm;
          if (!prfOid) {
            prfAlgorithm = "hmacWithSHA1";
          } else {
            prfAlgorithm = pki2.oids[asn12.derToOid(prfOid)];
            if (!prfAlgorithm) {
              var error = new Error("Unsupported PRF OID.");
              error.oid = prfOid;
              error.supported = [
                "hmacWithSHA1",
                "hmacWithSHA224",
                "hmacWithSHA256",
                "hmacWithSHA384",
                "hmacWithSHA512"
              ];
              throw error;
            }
          }
          return prfAlgorithmToMessageDigest(prfAlgorithm);
        }
        function prfAlgorithmToMessageDigest(prfAlgorithm) {
          var factory = forge2.md;
          switch (prfAlgorithm) {
            case "hmacWithSHA224":
              factory = forge2.md.sha512;
            case "hmacWithSHA1":
            case "hmacWithSHA256":
            case "hmacWithSHA384":
            case "hmacWithSHA512":
              prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
              break;
            default:
              var error = new Error("Unsupported PRF algorithm.");
              error.algorithm = prfAlgorithm;
              error.supported = [
                "hmacWithSHA1",
                "hmacWithSHA224",
                "hmacWithSHA256",
                "hmacWithSHA384",
                "hmacWithSHA512"
              ];
              throw error;
          }
          if (!factory || !(prfAlgorithm in factory)) {
            throw new Error("Unknown hash algorithm: " + prfAlgorithm);
          }
          return factory[prfAlgorithm].create();
        }
        function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
          var params = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // salt
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OCTETSTRING,
              false,
              salt
            ),
            // iteration count
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              countBytes.getBytes()
            )
          ]);
          if (prfAlgorithm !== "hmacWithSHA1") {
            params.value.push(
              // key length
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.INTEGER,
                false,
                forge2.util.hexToBytes(dkLen.toString(16))
              ),
              // AlgorithmIdentifier
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // algorithm
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(pki2.oids[prfAlgorithm]).getBytes()
                ),
                // parameters (null)
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
              ])
            );
          }
          return params;
        }
        return pbe;
      }
      var pkcs12 = { exports: {} };
      var pkcs7asn1 = { exports: {} };
      var hasRequiredPkcs7asn1;
      function requirePkcs7asn1() {
        if (hasRequiredPkcs7asn1) return pkcs7asn1.exports;
        hasRequiredPkcs7asn1 = 1;
        var forge2 = requireForge();
        requireAsn1();
        requireUtil();
        var asn12 = forge2.asn1;
        var p7v = pkcs7asn1.exports = forge2.pkcs7asn1 = forge2.pkcs7asn1 || {};
        forge2.pkcs7 = forge2.pkcs7 || {};
        forge2.pkcs7.asn1 = p7v;
        var contentInfoValidator = {
          name: "ContentInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "ContentInfo.ContentType",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OID,
            constructed: false,
            capture: "contentType"
          }, {
            name: "ContentInfo.content",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            captureAsn1: "content"
          }]
        };
        p7v.contentInfoValidator = contentInfoValidator;
        var encryptedContentInfoValidator = {
          name: "EncryptedContentInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "EncryptedContentInfo.contentType",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OID,
            constructed: false,
            capture: "contentType"
          }, {
            name: "EncryptedContentInfo.contentEncryptionAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "encAlgorithm"
            }, {
              name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
              tagClass: asn12.Class.UNIVERSAL,
              captureAsn1: "encParameter"
            }]
          }, {
            name: "EncryptedContentInfo.encryptedContent",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            type: 0,
            /* The PKCS#7 structure output by OpenSSL somewhat differs from what
             * other implementations do generate.
             *
             * OpenSSL generates a structure like this:
             * SEQUENCE {
             *    ...
             *    [0]
             *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
             *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
             *       ...
             * }
             *
             * Whereas other implementations (and this PKCS#7 module) generate:
             * SEQUENCE {
             *    ...
             *    [0] {
             *       OCTET STRING
             *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
             *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
             *          ...
             *    }
             * }
             *
             * In order to support both, we just capture the context specific
             * field here.  The OCTET STRING bit is removed below.
             */
            capture: "encryptedContent",
            captureAsn1: "encryptedContentAsn1"
          }]
        };
        p7v.envelopedDataValidator = {
          name: "EnvelopedData",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "EnvelopedData.Version",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "version"
          }, {
            name: "EnvelopedData.RecipientInfos",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SET,
            constructed: true,
            captureAsn1: "recipientInfos"
          }].concat(encryptedContentInfoValidator)
        };
        p7v.encryptedDataValidator = {
          name: "EncryptedData",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "EncryptedData.Version",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "version"
          }].concat(encryptedContentInfoValidator)
        };
        var signerValidator = {
          name: "SignerInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "SignerInfo.version",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false
          }, {
            name: "SignerInfo.issuerAndSerialNumber",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "SignerInfo.issuerAndSerialNumber.issuer",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "issuer"
            }, {
              name: "SignerInfo.issuerAndSerialNumber.serialNumber",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.INTEGER,
              constructed: false,
              capture: "serial"
            }]
          }, {
            name: "SignerInfo.digestAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "SignerInfo.digestAlgorithm.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "digestAlgorithm"
            }, {
              name: "SignerInfo.digestAlgorithm.parameter",
              tagClass: asn12.Class.UNIVERSAL,
              constructed: false,
              captureAsn1: "digestParameter",
              optional: true
            }]
          }, {
            name: "SignerInfo.authenticatedAttributes",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            capture: "authenticatedAttributes"
          }, {
            name: "SignerInfo.digestEncryptionAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            capture: "signatureAlgorithm"
          }, {
            name: "SignerInfo.encryptedDigest",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OCTETSTRING,
            constructed: false,
            capture: "signature"
          }, {
            name: "SignerInfo.unauthenticatedAttributes",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            capture: "unauthenticatedAttributes"
          }]
        };
        p7v.signedDataValidator = {
          name: "SignedData",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "SignedData.Version",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.INTEGER,
              constructed: false,
              capture: "version"
            },
            {
              name: "SignedData.DigestAlgorithms",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SET,
              constructed: true,
              captureAsn1: "digestAlgorithms"
            },
            contentInfoValidator,
            {
              name: "SignedData.Certificates",
              tagClass: asn12.Class.CONTEXT_SPECIFIC,
              type: 0,
              optional: true,
              captureAsn1: "certificates"
            },
            {
              name: "SignedData.CertificateRevocationLists",
              tagClass: asn12.Class.CONTEXT_SPECIFIC,
              type: 1,
              optional: true,
              captureAsn1: "crls"
            },
            {
              name: "SignedData.SignerInfos",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SET,
              capture: "signerInfos",
              optional: true,
              value: [signerValidator]
            }
          ]
        };
        p7v.recipientInfoValidator = {
          name: "RecipientInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "RecipientInfo.version",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "version"
          }, {
            name: "RecipientInfo.issuerAndSerial",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "RecipientInfo.issuerAndSerial.issuer",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "issuer"
            }, {
              name: "RecipientInfo.issuerAndSerial.serialNumber",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.INTEGER,
              constructed: false,
              capture: "serial"
            }]
          }, {
            name: "RecipientInfo.keyEncryptionAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "encAlgorithm"
            }, {
              name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
              tagClass: asn12.Class.UNIVERSAL,
              constructed: false,
              captureAsn1: "encParameter",
              optional: true
            }]
          }, {
            name: "RecipientInfo.encryptedKey",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OCTETSTRING,
            constructed: false,
            capture: "encKey"
          }]
        };
        return pkcs7asn1.exports;
      }
      var x509 = { exports: {} };
      var mgf1 = { exports: {} };
      var hasRequiredMgf1;
      function requireMgf1() {
        if (hasRequiredMgf1) return mgf1.exports;
        hasRequiredMgf1 = 1;
        var forge2 = requireForge();
        requireUtil();
        forge2.mgf = forge2.mgf || {};
        var mgf1$1 = mgf1.exports = forge2.mgf.mgf1 = forge2.mgf1 = forge2.mgf1 || {};
        mgf1$1.create = function(md2) {
          var mgf2 = {
            /**
             * Generate mask of specified length.
             *
             * @param {String} seed The seed for mask generation.
             * @param maskLen Number of bytes to generate.
             * @return {String} The generated mask.
             */
            generate: function(seed, maskLen) {
              var t = new forge2.util.ByteBuffer();
              var len = Math.ceil(maskLen / md2.digestLength);
              for (var i = 0; i < len; i++) {
                var c = new forge2.util.ByteBuffer();
                c.putInt32(i);
                md2.start();
                md2.update(seed + c.getBytes());
                t.putBuffer(md2.digest());
              }
              t.truncate(t.length() - maskLen);
              return t.getBytes();
            }
          };
          return mgf2;
        };
        return mgf1.exports;
      }
      var mgf;
      var hasRequiredMgf;
      function requireMgf() {
        if (hasRequiredMgf) return mgf;
        hasRequiredMgf = 1;
        var forge2 = requireForge();
        requireMgf1();
        mgf = forge2.mgf = forge2.mgf || {};
        forge2.mgf.mgf1 = forge2.mgf1;
        return mgf;
      }
      var pss = { exports: {} };
      var hasRequiredPss;
      function requirePss() {
        if (hasRequiredPss) return pss.exports;
        hasRequiredPss = 1;
        var forge2 = requireForge();
        requireRandom();
        requireUtil();
        var pss$1 = pss.exports = forge2.pss = forge2.pss || {};
        pss$1.create = function(options) {
          if (arguments.length === 3) {
            options = {
              md: arguments[0],
              mgf: arguments[1],
              saltLength: arguments[2]
            };
          }
          var hash = options.md;
          var mgf2 = options.mgf;
          var hLen = hash.digestLength;
          var salt_ = options.salt || null;
          if (typeof salt_ === "string") {
            salt_ = forge2.util.createBuffer(salt_);
          }
          var sLen;
          if ("saltLength" in options) {
            sLen = options.saltLength;
          } else if (salt_ !== null) {
            sLen = salt_.length();
          } else {
            throw new Error("Salt length not specified or specific salt not given.");
          }
          if (salt_ !== null && salt_.length() !== sLen) {
            throw new Error("Given salt length does not match length of given salt.");
          }
          var prng2 = options.prng || forge2.random;
          var pssobj = {};
          pssobj.encode = function(md2, modBits) {
            var i;
            var emBits = modBits - 1;
            var emLen = Math.ceil(emBits / 8);
            var mHash = md2.digest().getBytes();
            if (emLen < hLen + sLen + 2) {
              throw new Error("Message is too long to encrypt.");
            }
            var salt;
            if (salt_ === null) {
              salt = prng2.getBytesSync(sLen);
            } else {
              salt = salt_.bytes();
            }
            var m_ = new forge2.util.ByteBuffer();
            m_.fillWithByte(0, 8);
            m_.putBytes(mHash);
            m_.putBytes(salt);
            hash.start();
            hash.update(m_.getBytes());
            var h = hash.digest().getBytes();
            var ps = new forge2.util.ByteBuffer();
            ps.fillWithByte(0, emLen - sLen - hLen - 2);
            ps.putByte(1);
            ps.putBytes(salt);
            var db = ps.getBytes();
            var maskLen = emLen - hLen - 1;
            var dbMask = mgf2.generate(h, maskLen);
            var maskedDB = "";
            for (i = 0; i < maskLen; i++) {
              maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
            }
            var mask = 65280 >> 8 * emLen - emBits & 255;
            maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
            return maskedDB + h + String.fromCharCode(188);
          };
          pssobj.verify = function(mHash, em, modBits) {
            var i;
            var emBits = modBits - 1;
            var emLen = Math.ceil(emBits / 8);
            em = em.substr(-emLen);
            if (emLen < hLen + sLen + 2) {
              throw new Error("Inconsistent parameters to PSS signature verification.");
            }
            if (em.charCodeAt(emLen - 1) !== 188) {
              throw new Error("Encoded message does not end in 0xBC.");
            }
            var maskLen = emLen - hLen - 1;
            var maskedDB = em.substr(0, maskLen);
            var h = em.substr(maskLen, hLen);
            var mask = 65280 >> 8 * emLen - emBits & 255;
            if ((maskedDB.charCodeAt(0) & mask) !== 0) {
              throw new Error("Bits beyond keysize not zero as expected.");
            }
            var dbMask = mgf2.generate(h, maskLen);
            var db = "";
            for (i = 0; i < maskLen; i++) {
              db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
            }
            db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
            var checkLen = emLen - hLen - sLen - 2;
            for (i = 0; i < checkLen; i++) {
              if (db.charCodeAt(i) !== 0) {
                throw new Error("Leftmost octets not zero as expected");
              }
            }
            if (db.charCodeAt(checkLen) !== 1) {
              throw new Error("Inconsistent PSS signature, 0x01 marker not found");
            }
            var salt = db.substr(-sLen);
            var m_ = new forge2.util.ByteBuffer();
            m_.fillWithByte(0, 8);
            m_.putBytes(mHash);
            m_.putBytes(salt);
            hash.start();
            hash.update(m_.getBytes());
            var h_ = hash.digest().getBytes();
            return h === h_;
          };
          return pssobj;
        };
        return pss.exports;
      }
      var hasRequiredX509;
      function requireX509() {
        if (hasRequiredX509) return x509.exports;
        hasRequiredX509 = 1;
        var forge2 = requireForge();
        requireAes();
        requireAsn1();
        requireDes();
        requireMd();
        requireMgf();
        requireOids();
        requirePem();
        requirePss();
        requireRsa();
        requireUtil();
        var asn12 = forge2.asn1;
        var pki2 = x509.exports = forge2.pki = forge2.pki || {};
        var oids2 = pki2.oids;
        var _shortNames = {};
        _shortNames["CN"] = oids2["commonName"];
        _shortNames["commonName"] = "CN";
        _shortNames["C"] = oids2["countryName"];
        _shortNames["countryName"] = "C";
        _shortNames["L"] = oids2["localityName"];
        _shortNames["localityName"] = "L";
        _shortNames["ST"] = oids2["stateOrProvinceName"];
        _shortNames["stateOrProvinceName"] = "ST";
        _shortNames["O"] = oids2["organizationName"];
        _shortNames["organizationName"] = "O";
        _shortNames["OU"] = oids2["organizationalUnitName"];
        _shortNames["organizationalUnitName"] = "OU";
        _shortNames["E"] = oids2["emailAddress"];
        _shortNames["emailAddress"] = "E";
        var publicKeyValidator = forge2.pki.rsa.publicKeyValidator;
        var x509CertificateValidator = {
          name: "Certificate",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "Certificate.TBSCertificate",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "tbsCertificate",
            value: [
              {
                name: "Certificate.TBSCertificate.version",
                tagClass: asn12.Class.CONTEXT_SPECIFIC,
                type: 0,
                constructed: true,
                optional: true,
                value: [{
                  name: "Certificate.TBSCertificate.version.integer",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.INTEGER,
                  constructed: false,
                  capture: "certVersion"
                }]
              },
              {
                name: "Certificate.TBSCertificate.serialNumber",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.INTEGER,
                constructed: false,
                capture: "certSerialNumber"
              },
              {
                name: "Certificate.TBSCertificate.signature",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.SEQUENCE,
                constructed: true,
                value: [{
                  name: "Certificate.TBSCertificate.signature.algorithm",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.OID,
                  constructed: false,
                  capture: "certinfoSignatureOid"
                }, {
                  name: "Certificate.TBSCertificate.signature.parameters",
                  tagClass: asn12.Class.UNIVERSAL,
                  optional: true,
                  captureAsn1: "certinfoSignatureParams"
                }]
              },
              {
                name: "Certificate.TBSCertificate.issuer",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.SEQUENCE,
                constructed: true,
                captureAsn1: "certIssuer"
              },
              {
                name: "Certificate.TBSCertificate.validity",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.SEQUENCE,
                constructed: true,
                // Note: UTC and generalized times may both appear so the capture
                // names are based on their detected order, the names used below
                // are only for the common case, which validity time really means
                // "notBefore" and which means "notAfter" will be determined by order
                value: [{
                  // notBefore (Time) (UTC time case)
                  name: "Certificate.TBSCertificate.validity.notBefore (utc)",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.UTCTIME,
                  constructed: false,
                  optional: true,
                  capture: "certValidity1UTCTime"
                }, {
                  // notBefore (Time) (generalized time case)
                  name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.GENERALIZEDTIME,
                  constructed: false,
                  optional: true,
                  capture: "certValidity2GeneralizedTime"
                }, {
                  // notAfter (Time) (only UTC time is supported)
                  name: "Certificate.TBSCertificate.validity.notAfter (utc)",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.UTCTIME,
                  constructed: false,
                  optional: true,
                  capture: "certValidity3UTCTime"
                }, {
                  // notAfter (Time) (only UTC time is supported)
                  name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.GENERALIZEDTIME,
                  constructed: false,
                  optional: true,
                  capture: "certValidity4GeneralizedTime"
                }]
              },
              {
                // Name (subject) (RDNSequence)
                name: "Certificate.TBSCertificate.subject",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.SEQUENCE,
                constructed: true,
                captureAsn1: "certSubject"
              },
              // SubjectPublicKeyInfo
              publicKeyValidator,
              {
                // issuerUniqueID (optional)
                name: "Certificate.TBSCertificate.issuerUniqueID",
                tagClass: asn12.Class.CONTEXT_SPECIFIC,
                type: 1,
                constructed: true,
                optional: true,
                value: [{
                  name: "Certificate.TBSCertificate.issuerUniqueID.id",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.BITSTRING,
                  constructed: false,
                  // TODO: support arbitrary bit length ids
                  captureBitStringValue: "certIssuerUniqueId"
                }]
              },
              {
                // subjectUniqueID (optional)
                name: "Certificate.TBSCertificate.subjectUniqueID",
                tagClass: asn12.Class.CONTEXT_SPECIFIC,
                type: 2,
                constructed: true,
                optional: true,
                value: [{
                  name: "Certificate.TBSCertificate.subjectUniqueID.id",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.BITSTRING,
                  constructed: false,
                  // TODO: support arbitrary bit length ids
                  captureBitStringValue: "certSubjectUniqueId"
                }]
              },
              {
                // Extensions (optional)
                name: "Certificate.TBSCertificate.extensions",
                tagClass: asn12.Class.CONTEXT_SPECIFIC,
                type: 3,
                constructed: true,
                captureAsn1: "certExtensions",
                optional: true
              }
            ]
          }, {
            // AlgorithmIdentifier (signature algorithm)
            name: "Certificate.signatureAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              // algorithm
              name: "Certificate.signatureAlgorithm.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "certSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn12.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certSignatureParams"
            }]
          }, {
            // SignatureValue
            name: "Certificate.signatureValue",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.BITSTRING,
            constructed: false,
            captureBitStringValue: "certSignature"
          }]
        };
        var rsassaPssParameterValidator = {
          name: "rsapss",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "rsapss.hashAlgorithm",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            value: [{
              name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Class.SEQUENCE,
              constructed: true,
              optional: true,
              value: [{
                name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.OID,
                constructed: false,
                capture: "hashOid"
                /* parameter block omitted, for SHA1 NULL anyhow. */
              }]
            }]
          }, {
            name: "rsapss.maskGenAlgorithm",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Class.SEQUENCE,
              constructed: true,
              optional: true,
              value: [{
                name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.OID,
                constructed: false,
                capture: "maskGenOid"
              }, {
                name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.SEQUENCE,
                constructed: true,
                value: [{
                  name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.OID,
                  constructed: false,
                  capture: "maskGenHashOid"
                  /* parameter block omitted, for SHA1 NULL anyhow. */
                }]
              }]
            }]
          }, {
            name: "rsapss.saltLength",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            type: 2,
            optional: true,
            value: [{
              name: "rsapss.saltLength.saltLength",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Class.INTEGER,
              constructed: false,
              capture: "saltLength"
            }]
          }, {
            name: "rsapss.trailerField",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            type: 3,
            optional: true,
            value: [{
              name: "rsapss.trailer.trailer",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Class.INTEGER,
              constructed: false,
              capture: "trailer"
            }]
          }]
        };
        var certificationRequestInfoValidator = {
          name: "CertificationRequestInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfo",
          value: [
            {
              name: "CertificationRequestInfo.integer",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.INTEGER,
              constructed: false,
              capture: "certificationRequestInfoVersion"
            },
            {
              // Name (subject) (RDNSequence)
              name: "CertificationRequestInfo.subject",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "certificationRequestInfoSubject"
            },
            // SubjectPublicKeyInfo
            publicKeyValidator,
            {
              name: "CertificationRequestInfo.attributes",
              tagClass: asn12.Class.CONTEXT_SPECIFIC,
              type: 0,
              constructed: true,
              optional: true,
              capture: "certificationRequestInfoAttributes",
              value: [{
                name: "CertificationRequestInfo.attributes",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.SEQUENCE,
                constructed: true,
                value: [{
                  name: "CertificationRequestInfo.attributes.type",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.OID,
                  constructed: false
                }, {
                  name: "CertificationRequestInfo.attributes.value",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.SET,
                  constructed: true
                }]
              }]
            }
          ]
        };
        var certificationRequestValidator = {
          name: "CertificationRequest",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "csr",
          value: [
            certificationRequestInfoValidator,
            {
              // AlgorithmIdentifier (signature algorithm)
              name: "CertificationRequest.signatureAlgorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              value: [{
                // algorithm
                name: "CertificationRequest.signatureAlgorithm.algorithm",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.OID,
                constructed: false,
                capture: "csrSignatureOid"
              }, {
                name: "CertificationRequest.signatureAlgorithm.parameters",
                tagClass: asn12.Class.UNIVERSAL,
                optional: true,
                captureAsn1: "csrSignatureParams"
              }]
            },
            {
              // signature
              name: "CertificationRequest.signature",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "csrSignature"
            }
          ]
        };
        pki2.RDNAttributesAsArray = function(rdn, md2) {
          var rval = [];
          var set, attr, obj;
          for (var si = 0; si < rdn.value.length; ++si) {
            set = rdn.value[si];
            for (var i = 0; i < set.value.length; ++i) {
              obj = {};
              attr = set.value[i];
              obj.type = asn12.derToOid(attr.value[0].value);
              obj.value = attr.value[1].value;
              obj.valueTagClass = attr.value[1].type;
              if (obj.type in oids2) {
                obj.name = oids2[obj.type];
                if (obj.name in _shortNames) {
                  obj.shortName = _shortNames[obj.name];
                }
              }
              if (md2) {
                md2.update(obj.type);
                md2.update(obj.value);
              }
              rval.push(obj);
            }
          }
          return rval;
        };
        pki2.CRIAttributesAsArray = function(attributes) {
          var rval = [];
          for (var si = 0; si < attributes.length; ++si) {
            var seq = attributes[si];
            var type = asn12.derToOid(seq.value[0].value);
            var values = seq.value[1].value;
            for (var vi = 0; vi < values.length; ++vi) {
              var obj = {};
              obj.type = type;
              obj.value = values[vi].value;
              obj.valueTagClass = values[vi].type;
              if (obj.type in oids2) {
                obj.name = oids2[obj.type];
                if (obj.name in _shortNames) {
                  obj.shortName = _shortNames[obj.name];
                }
              }
              if (obj.type === oids2.extensionRequest) {
                obj.extensions = [];
                for (var ei = 0; ei < obj.value.length; ++ei) {
                  obj.extensions.push(pki2.certificateExtensionFromAsn1(obj.value[ei]));
                }
              }
              rval.push(obj);
            }
          }
          return rval;
        };
        function _getAttribute(obj, options) {
          if (typeof options === "string") {
            options = { shortName: options };
          }
          var rval = null;
          var attr;
          for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
            attr = obj.attributes[i];
            if (options.type && options.type === attr.type) {
              rval = attr;
            } else if (options.name && options.name === attr.name) {
              rval = attr;
            } else if (options.shortName && options.shortName === attr.shortName) {
              rval = attr;
            }
          }
          return rval;
        }
        var _readSignatureParameters = function(oid, obj, fillDefaults) {
          var params = {};
          if (oid !== oids2["RSASSA-PSS"]) {
            return params;
          }
          if (fillDefaults) {
            params = {
              hash: {
                algorithmOid: oids2["sha1"]
              },
              mgf: {
                algorithmOid: oids2["mgf1"],
                hash: {
                  algorithmOid: oids2["sha1"]
                }
              },
              saltLength: 20
            };
          }
          var capture = {};
          var errors = [];
          if (!asn12.validate(obj, rsassaPssParameterValidator, capture, errors)) {
            var error = new Error("Cannot read RSASSA-PSS parameter block.");
            error.errors = errors;
            throw error;
          }
          if (capture.hashOid !== void 0) {
            params.hash = params.hash || {};
            params.hash.algorithmOid = asn12.derToOid(capture.hashOid);
          }
          if (capture.maskGenOid !== void 0) {
            params.mgf = params.mgf || {};
            params.mgf.algorithmOid = asn12.derToOid(capture.maskGenOid);
            params.mgf.hash = params.mgf.hash || {};
            params.mgf.hash.algorithmOid = asn12.derToOid(capture.maskGenHashOid);
          }
          if (capture.saltLength !== void 0) {
            params.saltLength = capture.saltLength.charCodeAt(0);
          }
          return params;
        };
        var _createSignatureDigest = function(options) {
          switch (oids2[options.signatureOid]) {
            case "sha1WithRSAEncryption":
            // deprecated alias
            case "sha1WithRSASignature":
              return forge2.md.sha1.create();
            case "md5WithRSAEncryption":
              return forge2.md.md5.create();
            case "sha256WithRSAEncryption":
              return forge2.md.sha256.create();
            case "sha384WithRSAEncryption":
              return forge2.md.sha384.create();
            case "sha512WithRSAEncryption":
              return forge2.md.sha512.create();
            case "RSASSA-PSS":
              return forge2.md.sha256.create();
            default:
              var error = new Error(
                "Could not compute " + options.type + " digest. Unknown signature OID."
              );
              error.signatureOid = options.signatureOid;
              throw error;
          }
        };
        var _verifySignature = function(options) {
          var cert = options.certificate;
          var scheme;
          switch (cert.signatureOid) {
            case oids2.sha1WithRSAEncryption:
            // deprecated alias
            case oids2.sha1WithRSASignature:
              break;
            case oids2["RSASSA-PSS"]:
              var hash, mgf2;
              hash = oids2[cert.signatureParameters.mgf.hash.algorithmOid];
              if (hash === void 0 || forge2.md[hash] === void 0) {
                var error = new Error("Unsupported MGF hash function.");
                error.oid = cert.signatureParameters.mgf.hash.algorithmOid;
                error.name = hash;
                throw error;
              }
              mgf2 = oids2[cert.signatureParameters.mgf.algorithmOid];
              if (mgf2 === void 0 || forge2.mgf[mgf2] === void 0) {
                var error = new Error("Unsupported MGF function.");
                error.oid = cert.signatureParameters.mgf.algorithmOid;
                error.name = mgf2;
                throw error;
              }
              mgf2 = forge2.mgf[mgf2].create(forge2.md[hash].create());
              hash = oids2[cert.signatureParameters.hash.algorithmOid];
              if (hash === void 0 || forge2.md[hash] === void 0) {
                var error = new Error("Unsupported RSASSA-PSS hash function.");
                error.oid = cert.signatureParameters.hash.algorithmOid;
                error.name = hash;
                throw error;
              }
              scheme = forge2.pss.create(
                forge2.md[hash].create(),
                mgf2,
                cert.signatureParameters.saltLength
              );
              break;
          }
          return cert.publicKey.verify(
            options.md.digest().getBytes(),
            options.signature,
            scheme
          );
        };
        pki2.certificateFromPem = function(pem2, computeHash, strict) {
          var msg = forge2.pem.decode(pem2)[0];
          if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
            var error = new Error(
              'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
            );
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error(
              "Could not convert certificate from PEM; PEM is encrypted."
            );
          }
          var obj = asn12.fromDer(msg.body, strict);
          return pki2.certificateFromAsn1(obj, computeHash);
        };
        pki2.certificateToPem = function(cert, maxline) {
          var msg = {
            type: "CERTIFICATE",
            body: asn12.toDer(pki2.certificateToAsn1(cert)).getBytes()
          };
          return forge2.pem.encode(msg, { maxline });
        };
        pki2.publicKeyFromPem = function(pem2) {
          var msg = forge2.pem.decode(pem2)[0];
          if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
            var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert public key from PEM; PEM is encrypted.");
          }
          var obj = asn12.fromDer(msg.body);
          return pki2.publicKeyFromAsn1(obj);
        };
        pki2.publicKeyToPem = function(key, maxline) {
          var msg = {
            type: "PUBLIC KEY",
            body: asn12.toDer(pki2.publicKeyToAsn1(key)).getBytes()
          };
          return forge2.pem.encode(msg, { maxline });
        };
        pki2.publicKeyToRSAPublicKeyPem = function(key, maxline) {
          var msg = {
            type: "RSA PUBLIC KEY",
            body: asn12.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes()
          };
          return forge2.pem.encode(msg, { maxline });
        };
        pki2.getPublicKeyFingerprint = function(key, options) {
          options = options || {};
          var md2 = options.md || forge2.md.sha1.create();
          var type = options.type || "RSAPublicKey";
          var bytes;
          switch (type) {
            case "RSAPublicKey":
              bytes = asn12.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes();
              break;
            case "SubjectPublicKeyInfo":
              bytes = asn12.toDer(pki2.publicKeyToAsn1(key)).getBytes();
              break;
            default:
              throw new Error('Unknown fingerprint type "' + options.type + '".');
          }
          md2.start();
          md2.update(bytes);
          var digest = md2.digest();
          if (options.encoding === "hex") {
            var hex = digest.toHex();
            if (options.delimiter) {
              return hex.match(/.{2}/g).join(options.delimiter);
            }
            return hex;
          } else if (options.encoding === "binary") {
            return digest.getBytes();
          } else if (options.encoding) {
            throw new Error('Unknown encoding "' + options.encoding + '".');
          }
          return digest;
        };
        pki2.certificationRequestFromPem = function(pem2, computeHash, strict) {
          var msg = forge2.pem.decode(pem2)[0];
          if (msg.type !== "CERTIFICATE REQUEST") {
            var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
          }
          var obj = asn12.fromDer(msg.body, strict);
          return pki2.certificationRequestFromAsn1(obj, computeHash);
        };
        pki2.certificationRequestToPem = function(csr, maxline) {
          var msg = {
            type: "CERTIFICATE REQUEST",
            body: asn12.toDer(pki2.certificationRequestToAsn1(csr)).getBytes()
          };
          return forge2.pem.encode(msg, { maxline });
        };
        pki2.createCertificate = function() {
          var cert = {};
          cert.version = 2;
          cert.serialNumber = "00";
          cert.signatureOid = null;
          cert.signature = null;
          cert.siginfo = {};
          cert.siginfo.algorithmOid = null;
          cert.validity = {};
          cert.validity.notBefore = /* @__PURE__ */ new Date();
          cert.validity.notAfter = /* @__PURE__ */ new Date();
          cert.issuer = {};
          cert.issuer.getField = function(sn) {
            return _getAttribute(cert.issuer, sn);
          };
          cert.issuer.addField = function(attr) {
            _fillMissingFields([attr]);
            cert.issuer.attributes.push(attr);
          };
          cert.issuer.attributes = [];
          cert.issuer.hash = null;
          cert.subject = {};
          cert.subject.getField = function(sn) {
            return _getAttribute(cert.subject, sn);
          };
          cert.subject.addField = function(attr) {
            _fillMissingFields([attr]);
            cert.subject.attributes.push(attr);
          };
          cert.subject.attributes = [];
          cert.subject.hash = null;
          cert.extensions = [];
          cert.publicKey = null;
          cert.md = null;
          cert.setSubject = function(attrs, uniqueId) {
            _fillMissingFields(attrs);
            cert.subject.attributes = attrs;
            delete cert.subject.uniqueId;
            if (uniqueId) {
              cert.subject.uniqueId = uniqueId;
            }
            cert.subject.hash = null;
          };
          cert.setIssuer = function(attrs, uniqueId) {
            _fillMissingFields(attrs);
            cert.issuer.attributes = attrs;
            delete cert.issuer.uniqueId;
            if (uniqueId) {
              cert.issuer.uniqueId = uniqueId;
            }
            cert.issuer.hash = null;
          };
          cert.setExtensions = function(exts) {
            for (var i = 0; i < exts.length; ++i) {
              _fillMissingExtensionFields(exts[i], { cert });
            }
            cert.extensions = exts;
          };
          cert.getExtension = function(options) {
            if (typeof options === "string") {
              options = { name: options };
            }
            var rval = null;
            var ext;
            for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
              ext = cert.extensions[i];
              if (options.id && ext.id === options.id) {
                rval = ext;
              } else if (options.name && ext.name === options.name) {
                rval = ext;
              }
            }
            return rval;
          };
          cert.sign = function(key, md2) {
            cert.md = md2 || forge2.md.sha1.create();
            var algorithmOid = oids2[cert.md.algorithm + "WithRSAEncryption"];
            if (!algorithmOid) {
              var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
              error.algorithm = cert.md.algorithm;
              throw error;
            }
            cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
            cert.tbsCertificate = pki2.getTBSCertificate(cert);
            var bytes = asn12.toDer(cert.tbsCertificate);
            cert.md.update(bytes.getBytes());
            cert.signature = key.sign(cert.md);
          };
          cert.verify = function(child) {
            var rval = false;
            if (!cert.issued(child)) {
              var issuer = child.issuer;
              var subject = cert.subject;
              var error = new Error(
                "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
              );
              error.expectedIssuer = subject.attributes;
              error.actualIssuer = issuer.attributes;
              throw error;
            }
            var md2 = child.md;
            if (md2 === null) {
              md2 = _createSignatureDigest({
                signatureOid: child.signatureOid,
                type: "certificate"
              });
              var tbsCertificate = child.tbsCertificate || pki2.getTBSCertificate(child);
              var bytes = asn12.toDer(tbsCertificate);
              md2.update(bytes.getBytes());
            }
            if (md2 !== null) {
              rval = _verifySignature({
                certificate: cert,
                md: md2,
                signature: child.signature
              });
            }
            return rval;
          };
          cert.isIssuer = function(parent) {
            var rval = false;
            var i = cert.issuer;
            var s = parent.subject;
            if (i.hash && s.hash) {
              rval = i.hash === s.hash;
            } else if (i.attributes.length === s.attributes.length) {
              rval = true;
              var iattr, sattr;
              for (var n = 0; rval && n < i.attributes.length; ++n) {
                iattr = i.attributes[n];
                sattr = s.attributes[n];
                if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
                  rval = false;
                }
              }
            }
            return rval;
          };
          cert.issued = function(child) {
            return child.isIssuer(cert);
          };
          cert.generateSubjectKeyIdentifier = function() {
            return pki2.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
          };
          cert.verifySubjectKeyIdentifier = function() {
            var oid = oids2["subjectKeyIdentifier"];
            for (var i = 0; i < cert.extensions.length; ++i) {
              var ext = cert.extensions[i];
              if (ext.id === oid) {
                var ski = cert.generateSubjectKeyIdentifier().getBytes();
                return forge2.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
              }
            }
            return false;
          };
          return cert;
        };
        pki2.certificateFromAsn1 = function(obj, computeHash) {
          var capture = {};
          var errors = [];
          if (!asn12.validate(obj, x509CertificateValidator, capture, errors)) {
            var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
            error.errors = errors;
            throw error;
          }
          var oid = asn12.derToOid(capture.publicKeyOid);
          if (oid !== pki2.oids.rsaEncryption) {
            throw new Error("Cannot read public key. OID is not RSA.");
          }
          var cert = pki2.createCertificate();
          cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
          var serial = forge2.util.createBuffer(capture.certSerialNumber);
          cert.serialNumber = serial.toHex();
          cert.signatureOid = forge2.asn1.derToOid(capture.certSignatureOid);
          cert.signatureParameters = _readSignatureParameters(
            cert.signatureOid,
            capture.certSignatureParams,
            true
          );
          cert.siginfo.algorithmOid = forge2.asn1.derToOid(capture.certinfoSignatureOid);
          cert.siginfo.parameters = _readSignatureParameters(
            cert.siginfo.algorithmOid,
            capture.certinfoSignatureParams,
            false
          );
          cert.signature = capture.certSignature;
          var validity = [];
          if (capture.certValidity1UTCTime !== void 0) {
            validity.push(asn12.utcTimeToDate(capture.certValidity1UTCTime));
          }
          if (capture.certValidity2GeneralizedTime !== void 0) {
            validity.push(asn12.generalizedTimeToDate(
              capture.certValidity2GeneralizedTime
            ));
          }
          if (capture.certValidity3UTCTime !== void 0) {
            validity.push(asn12.utcTimeToDate(capture.certValidity3UTCTime));
          }
          if (capture.certValidity4GeneralizedTime !== void 0) {
            validity.push(asn12.generalizedTimeToDate(
              capture.certValidity4GeneralizedTime
            ));
          }
          if (validity.length > 2) {
            throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
          }
          if (validity.length < 2) {
            throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
          }
          cert.validity.notBefore = validity[0];
          cert.validity.notAfter = validity[1];
          cert.tbsCertificate = capture.tbsCertificate;
          if (computeHash) {
            cert.md = _createSignatureDigest({
              signatureOid: cert.signatureOid,
              type: "certificate"
            });
            var bytes = asn12.toDer(cert.tbsCertificate);
            cert.md.update(bytes.getBytes());
          }
          var imd = forge2.md.sha1.create();
          var ibytes = asn12.toDer(capture.certIssuer);
          imd.update(ibytes.getBytes());
          cert.issuer.getField = function(sn) {
            return _getAttribute(cert.issuer, sn);
          };
          cert.issuer.addField = function(attr) {
            _fillMissingFields([attr]);
            cert.issuer.attributes.push(attr);
          };
          cert.issuer.attributes = pki2.RDNAttributesAsArray(capture.certIssuer);
          if (capture.certIssuerUniqueId) {
            cert.issuer.uniqueId = capture.certIssuerUniqueId;
          }
          cert.issuer.hash = imd.digest().toHex();
          var smd = forge2.md.sha1.create();
          var sbytes = asn12.toDer(capture.certSubject);
          smd.update(sbytes.getBytes());
          cert.subject.getField = function(sn) {
            return _getAttribute(cert.subject, sn);
          };
          cert.subject.addField = function(attr) {
            _fillMissingFields([attr]);
            cert.subject.attributes.push(attr);
          };
          cert.subject.attributes = pki2.RDNAttributesAsArray(capture.certSubject);
          if (capture.certSubjectUniqueId) {
            cert.subject.uniqueId = capture.certSubjectUniqueId;
          }
          cert.subject.hash = smd.digest().toHex();
          if (capture.certExtensions) {
            cert.extensions = pki2.certificateExtensionsFromAsn1(capture.certExtensions);
          } else {
            cert.extensions = [];
          }
          cert.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
          return cert;
        };
        pki2.certificateExtensionsFromAsn1 = function(exts) {
          var rval = [];
          for (var i = 0; i < exts.value.length; ++i) {
            var extseq = exts.value[i];
            for (var ei = 0; ei < extseq.value.length; ++ei) {
              rval.push(pki2.certificateExtensionFromAsn1(extseq.value[ei]));
            }
          }
          return rval;
        };
        pki2.certificateExtensionFromAsn1 = function(ext) {
          var e = {};
          e.id = asn12.derToOid(ext.value[0].value);
          e.critical = false;
          if (ext.value[1].type === asn12.Type.BOOLEAN) {
            e.critical = ext.value[1].value.charCodeAt(0) !== 0;
            e.value = ext.value[2].value;
          } else {
            e.value = ext.value[1].value;
          }
          if (e.id in oids2) {
            e.name = oids2[e.id];
            if (e.name === "keyUsage") {
              var ev = asn12.fromDer(e.value);
              var b2 = 0;
              var b3 = 0;
              if (ev.value.length > 1) {
                b2 = ev.value.charCodeAt(1);
                b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
              }
              e.digitalSignature = (b2 & 128) === 128;
              e.nonRepudiation = (b2 & 64) === 64;
              e.keyEncipherment = (b2 & 32) === 32;
              e.dataEncipherment = (b2 & 16) === 16;
              e.keyAgreement = (b2 & 8) === 8;
              e.keyCertSign = (b2 & 4) === 4;
              e.cRLSign = (b2 & 2) === 2;
              e.encipherOnly = (b2 & 1) === 1;
              e.decipherOnly = (b3 & 128) === 128;
            } else if (e.name === "basicConstraints") {
              var ev = asn12.fromDer(e.value);
              if (ev.value.length > 0 && ev.value[0].type === asn12.Type.BOOLEAN) {
                e.cA = ev.value[0].value.charCodeAt(0) !== 0;
              } else {
                e.cA = false;
              }
              var value = null;
              if (ev.value.length > 0 && ev.value[0].type === asn12.Type.INTEGER) {
                value = ev.value[0].value;
              } else if (ev.value.length > 1) {
                value = ev.value[1].value;
              }
              if (value !== null) {
                e.pathLenConstraint = asn12.derToInteger(value);
              }
            } else if (e.name === "extKeyUsage") {
              var ev = asn12.fromDer(e.value);
              for (var vi = 0; vi < ev.value.length; ++vi) {
                var oid = asn12.derToOid(ev.value[vi].value);
                if (oid in oids2) {
                  e[oids2[oid]] = true;
                } else {
                  e[oid] = true;
                }
              }
            } else if (e.name === "nsCertType") {
              var ev = asn12.fromDer(e.value);
              var b2 = 0;
              if (ev.value.length > 1) {
                b2 = ev.value.charCodeAt(1);
              }
              e.client = (b2 & 128) === 128;
              e.server = (b2 & 64) === 64;
              e.email = (b2 & 32) === 32;
              e.objsign = (b2 & 16) === 16;
              e.reserved = (b2 & 8) === 8;
              e.sslCA = (b2 & 4) === 4;
              e.emailCA = (b2 & 2) === 2;
              e.objCA = (b2 & 1) === 1;
            } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
              e.altNames = [];
              var gn;
              var ev = asn12.fromDer(e.value);
              for (var n = 0; n < ev.value.length; ++n) {
                gn = ev.value[n];
                var altName = {
                  type: gn.type,
                  value: gn.value
                };
                e.altNames.push(altName);
                switch (gn.type) {
                  // rfc822Name
                  case 1:
                  // dNSName
                  case 2:
                  // uniformResourceIdentifier (URI)
                  case 6:
                    break;
                  // IPAddress
                  case 7:
                    altName.ip = forge2.util.bytesToIP(gn.value);
                    break;
                  // registeredID
                  case 8:
                    altName.oid = asn12.derToOid(gn.value);
                    break;
                }
              }
            } else if (e.name === "subjectKeyIdentifier") {
              var ev = asn12.fromDer(e.value);
              e.subjectKeyIdentifier = forge2.util.bytesToHex(ev.value);
            }
          }
          return e;
        };
        pki2.certificationRequestFromAsn1 = function(obj, computeHash) {
          var capture = {};
          var errors = [];
          if (!asn12.validate(obj, certificationRequestValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
            error.errors = errors;
            throw error;
          }
          var oid = asn12.derToOid(capture.publicKeyOid);
          if (oid !== pki2.oids.rsaEncryption) {
            throw new Error("Cannot read public key. OID is not RSA.");
          }
          var csr = pki2.createCertificationRequest();
          csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
          csr.signatureOid = forge2.asn1.derToOid(capture.csrSignatureOid);
          csr.signatureParameters = _readSignatureParameters(
            csr.signatureOid,
            capture.csrSignatureParams,
            true
          );
          csr.siginfo.algorithmOid = forge2.asn1.derToOid(capture.csrSignatureOid);
          csr.siginfo.parameters = _readSignatureParameters(
            csr.siginfo.algorithmOid,
            capture.csrSignatureParams,
            false
          );
          csr.signature = capture.csrSignature;
          csr.certificationRequestInfo = capture.certificationRequestInfo;
          if (computeHash) {
            csr.md = _createSignatureDigest({
              signatureOid: csr.signatureOid,
              type: "certification request"
            });
            var bytes = asn12.toDer(csr.certificationRequestInfo);
            csr.md.update(bytes.getBytes());
          }
          var smd = forge2.md.sha1.create();
          csr.subject.getField = function(sn) {
            return _getAttribute(csr.subject, sn);
          };
          csr.subject.addField = function(attr) {
            _fillMissingFields([attr]);
            csr.subject.attributes.push(attr);
          };
          csr.subject.attributes = pki2.RDNAttributesAsArray(
            capture.certificationRequestInfoSubject,
            smd
          );
          csr.subject.hash = smd.digest().toHex();
          csr.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
          csr.getAttribute = function(sn) {
            return _getAttribute(csr, sn);
          };
          csr.addAttribute = function(attr) {
            _fillMissingFields([attr]);
            csr.attributes.push(attr);
          };
          csr.attributes = pki2.CRIAttributesAsArray(
            capture.certificationRequestInfoAttributes || []
          );
          return csr;
        };
        pki2.createCertificationRequest = function() {
          var csr = {};
          csr.version = 0;
          csr.signatureOid = null;
          csr.signature = null;
          csr.siginfo = {};
          csr.siginfo.algorithmOid = null;
          csr.subject = {};
          csr.subject.getField = function(sn) {
            return _getAttribute(csr.subject, sn);
          };
          csr.subject.addField = function(attr) {
            _fillMissingFields([attr]);
            csr.subject.attributes.push(attr);
          };
          csr.subject.attributes = [];
          csr.subject.hash = null;
          csr.publicKey = null;
          csr.attributes = [];
          csr.getAttribute = function(sn) {
            return _getAttribute(csr, sn);
          };
          csr.addAttribute = function(attr) {
            _fillMissingFields([attr]);
            csr.attributes.push(attr);
          };
          csr.md = null;
          csr.setSubject = function(attrs) {
            _fillMissingFields(attrs);
            csr.subject.attributes = attrs;
            csr.subject.hash = null;
          };
          csr.setAttributes = function(attrs) {
            _fillMissingFields(attrs);
            csr.attributes = attrs;
          };
          csr.sign = function(key, md2) {
            csr.md = md2 || forge2.md.sha1.create();
            var algorithmOid = oids2[csr.md.algorithm + "WithRSAEncryption"];
            if (!algorithmOid) {
              var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
              error.algorithm = csr.md.algorithm;
              throw error;
            }
            csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
            csr.certificationRequestInfo = pki2.getCertificationRequestInfo(csr);
            var bytes = asn12.toDer(csr.certificationRequestInfo);
            csr.md.update(bytes.getBytes());
            csr.signature = key.sign(csr.md);
          };
          csr.verify = function() {
            var rval = false;
            var md2 = csr.md;
            if (md2 === null) {
              md2 = _createSignatureDigest({
                signatureOid: csr.signatureOid,
                type: "certification request"
              });
              var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);
              var bytes = asn12.toDer(cri);
              md2.update(bytes.getBytes());
            }
            if (md2 !== null) {
              rval = _verifySignature({
                certificate: csr,
                md: md2,
                signature: csr.signature
              });
            }
            return rval;
          };
          return csr;
        };
        function _dnToAsn1(obj) {
          var rval = asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.SEQUENCE,
            true,
            []
          );
          var attr, set;
          var attrs = obj.attributes;
          for (var i = 0; i < attrs.length; ++i) {
            attr = attrs[i];
            var value = attr.value;
            var valueTagClass = asn12.Type.PRINTABLESTRING;
            if ("valueTagClass" in attr) {
              valueTagClass = attr.valueTagClass;
              if (valueTagClass === asn12.Type.UTF8) {
                value = forge2.util.encodeUtf8(value);
              }
            }
            set = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SET, true, [
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // AttributeType
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(attr.type).getBytes()
                ),
                // AttributeValue
                asn12.create(asn12.Class.UNIVERSAL, valueTagClass, false, value)
              ])
            ]);
            rval.value.push(set);
          }
          return rval;
        }
        function _fillMissingFields(attrs) {
          var attr;
          for (var i = 0; i < attrs.length; ++i) {
            attr = attrs[i];
            if (typeof attr.name === "undefined") {
              if (attr.type && attr.type in pki2.oids) {
                attr.name = pki2.oids[attr.type];
              } else if (attr.shortName && attr.shortName in _shortNames) {
                attr.name = pki2.oids[_shortNames[attr.shortName]];
              }
            }
            if (typeof attr.type === "undefined") {
              if (attr.name && attr.name in pki2.oids) {
                attr.type = pki2.oids[attr.name];
              } else {
                var error = new Error("Attribute type not specified.");
                error.attribute = attr;
                throw error;
              }
            }
            if (typeof attr.shortName === "undefined") {
              if (attr.name && attr.name in _shortNames) {
                attr.shortName = _shortNames[attr.name];
              }
            }
            if (attr.type === oids2.extensionRequest) {
              attr.valueConstructed = true;
              attr.valueTagClass = asn12.Type.SEQUENCE;
              if (!attr.value && attr.extensions) {
                attr.value = [];
                for (var ei = 0; ei < attr.extensions.length; ++ei) {
                  attr.value.push(pki2.certificateExtensionToAsn1(
                    _fillMissingExtensionFields(attr.extensions[ei])
                  ));
                }
              }
            }
            if (typeof attr.value === "undefined") {
              var error = new Error("Attribute value not specified.");
              error.attribute = attr;
              throw error;
            }
          }
        }
        function _fillMissingExtensionFields(e, options) {
          options = options || {};
          if (typeof e.name === "undefined") {
            if (e.id && e.id in pki2.oids) {
              e.name = pki2.oids[e.id];
            }
          }
          if (typeof e.id === "undefined") {
            if (e.name && e.name in pki2.oids) {
              e.id = pki2.oids[e.name];
            } else {
              var error = new Error("Extension ID not specified.");
              error.extension = e;
              throw error;
            }
          }
          if (typeof e.value !== "undefined") {
            return e;
          }
          if (e.name === "keyUsage") {
            var unused = 0;
            var b2 = 0;
            var b3 = 0;
            if (e.digitalSignature) {
              b2 |= 128;
              unused = 7;
            }
            if (e.nonRepudiation) {
              b2 |= 64;
              unused = 6;
            }
            if (e.keyEncipherment) {
              b2 |= 32;
              unused = 5;
            }
            if (e.dataEncipherment) {
              b2 |= 16;
              unused = 4;
            }
            if (e.keyAgreement) {
              b2 |= 8;
              unused = 3;
            }
            if (e.keyCertSign) {
              b2 |= 4;
              unused = 2;
            }
            if (e.cRLSign) {
              b2 |= 2;
              unused = 1;
            }
            if (e.encipherOnly) {
              b2 |= 1;
              unused = 0;
            }
            if (e.decipherOnly) {
              b3 |= 128;
              unused = 7;
            }
            var value = String.fromCharCode(unused);
            if (b3 !== 0) {
              value += String.fromCharCode(b2) + String.fromCharCode(b3);
            } else if (b2 !== 0) {
              value += String.fromCharCode(b2);
            }
            e.value = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.BITSTRING,
              false,
              value
            );
          } else if (e.name === "basicConstraints") {
            e.value = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.SEQUENCE,
              true,
              []
            );
            if (e.cA) {
              e.value.value.push(asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.BOOLEAN,
                false,
                String.fromCharCode(255)
              ));
            }
            if ("pathLenConstraint" in e) {
              e.value.value.push(asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.INTEGER,
                false,
                asn12.integerToDer(e.pathLenConstraint).getBytes()
              ));
            }
          } else if (e.name === "extKeyUsage") {
            e.value = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.SEQUENCE,
              true,
              []
            );
            var seq = e.value.value;
            for (var key in e) {
              if (e[key] !== true) {
                continue;
              }
              if (key in oids2) {
                seq.push(asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(oids2[key]).getBytes()
                ));
              } else if (key.indexOf(".") !== -1) {
                seq.push(asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(key).getBytes()
                ));
              }
            }
          } else if (e.name === "nsCertType") {
            var unused = 0;
            var b2 = 0;
            if (e.client) {
              b2 |= 128;
              unused = 7;
            }
            if (e.server) {
              b2 |= 64;
              unused = 6;
            }
            if (e.email) {
              b2 |= 32;
              unused = 5;
            }
            if (e.objsign) {
              b2 |= 16;
              unused = 4;
            }
            if (e.reserved) {
              b2 |= 8;
              unused = 3;
            }
            if (e.sslCA) {
              b2 |= 4;
              unused = 2;
            }
            if (e.emailCA) {
              b2 |= 2;
              unused = 1;
            }
            if (e.objCA) {
              b2 |= 1;
              unused = 0;
            }
            var value = String.fromCharCode(unused);
            if (b2 !== 0) {
              value += String.fromCharCode(b2);
            }
            e.value = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.BITSTRING,
              false,
              value
            );
          } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
            e.value = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, []);
            var altName;
            for (var n = 0; n < e.altNames.length; ++n) {
              altName = e.altNames[n];
              var value = altName.value;
              if (altName.type === 7 && altName.ip) {
                value = forge2.util.bytesFromIP(altName.ip);
                if (value === null) {
                  var error = new Error(
                    'Extension "ip" value is not a valid IPv4 or IPv6 address.'
                  );
                  error.extension = e;
                  throw error;
                }
              } else if (altName.type === 8) {
                if (altName.oid) {
                  value = asn12.oidToDer(asn12.oidToDer(altName.oid));
                } else {
                  value = asn12.oidToDer(value);
                }
              }
              e.value.value.push(asn12.create(
                asn12.Class.CONTEXT_SPECIFIC,
                altName.type,
                false,
                value
              ));
            }
          } else if (e.name === "nsComment" && options.cert) {
            if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
              throw new Error('Invalid "nsComment" content.');
            }
            e.value = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.IA5STRING,
              false,
              e.comment
            );
          } else if (e.name === "subjectKeyIdentifier" && options.cert) {
            var ski = options.cert.generateSubjectKeyIdentifier();
            e.subjectKeyIdentifier = ski.toHex();
            e.value = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OCTETSTRING,
              false,
              ski.getBytes()
            );
          } else if (e.name === "authorityKeyIdentifier" && options.cert) {
            e.value = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, []);
            var seq = e.value.value;
            if (e.keyIdentifier) {
              var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
              seq.push(
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
              );
            }
            if (e.authorityCertIssuer) {
              var authorityCertIssuer = [
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 4, true, [
                  _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
                ])
              ];
              seq.push(
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
              );
            }
            if (e.serialNumber) {
              var serialNumber = forge2.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
              seq.push(
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
              );
            }
          } else if (e.name === "cRLDistributionPoints") {
            e.value = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, []);
            var seq = e.value.value;
            var subSeq = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.SEQUENCE,
              true,
              []
            );
            var fullNameGeneralNames = asn12.create(
              asn12.Class.CONTEXT_SPECIFIC,
              0,
              true,
              []
            );
            var altName;
            for (var n = 0; n < e.altNames.length; ++n) {
              altName = e.altNames[n];
              var value = altName.value;
              if (altName.type === 7 && altName.ip) {
                value = forge2.util.bytesFromIP(altName.ip);
                if (value === null) {
                  var error = new Error(
                    'Extension "ip" value is not a valid IPv4 or IPv6 address.'
                  );
                  error.extension = e;
                  throw error;
                }
              } else if (altName.type === 8) {
                if (altName.oid) {
                  value = asn12.oidToDer(asn12.oidToDer(altName.oid));
                } else {
                  value = asn12.oidToDer(value);
                }
              }
              fullNameGeneralNames.value.push(asn12.create(
                asn12.Class.CONTEXT_SPECIFIC,
                altName.type,
                false,
                value
              ));
            }
            subSeq.value.push(asn12.create(
              asn12.Class.CONTEXT_SPECIFIC,
              0,
              true,
              [fullNameGeneralNames]
            ));
            seq.push(subSeq);
          }
          if (typeof e.value === "undefined") {
            var error = new Error("Extension value not specified.");
            error.extension = e;
            throw error;
          }
          return e;
        }
        function _signatureParametersToAsn1(oid, params) {
          switch (oid) {
            case oids2["RSASSA-PSS"]:
              var parts = [];
              if (params.hash.algorithmOid !== void 0) {
                parts.push(asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                  asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.OID,
                      false,
                      asn12.oidToDer(params.hash.algorithmOid).getBytes()
                    ),
                    asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
                  ])
                ]));
              }
              if (params.mgf.algorithmOid !== void 0) {
                parts.push(asn12.create(asn12.Class.CONTEXT_SPECIFIC, 1, true, [
                  asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.OID,
                      false,
                      asn12.oidToDer(params.mgf.algorithmOid).getBytes()
                    ),
                    asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                      asn12.create(
                        asn12.Class.UNIVERSAL,
                        asn12.Type.OID,
                        false,
                        asn12.oidToDer(params.mgf.hash.algorithmOid).getBytes()
                      ),
                      asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
                    ])
                  ])
                ]));
              }
              if (params.saltLength !== void 0) {
                parts.push(asn12.create(asn12.Class.CONTEXT_SPECIFIC, 2, true, [
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.INTEGER,
                    false,
                    asn12.integerToDer(params.saltLength).getBytes()
                  )
                ]));
              }
              return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, parts);
            default:
              return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "");
          }
        }
        function _CRIAttributesToAsn1(csr) {
          var rval = asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, []);
          if (csr.attributes.length === 0) {
            return rval;
          }
          var attrs = csr.attributes;
          for (var i = 0; i < attrs.length; ++i) {
            var attr = attrs[i];
            var value = attr.value;
            var valueTagClass = asn12.Type.UTF8;
            if ("valueTagClass" in attr) {
              valueTagClass = attr.valueTagClass;
            }
            if (valueTagClass === asn12.Type.UTF8) {
              value = forge2.util.encodeUtf8(value);
            }
            var valueConstructed = false;
            if ("valueConstructed" in attr) {
              valueConstructed = attr.valueConstructed;
            }
            var seq = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // AttributeType
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(attr.type).getBytes()
              ),
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SET, true, [
                // AttributeValue
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  valueTagClass,
                  valueConstructed,
                  value
                )
              ])
            ]);
            rval.value.push(seq);
          }
          return rval;
        }
        var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
        var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
        function _dateToAsn1(date) {
          if (date >= jan_1_1950 && date < jan_1_2050) {
            return asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.UTCTIME,
              false,
              asn12.dateToUtcTime(date)
            );
          } else {
            return asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.GENERALIZEDTIME,
              false,
              asn12.dateToGeneralizedTime(date)
            );
          }
        }
        pki2.getTBSCertificate = function(cert) {
          var notBefore = _dateToAsn1(cert.validity.notBefore);
          var notAfter = _dateToAsn1(cert.validity.notAfter);
          var tbs = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // version
            asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
              // integer
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.INTEGER,
                false,
                asn12.integerToDer(cert.version).getBytes()
              )
            ]),
            // serialNumber
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              forge2.util.hexToBytes(cert.serialNumber)
            ),
            // signature
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // algorithm
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(cert.siginfo.algorithmOid).getBytes()
              ),
              // parameters
              _signatureParametersToAsn1(
                cert.siginfo.algorithmOid,
                cert.siginfo.parameters
              )
            ]),
            // issuer
            _dnToAsn1(cert.issuer),
            // validity
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              notBefore,
              notAfter
            ]),
            // subject
            _dnToAsn1(cert.subject),
            // SubjectPublicKeyInfo
            pki2.publicKeyToAsn1(cert.publicKey)
          ]);
          if (cert.issuer.uniqueId) {
            tbs.value.push(
              asn12.create(asn12.Class.CONTEXT_SPECIFIC, 1, true, [
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.BITSTRING,
                  false,
                  // TODO: support arbitrary bit length ids
                  String.fromCharCode(0) + cert.issuer.uniqueId
                )
              ])
            );
          }
          if (cert.subject.uniqueId) {
            tbs.value.push(
              asn12.create(asn12.Class.CONTEXT_SPECIFIC, 2, true, [
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.BITSTRING,
                  false,
                  // TODO: support arbitrary bit length ids
                  String.fromCharCode(0) + cert.subject.uniqueId
                )
              ])
            );
          }
          if (cert.extensions.length > 0) {
            tbs.value.push(pki2.certificateExtensionsToAsn1(cert.extensions));
          }
          return tbs;
        };
        pki2.getCertificationRequestInfo = function(csr) {
          var cri = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // version
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              asn12.integerToDer(csr.version).getBytes()
            ),
            // subject
            _dnToAsn1(csr.subject),
            // SubjectPublicKeyInfo
            pki2.publicKeyToAsn1(csr.publicKey),
            // attributes
            _CRIAttributesToAsn1(csr)
          ]);
          return cri;
        };
        pki2.distinguishedNameToAsn1 = function(dn) {
          return _dnToAsn1(dn);
        };
        pki2.certificateToAsn1 = function(cert) {
          var tbsCertificate = cert.tbsCertificate || pki2.getTBSCertificate(cert);
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // TBSCertificate
            tbsCertificate,
            // AlgorithmIdentifier (signature algorithm)
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // algorithm
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(cert.signatureOid).getBytes()
              ),
              // parameters
              _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
            ]),
            // SignatureValue
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.BITSTRING,
              false,
              String.fromCharCode(0) + cert.signature
            )
          ]);
        };
        pki2.certificateExtensionsToAsn1 = function(exts) {
          var rval = asn12.create(asn12.Class.CONTEXT_SPECIFIC, 3, true, []);
          var seq = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, []);
          rval.value.push(seq);
          for (var i = 0; i < exts.length; ++i) {
            seq.value.push(pki2.certificateExtensionToAsn1(exts[i]));
          }
          return rval;
        };
        pki2.certificateExtensionToAsn1 = function(ext) {
          var extseq = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, []);
          extseq.value.push(asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.OID,
            false,
            asn12.oidToDer(ext.id).getBytes()
          ));
          if (ext.critical) {
            extseq.value.push(asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.BOOLEAN,
              false,
              String.fromCharCode(255)
            ));
          }
          var value = ext.value;
          if (typeof ext.value !== "string") {
            value = asn12.toDer(value).getBytes();
          }
          extseq.value.push(asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.OCTETSTRING,
            false,
            value
          ));
          return extseq;
        };
        pki2.certificationRequestToAsn1 = function(csr) {
          var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // CertificationRequestInfo
            cri,
            // AlgorithmIdentifier (signature algorithm)
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // algorithm
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(csr.signatureOid).getBytes()
              ),
              // parameters
              _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
            ]),
            // signature
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.BITSTRING,
              false,
              String.fromCharCode(0) + csr.signature
            )
          ]);
        };
        pki2.createCaStore = function(certs) {
          var caStore = {
            // stored certificates
            certs: {}
          };
          caStore.getIssuer = function(cert2) {
            var rval = getBySubject(cert2.issuer);
            return rval;
          };
          caStore.addCertificate = function(cert2) {
            if (typeof cert2 === "string") {
              cert2 = forge2.pki.certificateFromPem(cert2);
            }
            ensureSubjectHasHash(cert2.subject);
            if (!caStore.hasCertificate(cert2)) {
              if (cert2.subject.hash in caStore.certs) {
                var tmp = caStore.certs[cert2.subject.hash];
                if (!forge2.util.isArray(tmp)) {
                  tmp = [tmp];
                }
                tmp.push(cert2);
                caStore.certs[cert2.subject.hash] = tmp;
              } else {
                caStore.certs[cert2.subject.hash] = cert2;
              }
            }
          };
          caStore.hasCertificate = function(cert2) {
            if (typeof cert2 === "string") {
              cert2 = forge2.pki.certificateFromPem(cert2);
            }
            var match = getBySubject(cert2.subject);
            if (!match) {
              return false;
            }
            if (!forge2.util.isArray(match)) {
              match = [match];
            }
            var der1 = asn12.toDer(pki2.certificateToAsn1(cert2)).getBytes();
            for (var i2 = 0; i2 < match.length; ++i2) {
              var der2 = asn12.toDer(pki2.certificateToAsn1(match[i2])).getBytes();
              if (der1 === der2) {
                return true;
              }
            }
            return false;
          };
          caStore.listAllCertificates = function() {
            var certList = [];
            for (var hash in caStore.certs) {
              if (caStore.certs.hasOwnProperty(hash)) {
                var value = caStore.certs[hash];
                if (!forge2.util.isArray(value)) {
                  certList.push(value);
                } else {
                  for (var i2 = 0; i2 < value.length; ++i2) {
                    certList.push(value[i2]);
                  }
                }
              }
            }
            return certList;
          };
          caStore.removeCertificate = function(cert2) {
            var result;
            if (typeof cert2 === "string") {
              cert2 = forge2.pki.certificateFromPem(cert2);
            }
            ensureSubjectHasHash(cert2.subject);
            if (!caStore.hasCertificate(cert2)) {
              return null;
            }
            var match = getBySubject(cert2.subject);
            if (!forge2.util.isArray(match)) {
              result = caStore.certs[cert2.subject.hash];
              delete caStore.certs[cert2.subject.hash];
              return result;
            }
            var der1 = asn12.toDer(pki2.certificateToAsn1(cert2)).getBytes();
            for (var i2 = 0; i2 < match.length; ++i2) {
              var der2 = asn12.toDer(pki2.certificateToAsn1(match[i2])).getBytes();
              if (der1 === der2) {
                result = match[i2];
                match.splice(i2, 1);
              }
            }
            if (match.length === 0) {
              delete caStore.certs[cert2.subject.hash];
            }
            return result;
          };
          function getBySubject(subject) {
            ensureSubjectHasHash(subject);
            return caStore.certs[subject.hash] || null;
          }
          function ensureSubjectHasHash(subject) {
            if (!subject.hash) {
              var md2 = forge2.md.sha1.create();
              subject.attributes = pki2.RDNAttributesAsArray(_dnToAsn1(subject), md2);
              subject.hash = md2.digest().toHex();
            }
          }
          if (certs) {
            for (var i = 0; i < certs.length; ++i) {
              var cert = certs[i];
              caStore.addCertificate(cert);
            }
          }
          return caStore;
        };
        pki2.certificateError = {
          bad_certificate: "forge.pki.BadCertificate",
          unsupported_certificate: "forge.pki.UnsupportedCertificate",
          certificate_revoked: "forge.pki.CertificateRevoked",
          certificate_expired: "forge.pki.CertificateExpired",
          certificate_unknown: "forge.pki.CertificateUnknown",
          unknown_ca: "forge.pki.UnknownCertificateAuthority"
        };
        pki2.verifyCertificateChain = function(caStore, chain, options) {
          if (typeof options === "function") {
            options = { verify: options };
          }
          options = options || {};
          chain = chain.slice(0);
          var certs = chain.slice(0);
          var validityCheckDate = options.validityCheckDate;
          if (typeof validityCheckDate === "undefined") {
            validityCheckDate = /* @__PURE__ */ new Date();
          }
          var first = true;
          var error = null;
          var depth = 0;
          do {
            var cert = chain.shift();
            var parent = null;
            var selfSigned = false;
            if (validityCheckDate) {
              if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
                error = {
                  message: "Certificate is not valid yet or has expired.",
                  error: pki2.certificateError.certificate_expired,
                  notBefore: cert.validity.notBefore,
                  notAfter: cert.validity.notAfter,
                  // TODO: we might want to reconsider renaming 'now' to
                  // 'validityCheckDate' should this API be changed in the future.
                  now: validityCheckDate
                };
              }
            }
            if (error === null) {
              parent = chain[0] || caStore.getIssuer(cert);
              if (parent === null) {
                if (cert.isIssuer(cert)) {
                  selfSigned = true;
                  parent = cert;
                }
              }
              if (parent) {
                var parents = parent;
                if (!forge2.util.isArray(parents)) {
                  parents = [parents];
                }
                var verified = false;
                while (!verified && parents.length > 0) {
                  parent = parents.shift();
                  try {
                    verified = parent.verify(cert);
                  } catch (ex) {
                  }
                }
                if (!verified) {
                  error = {
                    message: "Certificate signature is invalid.",
                    error: pki2.certificateError.bad_certificate
                  };
                }
              }
              if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
                error = {
                  message: "Certificate is not trusted.",
                  error: pki2.certificateError.unknown_ca
                };
              }
            }
            if (error === null && parent && !cert.isIssuer(parent)) {
              error = {
                message: "Certificate issuer is invalid.",
                error: pki2.certificateError.bad_certificate
              };
            }
            if (error === null) {
              var se = {
                keyUsage: true,
                basicConstraints: true
              };
              for (var i = 0; error === null && i < cert.extensions.length; ++i) {
                var ext = cert.extensions[i];
                if (ext.critical && !(ext.name in se)) {
                  error = {
                    message: "Certificate has an unsupported critical extension.",
                    error: pki2.certificateError.unsupported_certificate
                  };
                }
              }
            }
            if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {
              var bcExt = cert.getExtension("basicConstraints");
              var keyUsageExt = cert.getExtension("keyUsage");
              if (keyUsageExt !== null) {
                if (!keyUsageExt.keyCertSign || bcExt === null) {
                  error = {
                    message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                    error: pki2.certificateError.bad_certificate
                  };
                }
              }
              if (error === null && bcExt !== null && !bcExt.cA) {
                error = {
                  message: "Certificate basicConstraints indicates the certificate is not a CA.",
                  error: pki2.certificateError.bad_certificate
                };
              }
              if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
                var pathLen = depth - 1;
                if (pathLen > bcExt.pathLenConstraint) {
                  error = {
                    message: "Certificate basicConstraints pathLenConstraint violated.",
                    error: pki2.certificateError.bad_certificate
                  };
                }
              }
            }
            var vfd = error === null ? true : error.error;
            var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
            if (ret === true) {
              error = null;
            } else {
              if (vfd === true) {
                error = {
                  message: "The application rejected the certificate.",
                  error: pki2.certificateError.bad_certificate
                };
              }
              if (ret || ret === 0) {
                if (typeof ret === "object" && !forge2.util.isArray(ret)) {
                  if (ret.message) {
                    error.message = ret.message;
                  }
                  if (ret.error) {
                    error.error = ret.error;
                  }
                } else if (typeof ret === "string") {
                  error.error = ret;
                }
              }
              throw error;
            }
            first = false;
            ++depth;
          } while (chain.length > 0);
          return true;
        };
        return x509.exports;
      }
      var hasRequiredPkcs12;
      function requirePkcs12() {
        if (hasRequiredPkcs12) return pkcs12.exports;
        hasRequiredPkcs12 = 1;
        var forge2 = requireForge();
        requireAsn1();
        requireHmac();
        requireOids();
        requirePkcs7asn1();
        requirePbe();
        requireRandom();
        requireRsa();
        requireSha1();
        requireUtil();
        requireX509();
        var asn12 = forge2.asn1;
        var pki2 = forge2.pki;
        var p12 = pkcs12.exports = forge2.pkcs12 = forge2.pkcs12 || {};
        var contentInfoValidator = {
          name: "ContentInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          // a ContentInfo
          constructed: true,
          value: [{
            name: "ContentInfo.contentType",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OID,
            constructed: false,
            capture: "contentType"
          }, {
            name: "ContentInfo.content",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            constructed: true,
            captureAsn1: "content"
          }]
        };
        var pfxValidator = {
          name: "PFX",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "PFX.version",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.INTEGER,
              constructed: false,
              capture: "version"
            },
            contentInfoValidator,
            {
              name: "PFX.macData",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              optional: true,
              captureAsn1: "mac",
              value: [{
                name: "PFX.macData.mac",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.SEQUENCE,
                // DigestInfo
                constructed: true,
                value: [{
                  name: "PFX.macData.mac.digestAlgorithm",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.SEQUENCE,
                  // DigestAlgorithmIdentifier
                  constructed: true,
                  value: [{
                    name: "PFX.macData.mac.digestAlgorithm.algorithm",
                    tagClass: asn12.Class.UNIVERSAL,
                    type: asn12.Type.OID,
                    constructed: false,
                    capture: "macAlgorithm"
                  }, {
                    name: "PFX.macData.mac.digestAlgorithm.parameters",
                    tagClass: asn12.Class.UNIVERSAL,
                    captureAsn1: "macAlgorithmParameters"
                  }]
                }, {
                  name: "PFX.macData.mac.digest",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.OCTETSTRING,
                  constructed: false,
                  capture: "macDigest"
                }]
              }, {
                name: "PFX.macData.macSalt",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.OCTETSTRING,
                constructed: false,
                capture: "macSalt"
              }, {
                name: "PFX.macData.iterations",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.INTEGER,
                constructed: false,
                optional: true,
                capture: "macIterations"
              }]
            }
          ]
        };
        var safeBagValidator = {
          name: "SafeBag",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "SafeBag.bagId",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OID,
            constructed: false,
            capture: "bagId"
          }, {
            name: "SafeBag.bagValue",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            constructed: true,
            captureAsn1: "bagValue"
          }, {
            name: "SafeBag.bagAttributes",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SET,
            constructed: true,
            optional: true,
            capture: "bagAttributes"
          }]
        };
        var attributeValidator = {
          name: "Attribute",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "Attribute.attrId",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OID,
            constructed: false,
            capture: "oid"
          }, {
            name: "Attribute.attrValues",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SET,
            constructed: true,
            capture: "values"
          }]
        };
        var certBagValidator = {
          name: "CertBag",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "CertBag.certId",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OID,
            constructed: false,
            capture: "certId"
          }, {
            name: "CertBag.certValue",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            constructed: true,
            /* So far we only support X.509 certificates (which are wrapped in
               an OCTET STRING, hence hard code that here). */
            value: [{
              name: "CertBag.certValue[0]",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Class.OCTETSTRING,
              constructed: false,
              capture: "cert"
            }]
          }]
        };
        function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
          var result = [];
          for (var i = 0; i < safeContents.length; i++) {
            for (var j = 0; j < safeContents[i].safeBags.length; j++) {
              var bag = safeContents[i].safeBags[j];
              if (bagType !== void 0 && bag.type !== bagType) {
                continue;
              }
              if (attrName === null) {
                result.push(bag);
                continue;
              }
              if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {
                result.push(bag);
              }
            }
          }
          return result;
        }
        p12.pkcs12FromAsn1 = function(obj, strict, password) {
          if (typeof strict === "string") {
            password = strict;
            strict = true;
          } else if (strict === void 0) {
            strict = true;
          }
          var capture = {};
          var errors = [];
          if (!asn12.validate(obj, pfxValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
            error.errors = error;
            throw error;
          }
          var pfx = {
            version: capture.version.charCodeAt(0),
            safeContents: [],
            /**
             * Gets bags with matching attributes.
             *
             * @param filter the attributes to filter by:
             *          [localKeyId] the localKeyId to search for.
             *          [localKeyIdHex] the localKeyId in hex to search for.
             *          [friendlyName] the friendly name to search for.
             *          [bagType] bag type to narrow each attribute search by.
             *
             * @return a map of attribute type to an array of matching bags or, if no
             *           attribute was given but a bag type, the map key will be the
             *           bag type.
             */
            getBags: function(filter) {
              var rval = {};
              var localKeyId;
              if ("localKeyId" in filter) {
                localKeyId = filter.localKeyId;
              } else if ("localKeyIdHex" in filter) {
                localKeyId = forge2.util.hexToBytes(filter.localKeyIdHex);
              }
              if (localKeyId === void 0 && !("friendlyName" in filter) && "bagType" in filter) {
                rval[filter.bagType] = _getBagsByAttribute(
                  pfx.safeContents,
                  null,
                  null,
                  filter.bagType
                );
              }
              if (localKeyId !== void 0) {
                rval.localKeyId = _getBagsByAttribute(
                  pfx.safeContents,
                  "localKeyId",
                  localKeyId,
                  filter.bagType
                );
              }
              if ("friendlyName" in filter) {
                rval.friendlyName = _getBagsByAttribute(
                  pfx.safeContents,
                  "friendlyName",
                  filter.friendlyName,
                  filter.bagType
                );
              }
              return rval;
            },
            /**
             * DEPRECATED: use getBags() instead.
             *
             * Get bags with matching friendlyName attribute.
             *
             * @param friendlyName the friendly name to search for.
             * @param [bagType] bag type to narrow search by.
             *
             * @return an array of bags with matching friendlyName attribute.
             */
            getBagsByFriendlyName: function(friendlyName, bagType) {
              return _getBagsByAttribute(
                pfx.safeContents,
                "friendlyName",
                friendlyName,
                bagType
              );
            },
            /**
             * DEPRECATED: use getBags() instead.
             *
             * Get bags with matching localKeyId attribute.
             *
             * @param localKeyId the localKeyId to search for.
             * @param [bagType] bag type to narrow search by.
             *
             * @return an array of bags with matching localKeyId attribute.
             */
            getBagsByLocalKeyId: function(localKeyId, bagType) {
              return _getBagsByAttribute(
                pfx.safeContents,
                "localKeyId",
                localKeyId,
                bagType
              );
            }
          };
          if (capture.version.charCodeAt(0) !== 3) {
            var error = new Error("PKCS#12 PFX of version other than 3 not supported.");
            error.version = capture.version.charCodeAt(0);
            throw error;
          }
          if (asn12.derToOid(capture.contentType) !== pki2.oids.data) {
            var error = new Error("Only PKCS#12 PFX in password integrity mode supported.");
            error.oid = asn12.derToOid(capture.contentType);
            throw error;
          }
          var data = capture.content.value[0];
          if (data.tagClass !== asn12.Class.UNIVERSAL || data.type !== asn12.Type.OCTETSTRING) {
            throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
          }
          data = _decodePkcs7Data(data);
          if (capture.mac) {
            var md2 = null;
            var macKeyBytes = 0;
            var macAlgorithm = asn12.derToOid(capture.macAlgorithm);
            switch (macAlgorithm) {
              case pki2.oids.sha1:
                md2 = forge2.md.sha1.create();
                macKeyBytes = 20;
                break;
              case pki2.oids.sha256:
                md2 = forge2.md.sha256.create();
                macKeyBytes = 32;
                break;
              case pki2.oids.sha384:
                md2 = forge2.md.sha384.create();
                macKeyBytes = 48;
                break;
              case pki2.oids.sha512:
                md2 = forge2.md.sha512.create();
                macKeyBytes = 64;
                break;
              case pki2.oids.md5:
                md2 = forge2.md.md5.create();
                macKeyBytes = 16;
                break;
            }
            if (md2 === null) {
              throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
            }
            var macSalt = new forge2.util.ByteBuffer(capture.macSalt);
            var macIterations = "macIterations" in capture ? parseInt(forge2.util.bytesToHex(capture.macIterations), 16) : 1;
            var macKey = p12.generateKey(
              password,
              macSalt,
              3,
              macIterations,
              macKeyBytes,
              md2
            );
            var mac = forge2.hmac.create();
            mac.start(md2, macKey);
            mac.update(data.value);
            var macValue = mac.getMac();
            if (macValue.getBytes() !== capture.macDigest) {
              throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
            }
          } else if (Array.isArray(obj.value) && obj.value.length > 2) {
            throw new Error("Invalid PKCS#12. macData field present but MAC was not validated.");
          }
          _decodeAuthenticatedSafe(pfx, data.value, strict, password);
          return pfx;
        };
        function _decodePkcs7Data(data) {
          if (data.composed || data.constructed) {
            var value = forge2.util.createBuffer();
            for (var i = 0; i < data.value.length; ++i) {
              value.putBytes(data.value[i].value);
            }
            data.composed = data.constructed = false;
            data.value = value.getBytes();
          }
          return data;
        }
        function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
          authSafe = asn12.fromDer(authSafe, strict);
          if (authSafe.tagClass !== asn12.Class.UNIVERSAL || authSafe.type !== asn12.Type.SEQUENCE || authSafe.constructed !== true) {
            throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
          }
          for (var i = 0; i < authSafe.value.length; i++) {
            var contentInfo = authSafe.value[i];
            var capture = {};
            var errors = [];
            if (!asn12.validate(contentInfo, contentInfoValidator, capture, errors)) {
              var error = new Error("Cannot read ContentInfo.");
              error.errors = errors;
              throw error;
            }
            var obj = {
              encrypted: false
            };
            var safeContents = null;
            var data = capture.content.value[0];
            switch (asn12.derToOid(capture.contentType)) {
              case pki2.oids.data:
                if (data.tagClass !== asn12.Class.UNIVERSAL || data.type !== asn12.Type.OCTETSTRING) {
                  throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
                }
                safeContents = _decodePkcs7Data(data).value;
                break;
              case pki2.oids.encryptedData:
                safeContents = _decryptSafeContents(data, password);
                obj.encrypted = true;
                break;
              default:
                var error = new Error("Unsupported PKCS#12 contentType.");
                error.contentType = asn12.derToOid(capture.contentType);
                throw error;
            }
            obj.safeBags = _decodeSafeContents(safeContents, strict, password);
            pfx.safeContents.push(obj);
          }
        }
        function _decryptSafeContents(data, password) {
          var capture = {};
          var errors = [];
          if (!asn12.validate(
            data,
            forge2.pkcs7.asn1.encryptedDataValidator,
            capture,
            errors
          )) {
            var error = new Error("Cannot read EncryptedContentInfo.");
            error.errors = errors;
            throw error;
          }
          var oid = asn12.derToOid(capture.contentType);
          if (oid !== pki2.oids.data) {
            var error = new Error(
              "PKCS#12 EncryptedContentInfo ContentType is not Data."
            );
            error.oid = oid;
            throw error;
          }
          oid = asn12.derToOid(capture.encAlgorithm);
          var cipher2 = pki2.pbe.getCipher(oid, capture.encParameter, password);
          var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
          var encrypted = forge2.util.createBuffer(encryptedContentAsn1.value);
          cipher2.update(encrypted);
          if (!cipher2.finish()) {
            throw new Error("Failed to decrypt PKCS#12 SafeContents.");
          }
          return cipher2.output.getBytes();
        }
        function _decodeSafeContents(safeContents, strict, password) {
          if (!strict && safeContents.length === 0) {
            return [];
          }
          safeContents = asn12.fromDer(safeContents, strict);
          if (safeContents.tagClass !== asn12.Class.UNIVERSAL || safeContents.type !== asn12.Type.SEQUENCE || safeContents.constructed !== true) {
            throw new Error(
              "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag."
            );
          }
          var res = [];
          for (var i = 0; i < safeContents.value.length; i++) {
            var safeBag = safeContents.value[i];
            var capture = {};
            var errors = [];
            if (!asn12.validate(safeBag, safeBagValidator, capture, errors)) {
              var error = new Error("Cannot read SafeBag.");
              error.errors = errors;
              throw error;
            }
            var bag = {
              type: asn12.derToOid(capture.bagId),
              attributes: _decodeBagAttributes(capture.bagAttributes)
            };
            res.push(bag);
            var validator, decoder;
            var bagAsn1 = capture.bagValue.value[0];
            switch (bag.type) {
              case pki2.oids.pkcs8ShroudedKeyBag:
                bagAsn1 = pki2.decryptPrivateKeyInfo(bagAsn1, password);
                if (bagAsn1 === null) {
                  throw new Error(
                    "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"
                  );
                }
              /* fall through */
              case pki2.oids.keyBag:
                try {
                  bag.key = pki2.privateKeyFromAsn1(bagAsn1);
                } catch (e) {
                  bag.key = null;
                  bag.asn1 = bagAsn1;
                }
                continue;
              /* Nothing more to do. */
              case pki2.oids.certBag:
                validator = certBagValidator;
                decoder = function() {
                  if (asn12.derToOid(capture.certId) !== pki2.oids.x509Certificate) {
                    var error2 = new Error(
                      "Unsupported certificate type, only X.509 supported."
                    );
                    error2.oid = asn12.derToOid(capture.certId);
                    throw error2;
                  }
                  var certAsn1 = asn12.fromDer(capture.cert, strict);
                  try {
                    bag.cert = pki2.certificateFromAsn1(certAsn1, true);
                  } catch (e) {
                    bag.cert = null;
                    bag.asn1 = certAsn1;
                  }
                };
                break;
              default:
                var error = new Error("Unsupported PKCS#12 SafeBag type.");
                error.oid = bag.type;
                throw error;
            }
            if (validator !== void 0 && !asn12.validate(bagAsn1, validator, capture, errors)) {
              var error = new Error("Cannot read PKCS#12 " + validator.name);
              error.errors = errors;
              throw error;
            }
            decoder();
          }
          return res;
        }
        function _decodeBagAttributes(attributes) {
          var decodedAttrs = {};
          if (attributes !== void 0) {
            for (var i = 0; i < attributes.length; ++i) {
              var capture = {};
              var errors = [];
              if (!asn12.validate(attributes[i], attributeValidator, capture, errors)) {
                var error = new Error("Cannot read PKCS#12 BagAttribute.");
                error.errors = errors;
                throw error;
              }
              var oid = asn12.derToOid(capture.oid);
              if (pki2.oids[oid] === void 0) {
                continue;
              }
              decodedAttrs[pki2.oids[oid]] = [];
              for (var j = 0; j < capture.values.length; ++j) {
                decodedAttrs[pki2.oids[oid]].push(capture.values[j].value);
              }
            }
          }
          return decodedAttrs;
        }
        p12.toPkcs12Asn1 = function(key, cert, password, options) {
          options = options || {};
          options.saltSize = options.saltSize || 8;
          options.count = options.count || 2048;
          options.algorithm = options.algorithm || options.encAlgorithm || "aes128";
          if (!("useMac" in options)) {
            options.useMac = true;
          }
          if (!("localKeyId" in options)) {
            options.localKeyId = null;
          }
          if (!("generateLocalKeyId" in options)) {
            options.generateLocalKeyId = true;
          }
          var localKeyId = options.localKeyId;
          var bagAttrs;
          if (localKeyId !== null) {
            localKeyId = forge2.util.hexToBytes(localKeyId);
          } else if (options.generateLocalKeyId) {
            if (cert) {
              var pairedCert = forge2.util.isArray(cert) ? cert[0] : cert;
              if (typeof pairedCert === "string") {
                pairedCert = pki2.certificateFromPem(pairedCert);
              }
              var sha12 = forge2.md.sha1.create();
              sha12.update(asn12.toDer(pki2.certificateToAsn1(pairedCert)).getBytes());
              localKeyId = sha12.digest().getBytes();
            } else {
              localKeyId = forge2.random.getBytes(20);
            }
          }
          var attrs = [];
          if (localKeyId !== null) {
            attrs.push(
              // localKeyID
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // attrId
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(pki2.oids.localKeyId).getBytes()
                ),
                // attrValues
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SET, true, [
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.OCTETSTRING,
                    false,
                    localKeyId
                  )
                ])
              ])
            );
          }
          if ("friendlyName" in options) {
            attrs.push(
              // friendlyName
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // attrId
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(pki2.oids.friendlyName).getBytes()
                ),
                // attrValues
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SET, true, [
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.BMPSTRING,
                    false,
                    options.friendlyName
                  )
                ])
              ])
            );
          }
          if (attrs.length > 0) {
            bagAttrs = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SET, true, attrs);
          }
          var contents = [];
          var chain = [];
          if (cert !== null) {
            if (forge2.util.isArray(cert)) {
              chain = cert;
            } else {
              chain = [cert];
            }
          }
          var certSafeBags = [];
          for (var i = 0; i < chain.length; ++i) {
            cert = chain[i];
            if (typeof cert === "string") {
              cert = pki2.certificateFromPem(cert);
            }
            var certBagAttrs = i === 0 ? bagAttrs : void 0;
            var certAsn1 = pki2.certificateToAsn1(cert);
            var certSafeBag = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // bagId
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(pki2.oids.certBag).getBytes()
              ),
              // bagValue
              asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                // CertBag
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                  // certId
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.OID,
                    false,
                    asn12.oidToDer(pki2.oids.x509Certificate).getBytes()
                  ),
                  // certValue (x509Certificate)
                  asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.OCTETSTRING,
                      false,
                      asn12.toDer(certAsn1).getBytes()
                    )
                  ])
                ])
              ]),
              // bagAttributes (OPTIONAL)
              certBagAttrs
            ]);
            certSafeBags.push(certSafeBag);
          }
          if (certSafeBags.length > 0) {
            var certSafeContents = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.SEQUENCE,
              true,
              certSafeBags
            );
            var certCI = (
              // PKCS#7 ContentInfo
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // contentType
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  // OID for the content type is 'data'
                  asn12.oidToDer(pki2.oids.data).getBytes()
                ),
                // content
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.OCTETSTRING,
                    false,
                    asn12.toDer(certSafeContents).getBytes()
                  )
                ])
              ])
            );
            contents.push(certCI);
          }
          var keyBag = null;
          if (key !== null) {
            var pkAsn1 = pki2.wrapRsaPrivateKey(pki2.privateKeyToAsn1(key));
            if (password === null) {
              keyBag = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // bagId
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(pki2.oids.keyBag).getBytes()
                ),
                // bagValue
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                  // PrivateKeyInfo
                  pkAsn1
                ]),
                // bagAttributes (OPTIONAL)
                bagAttrs
              ]);
            } else {
              keyBag = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // bagId
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(pki2.oids.pkcs8ShroudedKeyBag).getBytes()
                ),
                // bagValue
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                  // EncryptedPrivateKeyInfo
                  pki2.encryptPrivateKeyInfo(pkAsn1, password, options)
                ]),
                // bagAttributes (OPTIONAL)
                bagAttrs
              ]);
            }
            var keySafeContents = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [keyBag]);
            var keyCI = (
              // PKCS#7 ContentInfo
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // contentType
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  // OID for the content type is 'data'
                  asn12.oidToDer(pki2.oids.data).getBytes()
                ),
                // content
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.OCTETSTRING,
                    false,
                    asn12.toDer(keySafeContents).getBytes()
                  )
                ])
              ])
            );
            contents.push(keyCI);
          }
          var safe = asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.SEQUENCE,
            true,
            contents
          );
          var macData;
          if (options.useMac) {
            var sha12 = forge2.md.sha1.create();
            var macSalt = new forge2.util.ByteBuffer(
              forge2.random.getBytes(options.saltSize)
            );
            var count = options.count;
            var key = p12.generateKey(password, macSalt, 3, count, 20);
            var mac = forge2.hmac.create();
            mac.start(sha12, key);
            mac.update(asn12.toDer(safe).getBytes());
            var macValue = mac.getMac();
            macData = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // mac DigestInfo
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // digestAlgorithm
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                  // algorithm = SHA-1
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.OID,
                    false,
                    asn12.oidToDer(pki2.oids.sha1).getBytes()
                  ),
                  // parameters = Null
                  asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
                ]),
                // digest
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OCTETSTRING,
                  false,
                  macValue.getBytes()
                )
              ]),
              // macSalt OCTET STRING
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OCTETSTRING,
                false,
                macSalt.getBytes()
              ),
              // iterations INTEGER (XXX: Only support count < 65536)
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.INTEGER,
                false,
                asn12.integerToDer(count).getBytes()
              )
            ]);
          }
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // version (3)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              asn12.integerToDer(3).getBytes()
            ),
            // PKCS#7 ContentInfo
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // contentType
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                // OID for the content type is 'data'
                asn12.oidToDer(pki2.oids.data).getBytes()
              ),
              // content
              asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OCTETSTRING,
                  false,
                  asn12.toDer(safe).getBytes()
                )
              ])
            ]),
            macData
          ]);
        };
        p12.generateKey = forge2.pbe.generatePkcs12Key;
        return pkcs12.exports;
      }
      var hasRequiredPki;
      function requirePki() {
        if (hasRequiredPki) return pki.exports;
        hasRequiredPki = 1;
        var forge2 = requireForge();
        requireAsn1();
        requireOids();
        requirePbe();
        requirePem();
        requirePbkdf2();
        requirePkcs12();
        requirePss();
        requireRsa();
        requireUtil();
        requireX509();
        var asn12 = forge2.asn1;
        var pki$1 = pki.exports = forge2.pki = forge2.pki || {};
        pki$1.pemToDer = function(pem2) {
          var msg = forge2.pem.decode(pem2)[0];
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert PEM to DER; PEM is encrypted.");
          }
          return forge2.util.createBuffer(msg.body);
        };
        pki$1.privateKeyFromPem = function(pem2) {
          var msg = forge2.pem.decode(pem2)[0];
          if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
            var error = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert private key from PEM; PEM is encrypted.");
          }
          var obj = asn12.fromDer(msg.body);
          return pki$1.privateKeyFromAsn1(obj);
        };
        pki$1.privateKeyToPem = function(key, maxline) {
          var msg = {
            type: "RSA PRIVATE KEY",
            body: asn12.toDer(pki$1.privateKeyToAsn1(key)).getBytes()
          };
          return forge2.pem.encode(msg, { maxline });
        };
        pki$1.privateKeyInfoToPem = function(pki2, maxline) {
          var msg = {
            type: "PRIVATE KEY",
            body: asn12.toDer(pki2).getBytes()
          };
          return forge2.pem.encode(msg, { maxline });
        };
        return pki.exports;
      }
      var tls_1;
      var hasRequiredTls;
      function requireTls() {
        if (hasRequiredTls) return tls_1;
        hasRequiredTls = 1;
        var forge2 = requireForge();
        requireAsn1();
        requireHmac();
        requireMd5();
        requirePem();
        requirePki();
        requireRandom();
        requireSha1();
        requireUtil();
        var prf_TLS1 = function(secret, label, seed, length) {
          var rval = forge2.util.createBuffer();
          var idx = secret.length >> 1;
          var slen = idx + (secret.length & 1);
          var s1 = secret.substr(0, slen);
          var s2 = secret.substr(idx, slen);
          var ai = forge2.util.createBuffer();
          var hmac2 = forge2.hmac.create();
          seed = label + seed;
          var md5itr = Math.ceil(length / 16);
          var sha1itr = Math.ceil(length / 20);
          hmac2.start("MD5", s1);
          var md5bytes = forge2.util.createBuffer();
          ai.putBytes(seed);
          for (var i = 0; i < md5itr; ++i) {
            hmac2.start(null, null);
            hmac2.update(ai.getBytes());
            ai.putBuffer(hmac2.digest());
            hmac2.start(null, null);
            hmac2.update(ai.bytes() + seed);
            md5bytes.putBuffer(hmac2.digest());
          }
          hmac2.start("SHA1", s2);
          var sha1bytes = forge2.util.createBuffer();
          ai.clear();
          ai.putBytes(seed);
          for (var i = 0; i < sha1itr; ++i) {
            hmac2.start(null, null);
            hmac2.update(ai.getBytes());
            ai.putBuffer(hmac2.digest());
            hmac2.start(null, null);
            hmac2.update(ai.bytes() + seed);
            sha1bytes.putBuffer(hmac2.digest());
          }
          rval.putBytes(forge2.util.xorBytes(
            md5bytes.getBytes(),
            sha1bytes.getBytes(),
            length
          ));
          return rval;
        };
        var hmac_sha1 = function(key2, seqNum, record) {
          var hmac2 = forge2.hmac.create();
          hmac2.start("SHA1", key2);
          var b = forge2.util.createBuffer();
          b.putInt32(seqNum[0]);
          b.putInt32(seqNum[1]);
          b.putByte(record.type);
          b.putByte(record.version.major);
          b.putByte(record.version.minor);
          b.putInt16(record.length);
          b.putBytes(record.fragment.bytes());
          hmac2.update(b.getBytes());
          return hmac2.digest().getBytes();
        };
        var deflate = function(c, record, s) {
          var rval = false;
          try {
            var bytes = c.deflate(record.fragment.getBytes());
            record.fragment = forge2.util.createBuffer(bytes);
            record.length = bytes.length;
            rval = true;
          } catch (ex) {
          }
          return rval;
        };
        var inflate = function(c, record, s) {
          var rval = false;
          try {
            var bytes = c.inflate(record.fragment.getBytes());
            record.fragment = forge2.util.createBuffer(bytes);
            record.length = bytes.length;
            rval = true;
          } catch (ex) {
          }
          return rval;
        };
        var readVector = function(b, lenBytes) {
          var len = 0;
          switch (lenBytes) {
            case 1:
              len = b.getByte();
              break;
            case 2:
              len = b.getInt16();
              break;
            case 3:
              len = b.getInt24();
              break;
            case 4:
              len = b.getInt32();
              break;
          }
          return forge2.util.createBuffer(b.getBytes(len));
        };
        var writeVector = function(b, lenBytes, v) {
          b.putInt(v.length(), lenBytes << 3);
          b.putBuffer(v);
        };
        var tls = {};
        tls.Versions = {
          TLS_1_0: { major: 3, minor: 1 },
          TLS_1_1: { major: 3, minor: 2 },
          TLS_1_2: { major: 3, minor: 3 }
        };
        tls.SupportedVersions = [
          tls.Versions.TLS_1_1,
          tls.Versions.TLS_1_0
        ];
        tls.Version = tls.SupportedVersions[0];
        tls.MaxFragment = 16384 - 1024;
        tls.ConnectionEnd = {
          server: 0,
          client: 1
        };
        tls.PRFAlgorithm = {
          tls_prf_sha256: 0
        };
        tls.BulkCipherAlgorithm = {
          none: null,
          rc4: 0,
          des3: 1,
          aes: 2
        };
        tls.CipherType = {
          stream: 0,
          block: 1,
          aead: 2
        };
        tls.MACAlgorithm = {
          none: null,
          hmac_md5: 0,
          hmac_sha1: 1,
          hmac_sha256: 2,
          hmac_sha384: 3,
          hmac_sha512: 4
        };
        tls.CompressionMethod = {
          none: 0,
          deflate: 1
        };
        tls.ContentType = {
          change_cipher_spec: 20,
          alert: 21,
          handshake: 22,
          application_data: 23,
          heartbeat: 24
        };
        tls.HandshakeType = {
          hello_request: 0,
          client_hello: 1,
          server_hello: 2,
          certificate: 11,
          server_key_exchange: 12,
          certificate_request: 13,
          server_hello_done: 14,
          certificate_verify: 15,
          client_key_exchange: 16,
          finished: 20
        };
        tls.Alert = {};
        tls.Alert.Level = {
          warning: 1,
          fatal: 2
        };
        tls.Alert.Description = {
          close_notify: 0,
          unexpected_message: 10,
          bad_record_mac: 20,
          decryption_failed: 21,
          record_overflow: 22,
          decompression_failure: 30,
          handshake_failure: 40,
          bad_certificate: 42,
          unsupported_certificate: 43,
          certificate_revoked: 44,
          certificate_expired: 45,
          certificate_unknown: 46,
          illegal_parameter: 47,
          unknown_ca: 48,
          access_denied: 49,
          decode_error: 50,
          decrypt_error: 51,
          export_restriction: 60,
          protocol_version: 70,
          insufficient_security: 71,
          internal_error: 80,
          user_canceled: 90,
          no_renegotiation: 100
        };
        tls.HeartbeatMessageType = {
          heartbeat_request: 1,
          heartbeat_response: 2
        };
        tls.CipherSuites = {};
        tls.getCipherSuite = function(twoBytes) {
          var rval = null;
          for (var key2 in tls.CipherSuites) {
            var cs = tls.CipherSuites[key2];
            if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
              rval = cs;
              break;
            }
          }
          return rval;
        };
        tls.handleUnexpected = function(c, record) {
          var ignore = !c.open && c.entity === tls.ConnectionEnd.client;
          if (!ignore) {
            c.error(c, {
              message: "Unexpected message. Received TLS record out of order.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.unexpected_message
              }
            });
          }
        };
        tls.handleHelloRequest = function(c, record, length) {
          if (!c.handshaking && c.handshakes > 0) {
            tls.queue(c, tls.createAlert(c, {
              level: tls.Alert.Level.warning,
              description: tls.Alert.Description.no_renegotiation
            }));
            tls.flush(c);
          }
          c.process();
        };
        tls.parseHelloMessage = function(c, record, length) {
          var msg = null;
          var client2 = c.entity === tls.ConnectionEnd.client;
          if (length < 38) {
            c.error(c, {
              message: client2 ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          } else {
            var b = record.fragment;
            var remaining = b.length();
            msg = {
              version: {
                major: b.getByte(),
                minor: b.getByte()
              },
              random: forge2.util.createBuffer(b.getBytes(32)),
              session_id: readVector(b, 1),
              extensions: []
            };
            if (client2) {
              msg.cipher_suite = b.getBytes(2);
              msg.compression_method = b.getByte();
            } else {
              msg.cipher_suites = readVector(b, 2);
              msg.compression_methods = readVector(b, 1);
            }
            remaining = length - (remaining - b.length());
            if (remaining > 0) {
              var exts = readVector(b, 2);
              while (exts.length() > 0) {
                msg.extensions.push({
                  type: [exts.getByte(), exts.getByte()],
                  data: readVector(exts, 2)
                });
              }
              if (!client2) {
                for (var i = 0; i < msg.extensions.length; ++i) {
                  var ext = msg.extensions[i];
                  if (ext.type[0] === 0 && ext.type[1] === 0) {
                    var snl = readVector(ext.data, 2);
                    while (snl.length() > 0) {
                      var snType = snl.getByte();
                      if (snType !== 0) {
                        break;
                      }
                      c.session.extensions.server_name.serverNameList.push(
                        readVector(snl, 2).getBytes()
                      );
                    }
                  }
                }
              }
            }
            if (c.session.version) {
              if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) {
                return c.error(c, {
                  message: "TLS version change is disallowed during renegotiation.",
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.protocol_version
                  }
                });
              }
            }
            if (client2) {
              c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);
            } else {
              var tmp = forge2.util.createBuffer(msg.cipher_suites.bytes());
              while (tmp.length() > 0) {
                c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));
                if (c.session.cipherSuite !== null) {
                  break;
                }
              }
            }
            if (c.session.cipherSuite === null) {
              return c.error(c, {
                message: "No cipher suites in common.",
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.handshake_failure
                },
                cipherSuite: forge2.util.bytesToHex(msg.cipher_suite)
              });
            }
            if (client2) {
              c.session.compressionMethod = msg.compression_method;
            } else {
              c.session.compressionMethod = tls.CompressionMethod.none;
            }
          }
          return msg;
        };
        tls.createSecurityParameters = function(c, msg) {
          var client2 = c.entity === tls.ConnectionEnd.client;
          var msgRandom = msg.random.bytes();
          var cRandom = client2 ? c.session.sp.client_random : msgRandom;
          var sRandom = client2 ? msgRandom : tls.createRandom().getBytes();
          c.session.sp = {
            entity: c.entity,
            prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
            bulk_cipher_algorithm: null,
            cipher_type: null,
            enc_key_length: null,
            block_length: null,
            fixed_iv_length: null,
            record_iv_length: null,
            mac_algorithm: null,
            mac_length: null,
            mac_key_length: null,
            compression_algorithm: c.session.compressionMethod,
            pre_master_secret: null,
            master_secret: null,
            client_random: cRandom,
            server_random: sRandom
          };
        };
        tls.handleServerHello = function(c, record, length) {
          var msg = tls.parseHelloMessage(c, record, length);
          if (c.fail) {
            return;
          }
          if (msg.version.minor <= c.version.minor) {
            c.version.minor = msg.version.minor;
          } else {
            return c.error(c, {
              message: "Incompatible TLS version.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
          c.session.version = c.version;
          var sessionId = msg.session_id.bytes();
          if (sessionId.length > 0 && sessionId === c.session.id) {
            c.expect = SCC;
            c.session.resuming = true;
            c.session.sp.server_random = msg.random.bytes();
          } else {
            c.expect = SCE;
            c.session.resuming = false;
            tls.createSecurityParameters(c, msg);
          }
          c.session.id = sessionId;
          c.process();
        };
        tls.handleClientHello = function(c, record, length) {
          var msg = tls.parseHelloMessage(c, record, length);
          if (c.fail) {
            return;
          }
          var sessionId = msg.session_id.bytes();
          var session = null;
          if (c.sessionCache) {
            session = c.sessionCache.getSession(sessionId);
            if (session === null) {
              sessionId = "";
            } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
              session = null;
              sessionId = "";
            }
          }
          if (sessionId.length === 0) {
            sessionId = forge2.random.getBytes(32);
          }
          c.session.id = sessionId;
          c.session.clientHelloVersion = msg.version;
          c.session.sp = {};
          if (session) {
            c.version = c.session.version = session.version;
            c.session.sp = session.sp;
          } else {
            var version;
            for (var i = 1; i < tls.SupportedVersions.length; ++i) {
              version = tls.SupportedVersions[i];
              if (version.minor <= msg.version.minor) {
                break;
              }
            }
            c.version = { major: version.major, minor: version.minor };
            c.session.version = c.version;
          }
          if (session !== null) {
            c.expect = CCC;
            c.session.resuming = true;
            c.session.sp.client_random = msg.random.bytes();
          } else {
            c.expect = c.verifyClient !== false ? CCE : CKE;
            c.session.resuming = false;
            tls.createSecurityParameters(c, msg);
          }
          c.open = true;
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createServerHello(c)
          }));
          if (c.session.resuming) {
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.change_cipher_spec,
              data: tls.createChangeCipherSpec()
            }));
            c.state.pending = tls.createConnectionState(c);
            c.state.current.write = c.state.pending.write;
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createFinished(c)
            }));
          } else {
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createCertificate(c)
            }));
            if (!c.fail) {
              tls.queue(c, tls.createRecord(c, {
                type: tls.ContentType.handshake,
                data: tls.createServerKeyExchange(c)
              }));
              if (c.verifyClient !== false) {
                tls.queue(c, tls.createRecord(c, {
                  type: tls.ContentType.handshake,
                  data: tls.createCertificateRequest(c)
                }));
              }
              tls.queue(c, tls.createRecord(c, {
                type: tls.ContentType.handshake,
                data: tls.createServerHelloDone(c)
              }));
            }
          }
          tls.flush(c);
          c.process();
        };
        tls.handleCertificate = function(c, record, length) {
          if (length < 3) {
            return c.error(c, {
              message: "Invalid Certificate message. Message too short.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          }
          var b = record.fragment;
          var msg = {
            certificate_list: readVector(b, 3)
          };
          var cert, asn12;
          var certs = [];
          try {
            while (msg.certificate_list.length() > 0) {
              cert = readVector(msg.certificate_list, 3);
              asn12 = forge2.asn1.fromDer(cert);
              cert = forge2.pki.certificateFromAsn1(asn12, true);
              certs.push(cert);
            }
          } catch (ex) {
            return c.error(c, {
              message: "Could not parse certificate list.",
              cause: ex,
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.bad_certificate
              }
            });
          }
          var client2 = c.entity === tls.ConnectionEnd.client;
          if ((client2 || c.verifyClient === true) && certs.length === 0) {
            c.error(c, {
              message: client2 ? "No server certificate provided." : "No client certificate provided.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          } else if (certs.length === 0) {
            c.expect = client2 ? SKE : CKE;
          } else {
            if (client2) {
              c.session.serverCertificate = certs[0];
            } else {
              c.session.clientCertificate = certs[0];
            }
            if (tls.verifyCertificateChain(c, certs)) {
              c.expect = client2 ? SKE : CKE;
            }
          }
          c.process();
        };
        tls.handleServerKeyExchange = function(c, record, length) {
          if (length > 0) {
            return c.error(c, {
              message: "Invalid key parameters. Only RSA is supported.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.unsupported_certificate
              }
            });
          }
          c.expect = SCR;
          c.process();
        };
        tls.handleClientKeyExchange = function(c, record, length) {
          if (length < 48) {
            return c.error(c, {
              message: "Invalid key parameters. Only RSA is supported.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.unsupported_certificate
              }
            });
          }
          var b = record.fragment;
          var msg = {
            enc_pre_master_secret: readVector(b, 2).getBytes()
          };
          var privateKey = null;
          if (c.getPrivateKey) {
            try {
              privateKey = c.getPrivateKey(c, c.session.serverCertificate);
              privateKey = forge2.pki.privateKeyFromPem(privateKey);
            } catch (ex) {
              c.error(c, {
                message: "Could not get private key.",
                cause: ex,
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.internal_error
                }
              });
            }
          }
          if (privateKey === null) {
            return c.error(c, {
              message: "No private key set.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.internal_error
              }
            });
          }
          try {
            var sp = c.session.sp;
            sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
            var version = c.session.clientHelloVersion;
            if (version.major !== sp.pre_master_secret.charCodeAt(0) || version.minor !== sp.pre_master_secret.charCodeAt(1)) {
              throw new Error("TLS version rollback attack detected.");
            }
          } catch (ex) {
            sp.pre_master_secret = forge2.random.getBytes(48);
          }
          c.expect = CCC;
          if (c.session.clientCertificate !== null) {
            c.expect = CCV;
          }
          c.process();
        };
        tls.handleCertificateRequest = function(c, record, length) {
          if (length < 3) {
            return c.error(c, {
              message: "Invalid CertificateRequest. Message too short.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          }
          var b = record.fragment;
          var msg = {
            certificate_types: readVector(b, 1),
            certificate_authorities: readVector(b, 2)
          };
          c.session.certificateRequest = msg;
          c.expect = SHD;
          c.process();
        };
        tls.handleCertificateVerify = function(c, record, length) {
          if (length < 2) {
            return c.error(c, {
              message: "Invalid CertificateVerify. Message too short.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          }
          var b = record.fragment;
          b.read -= 4;
          var msgBytes = b.bytes();
          b.read += 4;
          var msg = {
            signature: readVector(b, 2).getBytes()
          };
          var verify = forge2.util.createBuffer();
          verify.putBuffer(c.session.md5.digest());
          verify.putBuffer(c.session.sha1.digest());
          verify = verify.getBytes();
          try {
            var cert = c.session.clientCertificate;
            if (!cert.publicKey.verify(verify, msg.signature, "NONE")) {
              throw new Error("CertificateVerify signature does not match.");
            }
            c.session.md5.update(msgBytes);
            c.session.sha1.update(msgBytes);
          } catch (ex) {
            return c.error(c, {
              message: "Bad signature in CertificateVerify.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.handshake_failure
              }
            });
          }
          c.expect = CCC;
          c.process();
        };
        tls.handleServerHelloDone = function(c, record, length) {
          if (length > 0) {
            return c.error(c, {
              message: "Invalid ServerHelloDone message. Invalid length.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.record_overflow
              }
            });
          }
          if (c.serverCertificate === null) {
            var error = {
              message: "No server certificate provided. Not enough security.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.insufficient_security
              }
            };
            var depth = 0;
            var ret = c.verify(c, error.alert.description, depth, []);
            if (ret !== true) {
              if (ret || ret === 0) {
                if (typeof ret === "object" && !forge2.util.isArray(ret)) {
                  if (ret.message) {
                    error.message = ret.message;
                  }
                  if (ret.alert) {
                    error.alert.description = ret.alert;
                  }
                } else if (typeof ret === "number") {
                  error.alert.description = ret;
                }
              }
              return c.error(c, error);
            }
          }
          if (c.session.certificateRequest !== null) {
            record = tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createCertificate(c)
            });
            tls.queue(c, record);
          }
          record = tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createClientKeyExchange(c)
          });
          tls.queue(c, record);
          c.expect = SER;
          var callback = function(c2, signature) {
            if (c2.session.certificateRequest !== null && c2.session.clientCertificate !== null) {
              tls.queue(c2, tls.createRecord(c2, {
                type: tls.ContentType.handshake,
                data: tls.createCertificateVerify(c2, signature)
              }));
            }
            tls.queue(c2, tls.createRecord(c2, {
              type: tls.ContentType.change_cipher_spec,
              data: tls.createChangeCipherSpec()
            }));
            c2.state.pending = tls.createConnectionState(c2);
            c2.state.current.write = c2.state.pending.write;
            tls.queue(c2, tls.createRecord(c2, {
              type: tls.ContentType.handshake,
              data: tls.createFinished(c2)
            }));
            c2.expect = SCC;
            tls.flush(c2);
            c2.process();
          };
          if (c.session.certificateRequest === null || c.session.clientCertificate === null) {
            return callback(c, null);
          }
          tls.getClientSignature(c, callback);
        };
        tls.handleChangeCipherSpec = function(c, record) {
          if (record.fragment.getByte() !== 1) {
            return c.error(c, {
              message: "Invalid ChangeCipherSpec message received.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          }
          var client2 = c.entity === tls.ConnectionEnd.client;
          if (c.session.resuming && client2 || !c.session.resuming && !client2) {
            c.state.pending = tls.createConnectionState(c);
          }
          c.state.current.read = c.state.pending.read;
          if (!c.session.resuming && client2 || c.session.resuming && !client2) {
            c.state.pending = null;
          }
          c.expect = client2 ? SFI : CFI;
          c.process();
        };
        tls.handleFinished = function(c, record, length) {
          var b = record.fragment;
          b.read -= 4;
          var msgBytes = b.bytes();
          b.read += 4;
          var vd = record.fragment.getBytes();
          b = forge2.util.createBuffer();
          b.putBuffer(c.session.md5.digest());
          b.putBuffer(c.session.sha1.digest());
          var client2 = c.entity === tls.ConnectionEnd.client;
          var label = client2 ? "server finished" : "client finished";
          var sp = c.session.sp;
          var vdl = 12;
          var prf = prf_TLS1;
          b = prf(sp.master_secret, label, b.getBytes(), vdl);
          if (b.getBytes() !== vd) {
            return c.error(c, {
              message: "Invalid verify_data in Finished message.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.decrypt_error
              }
            });
          }
          c.session.md5.update(msgBytes);
          c.session.sha1.update(msgBytes);
          if (c.session.resuming && client2 || !c.session.resuming && !client2) {
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.change_cipher_spec,
              data: tls.createChangeCipherSpec()
            }));
            c.state.current.write = c.state.pending.write;
            c.state.pending = null;
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createFinished(c)
            }));
          }
          c.expect = client2 ? SAD : CAD;
          c.handshaking = false;
          ++c.handshakes;
          c.peerCertificate = client2 ? c.session.serverCertificate : c.session.clientCertificate;
          tls.flush(c);
          c.isConnected = true;
          c.connected(c);
          c.process();
        };
        tls.handleAlert = function(c, record) {
          var b = record.fragment;
          var alert = {
            level: b.getByte(),
            description: b.getByte()
          };
          var msg;
          switch (alert.description) {
            case tls.Alert.Description.close_notify:
              msg = "Connection closed.";
              break;
            case tls.Alert.Description.unexpected_message:
              msg = "Unexpected message.";
              break;
            case tls.Alert.Description.bad_record_mac:
              msg = "Bad record MAC.";
              break;
            case tls.Alert.Description.decryption_failed:
              msg = "Decryption failed.";
              break;
            case tls.Alert.Description.record_overflow:
              msg = "Record overflow.";
              break;
            case tls.Alert.Description.decompression_failure:
              msg = "Decompression failed.";
              break;
            case tls.Alert.Description.handshake_failure:
              msg = "Handshake failure.";
              break;
            case tls.Alert.Description.bad_certificate:
              msg = "Bad certificate.";
              break;
            case tls.Alert.Description.unsupported_certificate:
              msg = "Unsupported certificate.";
              break;
            case tls.Alert.Description.certificate_revoked:
              msg = "Certificate revoked.";
              break;
            case tls.Alert.Description.certificate_expired:
              msg = "Certificate expired.";
              break;
            case tls.Alert.Description.certificate_unknown:
              msg = "Certificate unknown.";
              break;
            case tls.Alert.Description.illegal_parameter:
              msg = "Illegal parameter.";
              break;
            case tls.Alert.Description.unknown_ca:
              msg = "Unknown certificate authority.";
              break;
            case tls.Alert.Description.access_denied:
              msg = "Access denied.";
              break;
            case tls.Alert.Description.decode_error:
              msg = "Decode error.";
              break;
            case tls.Alert.Description.decrypt_error:
              msg = "Decrypt error.";
              break;
            case tls.Alert.Description.export_restriction:
              msg = "Export restriction.";
              break;
            case tls.Alert.Description.protocol_version:
              msg = "Unsupported protocol version.";
              break;
            case tls.Alert.Description.insufficient_security:
              msg = "Insufficient security.";
              break;
            case tls.Alert.Description.internal_error:
              msg = "Internal error.";
              break;
            case tls.Alert.Description.user_canceled:
              msg = "User canceled.";
              break;
            case tls.Alert.Description.no_renegotiation:
              msg = "Renegotiation not supported.";
              break;
            default:
              msg = "Unknown error.";
              break;
          }
          if (alert.description === tls.Alert.Description.close_notify) {
            return c.close();
          }
          c.error(c, {
            message: msg,
            send: false,
            // origin is the opposite end
            origin: c.entity === tls.ConnectionEnd.client ? "server" : "client",
            alert
          });
          c.process();
        };
        tls.handleHandshake = function(c, record) {
          var b = record.fragment;
          var type = b.getByte();
          var length = b.getInt24();
          if (length > b.length()) {
            c.fragmented = record;
            record.fragment = forge2.util.createBuffer();
            b.read -= 4;
            return c.process();
          }
          c.fragmented = null;
          b.read -= 4;
          var bytes = b.bytes(length + 4);
          b.read += 4;
          if (type in hsTable[c.entity][c.expect]) {
            if (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {
              c.handshaking = true;
              c.session = {
                version: null,
                extensions: {
                  server_name: {
                    serverNameList: []
                  }
                },
                cipherSuite: null,
                compressionMethod: null,
                serverCertificate: null,
                clientCertificate: null,
                md5: forge2.md.md5.create(),
                sha1: forge2.md.sha1.create()
              };
            }
            if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {
              c.session.md5.update(bytes);
              c.session.sha1.update(bytes);
            }
            hsTable[c.entity][c.expect][type](c, record, length);
          } else {
            tls.handleUnexpected(c, record);
          }
        };
        tls.handleApplicationData = function(c, record) {
          c.data.putBuffer(record.fragment);
          c.dataReady(c);
          c.process();
        };
        tls.handleHeartbeat = function(c, record) {
          var b = record.fragment;
          var type = b.getByte();
          var length = b.getInt16();
          var payload = b.getBytes(length);
          if (type === tls.HeartbeatMessageType.heartbeat_request) {
            if (c.handshaking || length > payload.length) {
              return c.process();
            }
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.heartbeat,
              data: tls.createHeartbeat(
                tls.HeartbeatMessageType.heartbeat_response,
                payload
              )
            }));
            tls.flush(c);
          } else if (type === tls.HeartbeatMessageType.heartbeat_response) {
            if (payload !== c.expectedHeartbeatPayload) {
              return c.process();
            }
            if (c.heartbeatReceived) {
              c.heartbeatReceived(c, forge2.util.createBuffer(payload));
            }
          }
          c.process();
        };
        var SHE = 0;
        var SCE = 1;
        var SKE = 2;
        var SCR = 3;
        var SHD = 4;
        var SCC = 5;
        var SFI = 6;
        var SAD = 7;
        var SER = 8;
        var CHE = 0;
        var CCE = 1;
        var CKE = 2;
        var CCV = 3;
        var CCC = 4;
        var CFI = 5;
        var CAD = 6;
        var __ = tls.handleUnexpected;
        var R0 = tls.handleChangeCipherSpec;
        var R1 = tls.handleAlert;
        var R2 = tls.handleHandshake;
        var R3 = tls.handleApplicationData;
        var R4 = tls.handleHeartbeat;
        var ctTable = [];
        ctTable[tls.ConnectionEnd.client] = [
          //      CC,AL,HS,AD,HB
          /*SHE*/
          [__, R1, R2, __, R4],
          /*SCE*/
          [__, R1, R2, __, R4],
          /*SKE*/
          [__, R1, R2, __, R4],
          /*SCR*/
          [__, R1, R2, __, R4],
          /*SHD*/
          [__, R1, R2, __, R4],
          /*SCC*/
          [R0, R1, __, __, R4],
          /*SFI*/
          [__, R1, R2, __, R4],
          /*SAD*/
          [__, R1, R2, R3, R4],
          /*SER*/
          [__, R1, R2, __, R4]
        ];
        ctTable[tls.ConnectionEnd.server] = [
          //      CC,AL,HS,AD
          /*CHE*/
          [__, R1, R2, __, R4],
          /*CCE*/
          [__, R1, R2, __, R4],
          /*CKE*/
          [__, R1, R2, __, R4],
          /*CCV*/
          [__, R1, R2, __, R4],
          /*CCC*/
          [R0, R1, __, __, R4],
          /*CFI*/
          [__, R1, R2, __, R4],
          /*CAD*/
          [__, R1, R2, R3, R4],
          /*CER*/
          [__, R1, R2, __, R4]
        ];
        var H0 = tls.handleHelloRequest;
        var H1 = tls.handleServerHello;
        var H2 = tls.handleCertificate;
        var H3 = tls.handleServerKeyExchange;
        var H4 = tls.handleCertificateRequest;
        var H5 = tls.handleServerHelloDone;
        var H6 = tls.handleFinished;
        var hsTable = [];
        hsTable[tls.ConnectionEnd.client] = [
          //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI
          /*SHE*/
          [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*SCE*/
          [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __],
          /*SKE*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],
          /*SCR*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],
          /*SHD*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],
          /*SCC*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*SFI*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
          /*SAD*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*SER*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
        ];
        var H7 = tls.handleClientHello;
        var H8 = tls.handleClientKeyExchange;
        var H9 = tls.handleCertificateVerify;
        hsTable[tls.ConnectionEnd.server] = [
          //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI
          /*CHE*/
          [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*CCE*/
          [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __],
          /*CKE*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],
          /*CCV*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],
          /*CCC*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*CFI*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
          /*CAD*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*CER*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
        ];
        tls.generateKeys = function(c, sp) {
          var prf = prf_TLS1;
          var random2 = sp.client_random + sp.server_random;
          if (!c.session.resuming) {
            sp.master_secret = prf(
              sp.pre_master_secret,
              "master secret",
              random2,
              48
            ).bytes();
            sp.pre_master_secret = null;
          }
          random2 = sp.server_random + sp.client_random;
          var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
          var tls10 = c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor;
          if (tls10) {
            length += 2 * sp.fixed_iv_length;
          }
          var km = prf(sp.master_secret, "key expansion", random2, length);
          var rval = {
            client_write_MAC_key: km.getBytes(sp.mac_key_length),
            server_write_MAC_key: km.getBytes(sp.mac_key_length),
            client_write_key: km.getBytes(sp.enc_key_length),
            server_write_key: km.getBytes(sp.enc_key_length)
          };
          if (tls10) {
            rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
            rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
          }
          return rval;
        };
        tls.createConnectionState = function(c) {
          var client2 = c.entity === tls.ConnectionEnd.client;
          var createMode = function() {
            var mode = {
              // two 32-bit numbers, first is most significant
              sequenceNumber: [0, 0],
              macKey: null,
              macLength: 0,
              macFunction: null,
              cipherState: null,
              cipherFunction: function(record) {
                return true;
              },
              compressionState: null,
              compressFunction: function(record) {
                return true;
              },
              updateSequenceNumber: function() {
                if (mode.sequenceNumber[1] === 4294967295) {
                  mode.sequenceNumber[1] = 0;
                  ++mode.sequenceNumber[0];
                } else {
                  ++mode.sequenceNumber[1];
                }
              }
            };
            return mode;
          };
          var state = {
            read: createMode(),
            write: createMode()
          };
          state.read.update = function(c2, record) {
            if (!state.read.cipherFunction(record, state.read)) {
              c2.error(c2, {
                message: "Could not decrypt record or bad MAC.",
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  // doesn't matter if decryption failed or MAC was
                  // invalid, return the same error so as not to reveal
                  // which one occurred
                  description: tls.Alert.Description.bad_record_mac
                }
              });
            } else if (!state.read.compressFunction(c2, record, state.read)) {
              c2.error(c2, {
                message: "Could not decompress record.",
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.decompression_failure
                }
              });
            }
            return !c2.fail;
          };
          state.write.update = function(c2, record) {
            if (!state.write.compressFunction(c2, record, state.write)) {
              c2.error(c2, {
                message: "Could not compress record.",
                send: false,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.internal_error
                }
              });
            } else if (!state.write.cipherFunction(record, state.write)) {
              c2.error(c2, {
                message: "Could not encrypt record.",
                send: false,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.internal_error
                }
              });
            }
            return !c2.fail;
          };
          if (c.session) {
            var sp = c.session.sp;
            c.session.cipherSuite.initSecurityParameters(sp);
            sp.keys = tls.generateKeys(c, sp);
            state.read.macKey = client2 ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
            state.write.macKey = client2 ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
            c.session.cipherSuite.initConnectionState(state, c, sp);
            switch (sp.compression_algorithm) {
              case tls.CompressionMethod.none:
                break;
              case tls.CompressionMethod.deflate:
                state.read.compressFunction = inflate;
                state.write.compressFunction = deflate;
                break;
              default:
                throw new Error("Unsupported compression algorithm.");
            }
          }
          return state;
        };
        tls.createRandom = function() {
          var d = /* @__PURE__ */ new Date();
          var utc = +d + d.getTimezoneOffset() * 6e4;
          var rval = forge2.util.createBuffer();
          rval.putInt32(utc);
          rval.putBytes(forge2.random.getBytes(28));
          return rval;
        };
        tls.createRecord = function(c, options) {
          if (!options.data) {
            return null;
          }
          var record = {
            type: options.type,
            version: {
              major: c.version.major,
              minor: c.version.minor
            },
            length: options.data.length(),
            fragment: options.data
          };
          return record;
        };
        tls.createAlert = function(c, alert) {
          var b = forge2.util.createBuffer();
          b.putByte(alert.level);
          b.putByte(alert.description);
          return tls.createRecord(c, {
            type: tls.ContentType.alert,
            data: b
          });
        };
        tls.createClientHello = function(c) {
          c.session.clientHelloVersion = {
            major: c.version.major,
            minor: c.version.minor
          };
          var cipherSuites = forge2.util.createBuffer();
          for (var i = 0; i < c.cipherSuites.length; ++i) {
            var cs = c.cipherSuites[i];
            cipherSuites.putByte(cs.id[0]);
            cipherSuites.putByte(cs.id[1]);
          }
          var cSuites = cipherSuites.length();
          var compressionMethods = forge2.util.createBuffer();
          compressionMethods.putByte(tls.CompressionMethod.none);
          var cMethods = compressionMethods.length();
          var extensions2 = forge2.util.createBuffer();
          if (c.virtualHost) {
            var ext = forge2.util.createBuffer();
            ext.putByte(0);
            ext.putByte(0);
            var serverName = forge2.util.createBuffer();
            serverName.putByte(0);
            writeVector(serverName, 2, forge2.util.createBuffer(c.virtualHost));
            var snList = forge2.util.createBuffer();
            writeVector(snList, 2, serverName);
            writeVector(ext, 2, snList);
            extensions2.putBuffer(ext);
          }
          var extLength = extensions2.length();
          if (extLength > 0) {
            extLength += 2;
          }
          var sessionId = c.session.id;
          var length = sessionId.length + 1 + // session ID vector
          2 + // version (major + minor)
          4 + 28 + // random time and random bytes
          2 + cSuites + // cipher suites vector
          1 + cMethods + // compression methods vector
          extLength;
          var rval = forge2.util.createBuffer();
          rval.putByte(tls.HandshakeType.client_hello);
          rval.putInt24(length);
          rval.putByte(c.version.major);
          rval.putByte(c.version.minor);
          rval.putBytes(c.session.sp.client_random);
          writeVector(rval, 1, forge2.util.createBuffer(sessionId));
          writeVector(rval, 2, cipherSuites);
          writeVector(rval, 1, compressionMethods);
          if (extLength > 0) {
            writeVector(rval, 2, extensions2);
          }
          return rval;
        };
        tls.createServerHello = function(c) {
          var sessionId = c.session.id;
          var length = sessionId.length + 1 + // session ID vector
          2 + // version (major + minor)
          4 + 28 + // random time and random bytes
          2 + // chosen cipher suite
          1;
          var rval = forge2.util.createBuffer();
          rval.putByte(tls.HandshakeType.server_hello);
          rval.putInt24(length);
          rval.putByte(c.version.major);
          rval.putByte(c.version.minor);
          rval.putBytes(c.session.sp.server_random);
          writeVector(rval, 1, forge2.util.createBuffer(sessionId));
          rval.putByte(c.session.cipherSuite.id[0]);
          rval.putByte(c.session.cipherSuite.id[1]);
          rval.putByte(c.session.compressionMethod);
          return rval;
        };
        tls.createCertificate = function(c) {
          var client2 = c.entity === tls.ConnectionEnd.client;
          var cert = null;
          if (c.getCertificate) {
            var hint;
            if (client2) {
              hint = c.session.certificateRequest;
            } else {
              hint = c.session.extensions.server_name.serverNameList;
            }
            cert = c.getCertificate(c, hint);
          }
          var certList = forge2.util.createBuffer();
          if (cert !== null) {
            try {
              if (!forge2.util.isArray(cert)) {
                cert = [cert];
              }
              var asn12 = null;
              for (var i = 0; i < cert.length; ++i) {
                var msg = forge2.pem.decode(cert[i])[0];
                if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
                  var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
                  error.headerType = msg.type;
                  throw error;
                }
                if (msg.procType && msg.procType.type === "ENCRYPTED") {
                  throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
                }
                var der = forge2.util.createBuffer(msg.body);
                if (asn12 === null) {
                  asn12 = forge2.asn1.fromDer(der.bytes(), false);
                }
                var certBuffer = forge2.util.createBuffer();
                writeVector(certBuffer, 3, der);
                certList.putBuffer(certBuffer);
              }
              cert = forge2.pki.certificateFromAsn1(asn12);
              if (client2) {
                c.session.clientCertificate = cert;
              } else {
                c.session.serverCertificate = cert;
              }
            } catch (ex) {
              return c.error(c, {
                message: "Could not send certificate list.",
                cause: ex,
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.bad_certificate
                }
              });
            }
          }
          var length = 3 + certList.length();
          var rval = forge2.util.createBuffer();
          rval.putByte(tls.HandshakeType.certificate);
          rval.putInt24(length);
          writeVector(rval, 3, certList);
          return rval;
        };
        tls.createClientKeyExchange = function(c) {
          var b = forge2.util.createBuffer();
          b.putByte(c.session.clientHelloVersion.major);
          b.putByte(c.session.clientHelloVersion.minor);
          b.putBytes(forge2.random.getBytes(46));
          var sp = c.session.sp;
          sp.pre_master_secret = b.getBytes();
          var key2 = c.session.serverCertificate.publicKey;
          b = key2.encrypt(sp.pre_master_secret);
          var length = b.length + 2;
          var rval = forge2.util.createBuffer();
          rval.putByte(tls.HandshakeType.client_key_exchange);
          rval.putInt24(length);
          rval.putInt16(b.length);
          rval.putBytes(b);
          return rval;
        };
        tls.createServerKeyExchange = function(c) {
          var rval = forge2.util.createBuffer();
          return rval;
        };
        tls.getClientSignature = function(c, callback) {
          var b = forge2.util.createBuffer();
          b.putBuffer(c.session.md5.digest());
          b.putBuffer(c.session.sha1.digest());
          b = b.getBytes();
          c.getSignature = c.getSignature || function(c2, b2, callback2) {
            var privateKey = null;
            if (c2.getPrivateKey) {
              try {
                privateKey = c2.getPrivateKey(c2, c2.session.clientCertificate);
                privateKey = forge2.pki.privateKeyFromPem(privateKey);
              } catch (ex) {
                c2.error(c2, {
                  message: "Could not get private key.",
                  cause: ex,
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.internal_error
                  }
                });
              }
            }
            if (privateKey === null) {
              c2.error(c2, {
                message: "No private key set.",
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.internal_error
                }
              });
            } else {
              b2 = privateKey.sign(b2, null);
            }
            callback2(c2, b2);
          };
          c.getSignature(c, b, callback);
        };
        tls.createCertificateVerify = function(c, signature) {
          var length = signature.length + 2;
          var rval = forge2.util.createBuffer();
          rval.putByte(tls.HandshakeType.certificate_verify);
          rval.putInt24(length);
          rval.putInt16(signature.length);
          rval.putBytes(signature);
          return rval;
        };
        tls.createCertificateRequest = function(c) {
          var certTypes = forge2.util.createBuffer();
          certTypes.putByte(1);
          var cAs = forge2.util.createBuffer();
          for (var key2 in c.caStore.certs) {
            var cert = c.caStore.certs[key2];
            var dn = forge2.pki.distinguishedNameToAsn1(cert.subject);
            var byteBuffer = forge2.asn1.toDer(dn);
            cAs.putInt16(byteBuffer.length());
            cAs.putBuffer(byteBuffer);
          }
          var length = 1 + certTypes.length() + 2 + cAs.length();
          var rval = forge2.util.createBuffer();
          rval.putByte(tls.HandshakeType.certificate_request);
          rval.putInt24(length);
          writeVector(rval, 1, certTypes);
          writeVector(rval, 2, cAs);
          return rval;
        };
        tls.createServerHelloDone = function(c) {
          var rval = forge2.util.createBuffer();
          rval.putByte(tls.HandshakeType.server_hello_done);
          rval.putInt24(0);
          return rval;
        };
        tls.createChangeCipherSpec = function() {
          var rval = forge2.util.createBuffer();
          rval.putByte(1);
          return rval;
        };
        tls.createFinished = function(c) {
          var b = forge2.util.createBuffer();
          b.putBuffer(c.session.md5.digest());
          b.putBuffer(c.session.sha1.digest());
          var client2 = c.entity === tls.ConnectionEnd.client;
          var sp = c.session.sp;
          var vdl = 12;
          var prf = prf_TLS1;
          var label = client2 ? "client finished" : "server finished";
          b = prf(sp.master_secret, label, b.getBytes(), vdl);
          var rval = forge2.util.createBuffer();
          rval.putByte(tls.HandshakeType.finished);
          rval.putInt24(b.length());
          rval.putBuffer(b);
          return rval;
        };
        tls.createHeartbeat = function(type, payload, payloadLength) {
          if (typeof payloadLength === "undefined") {
            payloadLength = payload.length;
          }
          var rval = forge2.util.createBuffer();
          rval.putByte(type);
          rval.putInt16(payloadLength);
          rval.putBytes(payload);
          var plaintextLength = rval.length();
          var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
          rval.putBytes(forge2.random.getBytes(paddingLength));
          return rval;
        };
        tls.queue = function(c, record) {
          if (!record) {
            return;
          }
          if (record.fragment.length() === 0) {
            if (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec) {
              return;
            }
          }
          if (record.type === tls.ContentType.handshake) {
            var bytes = record.fragment.bytes();
            c.session.md5.update(bytes);
            c.session.sha1.update(bytes);
            bytes = null;
          }
          var records;
          if (record.fragment.length() <= tls.MaxFragment) {
            records = [record];
          } else {
            records = [];
            var data = record.fragment.bytes();
            while (data.length > tls.MaxFragment) {
              records.push(tls.createRecord(c, {
                type: record.type,
                data: forge2.util.createBuffer(data.slice(0, tls.MaxFragment))
              }));
              data = data.slice(tls.MaxFragment);
            }
            if (data.length > 0) {
              records.push(tls.createRecord(c, {
                type: record.type,
                data: forge2.util.createBuffer(data)
              }));
            }
          }
          for (var i = 0; i < records.length && !c.fail; ++i) {
            var rec = records[i];
            var s = c.state.current.write;
            if (s.update(c, rec)) {
              c.records.push(rec);
            }
          }
        };
        tls.flush = function(c) {
          for (var i = 0; i < c.records.length; ++i) {
            var record = c.records[i];
            c.tlsData.putByte(record.type);
            c.tlsData.putByte(record.version.major);
            c.tlsData.putByte(record.version.minor);
            c.tlsData.putInt16(record.fragment.length());
            c.tlsData.putBuffer(c.records[i].fragment);
          }
          c.records = [];
          return c.tlsDataReady(c);
        };
        var _certErrorToAlertDesc = function(error) {
          switch (error) {
            case true:
              return true;
            case forge2.pki.certificateError.bad_certificate:
              return tls.Alert.Description.bad_certificate;
            case forge2.pki.certificateError.unsupported_certificate:
              return tls.Alert.Description.unsupported_certificate;
            case forge2.pki.certificateError.certificate_revoked:
              return tls.Alert.Description.certificate_revoked;
            case forge2.pki.certificateError.certificate_expired:
              return tls.Alert.Description.certificate_expired;
            case forge2.pki.certificateError.certificate_unknown:
              return tls.Alert.Description.certificate_unknown;
            case forge2.pki.certificateError.unknown_ca:
              return tls.Alert.Description.unknown_ca;
            default:
              return tls.Alert.Description.bad_certificate;
          }
        };
        var _alertDescToCertError = function(desc) {
          switch (desc) {
            case true:
              return true;
            case tls.Alert.Description.bad_certificate:
              return forge2.pki.certificateError.bad_certificate;
            case tls.Alert.Description.unsupported_certificate:
              return forge2.pki.certificateError.unsupported_certificate;
            case tls.Alert.Description.certificate_revoked:
              return forge2.pki.certificateError.certificate_revoked;
            case tls.Alert.Description.certificate_expired:
              return forge2.pki.certificateError.certificate_expired;
            case tls.Alert.Description.certificate_unknown:
              return forge2.pki.certificateError.certificate_unknown;
            case tls.Alert.Description.unknown_ca:
              return forge2.pki.certificateError.unknown_ca;
            default:
              return forge2.pki.certificateError.bad_certificate;
          }
        };
        tls.verifyCertificateChain = function(c, chain) {
          try {
            var options = {};
            for (var key2 in c.verifyOptions) {
              options[key2] = c.verifyOptions[key2];
            }
            options.verify = function(vfd, depth, chain2) {
              var desc = _certErrorToAlertDesc(vfd);
              var ret = c.verify(c, vfd, depth, chain2);
              if (ret !== true) {
                if (typeof ret === "object" && !forge2.util.isArray(ret)) {
                  var error = new Error("The application rejected the certificate.");
                  error.send = true;
                  error.alert = {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.bad_certificate
                  };
                  if (ret.message) {
                    error.message = ret.message;
                  }
                  if (ret.alert) {
                    error.alert.description = ret.alert;
                  }
                  throw error;
                }
                if (ret !== vfd) {
                  ret = _alertDescToCertError(ret);
                }
              }
              return ret;
            };
            forge2.pki.verifyCertificateChain(c.caStore, chain, options);
          } catch (ex) {
            var err2 = ex;
            if (typeof err2 !== "object" || forge2.util.isArray(err2)) {
              err2 = {
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: _certErrorToAlertDesc(ex)
                }
              };
            }
            if (!("send" in err2)) {
              err2.send = true;
            }
            if (!("alert" in err2)) {
              err2.alert = {
                level: tls.Alert.Level.fatal,
                description: _certErrorToAlertDesc(err2.error)
              };
            }
            c.error(c, err2);
          }
          return !c.fail;
        };
        tls.createSessionCache = function(cache, capacity) {
          var rval = null;
          if (cache && cache.getSession && cache.setSession && cache.order) {
            rval = cache;
          } else {
            rval = {};
            rval.cache = cache || {};
            rval.capacity = Math.max(capacity || 100, 1);
            rval.order = [];
            for (var key2 in cache) {
              if (rval.order.length <= capacity) {
                rval.order.push(key2);
              } else {
                delete cache[key2];
              }
            }
            rval.getSession = function(sessionId) {
              var session = null;
              var key3 = null;
              if (sessionId) {
                key3 = forge2.util.bytesToHex(sessionId);
              } else if (rval.order.length > 0) {
                key3 = rval.order[0];
              }
              if (key3 !== null && key3 in rval.cache) {
                session = rval.cache[key3];
                delete rval.cache[key3];
                for (var i in rval.order) {
                  if (rval.order[i] === key3) {
                    rval.order.splice(i, 1);
                    break;
                  }
                }
              }
              return session;
            };
            rval.setSession = function(sessionId, session) {
              if (rval.order.length === rval.capacity) {
                var key3 = rval.order.shift();
                delete rval.cache[key3];
              }
              var key3 = forge2.util.bytesToHex(sessionId);
              rval.order.push(key3);
              rval.cache[key3] = session;
            };
          }
          return rval;
        };
        tls.createConnection = function(options) {
          var caStore = null;
          if (options.caStore) {
            if (forge2.util.isArray(options.caStore)) {
              caStore = forge2.pki.createCaStore(options.caStore);
            } else {
              caStore = options.caStore;
            }
          } else {
            caStore = forge2.pki.createCaStore();
          }
          var cipherSuites = options.cipherSuites || null;
          if (cipherSuites === null) {
            cipherSuites = [];
            for (var key2 in tls.CipherSuites) {
              cipherSuites.push(tls.CipherSuites[key2]);
            }
          }
          var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;
          var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;
          var c = {
            version: { major: tls.Version.major, minor: tls.Version.minor },
            entity,
            sessionId: options.sessionId,
            caStore,
            sessionCache,
            cipherSuites,
            connected: options.connected,
            virtualHost: options.virtualHost || null,
            verifyClient: options.verifyClient || false,
            verify: options.verify || function(cn, vfd, dpth, cts) {
              return vfd;
            },
            verifyOptions: options.verifyOptions || {},
            getCertificate: options.getCertificate || null,
            getPrivateKey: options.getPrivateKey || null,
            getSignature: options.getSignature || null,
            input: forge2.util.createBuffer(),
            tlsData: forge2.util.createBuffer(),
            data: forge2.util.createBuffer(),
            tlsDataReady: options.tlsDataReady,
            dataReady: options.dataReady,
            heartbeatReceived: options.heartbeatReceived,
            closed: options.closed,
            error: function(c2, ex) {
              ex.origin = ex.origin || (c2.entity === tls.ConnectionEnd.client ? "client" : "server");
              if (ex.send) {
                tls.queue(c2, tls.createAlert(c2, ex.alert));
                tls.flush(c2);
              }
              var fatal = ex.fatal !== false;
              if (fatal) {
                c2.fail = true;
              }
              options.error(c2, ex);
              if (fatal) {
                c2.close(false);
              }
            },
            deflate: options.deflate || null,
            inflate: options.inflate || null
          };
          c.reset = function(clearFail) {
            c.version = { major: tls.Version.major, minor: tls.Version.minor };
            c.record = null;
            c.session = null;
            c.peerCertificate = null;
            c.state = {
              pending: null,
              current: null
            };
            c.expect = c.entity === tls.ConnectionEnd.client ? SHE : CHE;
            c.fragmented = null;
            c.records = [];
            c.open = false;
            c.handshakes = 0;
            c.handshaking = false;
            c.isConnected = false;
            c.fail = !(clearFail || typeof clearFail === "undefined");
            c.input.clear();
            c.tlsData.clear();
            c.data.clear();
            c.state.current = tls.createConnectionState(c);
          };
          c.reset();
          var _update = function(c2, record) {
            var aligned = record.type - tls.ContentType.change_cipher_spec;
            var handlers = ctTable[c2.entity][c2.expect];
            if (aligned in handlers) {
              handlers[aligned](c2, record);
            } else {
              tls.handleUnexpected(c2, record);
            }
          };
          var _readRecordHeader = function(c2) {
            var rval = 0;
            var b = c2.input;
            var len = b.length();
            if (len < 5) {
              rval = 5 - len;
            } else {
              c2.record = {
                type: b.getByte(),
                version: {
                  major: b.getByte(),
                  minor: b.getByte()
                },
                length: b.getInt16(),
                fragment: forge2.util.createBuffer(),
                ready: false
              };
              var compatibleVersion = c2.record.version.major === c2.version.major;
              if (compatibleVersion && c2.session && c2.session.version) {
                compatibleVersion = c2.record.version.minor === c2.version.minor;
              }
              if (!compatibleVersion) {
                c2.error(c2, {
                  message: "Incompatible TLS version.",
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.protocol_version
                  }
                });
              }
            }
            return rval;
          };
          var _readRecord = function(c2) {
            var rval = 0;
            var b = c2.input;
            var len = b.length();
            if (len < c2.record.length) {
              rval = c2.record.length - len;
            } else {
              c2.record.fragment.putBytes(b.getBytes(c2.record.length));
              b.compact();
              var s = c2.state.current.read;
              if (s.update(c2, c2.record)) {
                if (c2.fragmented !== null) {
                  if (c2.fragmented.type === c2.record.type) {
                    c2.fragmented.fragment.putBuffer(c2.record.fragment);
                    c2.record = c2.fragmented;
                  } else {
                    c2.error(c2, {
                      message: "Invalid fragmented record.",
                      send: true,
                      alert: {
                        level: tls.Alert.Level.fatal,
                        description: tls.Alert.Description.unexpected_message
                      }
                    });
                  }
                }
                c2.record.ready = true;
              }
            }
            return rval;
          };
          c.handshake = function(sessionId) {
            if (c.entity !== tls.ConnectionEnd.client) {
              c.error(c, {
                message: "Cannot initiate handshake as a server.",
                fatal: false
              });
            } else if (c.handshaking) {
              c.error(c, {
                message: "Handshake already in progress.",
                fatal: false
              });
            } else {
              if (c.fail && !c.open && c.handshakes === 0) {
                c.fail = false;
              }
              c.handshaking = true;
              sessionId = sessionId || "";
              var session = null;
              if (sessionId.length > 0) {
                if (c.sessionCache) {
                  session = c.sessionCache.getSession(sessionId);
                }
                if (session === null) {
                  sessionId = "";
                }
              }
              if (sessionId.length === 0 && c.sessionCache) {
                session = c.sessionCache.getSession();
                if (session !== null) {
                  sessionId = session.id;
                }
              }
              c.session = {
                id: sessionId,
                version: null,
                cipherSuite: null,
                compressionMethod: null,
                serverCertificate: null,
                certificateRequest: null,
                clientCertificate: null,
                sp: {},
                md5: forge2.md.md5.create(),
                sha1: forge2.md.sha1.create()
              };
              if (session) {
                c.version = session.version;
                c.session.sp = session.sp;
              }
              c.session.sp.client_random = tls.createRandom().getBytes();
              c.open = true;
              tls.queue(c, tls.createRecord(c, {
                type: tls.ContentType.handshake,
                data: tls.createClientHello(c)
              }));
              tls.flush(c);
            }
          };
          c.process = function(data) {
            var rval = 0;
            if (data) {
              c.input.putBytes(data);
            }
            if (!c.fail) {
              if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) {
                c.record = null;
              }
              if (c.record === null) {
                rval = _readRecordHeader(c);
              }
              if (!c.fail && c.record !== null && !c.record.ready) {
                rval = _readRecord(c);
              }
              if (!c.fail && c.record !== null && c.record.ready) {
                _update(c, c.record);
              }
            }
            return rval;
          };
          c.prepare = function(data) {
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.application_data,
              data: forge2.util.createBuffer(data)
            }));
            return tls.flush(c);
          };
          c.prepareHeartbeatRequest = function(payload, payloadLength) {
            if (payload instanceof forge2.util.ByteBuffer) {
              payload = payload.bytes();
            }
            if (typeof payloadLength === "undefined") {
              payloadLength = payload.length;
            }
            c.expectedHeartbeatPayload = payload;
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.heartbeat,
              data: tls.createHeartbeat(
                tls.HeartbeatMessageType.heartbeat_request,
                payload,
                payloadLength
              )
            }));
            return tls.flush(c);
          };
          c.close = function(clearFail) {
            if (!c.fail && c.sessionCache && c.session) {
              var session = {
                id: c.session.id,
                version: c.session.version,
                sp: c.session.sp
              };
              session.sp.keys = null;
              c.sessionCache.setSession(session.id, session);
            }
            if (c.open) {
              c.open = false;
              c.input.clear();
              if (c.isConnected || c.handshaking) {
                c.isConnected = c.handshaking = false;
                tls.queue(c, tls.createAlert(c, {
                  level: tls.Alert.Level.warning,
                  description: tls.Alert.Description.close_notify
                }));
                tls.flush(c);
              }
              c.closed(c);
            }
            c.reset(clearFail);
          };
          return c;
        };
        tls_1 = forge2.tls = forge2.tls || {};
        for (var key in tls) {
          if (typeof tls[key] !== "function") {
            forge2.tls[key] = tls[key];
          }
        }
        forge2.tls.prf_tls1 = prf_TLS1;
        forge2.tls.hmac_sha1 = hmac_sha1;
        forge2.tls.createSessionCache = tls.createSessionCache;
        forge2.tls.createConnection = tls.createConnection;
        return tls_1;
      }
      var hasRequiredAesCipherSuites;
      function requireAesCipherSuites() {
        if (hasRequiredAesCipherSuites) return aesCipherSuites.exports;
        hasRequiredAesCipherSuites = 1;
        var forge2 = requireForge();
        requireAes();
        requireTls();
        var tls = aesCipherSuites.exports = forge2.tls;
        tls.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
          id: [0, 47],
          name: "TLS_RSA_WITH_AES_128_CBC_SHA",
          initSecurityParameters: function(sp) {
            sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
            sp.cipher_type = tls.CipherType.block;
            sp.enc_key_length = 16;
            sp.block_length = 16;
            sp.fixed_iv_length = 16;
            sp.record_iv_length = 16;
            sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
            sp.mac_length = 20;
            sp.mac_key_length = 20;
          },
          initConnectionState
        };
        tls.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
          id: [0, 53],
          name: "TLS_RSA_WITH_AES_256_CBC_SHA",
          initSecurityParameters: function(sp) {
            sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
            sp.cipher_type = tls.CipherType.block;
            sp.enc_key_length = 32;
            sp.block_length = 16;
            sp.fixed_iv_length = 16;
            sp.record_iv_length = 16;
            sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
            sp.mac_length = 20;
            sp.mac_key_length = 20;
          },
          initConnectionState
        };
        function initConnectionState(state, c, sp) {
          var client2 = c.entity === forge2.tls.ConnectionEnd.client;
          state.read.cipherState = {
            init: false,
            cipher: forge2.cipher.createDecipher("AES-CBC", client2 ? sp.keys.server_write_key : sp.keys.client_write_key),
            iv: client2 ? sp.keys.server_write_IV : sp.keys.client_write_IV
          };
          state.write.cipherState = {
            init: false,
            cipher: forge2.cipher.createCipher("AES-CBC", client2 ? sp.keys.client_write_key : sp.keys.server_write_key),
            iv: client2 ? sp.keys.client_write_IV : sp.keys.server_write_IV
          };
          state.read.cipherFunction = decrypt_aes_cbc_sha1;
          state.write.cipherFunction = encrypt_aes_cbc_sha1;
          state.read.macLength = state.write.macLength = sp.mac_length;
          state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
        }
        function encrypt_aes_cbc_sha1(record, s) {
          var rval = false;
          var mac = s.macFunction(s.macKey, s.sequenceNumber, record);
          record.fragment.putBytes(mac);
          s.updateSequenceNumber();
          var iv;
          if (record.version.minor === tls.Versions.TLS_1_0.minor) {
            iv = s.cipherState.init ? null : s.cipherState.iv;
          } else {
            iv = forge2.random.getBytesSync(16);
          }
          s.cipherState.init = true;
          var cipher2 = s.cipherState.cipher;
          cipher2.start({ iv });
          if (record.version.minor >= tls.Versions.TLS_1_1.minor) {
            cipher2.output.putBytes(iv);
          }
          cipher2.update(record.fragment);
          if (cipher2.finish(encrypt_aes_cbc_sha1_padding)) {
            record.fragment = cipher2.output;
            record.length = record.fragment.length();
            rval = true;
          }
          return rval;
        }
        function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
          if (!decrypt) {
            var padding = blockSize - input.length() % blockSize;
            input.fillWithByte(padding - 1, padding);
          }
          return true;
        }
        function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
          var rval = true;
          if (decrypt) {
            var len = output.length();
            var paddingLength = output.last();
            for (var i = len - 1 - paddingLength; i < len - 1; ++i) {
              rval = rval && output.at(i) == paddingLength;
            }
            if (rval) {
              output.truncate(paddingLength + 1);
            }
          }
          return rval;
        }
        function decrypt_aes_cbc_sha1(record, s) {
          var rval = false;
          var iv;
          if (record.version.minor === tls.Versions.TLS_1_0.minor) {
            iv = s.cipherState.init ? null : s.cipherState.iv;
          } else {
            iv = record.fragment.getBytes(16);
          }
          s.cipherState.init = true;
          var cipher2 = s.cipherState.cipher;
          cipher2.start({ iv });
          cipher2.update(record.fragment);
          rval = cipher2.finish(decrypt_aes_cbc_sha1_padding);
          var macLen = s.macLength;
          var mac = forge2.random.getBytesSync(macLen);
          var len = cipher2.output.length();
          if (len >= macLen) {
            record.fragment = cipher2.output.getBytes(len - macLen);
            mac = cipher2.output.getBytes(macLen);
          } else {
            record.fragment = cipher2.output.getBytes();
          }
          record.fragment = forge2.util.createBuffer(record.fragment);
          record.length = record.fragment.length();
          var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);
          s.updateSequenceNumber();
          rval = compareMacs(s.macKey, mac, mac2) && rval;
          return rval;
        }
        function compareMacs(key, mac1, mac2) {
          var hmac2 = forge2.hmac.create();
          hmac2.start("SHA1", key);
          hmac2.update(mac1);
          mac1 = hmac2.digest().getBytes();
          hmac2.start(null, null);
          hmac2.update(mac2);
          mac2 = hmac2.digest().getBytes();
          return mac1 === mac2;
        }
        return aesCipherSuites.exports;
      }
      var sha512 = { exports: {} };
      var hasRequiredSha512;
      function requireSha512() {
        if (hasRequiredSha512) return sha512.exports;
        hasRequiredSha512 = 1;
        var forge2 = requireForge();
        requireMd();
        requireUtil();
        var sha512$1 = sha512.exports = forge2.sha512 = forge2.sha512 || {};
        forge2.md.sha512 = forge2.md.algorithms.sha512 = sha512$1;
        var sha384 = forge2.sha384 = forge2.sha512.sha384 = forge2.sha512.sha384 || {};
        sha384.create = function() {
          return sha512$1.create("SHA-384");
        };
        forge2.md.sha384 = forge2.md.algorithms.sha384 = sha384;
        forge2.sha512.sha256 = forge2.sha512.sha256 || {
          create: function() {
            return sha512$1.create("SHA-512/256");
          }
        };
        forge2.md["sha512/256"] = forge2.md.algorithms["sha512/256"] = forge2.sha512.sha256;
        forge2.sha512.sha224 = forge2.sha512.sha224 || {
          create: function() {
            return sha512$1.create("SHA-512/224");
          }
        };
        forge2.md["sha512/224"] = forge2.md.algorithms["sha512/224"] = forge2.sha512.sha224;
        sha512$1.create = function(algorithm) {
          if (!_initialized) {
            _init();
          }
          if (typeof algorithm === "undefined") {
            algorithm = "SHA-512";
          }
          if (!(algorithm in _states)) {
            throw new Error("Invalid SHA-512 algorithm: " + algorithm);
          }
          var _state = _states[algorithm];
          var _h = null;
          var _input = forge2.util.createBuffer();
          var _w = new Array(80);
          for (var wi = 0; wi < 80; ++wi) {
            _w[wi] = new Array(2);
          }
          var digestLength = 64;
          switch (algorithm) {
            case "SHA-384":
              digestLength = 48;
              break;
            case "SHA-512/256":
              digestLength = 32;
              break;
            case "SHA-512/224":
              digestLength = 28;
              break;
          }
          var md2 = {
            // SHA-512 => sha512
            algorithm: algorithm.replace("-", "").toLowerCase(),
            blockLength: 128,
            digestLength,
            // 56-bit length of message so far (does not including padding)
            messageLength: 0,
            // true message length
            fullMessageLength: null,
            // size of message length in bytes
            messageLengthSize: 16
          };
          md2.start = function() {
            md2.messageLength = 0;
            md2.fullMessageLength = md2.messageLength128 = [];
            var int32s = md2.messageLengthSize / 4;
            for (var i = 0; i < int32s; ++i) {
              md2.fullMessageLength.push(0);
            }
            _input = forge2.util.createBuffer();
            _h = new Array(_state.length);
            for (var i = 0; i < _state.length; ++i) {
              _h[i] = _state[i].slice(0);
            }
            return md2;
          };
          md2.start();
          md2.update = function(msg, encoding) {
            if (encoding === "utf8") {
              msg = forge2.util.encodeUtf8(msg);
            }
            var len = msg.length;
            md2.messageLength += len;
            len = [len / 4294967296 >>> 0, len >>> 0];
            for (var i = md2.fullMessageLength.length - 1; i >= 0; --i) {
              md2.fullMessageLength[i] += len[1];
              len[1] = len[0] + (md2.fullMessageLength[i] / 4294967296 >>> 0);
              md2.fullMessageLength[i] = md2.fullMessageLength[i] >>> 0;
              len[0] = len[1] / 4294967296 >>> 0;
            }
            _input.putBytes(msg);
            _update(_h, _w, _input);
            if (_input.read > 2048 || _input.length() === 0) {
              _input.compact();
            }
            return md2;
          };
          md2.digest = function() {
            var finalBlock = forge2.util.createBuffer();
            finalBlock.putBytes(_input.bytes());
            var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
            var overflow = remaining & md2.blockLength - 1;
            finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
            var next, carry;
            var bits2 = md2.fullMessageLength[0] * 8;
            for (var i = 0; i < md2.fullMessageLength.length - 1; ++i) {
              next = md2.fullMessageLength[i + 1] * 8;
              carry = next / 4294967296 >>> 0;
              bits2 += carry;
              finalBlock.putInt32(bits2 >>> 0);
              bits2 = next >>> 0;
            }
            finalBlock.putInt32(bits2);
            var h = new Array(_h.length);
            for (var i = 0; i < _h.length; ++i) {
              h[i] = _h[i].slice(0);
            }
            _update(h, _w, finalBlock);
            var rval = forge2.util.createBuffer();
            var hlen;
            if (algorithm === "SHA-512") {
              hlen = h.length;
            } else if (algorithm === "SHA-384") {
              hlen = h.length - 2;
            } else {
              hlen = h.length - 4;
            }
            for (var i = 0; i < hlen; ++i) {
              rval.putInt32(h[i][0]);
              if (i !== hlen - 1 || algorithm !== "SHA-512/224") {
                rval.putInt32(h[i][1]);
              }
            }
            return rval;
          };
          return md2;
        };
        var _padding = null;
        var _initialized = false;
        var _k = null;
        var _states = null;
        function _init() {
          _padding = String.fromCharCode(128);
          _padding += forge2.util.fillString(String.fromCharCode(0), 128);
          _k = [
            [1116352408, 3609767458],
            [1899447441, 602891725],
            [3049323471, 3964484399],
            [3921009573, 2173295548],
            [961987163, 4081628472],
            [1508970993, 3053834265],
            [2453635748, 2937671579],
            [2870763221, 3664609560],
            [3624381080, 2734883394],
            [310598401, 1164996542],
            [607225278, 1323610764],
            [1426881987, 3590304994],
            [1925078388, 4068182383],
            [2162078206, 991336113],
            [2614888103, 633803317],
            [3248222580, 3479774868],
            [3835390401, 2666613458],
            [4022224774, 944711139],
            [264347078, 2341262773],
            [604807628, 2007800933],
            [770255983, 1495990901],
            [1249150122, 1856431235],
            [1555081692, 3175218132],
            [1996064986, 2198950837],
            [2554220882, 3999719339],
            [2821834349, 766784016],
            [2952996808, 2566594879],
            [3210313671, 3203337956],
            [3336571891, 1034457026],
            [3584528711, 2466948901],
            [113926993, 3758326383],
            [338241895, 168717936],
            [666307205, 1188179964],
            [773529912, 1546045734],
            [1294757372, 1522805485],
            [1396182291, 2643833823],
            [1695183700, 2343527390],
            [1986661051, 1014477480],
            [2177026350, 1206759142],
            [2456956037, 344077627],
            [2730485921, 1290863460],
            [2820302411, 3158454273],
            [3259730800, 3505952657],
            [3345764771, 106217008],
            [3516065817, 3606008344],
            [3600352804, 1432725776],
            [4094571909, 1467031594],
            [275423344, 851169720],
            [430227734, 3100823752],
            [506948616, 1363258195],
            [659060556, 3750685593],
            [883997877, 3785050280],
            [958139571, 3318307427],
            [1322822218, 3812723403],
            [1537002063, 2003034995],
            [1747873779, 3602036899],
            [1955562222, 1575990012],
            [2024104815, 1125592928],
            [2227730452, 2716904306],
            [2361852424, 442776044],
            [2428436474, 593698344],
            [2756734187, 3733110249],
            [3204031479, 2999351573],
            [3329325298, 3815920427],
            [3391569614, 3928383900],
            [3515267271, 566280711],
            [3940187606, 3454069534],
            [4118630271, 4000239992],
            [116418474, 1914138554],
            [174292421, 2731055270],
            [289380356, 3203993006],
            [460393269, 320620315],
            [685471733, 587496836],
            [852142971, 1086792851],
            [1017036298, 365543100],
            [1126000580, 2618297676],
            [1288033470, 3409855158],
            [1501505948, 4234509866],
            [1607167915, 987167468],
            [1816402316, 1246189591]
          ];
          _states = {};
          _states["SHA-512"] = [
            [1779033703, 4089235720],
            [3144134277, 2227873595],
            [1013904242, 4271175723],
            [2773480762, 1595750129],
            [1359893119, 2917565137],
            [2600822924, 725511199],
            [528734635, 4215389547],
            [1541459225, 327033209]
          ];
          _states["SHA-384"] = [
            [3418070365, 3238371032],
            [1654270250, 914150663],
            [2438529370, 812702999],
            [355462360, 4144912697],
            [1731405415, 4290775857],
            [2394180231, 1750603025],
            [3675008525, 1694076839],
            [1203062813, 3204075428]
          ];
          _states["SHA-512/256"] = [
            [573645204, 4230739756],
            [2673172387, 3360449730],
            [596883563, 1867755857],
            [2520282905, 1497426621],
            [2519219938, 2827943907],
            [3193839141, 1401305490],
            [721525244, 746961066],
            [246885852, 2177182882]
          ];
          _states["SHA-512/224"] = [
            [2352822216, 424955298],
            [1944164710, 2312950998],
            [502970286, 855612546],
            [1738396948, 1479516111],
            [258812777, 2077511080],
            [2011393907, 79989058],
            [1067287976, 1780299464],
            [286451373, 2446758561]
          ];
          _initialized = true;
        }
        function _update(s, w, bytes) {
          var t1_hi, t1_lo;
          var t2_hi, t2_lo;
          var s0_hi, s0_lo;
          var s1_hi, s1_lo;
          var ch_hi, ch_lo;
          var maj_hi, maj_lo;
          var a_hi, a_lo;
          var b_hi, b_lo;
          var c_hi, c_lo;
          var d_hi, d_lo;
          var e_hi, e_lo;
          var f_hi, f_lo;
          var g_hi, g_lo;
          var h_hi, h_lo;
          var i, hi, lo, w2, w7, w15, w16;
          var len = bytes.length();
          while (len >= 128) {
            for (i = 0; i < 16; ++i) {
              w[i][0] = bytes.getInt32() >>> 0;
              w[i][1] = bytes.getInt32() >>> 0;
            }
            for (; i < 80; ++i) {
              w2 = w[i - 2];
              hi = w2[0];
              lo = w2[1];
              t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19
              (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)
              hi >>> 6) >>> 0;
              t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19
              (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)
              (hi << 26 | lo >>> 6)) >>> 0;
              w15 = w[i - 15];
              hi = w15[0];
              lo = w15[1];
              t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1
              (hi >>> 8 | lo << 24) ^ // ROTR 8
              hi >>> 7) >>> 0;
              t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1
              (hi << 24 | lo >>> 8) ^ // ROTR 8
              (hi << 25 | lo >>> 7)) >>> 0;
              w7 = w[i - 7];
              w16 = w[i - 16];
              lo = t1_lo + w7[1] + t2_lo + w16[1];
              w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
              w[i][1] = lo >>> 0;
            }
            a_hi = s[0][0];
            a_lo = s[0][1];
            b_hi = s[1][0];
            b_lo = s[1][1];
            c_hi = s[2][0];
            c_lo = s[2][1];
            d_hi = s[3][0];
            d_lo = s[3][1];
            e_hi = s[4][0];
            e_lo = s[4][1];
            f_hi = s[5][0];
            f_lo = s[5][1];
            g_hi = s[6][0];
            g_lo = s[6][1];
            h_hi = s[7][0];
            h_lo = s[7][1];
            for (i = 0; i < 80; ++i) {
              s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
              (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
              (e_lo >>> 9 | e_hi << 23)) >>> 0;
              s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
              (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
              (e_lo << 23 | e_hi >>> 9)) >>> 0;
              ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
              ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
              s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
              (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
              (a_lo >>> 7 | a_hi << 25)) >>> 0;
              s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
              (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
              (a_lo << 25 | a_hi >>> 7)) >>> 0;
              maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
              maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
              lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];
              t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0;
              t1_lo = lo >>> 0;
              lo = s0_lo + maj_lo;
              t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
              t2_lo = lo >>> 0;
              h_hi = g_hi;
              h_lo = g_lo;
              g_hi = f_hi;
              g_lo = f_lo;
              f_hi = e_hi;
              f_lo = e_lo;
              lo = d_lo + t1_lo;
              e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
              e_lo = lo >>> 0;
              d_hi = c_hi;
              d_lo = c_lo;
              c_hi = b_hi;
              c_lo = b_lo;
              b_hi = a_hi;
              b_lo = a_lo;
              lo = t1_lo + t2_lo;
              a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
              a_lo = lo >>> 0;
            }
            lo = s[0][1] + a_lo;
            s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
            s[0][1] = lo >>> 0;
            lo = s[1][1] + b_lo;
            s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
            s[1][1] = lo >>> 0;
            lo = s[2][1] + c_lo;
            s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
            s[2][1] = lo >>> 0;
            lo = s[3][1] + d_lo;
            s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
            s[3][1] = lo >>> 0;
            lo = s[4][1] + e_lo;
            s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
            s[4][1] = lo >>> 0;
            lo = s[5][1] + f_lo;
            s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
            s[5][1] = lo >>> 0;
            lo = s[6][1] + g_lo;
            s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
            s[6][1] = lo >>> 0;
            lo = s[7][1] + h_lo;
            s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
            s[7][1] = lo >>> 0;
            len -= 128;
          }
        }
        return sha512.exports;
      }
      var asn1Validator = {};
      var hasRequiredAsn1Validator;
      function requireAsn1Validator() {
        if (hasRequiredAsn1Validator) return asn1Validator;
        hasRequiredAsn1Validator = 1;
        var forge2 = requireForge();
        requireAsn1();
        var asn12 = forge2.asn1;
        asn1Validator.privateKeyValidator = {
          // PrivateKeyInfo
          name: "PrivateKeyInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            // Version (INTEGER)
            name: "PrivateKeyInfo.version",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyVersion"
          }, {
            // privateKeyAlgorithm
            name: "PrivateKeyInfo.privateKeyAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "privateKeyOid"
            }]
          }, {
            // PrivateKey
            name: "PrivateKeyInfo",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OCTETSTRING,
            constructed: false,
            capture: "privateKey"
          }]
        };
        asn1Validator.publicKeyValidator = {
          name: "SubjectPublicKeyInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "subjectPublicKeyInfo",
          value: [
            {
              name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "AlgorithmIdentifier.algorithm",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.OID,
                constructed: false,
                capture: "publicKeyOid"
              }]
            },
            // capture group for ed25519PublicKey
            {
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.BITSTRING,
              constructed: false,
              composed: true,
              captureBitStringValue: "ed25519PublicKey"
            }
            // FIXME: this is capture group for rsaPublicKey, use it in this API or
            // discard?
            /* {
              // subjectPublicKey
              name: 'SubjectPublicKeyInfo.subjectPublicKey',
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              value: [{
                // RSAPublicKey
                name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.SEQUENCE,
                constructed: true,
                optional: true,
                captureAsn1: 'rsaPublicKey'
              }]
            } */
          ]
        };
        return asn1Validator;
      }
      var ed25519_1;
      var hasRequiredEd25519;
      function requireEd25519() {
        if (hasRequiredEd25519) return ed25519_1;
        hasRequiredEd25519 = 1;
        var forge2 = requireForge();
        requireJsbn();
        requireRandom();
        requireSha512();
        requireUtil();
        var asn1Validator2 = requireAsn1Validator();
        var publicKeyValidator = asn1Validator2.publicKeyValidator;
        var privateKeyValidator = asn1Validator2.privateKeyValidator;
        if (typeof BigInteger === "undefined") {
          var BigInteger = forge2.jsbn.BigInteger;
        }
        var ByteBuffer = forge2.util.ByteBuffer;
        var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
        forge2.pki = forge2.pki || {};
        ed25519_1 = forge2.pki.ed25519 = forge2.ed25519 = forge2.ed25519 || {};
        var ed25519 = forge2.ed25519;
        ed25519.constants = {};
        ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
        ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
        ed25519.constants.SEED_BYTE_LENGTH = 32;
        ed25519.constants.SIGN_BYTE_LENGTH = 64;
        ed25519.constants.HASH_BYTE_LENGTH = 64;
        ed25519.generateKeyPair = function(options) {
          options = options || {};
          var seed = options.seed;
          if (seed === void 0) {
            seed = forge2.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
          } else if (typeof seed === "string") {
            if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
              throw new TypeError(
                '"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length."
              );
            }
          } else if (!(seed instanceof Uint8Array)) {
            throw new TypeError(
              '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
            );
          }
          seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
          var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
          var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
          for (var i = 0; i < 32; ++i) {
            sk[i] = seed[i];
          }
          crypto_sign_keypair(pk, sk);
          return { publicKey: pk, privateKey: sk };
        };
        ed25519.privateKeyFromAsn1 = function(obj) {
          var capture = {};
          var errors = [];
          var valid = forge2.asn1.validate(obj, privateKeyValidator, capture, errors);
          if (!valid) {
            var error = new Error("Invalid Key.");
            error.errors = errors;
            throw error;
          }
          var oid = forge2.asn1.derToOid(capture.privateKeyOid);
          var ed25519Oid = forge2.oids.EdDSA25519;
          if (oid !== ed25519Oid) {
            throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
          }
          var privateKey = capture.privateKey;
          var privateKeyBytes = messageToNativeBuffer({
            message: forge2.asn1.fromDer(privateKey).value,
            encoding: "binary"
          });
          return { privateKeyBytes };
        };
        ed25519.publicKeyFromAsn1 = function(obj) {
          var capture = {};
          var errors = [];
          var valid = forge2.asn1.validate(obj, publicKeyValidator, capture, errors);
          if (!valid) {
            var error = new Error("Invalid Key.");
            error.errors = errors;
            throw error;
          }
          var oid = forge2.asn1.derToOid(capture.publicKeyOid);
          var ed25519Oid = forge2.oids.EdDSA25519;
          if (oid !== ed25519Oid) {
            throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
          }
          var publicKeyBytes = capture.ed25519PublicKey;
          if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
            throw new Error("Key length is invalid.");
          }
          return messageToNativeBuffer({
            message: publicKeyBytes,
            encoding: "binary"
          });
        };
        ed25519.publicKeyFromPrivateKey = function(options) {
          options = options || {};
          var privateKey = messageToNativeBuffer({
            message: options.privateKey,
            encoding: "binary"
          });
          if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
            throw new TypeError(
              '"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
            );
          }
          var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
          for (var i = 0; i < pk.length; ++i) {
            pk[i] = privateKey[32 + i];
          }
          return pk;
        };
        ed25519.sign = function(options) {
          options = options || {};
          var msg = messageToNativeBuffer(options);
          var privateKey = messageToNativeBuffer({
            message: options.privateKey,
            encoding: "binary"
          });
          if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
            var keyPair = ed25519.generateKeyPair({ seed: privateKey });
            privateKey = keyPair.privateKey;
          } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
            throw new TypeError(
              '"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
            );
          }
          var signedMsg = new NativeBuffer(
            ed25519.constants.SIGN_BYTE_LENGTH + msg.length
          );
          crypto_sign(signedMsg, msg, msg.length, privateKey);
          var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
          for (var i = 0; i < sig.length; ++i) {
            sig[i] = signedMsg[i];
          }
          return sig;
        };
        ed25519.verify = function(options) {
          options = options || {};
          var msg = messageToNativeBuffer(options);
          if (options.signature === void 0) {
            throw new TypeError(
              '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
            );
          }
          var sig = messageToNativeBuffer({
            message: options.signature,
            encoding: "binary"
          });
          if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
            throw new TypeError(
              '"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH
            );
          }
          var publicKey = messageToNativeBuffer({
            message: options.publicKey,
            encoding: "binary"
          });
          if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
            throw new TypeError(
              '"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH
            );
          }
          var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
          var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
          var i;
          for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) {
            sm[i] = sig[i];
          }
          for (i = 0; i < msg.length; ++i) {
            sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];
          }
          return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
        };
        function messageToNativeBuffer(options) {
          var message2 = options.message;
          if (message2 instanceof Uint8Array || message2 instanceof NativeBuffer) {
            return message2;
          }
          var encoding = options.encoding;
          if (message2 === void 0) {
            if (options.md) {
              message2 = options.md.digest().getBytes();
              encoding = "binary";
            } else {
              throw new TypeError('"options.message" or "options.md" not specified.');
            }
          }
          if (typeof message2 === "string" && !encoding) {
            throw new TypeError('"options.encoding" must be "binary" or "utf8".');
          }
          if (typeof message2 === "string") {
            if (typeof Buffer !== "undefined") {
              return Buffer.from(message2, encoding);
            }
            message2 = new ByteBuffer(message2, encoding);
          } else if (!(message2 instanceof ByteBuffer)) {
            throw new TypeError(
              '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
            );
          }
          var buffer = new NativeBuffer(message2.length());
          for (var i = 0; i < buffer.length; ++i) {
            buffer[i] = message2.at(i);
          }
          return buffer;
        }
        var gf0 = gf();
        var gf1 = gf([1]);
        var D = gf([
          30883,
          4953,
          19914,
          30187,
          55467,
          16705,
          2637,
          112,
          59544,
          30585,
          16505,
          36039,
          65139,
          11119,
          27886,
          20995
        ]);
        var D2 = gf([
          61785,
          9906,
          39828,
          60374,
          45398,
          33411,
          5274,
          224,
          53552,
          61171,
          33010,
          6542,
          64743,
          22239,
          55772,
          9222
        ]);
        var X = gf([
          54554,
          36645,
          11616,
          51542,
          42930,
          38181,
          51040,
          26924,
          56412,
          64982,
          57905,
          49316,
          21502,
          52590,
          14035,
          8553
        ]);
        var Y = gf([
          26200,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214
        ]);
        var L = new Float64Array([
          237,
          211,
          245,
          92,
          26,
          99,
          18,
          88,
          214,
          156,
          247,
          162,
          222,
          249,
          222,
          20,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          16
        ]);
        var I = gf([
          41136,
          18958,
          6951,
          50414,
          58488,
          44335,
          6150,
          12099,
          55207,
          15867,
          153,
          11085,
          57099,
          20417,
          9344,
          11139
        ]);
        function sha5122(msg, msgLen) {
          var md2 = forge2.md.sha512.create();
          var buffer = new ByteBuffer(msg);
          md2.update(buffer.getBytes(msgLen), "binary");
          var hash = md2.digest().getBytes();
          if (typeof Buffer !== "undefined") {
            return Buffer.from(hash, "binary");
          }
          var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
          for (var i = 0; i < 64; ++i) {
            out[i] = hash.charCodeAt(i);
          }
          return out;
        }
        function crypto_sign_keypair(pk, sk) {
          var p = [gf(), gf(), gf(), gf()];
          var i;
          var d = sha5122(sk, 32);
          d[0] &= 248;
          d[31] &= 127;
          d[31] |= 64;
          scalarbase(p, d);
          pack(pk, p);
          for (i = 0; i < 32; ++i) {
            sk[i + 32] = pk[i];
          }
          return 0;
        }
        function crypto_sign(sm, m, n, sk) {
          var i, j, x = new Float64Array(64);
          var p = [gf(), gf(), gf(), gf()];
          var d = sha5122(sk, 32);
          d[0] &= 248;
          d[31] &= 127;
          d[31] |= 64;
          var smlen = n + 64;
          for (i = 0; i < n; ++i) {
            sm[64 + i] = m[i];
          }
          for (i = 0; i < 32; ++i) {
            sm[32 + i] = d[32 + i];
          }
          var r = sha5122(sm.subarray(32), n + 32);
          reduce(r);
          scalarbase(p, r);
          pack(sm, p);
          for (i = 32; i < 64; ++i) {
            sm[i] = sk[i];
          }
          var h = sha5122(sm, n + 64);
          reduce(h);
          for (i = 32; i < 64; ++i) {
            x[i] = 0;
          }
          for (i = 0; i < 32; ++i) {
            x[i] = r[i];
          }
          for (i = 0; i < 32; ++i) {
            for (j = 0; j < 32; j++) {
              x[i + j] += h[i] * d[j];
            }
          }
          modL(sm.subarray(32), x);
          return smlen;
        }
        function crypto_sign_open(m, sm, n, pk) {
          var i, mlen;
          var t = new NativeBuffer(32);
          var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
          mlen = -1;
          if (n < 64) {
            return -1;
          }
          if (unpackneg(q, pk)) {
            return -1;
          }
          for (i = 0; i < n; ++i) {
            m[i] = sm[i];
          }
          for (i = 0; i < 32; ++i) {
            m[i + 32] = pk[i];
          }
          var h = sha5122(m, n);
          reduce(h);
          scalarmult(p, q, h);
          scalarbase(q, sm.subarray(32));
          add(p, q);
          pack(t, p);
          n -= 64;
          if (crypto_verify_32(sm, 0, t, 0)) {
            for (i = 0; i < n; ++i) {
              m[i] = 0;
            }
            return -1;
          }
          for (i = 0; i < n; ++i) {
            m[i] = sm[i + 64];
          }
          mlen = n;
          return mlen;
        }
        function modL(r, x) {
          var carry, i, j, k;
          for (i = 63; i >= 32; --i) {
            carry = 0;
            for (j = i - 32, k = i - 12; j < k; ++j) {
              x[j] += carry - 16 * x[i] * L[j - (i - 32)];
              carry = x[j] + 128 >> 8;
              x[j] -= carry * 256;
            }
            x[j] += carry;
            x[i] = 0;
          }
          carry = 0;
          for (j = 0; j < 32; ++j) {
            x[j] += carry - (x[31] >> 4) * L[j];
            carry = x[j] >> 8;
            x[j] &= 255;
          }
          for (j = 0; j < 32; ++j) {
            x[j] -= carry * L[j];
          }
          for (i = 0; i < 32; ++i) {
            x[i + 1] += x[i] >> 8;
            r[i] = x[i] & 255;
          }
        }
        function reduce(r) {
          var x = new Float64Array(64);
          for (var i = 0; i < 64; ++i) {
            x[i] = r[i];
            r[i] = 0;
          }
          modL(r, x);
        }
        function add(p, q) {
          var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
          Z(a, p[1], p[0]);
          Z(t, q[1], q[0]);
          M(a, a, t);
          A(b, p[0], p[1]);
          A(t, q[0], q[1]);
          M(b, b, t);
          M(c, p[3], q[3]);
          M(c, c, D2);
          M(d, p[2], q[2]);
          A(d, d, d);
          Z(e, b, a);
          Z(f, d, c);
          A(g, d, c);
          A(h, b, a);
          M(p[0], e, f);
          M(p[1], h, g);
          M(p[2], g, f);
          M(p[3], e, h);
        }
        function cswap(p, q, b) {
          for (var i = 0; i < 4; ++i) {
            sel25519(p[i], q[i], b);
          }
        }
        function pack(r, p) {
          var tx = gf(), ty = gf(), zi = gf();
          inv25519(zi, p[2]);
          M(tx, p[0], zi);
          M(ty, p[1], zi);
          pack25519(r, ty);
          r[31] ^= par25519(tx) << 7;
        }
        function pack25519(o, n) {
          var i, j, b;
          var m = gf(), t = gf();
          for (i = 0; i < 16; ++i) {
            t[i] = n[i];
          }
          car25519(t);
          car25519(t);
          car25519(t);
          for (j = 0; j < 2; ++j) {
            m[0] = t[0] - 65517;
            for (i = 1; i < 15; ++i) {
              m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
              m[i - 1] &= 65535;
            }
            m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
            b = m[15] >> 16 & 1;
            m[14] &= 65535;
            sel25519(t, m, 1 - b);
          }
          for (i = 0; i < 16; i++) {
            o[2 * i] = t[i] & 255;
            o[2 * i + 1] = t[i] >> 8;
          }
        }
        function unpackneg(r, p) {
          var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
          set25519(r[2], gf1);
          unpack25519(r[1], p);
          S(num, r[1]);
          M(den, num, D);
          Z(num, num, r[2]);
          A(den, r[2], den);
          S(den2, den);
          S(den4, den2);
          M(den6, den4, den2);
          M(t, den6, num);
          M(t, t, den);
          pow2523(t, t);
          M(t, t, num);
          M(t, t, den);
          M(t, t, den);
          M(r[0], t, den);
          S(chk, r[0]);
          M(chk, chk, den);
          if (neq25519(chk, num)) {
            M(r[0], r[0], I);
          }
          S(chk, r[0]);
          M(chk, chk, den);
          if (neq25519(chk, num)) {
            return -1;
          }
          if (par25519(r[0]) === p[31] >> 7) {
            Z(r[0], gf0, r[0]);
          }
          M(r[3], r[0], r[1]);
          return 0;
        }
        function unpack25519(o, n) {
          var i;
          for (i = 0; i < 16; ++i) {
            o[i] = n[2 * i] + (n[2 * i + 1] << 8);
          }
          o[15] &= 32767;
        }
        function pow2523(o, i) {
          var c = gf();
          var a;
          for (a = 0; a < 16; ++a) {
            c[a] = i[a];
          }
          for (a = 250; a >= 0; --a) {
            S(c, c);
            if (a !== 1) {
              M(c, c, i);
            }
          }
          for (a = 0; a < 16; ++a) {
            o[a] = c[a];
          }
        }
        function neq25519(a, b) {
          var c = new NativeBuffer(32);
          var d = new NativeBuffer(32);
          pack25519(c, a);
          pack25519(d, b);
          return crypto_verify_32(c, 0, d, 0);
        }
        function crypto_verify_32(x, xi, y, yi) {
          return vn(x, xi, y, yi, 32);
        }
        function vn(x, xi, y, yi, n) {
          var i, d = 0;
          for (i = 0; i < n; ++i) {
            d |= x[xi + i] ^ y[yi + i];
          }
          return (1 & d - 1 >>> 8) - 1;
        }
        function par25519(a) {
          var d = new NativeBuffer(32);
          pack25519(d, a);
          return d[0] & 1;
        }
        function scalarmult(p, q, s) {
          var b, i;
          set25519(p[0], gf0);
          set25519(p[1], gf1);
          set25519(p[2], gf1);
          set25519(p[3], gf0);
          for (i = 255; i >= 0; --i) {
            b = s[i / 8 | 0] >> (i & 7) & 1;
            cswap(p, q, b);
            add(q, p);
            add(p, p);
            cswap(p, q, b);
          }
        }
        function scalarbase(p, s) {
          var q = [gf(), gf(), gf(), gf()];
          set25519(q[0], X);
          set25519(q[1], Y);
          set25519(q[2], gf1);
          M(q[3], X, Y);
          scalarmult(p, q, s);
        }
        function set25519(r, a) {
          var i;
          for (i = 0; i < 16; i++) {
            r[i] = a[i] | 0;
          }
        }
        function inv25519(o, i) {
          var c = gf();
          var a;
          for (a = 0; a < 16; ++a) {
            c[a] = i[a];
          }
          for (a = 253; a >= 0; --a) {
            S(c, c);
            if (a !== 2 && a !== 4) {
              M(c, c, i);
            }
          }
          for (a = 0; a < 16; ++a) {
            o[a] = c[a];
          }
        }
        function car25519(o) {
          var i, v, c = 1;
          for (i = 0; i < 16; ++i) {
            v = o[i] + c + 65535;
            c = Math.floor(v / 65536);
            o[i] = v - c * 65536;
          }
          o[0] += c - 1 + 37 * (c - 1);
        }
        function sel25519(p, q, b) {
          var t, c = ~(b - 1);
          for (var i = 0; i < 16; ++i) {
            t = c & (p[i] ^ q[i]);
            p[i] ^= t;
            q[i] ^= t;
          }
        }
        function gf(init) {
          var i, r = new Float64Array(16);
          if (init) {
            for (i = 0; i < init.length; ++i) {
              r[i] = init[i];
            }
          }
          return r;
        }
        function A(o, a, b) {
          for (var i = 0; i < 16; ++i) {
            o[i] = a[i] + b[i];
          }
        }
        function Z(o, a, b) {
          for (var i = 0; i < 16; ++i) {
            o[i] = a[i] - b[i];
          }
        }
        function S(o, a) {
          M(o, a, a);
        }
        function M(o, a, b) {
          var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
          v = a[0];
          t0 += v * b0;
          t1 += v * b1;
          t2 += v * b2;
          t3 += v * b3;
          t4 += v * b4;
          t5 += v * b5;
          t6 += v * b6;
          t7 += v * b7;
          t8 += v * b8;
          t9 += v * b9;
          t10 += v * b10;
          t11 += v * b11;
          t12 += v * b12;
          t13 += v * b13;
          t14 += v * b14;
          t15 += v * b15;
          v = a[1];
          t1 += v * b0;
          t2 += v * b1;
          t3 += v * b2;
          t4 += v * b3;
          t5 += v * b4;
          t6 += v * b5;
          t7 += v * b6;
          t8 += v * b7;
          t9 += v * b8;
          t10 += v * b9;
          t11 += v * b10;
          t12 += v * b11;
          t13 += v * b12;
          t14 += v * b13;
          t15 += v * b14;
          t16 += v * b15;
          v = a[2];
          t2 += v * b0;
          t3 += v * b1;
          t4 += v * b2;
          t5 += v * b3;
          t6 += v * b4;
          t7 += v * b5;
          t8 += v * b6;
          t9 += v * b7;
          t10 += v * b8;
          t11 += v * b9;
          t12 += v * b10;
          t13 += v * b11;
          t14 += v * b12;
          t15 += v * b13;
          t16 += v * b14;
          t17 += v * b15;
          v = a[3];
          t3 += v * b0;
          t4 += v * b1;
          t5 += v * b2;
          t6 += v * b3;
          t7 += v * b4;
          t8 += v * b5;
          t9 += v * b6;
          t10 += v * b7;
          t11 += v * b8;
          t12 += v * b9;
          t13 += v * b10;
          t14 += v * b11;
          t15 += v * b12;
          t16 += v * b13;
          t17 += v * b14;
          t18 += v * b15;
          v = a[4];
          t4 += v * b0;
          t5 += v * b1;
          t6 += v * b2;
          t7 += v * b3;
          t8 += v * b4;
          t9 += v * b5;
          t10 += v * b6;
          t11 += v * b7;
          t12 += v * b8;
          t13 += v * b9;
          t14 += v * b10;
          t15 += v * b11;
          t16 += v * b12;
          t17 += v * b13;
          t18 += v * b14;
          t19 += v * b15;
          v = a[5];
          t5 += v * b0;
          t6 += v * b1;
          t7 += v * b2;
          t8 += v * b3;
          t9 += v * b4;
          t10 += v * b5;
          t11 += v * b6;
          t12 += v * b7;
          t13 += v * b8;
          t14 += v * b9;
          t15 += v * b10;
          t16 += v * b11;
          t17 += v * b12;
          t18 += v * b13;
          t19 += v * b14;
          t20 += v * b15;
          v = a[6];
          t6 += v * b0;
          t7 += v * b1;
          t8 += v * b2;
          t9 += v * b3;
          t10 += v * b4;
          t11 += v * b5;
          t12 += v * b6;
          t13 += v * b7;
          t14 += v * b8;
          t15 += v * b9;
          t16 += v * b10;
          t17 += v * b11;
          t18 += v * b12;
          t19 += v * b13;
          t20 += v * b14;
          t21 += v * b15;
          v = a[7];
          t7 += v * b0;
          t8 += v * b1;
          t9 += v * b2;
          t10 += v * b3;
          t11 += v * b4;
          t12 += v * b5;
          t13 += v * b6;
          t14 += v * b7;
          t15 += v * b8;
          t16 += v * b9;
          t17 += v * b10;
          t18 += v * b11;
          t19 += v * b12;
          t20 += v * b13;
          t21 += v * b14;
          t22 += v * b15;
          v = a[8];
          t8 += v * b0;
          t9 += v * b1;
          t10 += v * b2;
          t11 += v * b3;
          t12 += v * b4;
          t13 += v * b5;
          t14 += v * b6;
          t15 += v * b7;
          t16 += v * b8;
          t17 += v * b9;
          t18 += v * b10;
          t19 += v * b11;
          t20 += v * b12;
          t21 += v * b13;
          t22 += v * b14;
          t23 += v * b15;
          v = a[9];
          t9 += v * b0;
          t10 += v * b1;
          t11 += v * b2;
          t12 += v * b3;
          t13 += v * b4;
          t14 += v * b5;
          t15 += v * b6;
          t16 += v * b7;
          t17 += v * b8;
          t18 += v * b9;
          t19 += v * b10;
          t20 += v * b11;
          t21 += v * b12;
          t22 += v * b13;
          t23 += v * b14;
          t24 += v * b15;
          v = a[10];
          t10 += v * b0;
          t11 += v * b1;
          t12 += v * b2;
          t13 += v * b3;
          t14 += v * b4;
          t15 += v * b5;
          t16 += v * b6;
          t17 += v * b7;
          t18 += v * b8;
          t19 += v * b9;
          t20 += v * b10;
          t21 += v * b11;
          t22 += v * b12;
          t23 += v * b13;
          t24 += v * b14;
          t25 += v * b15;
          v = a[11];
          t11 += v * b0;
          t12 += v * b1;
          t13 += v * b2;
          t14 += v * b3;
          t15 += v * b4;
          t16 += v * b5;
          t17 += v * b6;
          t18 += v * b7;
          t19 += v * b8;
          t20 += v * b9;
          t21 += v * b10;
          t22 += v * b11;
          t23 += v * b12;
          t24 += v * b13;
          t25 += v * b14;
          t26 += v * b15;
          v = a[12];
          t12 += v * b0;
          t13 += v * b1;
          t14 += v * b2;
          t15 += v * b3;
          t16 += v * b4;
          t17 += v * b5;
          t18 += v * b6;
          t19 += v * b7;
          t20 += v * b8;
          t21 += v * b9;
          t22 += v * b10;
          t23 += v * b11;
          t24 += v * b12;
          t25 += v * b13;
          t26 += v * b14;
          t27 += v * b15;
          v = a[13];
          t13 += v * b0;
          t14 += v * b1;
          t15 += v * b2;
          t16 += v * b3;
          t17 += v * b4;
          t18 += v * b5;
          t19 += v * b6;
          t20 += v * b7;
          t21 += v * b8;
          t22 += v * b9;
          t23 += v * b10;
          t24 += v * b11;
          t25 += v * b12;
          t26 += v * b13;
          t27 += v * b14;
          t28 += v * b15;
          v = a[14];
          t14 += v * b0;
          t15 += v * b1;
          t16 += v * b2;
          t17 += v * b3;
          t18 += v * b4;
          t19 += v * b5;
          t20 += v * b6;
          t21 += v * b7;
          t22 += v * b8;
          t23 += v * b9;
          t24 += v * b10;
          t25 += v * b11;
          t26 += v * b12;
          t27 += v * b13;
          t28 += v * b14;
          t29 += v * b15;
          v = a[15];
          t15 += v * b0;
          t16 += v * b1;
          t17 += v * b2;
          t18 += v * b3;
          t19 += v * b4;
          t20 += v * b5;
          t21 += v * b6;
          t22 += v * b7;
          t23 += v * b8;
          t24 += v * b9;
          t25 += v * b10;
          t26 += v * b11;
          t27 += v * b12;
          t28 += v * b13;
          t29 += v * b14;
          t30 += v * b15;
          t0 += 38 * t16;
          t1 += 38 * t17;
          t2 += 38 * t18;
          t3 += 38 * t19;
          t4 += 38 * t20;
          t5 += 38 * t21;
          t6 += 38 * t22;
          t7 += 38 * t23;
          t8 += 38 * t24;
          t9 += 38 * t25;
          t10 += 38 * t26;
          t11 += 38 * t27;
          t12 += 38 * t28;
          t13 += 38 * t29;
          t14 += 38 * t30;
          c = 1;
          v = t0 + c + 65535;
          c = Math.floor(v / 65536);
          t0 = v - c * 65536;
          v = t1 + c + 65535;
          c = Math.floor(v / 65536);
          t1 = v - c * 65536;
          v = t2 + c + 65535;
          c = Math.floor(v / 65536);
          t2 = v - c * 65536;
          v = t3 + c + 65535;
          c = Math.floor(v / 65536);
          t3 = v - c * 65536;
          v = t4 + c + 65535;
          c = Math.floor(v / 65536);
          t4 = v - c * 65536;
          v = t5 + c + 65535;
          c = Math.floor(v / 65536);
          t5 = v - c * 65536;
          v = t6 + c + 65535;
          c = Math.floor(v / 65536);
          t6 = v - c * 65536;
          v = t7 + c + 65535;
          c = Math.floor(v / 65536);
          t7 = v - c * 65536;
          v = t8 + c + 65535;
          c = Math.floor(v / 65536);
          t8 = v - c * 65536;
          v = t9 + c + 65535;
          c = Math.floor(v / 65536);
          t9 = v - c * 65536;
          v = t10 + c + 65535;
          c = Math.floor(v / 65536);
          t10 = v - c * 65536;
          v = t11 + c + 65535;
          c = Math.floor(v / 65536);
          t11 = v - c * 65536;
          v = t12 + c + 65535;
          c = Math.floor(v / 65536);
          t12 = v - c * 65536;
          v = t13 + c + 65535;
          c = Math.floor(v / 65536);
          t13 = v - c * 65536;
          v = t14 + c + 65535;
          c = Math.floor(v / 65536);
          t14 = v - c * 65536;
          v = t15 + c + 65535;
          c = Math.floor(v / 65536);
          t15 = v - c * 65536;
          t0 += c - 1 + 37 * (c - 1);
          c = 1;
          v = t0 + c + 65535;
          c = Math.floor(v / 65536);
          t0 = v - c * 65536;
          v = t1 + c + 65535;
          c = Math.floor(v / 65536);
          t1 = v - c * 65536;
          v = t2 + c + 65535;
          c = Math.floor(v / 65536);
          t2 = v - c * 65536;
          v = t3 + c + 65535;
          c = Math.floor(v / 65536);
          t3 = v - c * 65536;
          v = t4 + c + 65535;
          c = Math.floor(v / 65536);
          t4 = v - c * 65536;
          v = t5 + c + 65535;
          c = Math.floor(v / 65536);
          t5 = v - c * 65536;
          v = t6 + c + 65535;
          c = Math.floor(v / 65536);
          t6 = v - c * 65536;
          v = t7 + c + 65535;
          c = Math.floor(v / 65536);
          t7 = v - c * 65536;
          v = t8 + c + 65535;
          c = Math.floor(v / 65536);
          t8 = v - c * 65536;
          v = t9 + c + 65535;
          c = Math.floor(v / 65536);
          t9 = v - c * 65536;
          v = t10 + c + 65535;
          c = Math.floor(v / 65536);
          t10 = v - c * 65536;
          v = t11 + c + 65535;
          c = Math.floor(v / 65536);
          t11 = v - c * 65536;
          v = t12 + c + 65535;
          c = Math.floor(v / 65536);
          t12 = v - c * 65536;
          v = t13 + c + 65535;
          c = Math.floor(v / 65536);
          t13 = v - c * 65536;
          v = t14 + c + 65535;
          c = Math.floor(v / 65536);
          t14 = v - c * 65536;
          v = t15 + c + 65535;
          c = Math.floor(v / 65536);
          t15 = v - c * 65536;
          t0 += c - 1 + 37 * (c - 1);
          o[0] = t0;
          o[1] = t1;
          o[2] = t2;
          o[3] = t3;
          o[4] = t4;
          o[5] = t5;
          o[6] = t6;
          o[7] = t7;
          o[8] = t8;
          o[9] = t9;
          o[10] = t10;
          o[11] = t11;
          o[12] = t12;
          o[13] = t13;
          o[14] = t14;
          o[15] = t15;
        }
        return ed25519_1;
      }
      var kem;
      var hasRequiredKem;
      function requireKem() {
        if (hasRequiredKem) return kem;
        hasRequiredKem = 1;
        var forge2 = requireForge();
        requireUtil();
        requireRandom();
        requireJsbn();
        kem = forge2.kem = forge2.kem || {};
        var BigInteger = forge2.jsbn.BigInteger;
        forge2.kem.rsa = {};
        forge2.kem.rsa.create = function(kdf, options) {
          options = options || {};
          var prng2 = options.prng || forge2.random;
          var kem2 = {};
          kem2.encrypt = function(publicKey, keyLength) {
            var byteLength = Math.ceil(publicKey.n.bitLength() / 8);
            var r;
            do {
              r = new BigInteger(
                forge2.util.bytesToHex(prng2.getBytesSync(byteLength)),
                16
              ).mod(publicKey.n);
            } while (r.compareTo(BigInteger.ONE) <= 0);
            r = forge2.util.hexToBytes(r.toString(16));
            var zeros = byteLength - r.length;
            if (zeros > 0) {
              r = forge2.util.fillString(String.fromCharCode(0), zeros) + r;
            }
            var encapsulation = publicKey.encrypt(r, "NONE");
            var key = kdf.generate(r, keyLength);
            return { encapsulation, key };
          };
          kem2.decrypt = function(privateKey, encapsulation, keyLength) {
            var r = privateKey.decrypt(encapsulation, "NONE");
            return kdf.generate(r, keyLength);
          };
          return kem2;
        };
        forge2.kem.kdf1 = function(md2, digestLength) {
          _createKDF(this, md2, 0, digestLength || md2.digestLength);
        };
        forge2.kem.kdf2 = function(md2, digestLength) {
          _createKDF(this, md2, 1, digestLength || md2.digestLength);
        };
        function _createKDF(kdf, md2, counterStart, digestLength) {
          kdf.generate = function(x, length) {
            var key = new forge2.util.ByteBuffer();
            var k = Math.ceil(length / digestLength) + counterStart;
            var c = new forge2.util.ByteBuffer();
            for (var i = counterStart; i < k; ++i) {
              c.putInt32(i);
              md2.start();
              md2.update(x + c.getBytes());
              var hash = md2.digest();
              key.putBytes(hash.getBytes(digestLength));
            }
            key.truncate(key.length() - length);
            return key.getBytes();
          };
        }
        return kem;
      }
      var log;
      var hasRequiredLog;
      function requireLog() {
        if (hasRequiredLog) return log;
        hasRequiredLog = 1;
        var forge2 = requireForge();
        requireUtil();
        log = forge2.log = forge2.log || {};
        forge2.log.levels = [
          "none",
          "error",
          "warning",
          "info",
          "debug",
          "verbose",
          "max"
        ];
        var sLevelInfo = {};
        var sLoggers = [];
        var sConsoleLogger = null;
        forge2.log.LEVEL_LOCKED = 1 << 1;
        forge2.log.NO_LEVEL_CHECK = 1 << 2;
        forge2.log.INTERPOLATE = 1 << 3;
        for (var i = 0; i < forge2.log.levels.length; ++i) {
          var level = forge2.log.levels[i];
          sLevelInfo[level] = {
            index: i,
            name: level.toUpperCase()
          };
        }
        forge2.log.logMessage = function(message2) {
          var messageLevelIndex = sLevelInfo[message2.level].index;
          for (var i2 = 0; i2 < sLoggers.length; ++i2) {
            var logger2 = sLoggers[i2];
            if (logger2.flags & forge2.log.NO_LEVEL_CHECK) {
              logger2.f(message2);
            } else {
              var loggerLevelIndex = sLevelInfo[logger2.level].index;
              if (messageLevelIndex <= loggerLevelIndex) {
                logger2.f(logger2, message2);
              }
            }
          }
        };
        forge2.log.prepareStandard = function(message2) {
          if (!("standard" in message2)) {
            message2.standard = sLevelInfo[message2.level].name + //' ' + +message.timestamp +
            " [" + message2.category + "] " + message2.message;
          }
        };
        forge2.log.prepareFull = function(message2) {
          if (!("full" in message2)) {
            var args = [message2.message];
            args = args.concat([]);
            message2.full = forge2.util.format.apply(this, args);
          }
        };
        forge2.log.prepareStandardFull = function(message2) {
          if (!("standardFull" in message2)) {
            forge2.log.prepareStandard(message2);
            message2.standardFull = message2.standard;
          }
        };
        {
          var levels = ["error", "warning", "info", "debug", "verbose"];
          for (var i = 0; i < levels.length; ++i) {
            (function(level2) {
              forge2.log[level2] = function(category, message2) {
                var args = Array.prototype.slice.call(arguments).slice(2);
                var msg = {
                  timestamp: /* @__PURE__ */ new Date(),
                  level: level2,
                  category,
                  message: message2,
                  "arguments": args
                  /*standard*/
                  /*full*/
                  /*fullMessage*/
                };
                forge2.log.logMessage(msg);
              };
            })(levels[i]);
          }
        }
        forge2.log.makeLogger = function(logFunction) {
          var logger2 = {
            flags: 0,
            f: logFunction
          };
          forge2.log.setLevel(logger2, "none");
          return logger2;
        };
        forge2.log.setLevel = function(logger2, level2) {
          var rval = false;
          if (logger2 && !(logger2.flags & forge2.log.LEVEL_LOCKED)) {
            for (var i2 = 0; i2 < forge2.log.levels.length; ++i2) {
              var aValidLevel = forge2.log.levels[i2];
              if (level2 == aValidLevel) {
                logger2.level = level2;
                rval = true;
                break;
              }
            }
          }
          return rval;
        };
        forge2.log.lock = function(logger2, lock2) {
          if (typeof lock2 === "undefined" || lock2) {
            logger2.flags |= forge2.log.LEVEL_LOCKED;
          } else {
            logger2.flags &= ~forge2.log.LEVEL_LOCKED;
          }
        };
        forge2.log.addLogger = function(logger2) {
          sLoggers.push(logger2);
        };
        if (typeof console !== "undefined" && "log" in console) {
          var logger;
          if (console.error && console.warn && console.info && console.debug) {
            var levelHandlers = {
              error: console.error,
              warning: console.warn,
              info: console.info,
              debug: console.debug,
              verbose: console.debug
            };
            var f = function(logger2, message2) {
              forge2.log.prepareStandard(message2);
              var handler = levelHandlers[message2.level];
              var args = [message2.standard];
              args = args.concat(message2["arguments"].slice());
              handler.apply(console, args);
            };
            logger = forge2.log.makeLogger(f);
          } else {
            var f = function(logger2, message2) {
              forge2.log.prepareStandardFull(message2);
              console.log(message2.standardFull);
            };
            logger = forge2.log.makeLogger(f);
          }
          forge2.log.setLevel(logger, "debug");
          forge2.log.addLogger(logger);
          sConsoleLogger = logger;
        } else {
          console = {
            log: function() {
            }
          };
        }
        if (sConsoleLogger !== null && typeof window !== "undefined" && window.location) {
          var query = new URL(window.location.href).searchParams;
          if (query.has("console.level")) {
            forge2.log.setLevel(
              sConsoleLogger,
              query.get("console.level").slice(-1)[0]
            );
          }
          if (query.has("console.lock")) {
            var lock = query.get("console.lock").slice(-1)[0];
            if (lock == "true") {
              forge2.log.lock(sConsoleLogger);
            }
          }
        }
        forge2.log.consoleLogger = sConsoleLogger;
        return log;
      }
      var md_all;
      var hasRequiredMd_all;
      function requireMd_all() {
        if (hasRequiredMd_all) return md_all;
        hasRequiredMd_all = 1;
        md_all = requireMd();
        requireMd5();
        requireSha1();
        requireSha256();
        requireSha512();
        return md_all;
      }
      var pkcs7 = { exports: {} };
      var hasRequiredPkcs7;
      function requirePkcs7() {
        if (hasRequiredPkcs7) return pkcs7.exports;
        hasRequiredPkcs7 = 1;
        var forge2 = requireForge();
        requireAes();
        requireAsn1();
        requireDes();
        requireOids();
        requirePem();
        requirePkcs7asn1();
        requireRandom();
        requireUtil();
        requireX509();
        var asn12 = forge2.asn1;
        var p7 = pkcs7.exports = forge2.pkcs7 = forge2.pkcs7 || {};
        p7.messageFromPem = function(pem2) {
          var msg = forge2.pem.decode(pem2)[0];
          if (msg.type !== "PKCS7") {
            var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
          }
          var obj = asn12.fromDer(msg.body);
          return p7.messageFromAsn1(obj);
        };
        p7.messageToPem = function(msg, maxline) {
          var pemObj = {
            type: "PKCS7",
            body: asn12.toDer(msg.toAsn1()).getBytes()
          };
          return forge2.pem.encode(pemObj, { maxline });
        };
        p7.messageFromAsn1 = function(obj) {
          var capture = {};
          var errors = [];
          if (!asn12.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
            error.errors = errors;
            throw error;
          }
          var contentType2 = asn12.derToOid(capture.contentType);
          var msg;
          switch (contentType2) {
            case forge2.pki.oids.envelopedData:
              msg = p7.createEnvelopedData();
              break;
            case forge2.pki.oids.encryptedData:
              msg = p7.createEncryptedData();
              break;
            case forge2.pki.oids.signedData:
              msg = p7.createSignedData();
              break;
            default:
              throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType2 + " is not (yet) supported.");
          }
          msg.fromAsn1(capture.content.value[0]);
          return msg;
        };
        p7.createSignedData = function() {
          var msg = null;
          msg = {
            type: forge2.pki.oids.signedData,
            version: 1,
            certificates: [],
            crls: [],
            // TODO: add json-formatted signer stuff here?
            signers: [],
            // populated during sign()
            digestAlgorithmIdentifiers: [],
            contentInfo: null,
            signerInfos: [],
            fromAsn1: function(obj) {
              _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
              msg.certificates = [];
              msg.crls = [];
              msg.digestAlgorithmIdentifiers = [];
              msg.contentInfo = null;
              msg.signerInfos = [];
              if (msg.rawCapture.certificates) {
                var certs = msg.rawCapture.certificates.value;
                for (var i = 0; i < certs.length; ++i) {
                  msg.certificates.push(forge2.pki.certificateFromAsn1(certs[i]));
                }
              }
            },
            toAsn1: function() {
              if (!msg.contentInfo) {
                msg.sign();
              }
              var certs = [];
              for (var i = 0; i < msg.certificates.length; ++i) {
                certs.push(forge2.pki.certificateToAsn1(msg.certificates[i]));
              }
              var crls = [];
              var signedData = asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                  // Version
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.INTEGER,
                    false,
                    asn12.integerToDer(msg.version).getBytes()
                  ),
                  // DigestAlgorithmIdentifiers
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.SET,
                    true,
                    msg.digestAlgorithmIdentifiers
                  ),
                  // ContentInfo
                  msg.contentInfo
                ])
              ]);
              if (certs.length > 0) {
                signedData.value[0].value.push(
                  asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, certs)
                );
              }
              if (crls.length > 0) {
                signedData.value[0].value.push(
                  asn12.create(asn12.Class.CONTEXT_SPECIFIC, 1, true, crls)
                );
              }
              signedData.value[0].value.push(
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.SET,
                  true,
                  msg.signerInfos
                )
              );
              return asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.SEQUENCE,
                true,
                [
                  // ContentType
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.OID,
                    false,
                    asn12.oidToDer(msg.type).getBytes()
                  ),
                  // [0] SignedData
                  signedData
                ]
              );
            },
            /**
             * Add (another) entity to list of signers.
             *
             * Note: If authenticatedAttributes are provided, then, per RFC 2315,
             * they must include at least two attributes: content type and
             * message digest. The message digest attribute value will be
             * auto-calculated during signing and will be ignored if provided.
             *
             * Here's an example of providing these two attributes:
             *
             * forge.pkcs7.createSignedData();
             * p7.addSigner({
             *   issuer: cert.issuer.attributes,
             *   serialNumber: cert.serialNumber,
             *   key: privateKey,
             *   digestAlgorithm: forge.pki.oids.sha1,
             *   authenticatedAttributes: [{
             *     type: forge.pki.oids.contentType,
             *     value: forge.pki.oids.data
             *   }, {
             *     type: forge.pki.oids.messageDigest
             *   }]
             * });
             *
             * TODO: Support [subjectKeyIdentifier] as signer's ID.
             *
             * @param signer the signer information:
             *          key the signer's private key.
             *          [certificate] a certificate containing the public key
             *            associated with the signer's private key; use this option as
             *            an alternative to specifying signer.issuer and
             *            signer.serialNumber.
             *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
             *          [serialNumber] the signer's certificate's serial number in
             *           hexadecimal (eg: cert.serialNumber).
             *          [digestAlgorithm] the message digest OID, as a string, to use
             *            (eg: forge.pki.oids.sha1).
             *          [authenticatedAttributes] an optional array of attributes
             *            to also sign along with the content.
             */
            addSigner: function(signer) {
              var issuer = signer.issuer;
              var serialNumber = signer.serialNumber;
              if (signer.certificate) {
                var cert = signer.certificate;
                if (typeof cert === "string") {
                  cert = forge2.pki.certificateFromPem(cert);
                }
                issuer = cert.issuer.attributes;
                serialNumber = cert.serialNumber;
              }
              var key = signer.key;
              if (!key) {
                throw new Error(
                  "Could not add PKCS#7 signer; no private key specified."
                );
              }
              if (typeof key === "string") {
                key = forge2.pki.privateKeyFromPem(key);
              }
              var digestAlgorithm = signer.digestAlgorithm || forge2.pki.oids.sha1;
              switch (digestAlgorithm) {
                case forge2.pki.oids.sha1:
                case forge2.pki.oids.sha256:
                case forge2.pki.oids.sha384:
                case forge2.pki.oids.sha512:
                case forge2.pki.oids.md5:
                  break;
                default:
                  throw new Error(
                    "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
                  );
              }
              var authenticatedAttributes = signer.authenticatedAttributes || [];
              if (authenticatedAttributes.length > 0) {
                var contentType2 = false;
                var messageDigest = false;
                for (var i = 0; i < authenticatedAttributes.length; ++i) {
                  var attr = authenticatedAttributes[i];
                  if (!contentType2 && attr.type === forge2.pki.oids.contentType) {
                    contentType2 = true;
                    if (messageDigest) {
                      break;
                    }
                    continue;
                  }
                  if (!messageDigest && attr.type === forge2.pki.oids.messageDigest) {
                    messageDigest = true;
                    if (contentType2) {
                      break;
                    }
                    continue;
                  }
                }
                if (!contentType2 || !messageDigest) {
                  throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
                }
              }
              msg.signers.push({
                key,
                version: 1,
                issuer,
                serialNumber,
                digestAlgorithm,
                signatureAlgorithm: forge2.pki.oids.rsaEncryption,
                signature: null,
                authenticatedAttributes,
                unauthenticatedAttributes: []
              });
            },
            /**
             * Signs the content.
             * @param options Options to apply when signing:
             *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
             */
            sign: function(options) {
              options = options || {};
              if (typeof msg.content !== "object" || msg.contentInfo === null) {
                msg.contentInfo = asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.SEQUENCE,
                  true,
                  [
                    // ContentType
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.OID,
                      false,
                      asn12.oidToDer(forge2.pki.oids.data).getBytes()
                    )
                  ]
                );
                if ("content" in msg) {
                  var content;
                  if (msg.content instanceof forge2.util.ByteBuffer) {
                    content = msg.content.bytes();
                  } else if (typeof msg.content === "string") {
                    content = forge2.util.encodeUtf8(msg.content);
                  }
                  if (options.detached) {
                    msg.detachedContent = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.OCTETSTRING, false, content);
                  } else {
                    msg.contentInfo.value.push(
                      // [0] EXPLICIT content
                      asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                        asn12.create(
                          asn12.Class.UNIVERSAL,
                          asn12.Type.OCTETSTRING,
                          false,
                          content
                        )
                      ])
                    );
                  }
                }
              }
              if (msg.signers.length === 0) {
                return;
              }
              var mds = addDigestAlgorithmIds();
              addSignerInfos(mds);
            },
            verify: function() {
              throw new Error("PKCS#7 signature verification not yet implemented.");
            },
            /**
             * Add a certificate.
             *
             * @param cert the certificate to add.
             */
            addCertificate: function(cert) {
              if (typeof cert === "string") {
                cert = forge2.pki.certificateFromPem(cert);
              }
              msg.certificates.push(cert);
            },
            /**
             * Add a certificate revokation list.
             *
             * @param crl the certificate revokation list to add.
             */
            addCertificateRevokationList: function(crl) {
              throw new Error("PKCS#7 CRL support not yet implemented.");
            }
          };
          return msg;
          function addDigestAlgorithmIds() {
            var mds = {};
            for (var i = 0; i < msg.signers.length; ++i) {
              var signer = msg.signers[i];
              var oid = signer.digestAlgorithm;
              if (!(oid in mds)) {
                mds[oid] = forge2.md[forge2.pki.oids[oid]].create();
              }
              if (signer.authenticatedAttributes.length === 0) {
                signer.md = mds[oid];
              } else {
                signer.md = forge2.md[forge2.pki.oids[oid]].create();
              }
            }
            msg.digestAlgorithmIdentifiers = [];
            for (var oid in mds) {
              msg.digestAlgorithmIdentifiers.push(
                // AlgorithmIdentifier
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                  // algorithm
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.OID,
                    false,
                    asn12.oidToDer(oid).getBytes()
                  ),
                  // parameters (null)
                  asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
                ])
              );
            }
            return mds;
          }
          function addSignerInfos(mds) {
            var content;
            if (msg.detachedContent) {
              content = msg.detachedContent;
            } else {
              content = msg.contentInfo.value[1];
              content = content.value[0];
            }
            if (!content) {
              throw new Error(
                "Could not sign PKCS#7 message; there is no content to sign."
              );
            }
            var contentType2 = asn12.derToOid(msg.contentInfo.value[0].value);
            var bytes = asn12.toDer(content);
            bytes.getByte();
            asn12.getBerValueLength(bytes);
            bytes = bytes.getBytes();
            for (var oid in mds) {
              mds[oid].start().update(bytes);
            }
            var signingTime = /* @__PURE__ */ new Date();
            for (var i = 0; i < msg.signers.length; ++i) {
              var signer = msg.signers[i];
              if (signer.authenticatedAttributes.length === 0) {
                if (contentType2 !== forge2.pki.oids.data) {
                  throw new Error(
                    "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
                  );
                }
              } else {
                signer.authenticatedAttributesAsn1 = asn12.create(
                  asn12.Class.CONTEXT_SPECIFIC,
                  0,
                  true,
                  []
                );
                var attrsAsn1 = asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.SET,
                  true,
                  []
                );
                for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
                  var attr = signer.authenticatedAttributes[ai];
                  if (attr.type === forge2.pki.oids.messageDigest) {
                    attr.value = mds[signer.digestAlgorithm].digest();
                  } else if (attr.type === forge2.pki.oids.signingTime) {
                    if (!attr.value) {
                      attr.value = signingTime;
                    }
                  }
                  attrsAsn1.value.push(_attributeToAsn1(attr));
                  signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
                }
                bytes = asn12.toDer(attrsAsn1).getBytes();
                signer.md.start().update(bytes);
              }
              signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
            }
            msg.signerInfos = _signersToAsn1(msg.signers);
          }
        };
        p7.createEncryptedData = function() {
          var msg = null;
          msg = {
            type: forge2.pki.oids.encryptedData,
            version: 0,
            encryptedContent: {
              algorithm: forge2.pki.oids["aes256-CBC"]
            },
            /**
             * Reads an EncryptedData content block (in ASN.1 format)
             *
             * @param obj The ASN.1 representation of the EncryptedData content block
             */
            fromAsn1: function(obj) {
              _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
            },
            /**
             * Decrypt encrypted content
             *
             * @param key The (symmetric) key as a byte buffer
             */
            decrypt: function(key) {
              if (key !== void 0) {
                msg.encryptedContent.key = key;
              }
              _decryptContent(msg);
            }
          };
          return msg;
        };
        p7.createEnvelopedData = function() {
          var msg = null;
          msg = {
            type: forge2.pki.oids.envelopedData,
            version: 0,
            recipients: [],
            encryptedContent: {
              algorithm: forge2.pki.oids["aes256-CBC"]
            },
            /**
             * Reads an EnvelopedData content block (in ASN.1 format)
             *
             * @param obj the ASN.1 representation of the EnvelopedData content block.
             */
            fromAsn1: function(obj) {
              var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
              msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
            },
            toAsn1: function() {
              return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // ContentType
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(msg.type).getBytes()
                ),
                // [0] EnvelopedData
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                  asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                    // Version
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.INTEGER,
                      false,
                      asn12.integerToDer(msg.version).getBytes()
                    ),
                    // RecipientInfos
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.SET,
                      true,
                      _recipientsToAsn1(msg.recipients)
                    ),
                    // EncryptedContentInfo
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.SEQUENCE,
                      true,
                      _encryptedContentToAsn1(msg.encryptedContent)
                    )
                  ])
                ])
              ]);
            },
            /**
             * Find recipient by X.509 certificate's issuer.
             *
             * @param cert the certificate with the issuer to look for.
             *
             * @return the recipient object.
             */
            findRecipient: function(cert) {
              var sAttr = cert.issuer.attributes;
              for (var i = 0; i < msg.recipients.length; ++i) {
                var r = msg.recipients[i];
                var rAttr = r.issuer;
                if (r.serialNumber !== cert.serialNumber) {
                  continue;
                }
                if (rAttr.length !== sAttr.length) {
                  continue;
                }
                var match = true;
                for (var j = 0; j < sAttr.length; ++j) {
                  if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
                    match = false;
                    break;
                  }
                }
                if (match) {
                  return r;
                }
              }
              return null;
            },
            /**
             * Decrypt enveloped content
             *
             * @param recipient The recipient object related to the private key
             * @param privKey The (RSA) private key object
             */
            decrypt: function(recipient, privKey) {
              if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
                switch (recipient.encryptedContent.algorithm) {
                  case forge2.pki.oids.rsaEncryption:
                  case forge2.pki.oids.desCBC:
                    var key = privKey.decrypt(recipient.encryptedContent.content);
                    msg.encryptedContent.key = forge2.util.createBuffer(key);
                    break;
                  default:
                    throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
                }
              }
              _decryptContent(msg);
            },
            /**
             * Add (another) entity to list of recipients.
             *
             * @param cert The certificate of the entity to add.
             */
            addRecipient: function(cert) {
              msg.recipients.push({
                version: 0,
                issuer: cert.issuer.attributes,
                serialNumber: cert.serialNumber,
                encryptedContent: {
                  // We simply assume rsaEncryption here, since forge.pki only
                  // supports RSA so far.  If the PKI module supports other
                  // ciphers one day, we need to modify this one as well.
                  algorithm: forge2.pki.oids.rsaEncryption,
                  key: cert.publicKey
                }
              });
            },
            /**
             * Encrypt enveloped content.
             *
             * This function supports two optional arguments, cipher and key, which
             * can be used to influence symmetric encryption.  Unless cipher is
             * provided, the cipher specified in encryptedContent.algorithm is used
             * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
             * is (re-)used.  If that one's not set, a random key will be generated
             * automatically.
             *
             * @param [key] The key to be used for symmetric encryption.
             * @param [cipher] The OID of the symmetric cipher to use.
             */
            encrypt: function(key, cipher2) {
              if (msg.encryptedContent.content === void 0) {
                cipher2 = cipher2 || msg.encryptedContent.algorithm;
                key = key || msg.encryptedContent.key;
                var keyLen, ivLen, ciphFn;
                switch (cipher2) {
                  case forge2.pki.oids["aes128-CBC"]:
                    keyLen = 16;
                    ivLen = 16;
                    ciphFn = forge2.aes.createEncryptionCipher;
                    break;
                  case forge2.pki.oids["aes192-CBC"]:
                    keyLen = 24;
                    ivLen = 16;
                    ciphFn = forge2.aes.createEncryptionCipher;
                    break;
                  case forge2.pki.oids["aes256-CBC"]:
                    keyLen = 32;
                    ivLen = 16;
                    ciphFn = forge2.aes.createEncryptionCipher;
                    break;
                  case forge2.pki.oids["des-EDE3-CBC"]:
                    keyLen = 24;
                    ivLen = 8;
                    ciphFn = forge2.des.createEncryptionCipher;
                    break;
                  default:
                    throw new Error("Unsupported symmetric cipher, OID " + cipher2);
                }
                if (key === void 0) {
                  key = forge2.util.createBuffer(forge2.random.getBytes(keyLen));
                } else if (key.length() != keyLen) {
                  throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
                }
                msg.encryptedContent.algorithm = cipher2;
                msg.encryptedContent.key = key;
                msg.encryptedContent.parameter = forge2.util.createBuffer(
                  forge2.random.getBytes(ivLen)
                );
                var ciph = ciphFn(key);
                ciph.start(msg.encryptedContent.parameter.copy());
                ciph.update(msg.content);
                if (!ciph.finish()) {
                  throw new Error("Symmetric encryption failed.");
                }
                msg.encryptedContent.content = ciph.output;
              }
              for (var i = 0; i < msg.recipients.length; ++i) {
                var recipient = msg.recipients[i];
                if (recipient.encryptedContent.content !== void 0) {
                  continue;
                }
                switch (recipient.encryptedContent.algorithm) {
                  case forge2.pki.oids.rsaEncryption:
                    recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
                      msg.encryptedContent.key.data
                    );
                    break;
                  default:
                    throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
                }
              }
            }
          };
          return msg;
        };
        function _recipientFromAsn1(obj) {
          var capture = {};
          var errors = [];
          if (!asn12.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
            error.errors = errors;
            throw error;
          }
          return {
            version: capture.version.charCodeAt(0),
            issuer: forge2.pki.RDNAttributesAsArray(capture.issuer),
            serialNumber: forge2.util.createBuffer(capture.serial).toHex(),
            encryptedContent: {
              algorithm: asn12.derToOid(capture.encAlgorithm),
              parameter: capture.encParameter ? capture.encParameter.value : void 0,
              content: capture.encKey
            }
          };
        }
        function _recipientToAsn1(obj) {
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // Version
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              asn12.integerToDer(obj.version).getBytes()
            ),
            // IssuerAndSerialNumber
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // Name
              forge2.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
              // Serial
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.INTEGER,
                false,
                forge2.util.hexToBytes(obj.serialNumber)
              )
            ]),
            // KeyEncryptionAlgorithmIdentifier
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // Algorithm
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(obj.encryptedContent.algorithm).getBytes()
              ),
              // Parameter, force NULL, only RSA supported for now.
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
            ]),
            // EncryptedKey
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OCTETSTRING,
              false,
              obj.encryptedContent.content
            )
          ]);
        }
        function _recipientsFromAsn1(infos) {
          var ret = [];
          for (var i = 0; i < infos.length; ++i) {
            ret.push(_recipientFromAsn1(infos[i]));
          }
          return ret;
        }
        function _recipientsToAsn1(recipients) {
          var ret = [];
          for (var i = 0; i < recipients.length; ++i) {
            ret.push(_recipientToAsn1(recipients[i]));
          }
          return ret;
        }
        function _signerToAsn1(obj) {
          var rval = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // version
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              asn12.integerToDer(obj.version).getBytes()
            ),
            // issuerAndSerialNumber
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // name
              forge2.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
              // serial
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.INTEGER,
                false,
                forge2.util.hexToBytes(obj.serialNumber)
              )
            ]),
            // digestAlgorithm
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // algorithm
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(obj.digestAlgorithm).getBytes()
              ),
              // parameters (null)
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
            ])
          ]);
          if (obj.authenticatedAttributesAsn1) {
            rval.value.push(obj.authenticatedAttributesAsn1);
          }
          rval.value.push(asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // algorithm
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OID,
              false,
              asn12.oidToDer(obj.signatureAlgorithm).getBytes()
            ),
            // parameters (null)
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
          ]));
          rval.value.push(asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.OCTETSTRING,
            false,
            obj.signature
          ));
          if (obj.unauthenticatedAttributes.length > 0) {
            var attrsAsn1 = asn12.create(asn12.Class.CONTEXT_SPECIFIC, 1, true, []);
            for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
              var attr = obj.unauthenticatedAttributes[i];
              attrsAsn1.values.push(_attributeToAsn1(attr));
            }
            rval.value.push(attrsAsn1);
          }
          return rval;
        }
        function _signersToAsn1(signers) {
          var ret = [];
          for (var i = 0; i < signers.length; ++i) {
            ret.push(_signerToAsn1(signers[i]));
          }
          return ret;
        }
        function _attributeToAsn1(attr) {
          var value;
          if (attr.type === forge2.pki.oids.contentType) {
            value = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OID,
              false,
              asn12.oidToDer(attr.value).getBytes()
            );
          } else if (attr.type === forge2.pki.oids.messageDigest) {
            value = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OCTETSTRING,
              false,
              attr.value.bytes()
            );
          } else if (attr.type === forge2.pki.oids.signingTime) {
            var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
            var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
            var date = attr.value;
            if (typeof date === "string") {
              var timestamp = Date.parse(date);
              if (!isNaN(timestamp)) {
                date = new Date(timestamp);
              } else if (date.length === 13) {
                date = asn12.utcTimeToDate(date);
              } else {
                date = asn12.generalizedTimeToDate(date);
              }
            }
            if (date >= jan_1_1950 && date < jan_1_2050) {
              value = asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.UTCTIME,
                false,
                asn12.dateToUtcTime(date)
              );
            } else {
              value = asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.GENERALIZEDTIME,
                false,
                asn12.dateToGeneralizedTime(date)
              );
            }
          }
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // AttributeType
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OID,
              false,
              asn12.oidToDer(attr.type).getBytes()
            ),
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SET, true, [
              // AttributeValue
              value
            ])
          ]);
        }
        function _encryptedContentToAsn1(ec2) {
          return [
            // ContentType, always Data for the moment
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OID,
              false,
              asn12.oidToDer(forge2.pki.oids.data).getBytes()
            ),
            // ContentEncryptionAlgorithmIdentifier
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // Algorithm
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(ec2.algorithm).getBytes()
              ),
              // Parameters (IV)
              !ec2.parameter ? void 0 : asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OCTETSTRING,
                false,
                ec2.parameter.getBytes()
              )
            ]),
            // [0] EncryptedContent
            asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OCTETSTRING,
                false,
                ec2.content.getBytes()
              )
            ])
          ];
        }
        function _fromAsn1(msg, obj, validator) {
          var capture = {};
          var errors = [];
          if (!asn12.validate(obj, validator, capture, errors)) {
            var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
            error.errors = error;
            throw error;
          }
          var contentType2 = asn12.derToOid(capture.contentType);
          if (contentType2 !== forge2.pki.oids.data) {
            throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
          }
          if (capture.encryptedContent) {
            var content = "";
            if (forge2.util.isArray(capture.encryptedContent)) {
              for (var i = 0; i < capture.encryptedContent.length; ++i) {
                if (capture.encryptedContent[i].type !== asn12.Type.OCTETSTRING) {
                  throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
                }
                content += capture.encryptedContent[i].value;
              }
            } else {
              content = capture.encryptedContent;
            }
            msg.encryptedContent = {
              algorithm: asn12.derToOid(capture.encAlgorithm),
              parameter: forge2.util.createBuffer(capture.encParameter.value),
              content: forge2.util.createBuffer(content)
            };
          }
          if (capture.content) {
            var content = "";
            if (forge2.util.isArray(capture.content)) {
              for (var i = 0; i < capture.content.length; ++i) {
                if (capture.content[i].type !== asn12.Type.OCTETSTRING) {
                  throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
                }
                content += capture.content[i].value;
              }
            } else {
              content = capture.content;
            }
            msg.content = forge2.util.createBuffer(content);
          }
          msg.version = capture.version.charCodeAt(0);
          msg.rawCapture = capture;
          return capture;
        }
        function _decryptContent(msg) {
          if (msg.encryptedContent.key === void 0) {
            throw new Error("Symmetric key not available.");
          }
          if (msg.content === void 0) {
            var ciph;
            switch (msg.encryptedContent.algorithm) {
              case forge2.pki.oids["aes128-CBC"]:
              case forge2.pki.oids["aes192-CBC"]:
              case forge2.pki.oids["aes256-CBC"]:
                ciph = forge2.aes.createDecryptionCipher(msg.encryptedContent.key);
                break;
              case forge2.pki.oids["desCBC"]:
              case forge2.pki.oids["des-EDE3-CBC"]:
                ciph = forge2.des.createDecryptionCipher(msg.encryptedContent.key);
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
            }
            ciph.start(msg.encryptedContent.parameter);
            ciph.update(msg.encryptedContent.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric decryption failed.");
            }
            msg.content = ciph.output;
          }
        }
        return pkcs7.exports;
      }
      var ssh = { exports: {} };
      var hasRequiredSsh;
      function requireSsh() {
        if (hasRequiredSsh) return ssh.exports;
        hasRequiredSsh = 1;
        var forge2 = requireForge();
        requireAes();
        requireHmac();
        requireMd5();
        requireSha1();
        requireUtil();
        var ssh$1 = ssh.exports = forge2.ssh = forge2.ssh || {};
        ssh$1.privateKeyToPutty = function(privateKey, passphrase, comment) {
          comment = comment || "";
          passphrase = passphrase || "";
          var algorithm = "ssh-rsa";
          var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
          var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
          ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
          ppk += "Comment: " + comment + "\r\n";
          var pubbuffer = forge2.util.createBuffer();
          _addStringToBuffer(pubbuffer, algorithm);
          _addBigIntegerToBuffer(pubbuffer, privateKey.e);
          _addBigIntegerToBuffer(pubbuffer, privateKey.n);
          var pub = forge2.util.encode64(pubbuffer.bytes(), 64);
          var length = Math.floor(pub.length / 66) + 1;
          ppk += "Public-Lines: " + length + "\r\n";
          ppk += pub;
          var privbuffer = forge2.util.createBuffer();
          _addBigIntegerToBuffer(privbuffer, privateKey.d);
          _addBigIntegerToBuffer(privbuffer, privateKey.p);
          _addBigIntegerToBuffer(privbuffer, privateKey.q);
          _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
          var priv;
          if (!passphrase) {
            priv = forge2.util.encode64(privbuffer.bytes(), 64);
          } else {
            var encLen = privbuffer.length() + 16 - 1;
            encLen -= encLen % 16;
            var padding = _sha1(privbuffer.bytes());
            padding.truncate(padding.length() - encLen + privbuffer.length());
            privbuffer.putBuffer(padding);
            var aeskey = forge2.util.createBuffer();
            aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
            aeskey.putBuffer(_sha1("\0\0\0", passphrase));
            var cipher2 = forge2.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
            cipher2.start(forge2.util.createBuffer().fillWithByte(0, 16));
            cipher2.update(privbuffer.copy());
            cipher2.finish();
            var encrypted = cipher2.output;
            encrypted.truncate(16);
            priv = forge2.util.encode64(encrypted.bytes(), 64);
          }
          length = Math.floor(priv.length / 66) + 1;
          ppk += "\r\nPrivate-Lines: " + length + "\r\n";
          ppk += priv;
          var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
          var macbuffer = forge2.util.createBuffer();
          _addStringToBuffer(macbuffer, algorithm);
          _addStringToBuffer(macbuffer, encryptionAlgorithm);
          _addStringToBuffer(macbuffer, comment);
          macbuffer.putInt32(pubbuffer.length());
          macbuffer.putBuffer(pubbuffer);
          macbuffer.putInt32(privbuffer.length());
          macbuffer.putBuffer(privbuffer);
          var hmac2 = forge2.hmac.create();
          hmac2.start("sha1", mackey);
          hmac2.update(macbuffer.bytes());
          ppk += "\r\nPrivate-MAC: " + hmac2.digest().toHex() + "\r\n";
          return ppk;
        };
        ssh$1.publicKeyToOpenSSH = function(key, comment) {
          var type = "ssh-rsa";
          comment = comment || "";
          var buffer = forge2.util.createBuffer();
          _addStringToBuffer(buffer, type);
          _addBigIntegerToBuffer(buffer, key.e);
          _addBigIntegerToBuffer(buffer, key.n);
          return type + " " + forge2.util.encode64(buffer.bytes()) + " " + comment;
        };
        ssh$1.privateKeyToOpenSSH = function(privateKey, passphrase) {
          if (!passphrase) {
            return forge2.pki.privateKeyToPem(privateKey);
          }
          return forge2.pki.encryptRsaPrivateKey(
            privateKey,
            passphrase,
            { legacy: true, algorithm: "aes128" }
          );
        };
        ssh$1.getPublicKeyFingerprint = function(key, options) {
          options = options || {};
          var md2 = options.md || forge2.md.md5.create();
          var type = "ssh-rsa";
          var buffer = forge2.util.createBuffer();
          _addStringToBuffer(buffer, type);
          _addBigIntegerToBuffer(buffer, key.e);
          _addBigIntegerToBuffer(buffer, key.n);
          md2.start();
          md2.update(buffer.getBytes());
          var digest = md2.digest();
          if (options.encoding === "hex") {
            var hex = digest.toHex();
            if (options.delimiter) {
              return hex.match(/.{2}/g).join(options.delimiter);
            }
            return hex;
          } else if (options.encoding === "binary") {
            return digest.getBytes();
          } else if (options.encoding) {
            throw new Error('Unknown encoding "' + options.encoding + '".');
          }
          return digest;
        };
        function _addBigIntegerToBuffer(buffer, val) {
          var hexVal = val.toString(16);
          if (hexVal[0] >= "8") {
            hexVal = "00" + hexVal;
          }
          var bytes = forge2.util.hexToBytes(hexVal);
          buffer.putInt32(bytes.length);
          buffer.putBytes(bytes);
        }
        function _addStringToBuffer(buffer, val) {
          buffer.putInt32(val.length);
          buffer.putString(val);
        }
        function _sha1() {
          var sha = forge2.md.sha1.create();
          var num = arguments.length;
          for (var i = 0; i < num; ++i) {
            sha.update(arguments[i]);
          }
          return sha.digest();
        }
        return ssh.exports;
      }
      var lib;
      var hasRequiredLib;
      function requireLib() {
        if (hasRequiredLib) return lib;
        hasRequiredLib = 1;
        lib = requireForge();
        requireAes();
        requireAesCipherSuites();
        requireAsn1();
        requireCipher();
        requireDes();
        requireEd25519();
        requireHmac();
        requireKem();
        requireLog();
        requireMd_all();
        requireMgf1();
        requirePbkdf2();
        requirePem();
        requirePkcs1();
        requirePkcs12();
        requirePkcs7();
        requirePki();
        requirePrime();
        requirePrng();
        requirePss();
        requireRandom();
        requireRc2();
        requireSsh();
        requireTls();
        requireUtil();
        return lib;
      }
      var libExports = requireLib();
      const forge = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
      const IV = "0102030405060708";
      const PRESET_KEY = "0CoJUm6Qyw8W8jud";
      const PUBLIC_KEY = "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDgtQn2JZ34ZC28NWYpAUd98iZ37BUrX/aKzmFbt7clFSs6sXqHauqKWqdtLkF2KexO40H1YTX8z2lSgBBOAxLsvaklV8k4cBFK9snQXE9/DDaFt6Rr7iVZMldczhC0JNgTz+SHXT6CBHuX3e9SdB1Ua44oncaTWz7OBGLbCiK45wIDAQAB\n-----END PUBLIC KEY-----";
      const BASE62 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      const aesEncrypt = (text, key, iv) => {
        const cipher2 = forge.cipher.createCipher("AES-CBC", key);
        cipher2.start({ iv });
        cipher2.update(forge.util.createBuffer(text, "utf8"));
        cipher2.finish();
        return forge.util.encode64(cipher2.output.getBytes());
      };
      const rsaEncrypt = (text, key) => {
        const publicKey = forge.pki.publicKeyFromPem(key);
        const encrypted = publicKey.encrypt(text, "NONE");
        return forge.util.bytesToHex(encrypted);
      };
      const weapi = (object) => {
        const text = JSON.stringify(object);
        const secretKey = Array.from(
          { length: 16 },
          () => BASE62.charAt(Math.floor(Math.random() * 62))
        ).join("");
        return {
          params: aesEncrypt(aesEncrypt(text, PRESET_KEY, IV), secretKey, IV),
          encSecKey: rsaEncrypt(secretKey.split("").reverse().join(""), PUBLIC_KEY)
        };
      };
      const CLIENT_CONFIG = {
        web: {
          cookie: true,
          userAgent: void 0
        },
        android: {
          cookie: "os=android;appver=9.1.78;channel=netease;osver=14;buildver=241009150147;",
          userAgent: "NeteaseMusic/9.1.78.241009150147(9001078);Dalvik/2.1.0 (Linux; U; Android 14; V2318A Build/TP1A.220624.014)"
        },
        pc: {
          cookie: "os=pc;appver=3.0.18.203152;channel=netease;osver=Microsoft-Windows-10-Professional-build-19045-64bit;",
          userAgent: "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Safari/537.36 Chrome/91.0.4472.164 NeteaseMusicDesktop/3.0.18.203152"
        }
      };
      const weapiRequest = (url, config) => {
        const { data = {}, clientType = "pc", ip, originResponse = false } = config;
        data.csrf_token = /* csrfToken ? csrfToken[1] : */
        "";
        const encryptedData = weapi(data);
        console.log({
          url,
          data,
          encryptedData
        });
        const headers = {
          "content-type": "application/x-www-form-urlencoded",
          "user-agent": CLIENT_CONFIG[clientType].userAgent
        };
        if (ip) {
          headers["X-Real-IP"] = ip;
          headers["X-Forwarded-For"] = ip;
        }
        const baseUrl = "https://music.163.com";
        const fullUrl = new URL(url.replace("api", "weapi"), baseUrl);
        return new Promise((resolve, reject) => {
          _GM_xmlhttpRequest({
            url: fullUrl.toString() + `?csrf_token=${data.csrf_token}`,
            method: "POST",
            responseType: "json",
            headers,
            cookie: CLIENT_CONFIG[clientType].cookie,
            data: `params=${encodeURIComponent(
        encryptedData.params
      )}&encSecKey=${encodeURIComponent(encryptedData.encSecKey)}`,
            onload: (res) => resolve(originResponse ? res : res.response),
            onerror: reject
          });
        });
      };
      const BUCKET = "jd-musicrep-privatecloud-audio-public";
      const getUserAccount = () => weapiRequest("/api/nuser/account/get", {
        data: {}
      });
      const uploadAudioToNos = async ({ file, bucket, objectKey, token, fileMd5, contentType: contentType2 }) => {
        const lbsUrl = `https://wanproxy.127.net/lbs?version=1.0&bucketname=${bucket}`;
        const lbs = await (await fetch(lbsUrl)).json();
        const safeObjectKey = objectKey.replace("/", "%2F");
        const uploadUrl = `${lbs.upload[0]}/${bucket}/${safeObjectKey}?offset=0&complete=true&version=1.0`.replace(
          "http://",
          "https://"
        );
        const response = await fetch(uploadUrl, {
          method: "post",
          headers: {
            "x-nos-token": token,
            "Content-MD5": fileMd5,
            "Content-Type": contentType2
          },
          body: file
        });
        let result = {};
        try {
          result = await response.json();
        } catch (error) {
          console.log("uploadAudioToNos parse error", error);
        }
        if (!response.ok) {
          msgError("上传失败：文件未通过 NOS 校验");
          throw new Error(result?.message || "上传失败：文件未通过 NOS 校验");
        }
        return result;
      };
      const uploadLocalSong = async (file, options = {}) => {
        const {
          defaultBitrate = 999e3,
          defaultAlbum,
          defaultArtist,
          defaultTitle,
          defaultArtists = []
        } = options || {};
        let defaultResult = {};
        try {
          const ext = file.name.split(".").pop() || "mp3";
          const fileMd5 = await getFileMD5(file);
          const bitrate = defaultBitrate;
          const filename = file.name.replace("." + ext, "").replace(/\s/g, "").replace(/\./g, "_");
          const contentType2 = file.type || "audio/mpeg";
          const checkRes = await weapiRequest("/api/cloud/upload/check", {
            data: {
              ext: "",
              bitrate: String(bitrate),
              md5: fileMd5,
              length: file.size,
              songId: "0",
              version: 1
            }
          });
          console.log("检查文件是否存在，checkRes", checkRes);
          if (checkRes.code != 200) {
            msgError("文件检查失败：" + checkRes.message || checkRes.msg || "");
            throw new Error(checkRes.message || checkRes.msg || "文件检查失败");
          }
          const { needUpload, songId } = checkRes;
          if (needUpload) {
            console.log("检测到云盘没有该文件，需要上传文件");
            const uploadTokenRes = await weapiRequest("/api/nos/token/alloc", {
              data: {
                bucket: BUCKET,
                ext,
                filename,
                local: false,
                nos_product: 3,
                type: "audio",
                md5: fileMd5
              }
            });
            if (uploadTokenRes.code !== 200) {
              msgError("上传授权失败");
              throw new Error(uploadTokenRes.message || "上传授权失败");
            }
            console.log("获取到上传授权，uploadTokenRes", uploadTokenRes);
            await uploadAudioToNos({
              file,
              bucket: BUCKET,
              objectKey: uploadTokenRes.result.objectKey,
              token: uploadTokenRes.result.token,
              fileMd5,
              contentType: contentType2
            });
            console.log("上传文件成功");
          }
          const tokenRes = await weapiRequest("/api/nos/token/alloc", {
            data: {
              bucket: "",
              ext,
              filename,
              local: false,
              nos_product: 3,
              type: "audio",
              md5: fileMd5
            }
          });
          console.log("申请上传token，tokenRes", tokenRes);
          if (tokenRes.code != 200) {
            msgError("获取上传token失败");
            throw new Error(tokenRes.message || tokenRes.msg || "获取上传token失败");
          }
          const { bucket, docId, objectKey, outerUrl, resourceId, token } = tokenRes.result;
          const {
            album = defaultAlbum,
            artist = defaultArtist,
            artists = defaultArtists,
            title = defaultTitle
          } = await getAudioMetadata(file);
          defaultResult = {
            ...defaultResult,
            artist,
            artists,
            album,
            md5: fileMd5,
            ext,
            bitrate
          };
          const uploadInfoRes = await weapiRequest("/api/upload/cloud/info/v2", {
            data: {
              md5: fileMd5,
              songid: songId,
              filename: file.name,
              song: title || filename,
              album: album || "未知专辑",
              artist: artist || artists.join(",") || "未知歌手",
              bitrate: String(bitrate),
              resourceId
            }
          });
          console.log("获取上传信息，uploadInfoRes", uploadInfoRes);
          defaultResult = {
            ...defaultResult,
            id: uploadInfoRes.songId
          };
          if (uploadInfoRes.code != 200) {
            msgError("获取上传信息失败");
            throw new Error(uploadInfoRes.message || uploadInfoRes.msg || "获取上传信息失败");
          }
          const pubRes = await weapiRequest("/api/cloud/pub/v2", {
            data: {
              songid: uploadInfoRes.songId
            }
          });
          console.log("发布资源，pubRes", pubRes);
          if (![200, 201].includes(pubRes.code)) {
            msgError(`歌曲： ${file.name} 发布失败`);
            throw new Error(pubRes.message || pubRes.msg || "歌曲发布失败");
          }
          const { songName, bitrate: realBitrate, fileSize } = pubRes.privateCloud;
          defaultResult = {
            ...defaultResult,
            name: songName,
            size: fileSize,
            bitrate: realBitrate
          };
          return defaultResult;
        } catch (error) {
          console.log("error", error);
          throw error;
        }
      };
      const mapToList = (map) => {
        return Object.entries(map).map(([key, value]) => ({
          label: key,
          value
        }));
      };
      const Area = {
        全部: -100,
        内地: 200,
        港台: 2,
        欧美: 5,
        日本: 4,
        韩国: 3,
        其他: 6
      };
      const AreaList = mapToList(Area);
      const Genre = {
        全部: -100,
        流行: 1,
        嘻哈: 6,
        摇滚: 2,
        电子: 4,
        民谣: 3,
        "R&B": 8,
        民歌: 10,
        轻音乐: 9,
        爵士: 5,
        古典: 14,
        乡村: 25,
        蓝调: 20
      };
      const GenreList = mapToList(Genre);
      const Sex = {
        全部: -100,
        男: 0,
        女: 1,
        组合: 2
      };
      const SexList = mapToList(Sex);
      const getCommonParams = () => ({
        g_tk: 1124214810,
        loginUin: getCookie("uin") || "0",
        hostUin: 0,
        inCharset: "utf8",
        outCharset: "utf-8",
        // format: 'json',
        notice: 0,
        platform: "yqq.json",
        needNewCode: 0
      });
      const _guid = Math.round(2147483647 * Math.random()) * (/* @__PURE__ */ new Date()).getUTCMilliseconds() % 1e10;
      const FileType = {
        m4a: {
          s: "C400",
          e: ".m4a"
        },
        128: {
          s: "M500",
          e: ".mp3"
        },
        320: {
          s: "M800",
          e: ".mp3"
        },
        ape: {
          s: "A000",
          e: ".ape"
        },
        flac: {
          s: "F000",
          e: ".flac"
        }
      };
      const ResourceType = {
        歌曲: "song",
        专辑: "album",
        视频: "mv",
        歌单: "playlist",
        歌手: "user",
        歌词: "lyric"
      };
      const FlacTag = {
        标题: "title",
        艺术家: "artist",
        专辑: "album",
        年份: "year",
        流派: "genre",
        评论: "comment",
        音轨: "track",
        碟片: "disc",
        作曲家: "composer",
        作词家: "lyricist",
        歌词: "lyrics"
      };
      mapToList(FlacTag);
      const FLAC_TAGS = Object.entries(FlacTag).reduce(
        (acc, [key, value]) => {
          acc[value] = key;
          return acc;
        },
        {}
      );
      const getSongInfo = async (songmid, options = {}) => {
        const { songid = "" } = options;
        const params = {
          ...getCommonParams(),
          format: "json",
          inCharset: "utf8",
          outCharset: "utf-8",
          notice: 0,
          platform: "yqq.json",
          needNewCode: 0,
          data: JSON.stringify({
            comm: {
              ct: 24,
              cv: 0
            },
            songinfo: {
              method: "get_song_detail_yqq",
              param: {
                song_type: 0,
                song_mid: songmid,
                song_id: songid
              },
              module: "music.pf_song_detail_svr"
            }
          })
        };
        const res = await qqMusicRequest(
          `/cgi-bin/musicu.fcg?${new URLSearchParams(params).toString()}`,
          {},
          "u"
        );
        if (res.code === 0) {
          return res.songinfo?.data;
        }
        throw new Error("获取歌曲信息失败");
      };
      const getSongLyric = async (songmid) => {
        const params = {
          songmid,
          format: "json",
          outCharset: "utf-8",
          pcachetime: dayjs().valueOf()
        };
        const res = await qqMusicRequest(
          `/lyric/fcgi-bin/fcg_query_lyric_new.fcg?${new URLSearchParams(params)}`,
          {}
        );
        if (res.code === 0) {
          const lyric = window.atob(res.lyric);
          const bytes = Uint8Array.from(lyric, (c) => c.charCodeAt(0));
          const decoder = new TextDecoder();
          const decodedText = decoder.decode(bytes);
          return decodedText;
        }
        throw new Error("获取歌曲歌词失败");
      };
      const getSongPlayUrl = async (songmid, options = {}) => {
        const { quality = "flac" } = options;
        const songmidList = Array.isArray(songmid) ? songmid : [songmid];
        const fileInfo = FileType[quality];
        const fileNames = songmidList.map((item, index2) => `${fileInfo.s}${item}${item}${fileInfo.e}`);
        const uin = getCookie("uin");
        const params = {
          format: "json",
          sign: "zzannc1o6o9b4i971602f3554385022046ab796512b7012",
          data: JSON.stringify({
            req_0: {
              module: "vkey.GetVkeyServer",
              method: "CgiGetVkey",
              param: {
                filename: fileNames,
                guid: _guid + "",
                songmid: songmidList,
                songtype: [0],
                uin,
                loginflag: 1,
                platform: "20"
              }
            },
            loginUin: uin,
            comm: {
              uin,
              format: "json",
              ct: 24,
              cv: 0
            }
          })
        };
        const res = await qqMusicRequest(
          `/cgi-bin/musicu.fcg?${new URLSearchParams(params)}`,
          {},
          "u"
        );
        console.log("res", res);
        if (res.code === 0) {
          const data = res.req_0.data;
          const domain = data.sip?.find((i) => !i.startsWith("http://ws")) || data.sip[0];
          let playUrl = {};
          data.midurlinfo.forEach((item) => {
            playUrl[item.songmid] = {
              url: item.purl ? `${domain}${item.purl}` : "",
              error: !item.purl && "暂无播放链接"
            };
          });
          return playUrl;
        }
        throw new Error("获取歌曲播放链接失败");
      };
      function stringToBytes(str, encoding = "utf8") {
        if (encoding === "utf8") {
          const utf8 = unescape(encodeURIComponent(str));
          const bytes = new Uint8Array(utf8.length);
          for (let i = 0; i < utf8.length; i++) {
            bytes[i] = utf8.charCodeAt(i);
          }
          return bytes;
        } else if (encoding === "ascii") {
          const bytes = new Uint8Array(str.length);
          for (let i = 0; i < str.length; i++) {
            bytes[i] = str.charCodeAt(i) & 255;
          }
          return bytes;
        } else if (encoding === "hex") {
          const bytes = new Uint8Array(str.length / 2);
          for (let i = 0; i < str.length; i += 2) {
            bytes[i / 2] = parseInt(str.substr(i, 2), 16);
          }
          return bytes;
        }
        throw new Error(`Unsupported encoding: ${encoding}`);
      }
      function bytesToString(bytes, encoding = "utf8") {
        if (encoding === "utf8") {
          let str = "";
          for (let i = 0; i < bytes.length; i++) {
            str += String.fromCharCode(bytes[i]);
          }
          try {
            return decodeURIComponent(escape(str));
          } catch (e) {
            return str;
          }
        } else if (encoding === "ascii") {
          let str = "";
          for (let i = 0; i < bytes.length; i++) {
            str += String.fromCharCode(bytes[i] & 255);
          }
          return str;
        } else if (encoding === "hex") {
          let hex = "";
          for (let i = 0; i < bytes.length; i++) {
            const h = bytes[i].toString(16);
            hex += h.length === 1 ? "0" + h : h;
          }
          return hex;
        }
        throw new Error(`Unsupported encoding: ${encoding}`);
      }
      class BrowserBuffer {
        constructor(data, byteOffset, length) {
          if (typeof data === "number") {
            this._data = new Uint8Array(data);
            this._view = new DataView(this._data.buffer);
          } else if (data instanceof Uint8Array) {
            this._data = data;
            this._view = new DataView(this._data.buffer, data.byteOffset, data.byteLength);
          } else if (typeof data === "string") {
            const encoding = byteOffset || "utf8";
            this._data = stringToBytes(data, encoding);
            this._view = new DataView(this._data.buffer);
          } else if (data instanceof ArrayBuffer) {
            const offset = byteOffset || 0;
            const len = length !== void 0 ? length : data.byteLength - offset;
            this._data = new Uint8Array(data, offset, len);
            this._view = new DataView(data, offset, len);
          } else if (data instanceof BrowserBuffer) {
            this._data = data._data;
            this._view = data._view;
          } else if (Array.isArray(data)) {
            this._data = new Uint8Array(data);
            this._view = new DataView(this._data.buffer);
          } else if (data === void 0) {
            this._data = new Uint8Array(0);
            this._view = new DataView(this._data.buffer);
          } else {
            this._data = new Uint8Array(data);
            this._view = new DataView(this._data.buffer);
          }
        }
        /**
         * 读取无符号 8 位整数
         */
        readUInt8(offset) {
          return this._view.getUint8(offset);
        }
        /**
         * 读取无符号 16 位整数（大端序）
         */
        readUInt16BE(offset) {
          return this._view.getUint16(offset, false);
        }
        /**
         * 读取无符号 16 位整数（小端序）
         */
        readUInt16LE(offset) {
          return this._view.getUint16(offset, true);
        }
        /**
         * 读取无符号 32 位整数（大端序）
         */
        readUInt32BE(offset) {
          return this._view.getUint32(offset, false);
        }
        /**
         * 读取无符号 32 位整数（小端序）
         */
        readUInt32LE(offset) {
          return this._view.getUint32(offset, true);
        }
        /**
         * 读取无符号整数（大端序，可变长度）
         */
        readUIntBE(offset, byteLength) {
          let value = 0;
          for (let i = 0; i < byteLength; i++) {
            value = (value << 8) + this._view.getUint8(offset + i);
          }
          return value;
        }
        /**
         * 写入无符号 8 位整数
         */
        writeUInt8(value, offset) {
          this._view.setUint8(offset, value);
        }
        /**
         * 写入无符号 16 位整数（大端序）
         */
        writeUInt16BE(value, offset) {
          this._view.setUint16(offset, value, false);
        }
        /**
         * 写入无符号 32 位整数（大端序）
         */
        writeUInt32BE(value, offset) {
          this._view.setUint32(offset, value, false);
        }
        /**
         * 写入无符号 32 位整数（小端序）
         */
        writeUInt32LE(value, offset) {
          this._view.setUint32(offset, value, true);
        }
        /**
         * 写入无符号整数（大端序，可变长度）
         */
        writeUIntBE(value, offset, byteLength) {
          for (let i = byteLength - 1; i >= 0; i--) {
            this._view.setUint8(offset + i, value & 255);
            value = value >> 8;
          }
        }
        /**
         * 转换为字符串
         */
        toString(encoding = "utf8") {
          return bytesToString(this._data, encoding);
        }
        /**
         * 切片
         */
        slice(start, end) {
          const sliced = this._data.slice(start, end);
          return new BrowserBuffer(sliced);
        }
        /**
         * 获取长度
         */
        get length() {
          return this._data.length;
        }
        /**
         * 获取底层 ArrayBuffer
         */
        get buffer() {
          return this._data.buffer;
        }
        /**
         * 转换为 Uint8Array
         */
        toUint8Array() {
          return new Uint8Array(this._data);
        }
        /**
         * 转换为 ArrayBuffer
         */
        toArrayBuffer() {
          const buf = this.buffer;
          if (typeof SharedArrayBuffer !== "undefined" && buf instanceof SharedArrayBuffer) {
            throw new Error("Cannot convert SharedArrayBuffer to ArrayBuffer");
          }
          return buf.slice(
            this._data.byteOffset,
            this._data.byteOffset + this._data.byteLength
          );
        }
        /**
         * 创建指定大小的 Buffer
         */
        static alloc(size) {
          return new BrowserBuffer(size);
        }
        /**
         * 从数据创建 Buffer
         */
        static from(data, encoding) {
          if (data instanceof BrowserBuffer) {
            return data;
          }
          if (data instanceof Uint8Array) {
            return new BrowserBuffer(data);
          }
          if (data instanceof ArrayBuffer) {
            return new BrowserBuffer(data);
          }
          if (typeof data === "string") {
            return new BrowserBuffer(data, encoding);
          }
          if (Array.isArray(data)) {
            return new BrowserBuffer(new Uint8Array(data));
          }
          throw new Error("Unsupported data type");
        }
        /**
         * 连接多个 Buffer
         */
        static concat(buffers) {
          let totalLength = 0;
          for (let i = 0; i < buffers.length; i++) {
            totalLength += buffers[i].length;
          }
          const result = new Uint8Array(totalLength);
          let offset = 0;
          for (let i = 0; i < buffers.length; i++) {
            const buf = buffers[i];
            if (buf instanceof BrowserBuffer) {
              result.set(buf._data, offset);
              offset += buf.length;
            } else if (buf instanceof Uint8Array) {
              result.set(buf, offset);
              offset += buf.length;
            }
          }
          return new BrowserBuffer(result);
        }
      }
      function detectImageType(data) {
        let bytes;
        if (data instanceof Uint8Array) {
          bytes = data;
        } else if (data instanceof ArrayBuffer) {
          bytes = new Uint8Array(data);
        } else if (data instanceof BrowserBuffer) {
          bytes = data.toUint8Array();
        } else {
          bytes = new Uint8Array(data);
        }
        if (bytes.length >= 3 && bytes[0] === 255 && bytes[1] === 216 && bytes[2] === 255) {
          return { mime: "image/jpeg" };
        }
        if (bytes.length >= 8 && bytes[0] === 137 && bytes[1] === 80 && bytes[2] === 78 && bytes[3] === 71 && bytes[4] === 13 && bytes[5] === 10 && bytes[6] === 26 && bytes[7] === 10) {
          return { mime: "image/png" };
        }
        if (bytes.length >= 4 && bytes[0] === 71 && bytes[1] === 73 && bytes[2] === 70 && bytes[3] === 56) {
          return { mime: "image/gif" };
        }
        if (bytes.length >= 12 && bytes[0] === 82 && bytes[1] === 73 && bytes[2] === 70 && bytes[3] === 70 && bytes[8] === 87 && bytes[9] === 69 && bytes[10] === 66 && bytes[11] === 80) {
          return { mime: "image/webp" };
        }
        throw new Error("Unsupported image type");
      }
      function parseJpegSize(bytes) {
        let offset = 2;
        while (offset < bytes.length) {
          if (bytes[offset] !== 255) {
            offset++;
            continue;
          }
          const marker = bytes[offset + 1];
          if (marker >= 192 && marker <= 195) {
            const height = bytes[offset + 5] << 8 | bytes[offset + 6];
            const width = bytes[offset + 7] << 8 | bytes[offset + 8];
            return { width, height };
          }
          if (marker === 216 || marker === 217) {
            offset += 2;
          } else if (marker >= 208 && marker <= 215) {
            offset += 2;
          } else {
            const length = bytes[offset + 2] << 8 | bytes[offset + 3];
            offset += 2 + length;
          }
        }
        throw new Error("Could not determine JPEG dimensions");
      }
      function parsePngSize(bytes) {
        if (bytes.length < 24) {
          throw new Error("Invalid PNG file");
        }
        const width = bytes[16] << 24 | bytes[17] << 16 | bytes[18] << 8 | bytes[19];
        const height = bytes[20] << 24 | bytes[21] << 16 | bytes[22] << 8 | bytes[23];
        return { width, height };
      }
      function getImageSize(data) {
        let bytes;
        if (data instanceof Uint8Array) {
          bytes = data;
        } else if (data instanceof ArrayBuffer) {
          bytes = new Uint8Array(data);
        } else if (data instanceof BrowserBuffer) {
          bytes = data.toUint8Array();
        } else {
          bytes = new Uint8Array(data);
        }
        const type = detectImageType(bytes);
        if (type.mime === "image/jpeg") {
          return parseJpegSize(bytes);
        } else if (type.mime === "image/png") {
          return parsePngSize(bytes);
        } else {
          throw new Error(`Unsupported image type: ${type.mime}`);
        }
      }
      function formatVorbisComment(vendorString, commentList) {
        const bufferArray = [];
        const vendorStringBuffer = BrowserBuffer.from(vendorString, "utf8");
        const vendorLengthBuffer = BrowserBuffer.alloc(4);
        vendorLengthBuffer.writeUInt32LE(vendorStringBuffer.length, 0);
        const userCommentListLengthBuffer = BrowserBuffer.alloc(4);
        userCommentListLengthBuffer.writeUInt32LE(commentList.length, 0);
        bufferArray.push(vendorLengthBuffer, vendorStringBuffer, userCommentListLengthBuffer);
        for (let i = 0; i < commentList.length; i++) {
          const comment = commentList[i];
          const commentBuffer = BrowserBuffer.from(comment, "utf8");
          const lengthBuffer = BrowserBuffer.alloc(4);
          lengthBuffer.writeUInt32LE(commentBuffer.length, 0);
          bufferArray.push(lengthBuffer, commentBuffer);
        }
        return BrowserBuffer.concat(bufferArray);
      }
      const STREAMINFO = 0;
      const PADDING = 1;
      const APPLICATION = 2;
      const SEEKTABLE = 3;
      const VORBIS_COMMENT = 4;
      const CUESHEET = 5;
      const PICTURE = 6;
      async function toBrowserBuffer(data) {
        if (data instanceof BrowserBuffer) {
          return data;
        }
        if (data instanceof Uint8Array) {
          return new BrowserBuffer(data);
        }
        if (data instanceof ArrayBuffer) {
          return new BrowserBuffer(data);
        }
        if (data instanceof File || data instanceof Blob) {
          const arrayBuffer = await data.arrayBuffer();
          return new BrowserBuffer(arrayBuffer);
        }
        throw new Error(
          "Unsupported data type. Expected ArrayBuffer, Uint8Array, File, Blob, or BrowserBuffer."
        );
      }
      class Metaflac {
        /**
         * 创建 Metaflac 实例
         * @param flac - FLAC 文件数据
         */
        constructor(flac) {
          this.buffer = null;
          this.streamInfo = null;
          this.blocks = [];
          this.padding = null;
          this.vorbisComment = null;
          this.vendorString = "";
          this.tags = [];
          this.pictures = [];
          this.picturesSpecs = [];
          this.picturesDatas = [];
          this.framesOffset = 0;
          if (flac instanceof File || flac instanceof Blob) {
            throw new Error(
              "File and Blob objects must be loaded asynchronously. Use Metaflac.fromFile() or Metaflac.fromBlob() instead."
            );
          }
          this.flac = flac;
          this.init();
        }
        /**
         * 从 File 对象创建 Metaflac 实例（异步）
         * @param file - File 对象
         * @returns Promise<Metaflac>
         */
        static async fromFile(file) {
          const buffer = await toBrowserBuffer(file);
          return new Metaflac(buffer);
        }
        /**
         * 从 Blob 对象创建 Metaflac 实例（异步）
         * @param blob - Blob 对象
         * @returns Promise<Metaflac>
         */
        static async fromBlob(blob) {
          const buffer = await toBrowserBuffer(blob);
          return new Metaflac(buffer);
        }
        /**
         * 从 ArrayBuffer 创建 Metaflac 实例
         * @param arrayBuffer - ArrayBuffer 对象
         * @returns Metaflac
         */
        static fromArrayBuffer(arrayBuffer) {
          return new Metaflac(arrayBuffer);
        }
        /**
         * 从 Uint8Array 创建 Metaflac 实例
         * @param uint8Array - Uint8Array 对象
         * @returns Metaflac
         */
        static fromUint8Array(uint8Array) {
          return new Metaflac(uint8Array);
        }
        init() {
          if (this.flac instanceof BrowserBuffer) {
            this.buffer = this.flac;
          } else if (this.flac instanceof Uint8Array) {
            this.buffer = new BrowserBuffer(this.flac);
          } else if (this.flac instanceof ArrayBuffer) {
            this.buffer = new BrowserBuffer(this.flac);
          } else {
            throw new Error("Metaflac(flac) flac must be ArrayBuffer, Uint8Array, or BrowserBuffer.");
          }
          let offset = 0;
          const marker = this.buffer.slice(0, offset += 4).toString("ascii");
          if (marker !== "fLaC") {
            throw new Error("The file does not appear to be a FLAC file.");
          }
          let blockType = 0;
          let isLastBlock = false;
          while (!isLastBlock) {
            blockType = this.buffer.readUInt8(offset++);
            isLastBlock = blockType > 128;
            blockType = blockType % 128;
            const blockLength = this.buffer.readUIntBE(offset, 3);
            offset += 3;
            if (blockType === STREAMINFO) {
              this.streamInfo = this.buffer.slice(offset, offset + blockLength);
            }
            if (blockType === PADDING) {
              this.padding = this.buffer.slice(offset, offset + blockLength);
            }
            if (blockType === VORBIS_COMMENT) {
              this.vorbisComment = this.buffer.slice(offset, offset + blockLength);
              this.parseVorbisComment();
            }
            if (blockType === PICTURE) {
              this.pictures.push(this.buffer.slice(offset, offset + blockLength));
              this.parsePictureBlock();
            }
            if ([APPLICATION, SEEKTABLE, CUESHEET].includes(blockType)) {
              this.blocks.push([blockType, this.buffer.slice(offset, offset + blockLength)]);
            }
            offset += blockLength;
          }
          this.framesOffset = offset;
        }
        parseVorbisComment() {
          if (!this.vorbisComment) {
            return;
          }
          const vendorLength = this.vorbisComment.readUInt32LE(0);
          this.vendorString = this.vorbisComment.slice(4, vendorLength + 4).toString("utf8");
          this.vorbisComment.readUInt32LE(4 + vendorLength);
          const userCommentListBuffer = this.vorbisComment.slice(4 + vendorLength + 4);
          for (let offset = 0; offset < userCommentListBuffer.length; ) {
            const length = userCommentListBuffer.readUInt32LE(offset);
            offset += 4;
            const comment = userCommentListBuffer.slice(offset, offset + length).toString("utf8");
            offset += length;
            this.tags.push(comment);
          }
        }
        parsePictureBlock() {
          this.pictures.forEach((picture) => {
            let offset = 0;
            const type = picture.readUInt32BE(offset);
            offset += 4;
            const mimeTypeLength = picture.readUInt32BE(offset);
            offset += 4;
            const mime = picture.slice(offset, offset + mimeTypeLength).toString("ascii");
            offset += mimeTypeLength;
            const descriptionLength = picture.readUInt32BE(offset);
            offset += 4;
            const description = picture.slice(offset, offset + descriptionLength).toString("utf8");
            offset += descriptionLength;
            const width = picture.readUInt32BE(offset);
            offset += 4;
            const height = picture.readUInt32BE(offset);
            offset += 4;
            const depth = picture.readUInt32BE(offset);
            offset += 4;
            const colors = picture.readUInt32BE(offset);
            offset += 4;
            const pictureDataLength = picture.readUInt32BE(offset);
            offset += 4;
            this.picturesDatas.push(picture.slice(offset, offset + pictureDataLength));
            this.picturesSpecs.push(
              this.buildSpecification({
                type,
                mime,
                description,
                width,
                height,
                depth,
                colors
              })
            );
          });
        }
        /**
         * 获取所有图片规格
         * @returns 图片规格数组
         */
        getPicturesSpecs() {
          return this.picturesSpecs;
        }
        /**
         * Get the MD5 signature from the STREAMINFO block.
         */
        getMd5sum() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return this.streamInfo.slice(18, 34).toString("hex");
        }
        /**
         * Get the minimum block size from the STREAMINFO block.
         */
        getMinBlocksize() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return this.streamInfo.readUInt16BE(0);
        }
        /**
         * Get the maximum block size from the STREAMINFO block.
         */
        getMaxBlocksize() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return this.streamInfo.readUInt16BE(2);
        }
        /**
         * Get the minimum frame size from the STREAMINFO block.
         */
        getMinFramesize() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return this.streamInfo.readUIntBE(4, 3);
        }
        /**
         * Get the maximum frame size from the STREAMINFO block.
         */
        getMaxFramesize() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return this.streamInfo.readUIntBE(7, 3);
        }
        /**
         * Get the sample rate from the STREAMINFO block.
         */
        getSampleRate() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return this.streamInfo.readUIntBE(10, 3) >> 4;
        }
        /**
         * Get the number of channels from the STREAMINFO block.
         */
        getChannels() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return (this.streamInfo.readUIntBE(10, 3) & 15) >> 1;
        }
        /**
         * Get the # of bits per sample from the STREAMINFO block.
         */
        getBps() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return (this.streamInfo.readUIntBE(12, 2) & 496) >> 4;
        }
        /**
         * Get the total # of samples from the STREAMINFO block.
         */
        getTotalSamples() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return this.streamInfo.readUIntBE(13, 5) & 68719476735;
        }
        /**
         * Show the vendor string from the VORBIS_COMMENT block.
         */
        getVendorTag() {
          return this.vendorString;
        }
        /**
         * Get all tags where the the field name matches NAME.
         *
         * @param name - 标签名称
         * @returns 匹配的标签字符串（多个用换行符分隔）
         */
        getTag(name2) {
          return this.tags.filter((item) => {
            const itemName = item.split("=")[0];
            return itemName === name2;
          }).join("\n");
        }
        /**
         * Remove all tags whose field name is NAME.
         *
         * @param name - 标签名称
         */
        removeTag(name2) {
          this.tags = this.tags.filter((item) => {
            const itemName = item.split("=")[0];
            return itemName !== name2;
          });
        }
        /**
         * Remove first tag whose field name is NAME.
         *
         * @param name - 标签名称
         */
        removeFirstTag(name2) {
          const found = this.tags.findIndex((item) => {
            return item.split("=")[0] === name2;
          });
          if (found !== -1) {
            this.tags.splice(found, 1);
          }
        }
        /**
         * Remove all tags, leaving only the vendor string.
         */
        removeAllTags() {
          this.tags = [];
        }
        /**
         * Add a tag.
         * The FIELD must comply with the Vorbis comment spec, of the form NAME=VALUE. If there is currently no tag block, one will be created.
         *
         * @param field - 标签字段，格式为 NAME=VALUE
         */
        setTag(field) {
          if (field.indexOf("=") === -1) {
            throw new Error(`malformed vorbis comment field "${field}", field contains no '=' character`);
          }
          this.tags.push(field);
        }
        /**
         * Import tags from a string.
         * Each line should be of the form NAME=VALUE.
         *
         * @param tagsString - 标签字符串，每行一个标签
         */
        importTagsFromString(tagsString) {
          const tags = tagsString.split("\n").filter((line) => line.trim());
          tags.forEach((line) => {
            if (line.indexOf("=") === -1) {
              throw new Error(`malformed vorbis comment "${line}", contains no '=' character`);
            }
          });
          this.tags = this.tags.concat(tags);
        }
        /**
         * Export tags to a string.
         * Each line will be of the form NAME=VALUE.
         *
         * @returns 标签字符串
         */
        exportTagsToString() {
          return this.tags.join("\n");
        }
        /**
         * Import a picture and store it in a PICTURE metadata block.
         *
         * @param picture - 图片数据
         */
        importPictureFromBuffer(picture) {
          let pictureBuffer;
          if (picture instanceof BrowserBuffer) {
            pictureBuffer = picture;
          } else if (picture instanceof Uint8Array) {
            pictureBuffer = new BrowserBuffer(picture);
          } else if (picture instanceof ArrayBuffer) {
            pictureBuffer = new BrowserBuffer(picture);
          } else {
            throw new Error("Picture must be Uint8Array, ArrayBuffer, or BrowserBuffer");
          }
          const pictureArray = pictureBuffer.toUint8Array();
          const { mime } = detectImageType(pictureArray);
          if (mime !== "image/jpeg" && mime !== "image/png") {
            throw new Error(
              `only support image/jpeg and image/png picture temporarily, current import ${mime}`
            );
          }
          const dimensions = getImageSize(pictureArray);
          const spec = this.buildSpecification({
            mime,
            width: dimensions.width,
            height: dimensions.height
          });
          this.pictures.push(this.buildPictureBlock(pictureBuffer, spec));
          this.picturesSpecs.push(spec);
          this.picturesDatas.push(pictureBuffer);
        }
        /**
         * Import a picture from File or Blob (async).
         *
         * @param file - 图片文件
         * @returns Promise<void>
         */
        async importPictureFromFile(file) {
          const arrayBuffer = await file.arrayBuffer();
          this.importPictureFromBuffer(arrayBuffer);
        }
        /**
         * Export PICTURE block to a Blob.
         *
         * @param index - 图片索引，默认为 0
         * @returns Blob
         */
        exportPictureToBlob(index2 = 0) {
          if (this.picturesDatas.length > index2) {
            const pictureData = this.picturesDatas[index2];
            const spec = this.picturesSpecs[index2];
            return new Blob([pictureData.toArrayBuffer()], { type: spec.mime });
          }
          throw new Error(`Picture index ${index2} does not exist`);
        }
        /**
         * Export PICTURE block to ArrayBuffer.
         *
         * @param index - 图片索引，默认为 0
         * @returns ArrayBuffer
         */
        exportPictureToArrayBuffer(index2 = 0) {
          if (this.picturesDatas.length > index2) {
            return this.picturesDatas[index2].toArrayBuffer();
          }
          throw new Error(`Picture index ${index2} does not exist`);
        }
        /**
         * Remove a picture at the specified index.
         *
         * @param index - 图片索引，默认为 0
         */
        removePicture(index2 = 0) {
          if (this.pictures.length > index2) {
            this.pictures.splice(index2, 1);
            this.picturesSpecs.splice(index2, 1);
            this.picturesDatas.splice(index2, 1);
          } else {
            throw new Error(`Picture index ${index2} does not exist`);
          }
        }
        /**
         * Remove all pictures.
         */
        removeAllPictures() {
          this.pictures = [];
          this.picturesSpecs = [];
          this.picturesDatas = [];
        }
        /**
         * Return all tags.
         */
        getAllTags() {
          return this.tags;
        }
        buildSpecification(spec = {}) {
          const defaults = {
            type: 3,
            mime: "image/jpeg",
            description: "",
            width: 0,
            height: 0,
            depth: 24,
            colors: 0
          };
          return Object.assign(defaults, spec);
        }
        /**
         * Build a picture block.
         *
         * @param picture - 图片数据
         * @param specification - 图片规格
         * @returns BrowserBuffer
         */
        buildPictureBlock(picture, specification) {
          const pictureType = BrowserBuffer.alloc(4);
          const mimeLength = BrowserBuffer.alloc(4);
          const mime = BrowserBuffer.from(specification.mime, "ascii");
          const descriptionLength = BrowserBuffer.alloc(4);
          const description = BrowserBuffer.from(specification.description, "utf8");
          const width = BrowserBuffer.alloc(4);
          const height = BrowserBuffer.alloc(4);
          const depth = BrowserBuffer.alloc(4);
          const colors = BrowserBuffer.alloc(4);
          const pictureLength = BrowserBuffer.alloc(4);
          pictureType.writeUInt32BE(specification.type, 0);
          mimeLength.writeUInt32BE(specification.mime.length, 0);
          descriptionLength.writeUInt32BE(specification.description.length, 0);
          width.writeUInt32BE(specification.width, 0);
          height.writeUInt32BE(specification.height, 0);
          depth.writeUInt32BE(specification.depth, 0);
          colors.writeUInt32BE(specification.colors, 0);
          pictureLength.writeUInt32BE(picture.length, 0);
          return BrowserBuffer.concat([
            pictureType,
            mimeLength,
            mime,
            descriptionLength,
            description,
            width,
            height,
            depth,
            colors,
            pictureLength,
            picture
          ]);
        }
        buildMetadataBlock(type, block, isLast = false) {
          const header = BrowserBuffer.alloc(4);
          if (isLast) {
            type += 128;
          }
          header.writeUIntBE(type, 0, 1);
          header.writeUIntBE(block.length, 1, 3);
          return BrowserBuffer.concat([header, block]);
        }
        buildMetadata() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          const bufferArray = [];
          bufferArray.push(this.buildMetadataBlock(STREAMINFO, this.streamInfo));
          this.blocks.forEach((block) => {
            bufferArray.push(this.buildMetadataBlock(...block));
          });
          bufferArray.push(
            this.buildMetadataBlock(VORBIS_COMMENT, formatVorbisComment(this.vendorString, this.tags))
          );
          this.pictures.forEach((block) => {
            bufferArray.push(this.buildMetadataBlock(PICTURE, block));
          });
          const padding = this.padding || BrowserBuffer.alloc(4);
          bufferArray.push(this.buildMetadataBlock(PADDING, padding, true));
          return bufferArray;
        }
        buildStream() {
          if (!this.buffer) {
            throw new Error("Buffer is not available");
          }
          const metadata = this.buildMetadata();
          return [this.buffer.slice(0, 4), ...metadata, this.buffer.slice(this.framesOffset)];
        }
        /**
         * Save changes and return ArrayBuffer.
         *
         * @returns ArrayBuffer
         */
        save() {
          const stream = this.buildStream();
          const result = BrowserBuffer.concat(stream);
          return result.toArrayBuffer();
        }
        /**
         * Save changes and return Blob.
         *
         * @returns Blob
         */
        saveAsBlob() {
          const arrayBuffer = this.save();
          return new Blob([arrayBuffer], { type: "audio/flac" });
        }
        /**
         * Save changes and return BrowserBuffer.
         *
         * @returns BrowserBuffer
         */
        saveAsBuffer() {
          const stream = this.buildStream();
          return BrowserBuffer.concat(stream);
        }
      }
      const parseTags = (tags) => {
        const result = {};
        tags.forEach((tag) => {
          const equalIndex = tag.indexOf("=");
          if (equalIndex === -1) return;
          const name2 = tag.substring(0, equalIndex).toLowerCase();
          const value = tag.substring(equalIndex + 1);
          if (result[name2]) {
            result[name2] = result[name2] + "\n" + value;
          } else {
            result[name2] = value;
          }
        });
        return result;
      };
      const readAllFlacTag = async (file) => {
        try {
          const metaflac = await Metaflac.fromBlob(file);
          const tags = metaflac.getAllTags();
          const parsedTags = parseTags(tags);
          console.log("解析后的标签:", parsedTags);
          return parsedTags;
        } catch (error) {
          console.error("读取 FLAC 标签失败:", error);
          return {};
        }
      };
      const readFlacTag = async (file, tagName) => {
        try {
          const metaflac = await Metaflac.fromBlob(file);
          const tagString = metaflac.getTag(tagName.toUpperCase());
          if (!tagString) {
            return void 0;
          }
          const lines = tagString.split("\n");
          if (lines.length > 0) {
            const equalIndex = lines[0].indexOf("=");
            if (equalIndex !== -1) {
              return lines[0].substring(equalIndex + 1);
            }
          }
          return void 0;
        } catch (error) {
          console.error(`读取 FLAC 标签 ${tagName} 失败:`, error);
          return void 0;
        }
      };
      const writeFlacTag = async (file, tagName, tagValue) => {
        try {
          const metaflac = await Metaflac.fromBlob(file);
          metaflac.removeTag(tagName.toUpperCase());
          metaflac.setTag(`${tagName.toUpperCase()}=${tagValue}`);
          const newBlob = metaflac.saveAsBlob();
          console.log("给 FLAC 写标签成功");
          return newBlob;
        } catch (error) {
          console.error("给 FLAC 写标签失败:", error);
          throw new Error("给 FLAC 写标签失败");
        }
      };
      const readFlacPictures = async (file) => {
        try {
          const metaflac = await Metaflac.fromBlob(file);
          const pictures = metaflac.getPicturesSpecs?.() || [];
          return pictures.map((_, index2) => metaflac.exportPictureToBlob(index2));
        } catch (error) {
          console.error("读取 FLAC 封面图片失败:", error);
          return [];
        }
      };
      const embedFlacPicture = async (file, picture) => {
        try {
          const metaflac = await Metaflac.fromBlob(file);
          await metaflac.importPictureFromFile(picture);
          const newBlob = metaflac.saveAsBlob();
          console.log("给 FLAC 嵌入图片成功");
          return newBlob;
        } catch (error) {
          console.error("给 FLAC 嵌入图片失败:", error);
          return file;
        }
      };
      const writeFlacTagAndPicture = async (file, tagName, tagValue, picture) => {
        try {
          const metaflac = await Metaflac.fromBlob(file);
          console.log("metaflac", metaflac, metaflac.getAllTags());
          if (tagName && tagValue) {
            metaflac.removeTag(tagName.toUpperCase());
            metaflac.setTag(`${tagName.toUpperCase()}=${tagValue}`);
          }
          if (picture) {
            await metaflac.importPictureFromFile(picture);
          }
          const outputFile = metaflac.saveAsBlob();
          return outputFile || file;
        } catch (error) {
          console.error("同时写入歌词和封面失败:", error);
          return file;
        }
      };
      const getFileBlob = async (url) => {
        const response = await fetch(url);
        const blob = await response.blob();
        return { blob, response };
      };
      const downloadAsJson = (data, filename, options = {}) => {
        try {
          const { space = 2, timestamp = false } = options;
          const jsonString = JSON.stringify(data, null, space);
          const blob = new Blob([jsonString], { type: "application/json" });
          const blobUrl = window.URL.createObjectURL(blob);
          let finalFilename = filename;
          if (timestamp) {
            const date = /* @__PURE__ */ new Date();
            const timeString = `${date.getFullYear()}${String(date.getMonth() + 1).padStart(2, "0")}${String(
        date.getDate()
      ).padStart(2, "0")}_${String(date.getHours()).padStart(2, "0")}${String(
        date.getMinutes()
      ).padStart(2, "0")}${String(date.getSeconds()).padStart(2, "0")}`;
            finalFilename = `${filename}_${timeString}`;
          }
          const a = document.createElement("a");
          a.href = blobUrl;
          a.download = `${finalFilename}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          window.URL.revokeObjectURL(blobUrl);
          return true;
        } catch (error) {
          console.error("JSON数据下载失败:", error);
          return false;
        }
      };
      const downloadAsLRC = (lrcContent, filename, options = {}) => {
        try {
          const { timestamp = false } = options;
          let finalFilename = filename;
          if (timestamp) {
            const now = /* @__PURE__ */ new Date();
            const ts = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, "0")}${String(
        now.getDate()
      ).padStart(2, "0")}_${String(now.getHours()).padStart(2, "0")}${String(
        now.getMinutes()
      ).padStart(2, "0")}${String(now.getSeconds()).padStart(2, "0")}`;
            finalFilename = `${filename}_${ts}`;
          }
          const blob = new Blob([lrcContent], { type: "text/plain" });
          const blobUrl = window.URL.createObjectURL(blob);
          downloadFileWithBlob(blob, `${finalFilename}.lrc`);
          window.URL.revokeObjectURL(blobUrl);
          return true;
        } catch (error) {
          console.error("LRC歌词下载失败:", error);
          return false;
        }
      };
      const downloadFileWithBlob = (file, name2) => {
        const blobUrl = window.URL.createObjectURL(file);
        const a = document.createElement("a");
        a.href = blobUrl;
        a.download = name2;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(blobUrl);
      };
      const audio = new Audio();
      const usePlayMusic = () => {
        const { downloadConfig } = useConfig();
        const { quality: downloadQuality, downloadLyric, embedLyricCover } = downloadConfig;
        const [currentMid, setCurrentMid] = useState("");
        const [isPlaying, setIsPlaying] = useState();
        const [currentTime, setCurrentTime] = useState(0);
        const [duration, setDuration] = useState(0);
        const urlMap = useRef({});
        const songInfoMap = useRef({});
        const getSongInfo$1 = async (mid) => {
          if (songInfoMap.current[mid]) {
            return songInfoMap.current[mid];
          }
          const res = await getSongInfo(mid);
          const songInfo = res.track_info;
          songInfoMap.current[mid] = songInfo;
          return songInfo;
        };
        const getUrl = async (mid, quality = downloadQuality) => {
          const key = mid + quality;
          if (urlMap.current[key]) {
            return urlMap.current[key];
          }
          const res = await getSongPlayUrl(mid, { quality });
          const url = res[mid]?.url || "";
          if (!url) throw new Error("获取歌曲播放地址失败");
          urlMap.current[key] = url;
          console.log("url", url);
          return url;
        };
        const getLyric = async (mid) => {
          const res = await getSongLyric(mid);
          return res;
        };
        const play = async (mid, quality = downloadQuality) => {
          try {
            if (mid === currentMid) {
              audio.play();
              return;
            }
            const url = await getUrl(mid, quality);
            audio.src = url;
            audio.play();
            setCurrentMid(mid);
            return new Promise((resolve) => {
              audio.onended = () => {
                resolve(true);
                setIsPlaying(void 0);
              };
            });
          } catch (error) {
            console.log("error", error);
          } finally {
            setIsPlaying(mid);
          }
        };
        const playList = async (midList) => {
          for (const mid of midList) {
            await play(mid);
          }
        };
        const download = async (mid, quality = downloadQuality) => {
          try {
            const songInfo = await getSongInfo$1(mid);
            const { name: name2, album: { mid: albumMid } = {} } = songInfo;
            const url = await getUrl(mid, quality);
            console.log(`当前下载歌曲${name2},音质为${quality},链接为${url}`);
            const finalExt = url.split("?")[0].split(".").pop();
            const { blob } = await getFileBlob(url.replace("http://", "https://"));
            let outputFile = blob;
            if (songInfo) {
              const { name: name3, album: { name: albumName }, singer } = songInfo;
              if (name3) {
                outputFile = await writeFlacTag(outputFile, FlacTag.标题, name3);
              }
              if (albumName) {
                outputFile = await writeFlacTag(outputFile, FlacTag.专辑, albumName);
              }
              if (singer) {
                outputFile = await writeFlacTag(outputFile, FlacTag.艺术家, singer.map((item) => item.name).join(","));
              }
            }
            let lyric = "";
            try {
              lyric = await getLyric(mid);
              console.log(`获取到歌词《${name2}》`, lyric);
            } catch (error) {
              console.log(`获取歌词失败《${name2}》`, error);
            }
            let coverBlob;
            if (albumMid) {
              const cover = getAlbumPicUrl(albumMid);
              const { blob: blob2 } = await getFileBlob(cover.replace("http://", "https://"));
              coverBlob = blob2;
            }
            if (embedLyricCover) {
              switch (finalExt) {
                case "flac":
                  outputFile = await writeFlacTagAndPicture(blob, "lyrics", lyric, coverBlob);
                  break;
                default:
                  console.log("当前格式不支持");
                  break;
              }
            }
            if (downloadLyric) {
              downloadAsLRC(lyric, name2);
            }
            downloadFileWithBlob(outputFile, `${name2}.${finalExt}`);
          } catch (error) {
            console.log("error", error);
          }
        };
        const convertToNeteaseMusic = async (mid, options) => {
          const { quality = downloadQuality, onChange } = options || {};
          const loadingKey = "convert-to-netease-music" + mid;
          const msgLoading2 = (msg) => {
            message$1.loading({
              key: loadingKey,
              content: msg,
              duration: 0
            });
          };
          const log2 = (msg, ...rest) => {
            console.log(msg, ...rest);
            onChange?.(msg);
            msgLoading2(msg);
          };
          try {
            log2(`开始获取歌曲信息：${mid}`);
            const songInfo = await getSongInfo$1(mid);
            const { name: name2, album: { mid: albumMid } = {} } = songInfo;
            log2(`获取到歌曲信息：${name2}`, songInfo);
            const url = await getUrl(mid, quality);
            log2(`获取到歌曲《${name2}》播放地址`, url);
            const finalExt = url.split("?")[0].split(".").pop();
            log2(`开始下载歌曲《${name2}》`, url);
            const { blob } = await getFileBlob(url.replace("http://", "https://"));
            let outputFile = blob;
            if (songInfo) {
              const { name: name3, album: { name: albumName }, singer } = songInfo;
              if (name3) {
                outputFile = await writeFlacTag(outputFile, FlacTag.标题, name3);
              }
              if (albumName) {
                outputFile = await writeFlacTag(outputFile, FlacTag.专辑, albumName);
              }
              if (singer) {
                outputFile = await writeFlacTag(outputFile, FlacTag.艺术家, singer.map((item) => item.name).join(","));
              }
              log2(`写入歌曲信息到文件《${name3}》`, { name: name3, albumName, singer });
            }
            if (embedLyricCover) {
              log2(`开始写入歌词和封面《${name2}》`);
              let lyric = "";
              try {
                lyric = await getLyric(mid);
                log2(`获取到歌词《${name2}》`, lyric);
              } catch (error) {
                log2(`获取歌词失败《${name2}》`, error);
              }
              let coverBlob;
              if (albumMid) {
                const cover = getAlbumPicUrl(albumMid);
                const { blob: blob2 } = await getFileBlob(cover.replace("http://", "https://"));
                coverBlob = blob2;
                log2(`获取到封面《${name2}》`, coverBlob);
              }
              switch (finalExt) {
                case "flac":
                  outputFile = await writeFlacTagAndPicture(blob, "lyrics", lyric, coverBlob);
                  log2(`写入歌词和封面成功《${name2}》`, outputFile);
                  break;
                default:
                  log2("当前格式不支持嵌入歌词和封面");
                  break;
              }
            }
            log2(`开始转存网易云《${name2}》`, outputFile);
            const res = await uploadLocalSong(new File([outputFile], `${name2}.${finalExt}`));
            log2(`转存网易云成功《${name2}》`, res);
          } catch (error) {
            log2(`转存网易云失败《${name}》`, error);
          } finally {
            message$1.destroy(loadingKey);
          }
        };
        const pause = () => {
          audio.pause();
          setIsPlaying(void 0);
        };
        const stop = () => {
          audio.pause();
          audio.currentTime = 0;
          setIsPlaying(void 0);
        };
        useEffect(() => {
          audio.onloadedmetadata = () => {
            setDuration(audio.duration);
          };
          audio.onpause = () => {
            setIsPlaying(void 0);
          };
        }, [currentMid]);
        return {
          isPlaying,
          currentTime,
          duration,
          audio,
          play,
          pause,
          stop,
          download,
          playList,
          getUrl,
          getLyric,
          getSongInfo: getSongInfo$1,
          convertToNeteaseMusic
        };
      };
      const useGetAlbumDetail = () => {
        const [currentMid, setCurrentMid] = useState("");
        const [albumInfo, setAlbumInfo] = useState();
        const [isLoading, setIsLoading] = useState(false);
        const albumInfoMap = useRef({});
        const { downloadConfig, functionConfig } = useConfig();
        const { quality: downloadQuality } = downloadConfig;
        const { uploadConcurrency } = functionConfig;
        const { play, getUrl, download, getLyric } = usePlayMusic();
        const getAlbumDetail = async (mid) => {
          try {
            setIsLoading(true);
            if (albumInfoMap.current[mid]) {
              return albumInfoMap.current[mid];
            }
            const res = await getAlbumInfo(mid);
            console.log("专辑详情", res);
            albumInfoMap.current[mid] = res;
            setAlbumInfo(res);
            return res;
          } catch (error) {
            console.error("获取专辑详情失败:", error);
          } finally {
            setIsLoading(false);
          }
        };
        const getAlbumSongList = async (mid) => {
          try {
            setIsLoading(true);
            const res = await getAlbumDetail(mid);
            return res?.list;
          } catch (error) {
            console.error("获取专辑歌曲列表失败:", error);
          } finally {
            setIsLoading(false);
          }
        };
        const getAlbumSongUrl = async (mid) => {
          const res = await getAlbumSongList(mid);
          const ids = res?.map((item) => {
            return {
              id: item.songmid,
              name: item.songname,
              file: item
            };
          });
          const promiseArr = ids?.map((item) => async () => {
            const qualityList = getFileQualityList(item.file);
            const finalQuality = qualityList.includes(downloadQuality) ? downloadQuality : qualityList[0];
            const url = await getUrl(item.id, finalQuality);
            return {
              ...item,
              url,
              quality: finalQuality
            };
          });
          const urls = await promiseLimit(promiseArr, 6);
          console.log("专辑歌曲播放地址:", urls);
          return urls;
        };
        const downloadAlbumSong = async (mid, options) => {
          try {
            const { onChange } = options || {};
            const albumSongList = await getAlbumSongList(mid);
            console.log("准备下载专辑歌曲:", albumSongList);
            let index2 = 1;
            const successList = [];
            const errorList = [];
            const promiseArr = albumSongList?.map((item) => async () => {
              try {
                const { songmid, songname } = item;
                console.log(`正在下载: songmid=${songmid}, songname=${songname}`);
                await download(songmid);
                console.log(`第${index2}首歌曲《${songname}》下载完成！`);
                successList.push(item);
                index2++;
                onChange?.({
                  songList: albumSongList,
                  index: index2
                });
              } catch (error) {
                errorList.push(item);
              }
            });
            const songList = await promiseLimit(promiseArr, uploadConcurrency);
            return {
              successList,
              errorList,
              songList,
              total: albumSongList?.length
            };
          } catch (error) {
            console.error("下载专辑歌曲失败:", error);
          }
        };
        const getDownLoadJson = async (mid) => {
          const albumDetail = await getAlbumDetail(mid);
          const { name: name2, list } = albumDetail || {};
          const promiseArr = list?.map((item) => async () => {
            const lrcContent = await getLyric(item.songmid);
            const qualityList = getFileQualityList(item);
            const finalQuality = qualityList.includes(downloadQuality) ? downloadQuality : qualityList[0];
            const url = await getUrl(item.songmid, finalQuality);
            return {
              songName: item.songname,
              url,
              lrcContent
            };
          });
          const songList = await promiseLimit(promiseArr, uploadConcurrency);
          return {
            albumName: name2,
            albumCover: getAlbumPicUrl(mid),
            list: songList
          };
        };
        const playAlbum = async (mid) => {
          const songList = await getAlbumSongList(mid);
          console.log("songList", songList);
          if (!songList?.length) return;
          for (const item of songList) {
            console.log("当前正在播放", item.songname);
            await play(item.songmid);
          }
        };
        return {
          albumInfo,
          isLoading,
          getAlbumDetail,
          getAlbumSongList,
          playAlbum,
          getAlbumSongUrl,
          downloadAlbumSong,
          getDownLoadJson
        };
      };
      const useGetData = (api, params, options) => {
        const {
          // 监控项
          monitors,
          // 终止函数，什么条件下不执行
          returnFunction,
          // 初始值
          initialValue = {},
          // 拿到数据后执行的函数
          callback
        } = options || {};
        const [data, setData] = useState(initialValue);
        const [loading2, setLoading] = useState(false);
        const getData = async () => {
          try {
            setLoading(true);
            const res = await api(params);
            setData(res || {});
            callback && callback(res || {});
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        useEffect(() => {
          if (returnFunction && returnFunction()) return;
          getData();
        }, monitors || []);
        return {
          /** 数据 */
          data,
          /** 手动更改数据 */
          setData,
          /** 是否加载中 */
          loading: loading2,
          /** 手动获取数据 */
          getData
        };
      };
      const getSongListCategory = async () => {
        const params = {
          format: "json",
          outCharset: "utf-8"
        };
        const res = await qqMusicRequest(
          `/splcloud/fcgi-bin/fcg_get_diss_tag_conf.fcg?${new URLSearchParams(params)}`,
          {}
        );
        if (res.code === 0) {
          return res.data?.categories;
        }
        throw new Error("获取歌单分类列表失败");
      };
      const getSongList = async (options = {}) => {
        const { limit = 20, page = 0, sortId = 5, categoryId = 1e7 } = options;
        const sin = page * limit;
        const ein = limit * (page + 1) - 1;
        const params = {
          categoryId,
          sortId,
          sin,
          ein,
          format: "json",
          outCharset: "utf-8",
          picmid: 1
        };
        const res = await qqMusicRequest(
          `/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg?${new URLSearchParams(params).toString()}`,
          {}
        );
        if (res.code === 0) {
          return res.data;
        }
        throw new Error("获取歌单列表失败");
      };
      const getSongListDetail = async (disstid) => {
        const disstidStr = Array.isArray(disstid) ? disstid.join(",") : disstid;
        const params = {
          disstid: disstidStr,
          format: "json",
          outCharset: "utf-8",
          type: "1",
          json: "1",
          utf8: "1",
          onlysong: "0",
          new_format: "1"
        };
        const res = await qqMusicRequest(
          `/qzone/fcg-bin/fcg_ucc_getcdinfo_byids_cp.fcg?${new URLSearchParams(params).toString()}`,
          {}
        );
        if (res.code === 0) {
          return res.cdlist;
        }
        throw new Error("获取歌单详情失败");
      };
      const useGetSonglistDetail = () => {
        const [playlistInfo, setPlaylistInfo] = useState();
        const [isLoading, setIsLoading] = useState(false);
        const playlistInfoMap = useRef({});
        const { downloadConfig, functionConfig } = useConfig();
        const { quality: downloadQuality } = downloadConfig;
        const { uploadConcurrency } = functionConfig;
        const { play, getUrl, download, getLyric, convertToNeteaseMusic } = usePlayMusic();
        const getPlaylistDetail = async (dissid) => {
          try {
            setIsLoading(true);
            if (playlistInfoMap.current[dissid]) {
              return playlistInfoMap.current[dissid];
            }
            const res = await getSongListDetail(dissid);
            console.log("歌单详情:", res);
            const playlistDetail = Array.isArray(res) ? res[0] : res;
            playlistInfoMap.current[dissid] = playlistDetail;
            return playlistDetail;
          } catch (error) {
            console.error("获取歌单详情失败:", error);
          } finally {
            setIsLoading(false);
          }
        };
        const getPlaylistSongList = async (dissid) => {
          try {
            setIsLoading(true);
            const res = await getPlaylistDetail(dissid);
            return res?.songlist;
          } catch (error) {
            console.error("获取歌单歌曲列表失败:", error);
          } finally {
            setIsLoading(false);
          }
        };
        const getPlaylistSongUrl = async (dissid) => {
          const res = await getPlaylistSongList(dissid);
          const ids = res?.map((item) => {
            return {
              id: item.mid,
              name: item.name,
              file: item.file
            };
          });
          const promiseArr = ids?.map((item) => async () => {
            const qualityList = getFile_qualityList(item.file);
            const finalQuality = qualityList.includes(downloadQuality) ? downloadQuality : qualityList[0];
            const url = await getUrl(item.id, finalQuality);
            return {
              ...item,
              url,
              quality: finalQuality
            };
          });
          const urls = await promiseLimit(promiseArr, 6);
          console.log("歌单歌曲播放地址:", urls);
          return urls;
        };
        const downloadPlaylistSong = async (dissid) => {
          try {
            const songList = await getPlaylistSongList(dissid);
            console.log("准备下载歌单歌曲:", songList);
            for (const item of songList || []) {
              const { mid, name: name2, file } = item;
              console.log(`正在下载: mid=${mid}, name=${name2}`);
              await download(mid);
            }
          } catch (error) {
            console.error("下载歌单歌曲失败:", error);
          }
        };
        const convertToNeteaseMusicPlaylistSong = async (dissid) => {
          const loadingKey = "convert-to-netease-music-playlist-song";
          message$1.loading({
            key: loadingKey,
            content: `正在转存歌单歌曲...`,
            duration: 0
          });
          try {
            const songList = await getPlaylistSongList(dissid);
            const task = songList?.map((item) => async () => {
              const { mid, name: name2 } = item;
              console.log(`正在转存: mid=${mid}, name=${name2}`);
              await convertToNeteaseMusic(mid, {
                onChange: (msg) => {
                  message$1.loading({
                    key: loadingKey,
                    content: msg,
                    duration: 0
                  });
                }
              });
            });
            await promiseLimit(task, uploadConcurrency);
            message$1.success({
              key: loadingKey,
              content: `转存歌单歌曲成功`,
              duration: 0
            });
          } catch (error) {
            console.log("error", error);
          }
        };
        const getPlaylistDownloadJson = async (dissid) => {
          const playlistDetail = await getPlaylistDetail(dissid);
          const { dissname, songlist } = playlistDetail || {};
          const promiseArr = songlist?.map((item) => async () => {
            const lrcContent = await getLyric(item.mid);
            const qualityList = getFile_qualityList(item.file);
            const finalQuality = qualityList.includes(downloadQuality) ? downloadQuality : qualityList[0];
            const url = await getUrl(item.mid, finalQuality);
            return {
              songName: item.name,
              url,
              lrcContent
            };
          });
          const songList = await promiseLimit(promiseArr, 6);
          return {
            playlistName: dissname,
            playlistCover: playlistDetail?.pic_mid ? `https://y.gtimg.cn/music/photo_new/T002R300x300M000${playlistDetail.pic_mid}.jpg` : "",
            songList
          };
        };
        const playPlaylist = async (dissid) => {
          const songList = await getPlaylistSongList(dissid);
          console.log("歌单歌曲列表:", songList);
          if (!songList?.length) return;
          for (const item of songList) {
            console.log("当前正在播放", item.name);
            await play(item.mid);
          }
        };
        return {
          playlistInfo,
          isLoading,
          getPlaylistDetail,
          getPlaylistSongList,
          playPlaylist,
          getPlaylistSongUrl,
          downloadPlaylistSong,
          getPlaylistDownloadJson,
          convertToNeteaseMusicPlaylistSong
        };
      };
      const useVisible = (props = {}, ref) => {
        const {
          onOpen = NOOP,
          onClose = NOOP,
          onReset = NOOP,
          resetOnOpen = true,
          resetOnClose = false
        } = props;
        const [visible, setVisible] = useState(false);
        const open = (params) => {
          resetOnOpen && reset();
          setVisible(true);
          onOpen(params);
        };
        const close = () => {
          resetOnClose && reset();
          setVisible(false);
          onClose();
        };
        const reset = () => {
          setVisible(false);
          onReset();
        };
        const resolve = useRef(null);
        const reject = useRef(null);
        const submit = () => {
          return new Promise((_resolve, _reject) => {
            resolve.current = _resolve;
            reject.current = _reject;
          });
        };
        ref && useImperativeHandle(ref, () => ({
          open,
          close,
          reset,
          submit,
          resolve,
          reject
        }));
        return {
          visible,
          open,
          close,
          reset,
          submit,
          resolve,
          reject
        };
      };
      const NOOP = () => {
      };
      const getSingerInfo = async (singermid) => {
        const params = {
          singermid,
          format: "xml",
          outCharset: "utf-8",
          utf8: "1",
          r: dayjs().valueOf() + ""
        };
        return qqMusicRequest(
          `/splcloud/fcgi-bin/fcg_get_singer_desc.fcg?${new URLSearchParams(params).toString()}`,
          {
            method: "GET",
            responseType: "text"
            // 改为 text 因为返回的是 XML
          }
        );
      };
      const getSingerAlbum = async (singermid, options = {}) => {
        const { begin = 0, num = 80 } = options;
        const params = {
          format: "json",
          singermid,
          data: JSON.stringify({
            comm: {
              ct: 24,
              cv: 0
            },
            singer: {
              method: "GetAlbumList",
              param: {
                sort: 5,
                singermid,
                begin,
                num
              },
              module: "music.musichallAlbum.AlbumListServer"
            }
          })
        };
        const res = await qqMusicRequest(
          `/cgi-bin/musicu.fcg?${new URLSearchParams(params).toString()}`,
          {},
          "u"
        );
        if (res.code === 0) {
          return res.singer?.data;
        }
        throw new Error("获取歌手专辑失败");
      };
      const getSingerAllAlbum = async (singermid) => {
        const allAlbum = [];
        let begin = 0;
        const num = 80;
        let hasMore = true;
        while (hasMore) {
          const res = await getSingerAlbum(singermid, { begin, num });
          if (res) {
            allAlbum.push(...res.albumList);
            hasMore = allAlbum.length < res.total;
          } else {
            hasMore = false;
          }
          begin += num;
        }
        return allAlbum;
      };
      const getSingerList = async (options) => {
        const { area = -100, sex = -100, genre = -100, cur_page = 1 } = options;
        const params = {
          format: "json",
          data: JSON.stringify({
            comm: {
              ct: 24,
              cv: 0
            },
            singerList: {
              module: "Music.SingerListServer",
              method: "get_singer_list",
              param: {
                area: +area,
                sex: +sex,
                genre: +genre,
                index: -100,
                sin: (cur_page - 1) * 80,
                num: 80,
                cur_page
              }
            }
          })
        };
        const res = await qqMusicRequest(
          `/cgi-bin/musicu.fcg?${new URLSearchParams(params).toString()}`,
          {},
          "u"
        );
        if (res.code === 0) {
          return res.singerList?.data;
        }
        throw new Error("获取歌手列表失败");
      };
      const getSingerFollowCount = async (singermid) => {
        const params = {
          singermid,
          format: "json",
          outCharset: "utf-8",
          utf8: "1",
          rnd: dayjs().valueOf() + ""
        };
        return qqMusicRequest(
          `/rsc/fcgi-bin/fcg_order_singer_getnum.fcg?${new URLSearchParams(params).toString()}`,
          {},
          "c"
        );
      };
      const getSingerHotSong = async (singermid, options = {}) => {
        const { sin = 0, num = 60 } = options;
        const params = {
          singermid,
          format: "json",
          data: JSON.stringify({
            comm: {
              ct: 24,
              cv: 0
            },
            singer: {
              method: "get_singer_detail_info",
              param: {
                sort: 5,
                singermid,
                sin,
                num
              },
              module: "music.web_singer_info_svr"
            }
          })
        };
        const res = await qqMusicRequest(
          `/cgi-bin/musicu.fcg?${new URLSearchParams(params).toString()}`,
          {},
          "u"
        );
        if (res.code === 0) {
          return res.singer?.data;
        }
        throw new Error("获取歌手热门歌曲失败");
      };
      const getSingerAllHotSong = async (singermid, options) => {
        const { onChange } = options || {};
        let sin = 0;
        const num = 60;
        let hasMore = true;
        const result = {
          code: 200,
          total: 0,
          totalSong: 0,
          totalAlbum: 0,
          totalMV: 0,
          songList: [],
          singerBrief: "",
          singerInfo: {},
          extras: []
        };
        while (hasMore) {
          const res = await getSingerHotSong(singermid, { sin, num });
          if (res) {
            Object.assign(result, {
              total: res.total_song,
              singerBrief: res.singer_brief,
              singerInfo: res.singer_info,
              totalSong: res.total_song,
              totalAlbum: res.total_album,
              totalMV: res.total_mv,
              songList: [...result.songList, ...res.songlist],
              extras: [...result.extras, ...res.extras]
            });
            onChange?.(result);
            hasMore = result.songList.length < res.total_song;
          } else {
            hasMore = false;
          }
          sin += num;
        }
        console.log("result", result);
        return result;
      };
      const getSimilarSinger = async (singer_mid, options = {}) => {
        const { start = 0, num = 5 } = options;
        const params = {
          singer_mid,
          format: "json",
          outCharset: "utf-8",
          utf8: "1",
          start: start + "",
          num: num + ""
        };
        const res = await qqMusicRequest(
          `/v8/fcg-bin/fcg_v8_simsinger.fcg?${new URLSearchParams(params).toString()}`,
          {}
        );
        return res.singers;
      };
      const getSingerPic = (singermid, options) => {
        const { size = "800x800" } = {};
        return `https://y.qq.com/music/photo_new/T001R${size}M000${singermid}.jpg?max_age=2592000`;
      };
      const copy = async (text, options = {}) => {
        try {
          if (navigator.clipboard && window.isSecureContext) {
            if (options.html) {
              const type = "text/html";
              const blob = new Blob([text], { type });
              const data = [new ClipboardItem({ [type]: blob })];
              await navigator.clipboard.write(data);
            } else {
              await navigator.clipboard.writeText(text);
            }
          } else {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.cssText = "position: fixed; top: -9999px; left: -9999px";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
              document.execCommand("copy");
            } catch (err2) {
              throw new Error("复制失败，请检查浏览器权限设置");
            } finally {
              document.body.removeChild(textArea);
            }
          }
        } catch (err2) {
          throw new Error(
            err2 instanceof Error ? err2.message : "复制失败，请重试"
          );
        }
      };
      const styles$a = {
        "copy-text": "_copy-text_1att4_1",
        "copy-btn": "_copy-btn_1att4_12"
      };
      var classnames = { exports: {} };
      /*!
      	Copyright (c) 2018 Jed Watson.
      	Licensed under the MIT License (MIT), see
      	http://jedwatson.github.io/classnames
      */
      var hasRequiredClassnames;
      function requireClassnames() {
        if (hasRequiredClassnames) return classnames.exports;
        hasRequiredClassnames = 1;
        (function(module) {
          (function() {
            var hasOwn = {}.hasOwnProperty;
            function classNames2() {
              var classes = "";
              for (var i = 0; i < arguments.length; i++) {
                var arg = arguments[i];
                if (arg) {
                  classes = appendClass(classes, parseValue(arg));
                }
              }
              return classes;
            }
            function parseValue(arg) {
              if (typeof arg === "string" || typeof arg === "number") {
                return arg;
              }
              if (typeof arg !== "object") {
                return "";
              }
              if (Array.isArray(arg)) {
                return classNames2.apply(null, arg);
              }
              if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                return arg.toString();
              }
              var classes = "";
              for (var key in arg) {
                if (hasOwn.call(arg, key) && arg[key]) {
                  classes = appendClass(classes, key);
                }
              }
              return classes;
            }
            function appendClass(value, newClass) {
              if (!newClass) {
                return value;
              }
              if (value) {
                return value + " " + newClass;
              }
              return value + newClass;
            }
            if (module.exports) {
              classNames2.default = classNames2;
              module.exports = classNames2;
            } else {
              window.classNames = classNames2;
            }
          })();
        })(classnames);
        return classnames.exports;
      }
      var classnamesExports = requireClassnames();
      const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
      const styles$9 = {
        "text-overflow-show-tips-container": "_text-overflow-show-tips-container_btabq_1"
      };
      function TextOverflowShowTips({
        text,
        tooltipProps,
        className,
        ...restProps
      }) {
        const containerRef = useRef(null);
        const { width: containerWidth } = useSize(containerRef) || {};
        const isTooLong = useMemo(() => {
          if (containerWidth) {
            const textWidth = getTextWidth(text);
            return containerWidth < textWidth;
          }
          return false;
        }, [text, containerWidth]);
        const containerStyle = {
          maxWidth: "100%",
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap"
        };
        return isTooLong ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: text, ...tooltipProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            ...restProps,
            className: classNames(styles$9["text-overflow-show-tips-container"], className),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: containerRef, style: containerStyle, children: text })
          }
        ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: containerRef, style: containerStyle, ...restProps, className, children: text });
      }
      function getTextWidth(text, font = "14px Arial") {
        const span = document.createElement("span");
        span.style.visibility = "hidden";
        span.style.whiteSpace = "nowrap";
        span.style.font = font;
        span.style.position = "absolute";
        span.style.top = "-9999px";
        span.style.left = "-9999px";
        span.innerText = text;
        document.body.appendChild(span);
        const width = span.offsetWidth;
        document.body.removeChild(span);
        return width;
      }
      function CopyText(props) {
        const { text, className, ...rest } = props;
        const handleCopy = () => {
          copy(text);
          msgSuccess("复制成功");
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classNames(styles$a["copy-text"], className), ...rest, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextOverflowShowTips,
            {
              text: text + "",
              tooltipProps: {
                getPopupContainer: (node) => {
                  return document.body;
                }
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "link",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CopyOutlined, {}),
              onClick: handleCopy,
              className: styles$a["copy-btn"]
            }
          )
        ] });
      }
      function MyButton(props) {
        const { loading: loading2, onClick, ...rest } = props;
        const [_loading, setLoading] = useState(loading2);
        const handleClick = async (...args) => {
          try {
            setLoading(true);
            await onClick?.(...args);
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        useEffect(() => {
          setLoading(loading2);
        }, [loading2]);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { ...rest, onClick: handleClick, loading: _loading });
      }
      const Styles$1 = {
        "select-search": "_select-search_19wb1_1"
      };
      const { Group } = Input;
      const defaultSearchParams$3 = {
        prop: "xm",
        value: ""
      };
      function SelectSearch(props) {
        const {
          value,
          onChange,
          defaultValue,
          SearchSelectOptions,
          selectProps,
          inputProps,
          width = 300,
          selectWidth = 80,
          inputWidth = 180
        } = props;
        const [searchParams, setSearchParams] = useState(() => {
          if (value?.prop == void 0) return defaultValue || defaultSearchParams$3;
          return {
            ...defaultValue || defaultSearchParams$3,
            ...value
          };
        });
        useEffect(() => {
          if (value?.prop == void 0) return;
          if (typeof value !== "object") return console.warn("value类型错误,必须为对象");
          setSearchParams({
            ...value
          });
        }, [value]);
        const handleSearchSelectChange = (value2) => {
          const newSearchParams = {
            ...searchParams,
            prop: value2
          };
          setSearchParams(newSearchParams);
          onChange?.(newSearchParams, searchParams);
        };
        const handleSearchInputChange = (e) => {
          const value2 = e.target.value;
          const newSearchParams = {
            ...searchParams,
            value: value2
          };
          setSearchParams(newSearchParams);
          onChange?.(newSearchParams, searchParams);
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Group,
          {
            compact: true,
            style: {
              width
            },
            className: Styles$1["select-search"],
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select,
                {
                  options: SearchSelectOptions || defaultSearchSelectOptions,
                  placeholder: "请选择",
                  value: searchParams.prop,
                  onChange: handleSearchSelectChange,
                  style: {
                    width: selectWidth,
                    borderRadius: "6px 0 0 6px"
                  },
                  ...selectProps
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  placeholder: `请输入`,
                  style: { width: inputWidth, height: 32 },
                  value: searchParams.value,
                  onChange: handleSearchInputChange,
                  allowClear: true,
                  ...inputProps
                }
              )
            ]
          }
        );
      }
      const defaultSearchSelectOptions = [
        {
          value: "xh",
          label: "学号"
        },
        {
          value: "xm",
          label: "姓名"
        }
      ];
      const styles$8 = {};
      const { RangePicker: AntRangePicker } = DatePicker;
      const RangePicker = ({
        value,
        onChange,
        format = "YYYY-MM-DD",
        className,
        placeholder = ["开始日期", "结束日期"],
        ...rest
      }) => {
        const toDayjs = (val) => {
          if (!val) return null;
          if (dayjs.isDayjs(val)) return val;
          return dayjs(val);
        };
        const rangeValue = Array.isArray(value) ? [toDayjs(value[0]), toDayjs(value[1])] : null;
        const handleChange = (dates, dateStrings) => {
          console.log("dates", dates);
          console.log("dateStrings", dateStrings);
          if (dates && onChange) {
            onChange(
              dates.map((date) => date ? date.format(format) : ""),
              dateStrings
            );
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          AntRangePicker,
          {
            value: rangeValue,
            onChange: handleChange,
            format,
            className: classNames(styles$8["rangePicker"], className),
            placeholder,
            ...rest
          }
        );
      };
      const filterOption = (inputValue, option) => {
        return option.label.toLowerCase().indexOf(inputValue.toLowerCase()) >= 0;
      };
      const COMPONENT_TYPE_MAP = {
        input: Input,
        select: Select,
        selectSearch: SelectSearch,
        rangePicker: RangePicker,
        treeSelect: TreeSelect
      };
      const defaultComponentProps = {
        input: {
          placeholder: "请输入",
          style: { width: "200px" },
          allowClear: true
        },
        select: {
          placeholder: "请选择",
          style: { width: "200px" },
          allowClear: true,
          maxTagCount: 2,
          showSearch: true,
          filterOption
        },
        selectSearch: {},
        rangePicker: {},
        treeSelect: {
          treeCheckable: true,
          allowClear: true,
          treeExpandAction: "click",
          filterTreeNode: (inputValue, treeNode) => {
            return treeNode.props.title.toLowerCase().indexOf(inputValue.toLowerCase()) >= 0;
          },
          placeholder: "请选择",
          style: {
            width: "200px"
          }
        }
      };
      const { Item: Item$3 } = Form;
      const SearchFormItem = (props) => {
        const { name: name2, type = "input", label = "", inputProps = {}, ...formItemProps } = props;
        const InputComponent = COMPONENT_TYPE_MAP[type];
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Item$3, { name: name2, label, ...formItemProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputComponent, { ...{ ...defaultComponentProps[type], ...inputProps } }) });
      };
      function AdvancedSearch(props) {
        Form.useFormInstance();
        const { params, items = [] } = props;
        const [optionsMap, setOptionsMap] = useState({});
        useEffect(() => {
          const asyncFn = async () => {
            try {
              items.map(async (item) => {
                if (!item.getOptionsApi) return;
                const res = await item.getOptionsApi(params);
                setOptionsMap((prev) => {
                  return {
                    ...prev,
                    [item.name]: res.data
                  };
                });
                item.getOptionsApiAfter?.(res.data);
              });
            } catch (error) {
              console.log("error", error);
            }
          };
          asyncFn();
        }, []);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: items.map((item) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            SearchFormItem,
            {
              name: item.name,
              label: item.label,
              type: item.type,
              inputProps: {
                ...item.inputProps,
                options: optionsMap[item.name] || item.options
              }
            },
            item.name
          );
        }) });
      }
      const Styles = {
        "search-form": "_search-form_10eg9_1"
      };
      const { Item: Item$2 } = Form;
      const SearchForm = (props, ref) => {
        const [formRef] = Form.useForm();
        const {
          options = [],
          advancedOptions = [],
          searchParams = {},
          onSearch = () => {
          },
          loading: loading2 = false,
          keepAdvancedSearchValue = true,
          ...restFormProps
        } = props;
        useEffect(() => {
          !keepAdvancedSearchValue && formRef.resetFields();
          formRef.setFieldsValue(searchParams);
        }, [searchParams]);
        const [optionsMap, setOptionsMap] = useState({});
        useEffect(() => {
          const asyncFn = async () => {
            try {
              options.map(async (item) => {
                if (!item.getOptionsApi || !item.name) return;
                const res = await item.getOptionsApi(searchParams);
                setOptionsMap((prev) => {
                  return {
                    ...prev,
                    [item.name]: res.data
                  };
                });
                item.getOptionsApiAfter?.(res.data);
              });
            } catch (error) {
              console.log("error", error);
            }
          };
          asyncFn();
        }, []);
        const [isAdvancedSearch, setIsAdvancedSearch] = useState(false);
        const handleSearch = () => {
          const values = formRef.getFieldsValue();
          console.log("values", values);
          onSearch(values);
        };
        const handleReset = () => {
          formRef.resetFields();
          handleSearch();
        };
        useImperativeHandle(ref, () => ({
          reset: handleReset,
          search: handleSearch,
          getValues: formRef.getFieldsValue
        }));
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Form,
          {
            layout: "inline",
            form: formRef,
            className: Styles["search-form"],
            ...restFormProps,
            children: [
              options.map((item) => {
                const { getOptionsApi, getOptionsApiAfter, ...rest } = item;
                return /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SearchFormItem,
                  {
                    ...rest,
                    inputProps: {
                      ...item.inputProps,
                      options: optionsMap[item.name] || item.options
                    }
                  },
                  item.name || item.label
                );
              }),
              isAdvancedSearch && /* @__PURE__ */ jsxRuntimeExports.jsx(AdvancedSearch, { params: searchParams, items: advancedOptions }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Item$2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleSearch, shape: "round", loading: loading2, children: "查询" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Item$2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleReset, shape: "round", children: "重置" }) }),
              advancedOptions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Item$2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "link", onClick: () => setIsAdvancedSearch(!isAdvancedSearch), children: isAdvancedSearch ? "关闭" : "高级搜索" }) })
            ]
          }
        );
      };
      const SearchForm$1 = forwardRef(SearchForm);
      const footer$2 = "_footer_e7ura_48";
      const styles$7 = {
        "album-detail-modal": "_album-detail-modal_e7ura_1",
        "modal-header": "_modal-header_e7ura_1",
        "album-basic-info": "_album-basic-info_e7ura_6",
        "album-info": "_album-info_e7ura_11",
        "album-name": "_album-name_e7ura_16",
        "album-meta": "_album-meta_e7ura_19",
        "song-table": "_song-table_e7ura_24",
        "song-name": "_song-name_e7ura_27",
        "artist-item": "_artist-item_e7ura_33",
        "artist-name": "_artist-name_e7ura_37",
        "artist-separator": "_artist-separator_e7ura_41",
        "song-duration": "_song-duration_e7ura_45",
        footer: footer$2,
        "selected-count": "_selected-count_e7ura_55"
      };
      const { Text: Text$4, Title: Title$3 } = Typography;
      const AlbumDetail = forwardRef((_, ref) => {
        const { visible, close } = useVisible(
          {
            onOpen(params) {
              if (params?.albummid) {
                setCurrentMid(params.albummid);
              }
            },
            onReset() {
              setCurrentMid("");
              setInputMid("");
              setSelectedRowKeys([]);
              setSelectedRows([]);
              setList([]);
            }
          },
          ref
        );
        const [currentMid, setCurrentMid] = useState("");
        const [inputMid, setInputMid] = useState("");
        const { downloadConfig } = useConfig();
        const { quality: defaultQuality } = downloadConfig;
        const { getAlbumDetail, getAlbumSongList, isLoading, getDownLoadJson } = useGetAlbumDetail();
        const { play, isPlaying, pause, download, convertToNeteaseMusic } = usePlayMusic();
        const { data: detail, loading: detailLoading } = useGetData(
          getAlbumDetail,
          currentMid,
          {
            initialValue: void 0,
            returnFunction: () => !currentMid || !visible,
            monitors: [currentMid, visible]
          }
        );
        const {
          data: list,
          loading: loading2,
          setData: setList
        } = useGetData(getAlbumSongList, currentMid, {
          initialValue: [],
          returnFunction: () => !currentMid || !visible,
          monitors: [currentMid, visible],
          callback: (data) => {
            console.log("data", data);
          }
        });
        const handleChooseQuality = (record, quality) => {
          setList(
            list?.map((item) => {
              if (item.songmid === record.songmid) {
                return {
                  ...item,
                  quality
                };
              }
              return item;
            }) || []
          );
        };
        const handlePlay = (record) => {
          if (isPlaying) {
            pause();
          } else {
            const { quality } = record;
            const finalQuality = getQuality$3(record, defaultQuality, quality);
            play(record.songmid, finalQuality);
          }
        };
        const [downloading, setDownloading] = useState("");
        const handleDownload = async (record) => {
          try {
            if (downloading === record.songmid) return;
            setDownloading(record.songmid);
            const { quality } = record;
            const finalQuality = getQuality$3(record, defaultQuality, quality);
            await download(record.songmid, finalQuality);
          } catch (error) {
            console.log("error", error);
          } finally {
            setDownloading("");
          }
        };
        const songColumns = [
          {
            title: "歌曲",
            dataIndex: "songname",
            key: "songname",
            width: 300,
            render: (text) => /* @__PURE__ */ jsxRuntimeExports.jsx(Text$4, { className: styles$7["song-name"], title: text, children: text })
          },
          {
            title: "歌手",
            dataIndex: "singer",
            key: "singer",
            width: 240,
            render: (singers = []) => /* @__PURE__ */ jsxRuntimeExports.jsx(Space, { size: "small", wrap: true, children: singers.length > 0 ? singers.map((s, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$7["artist-item"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { size: 30, style: { marginRight: 4 }, src: getSingerPic(s.mid) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$7["artist-name"], children: s.name }),
              index2 < singers.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$7["artist-separator"], children: "/" })
            ] }, s.mid || index2)) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "-" }) })
          },
          // 音质选择器
          {
            title: "音质",
            key: "quality",
            width: 100,
            align: "center",
            render: (_2, record) => {
              const qualityList = getFileQualityList(record);
              const defaultValue = qualityList.includes(defaultQuality) ? defaultQuality : qualityList[0];
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select,
                {
                  options: qualityList.map((quality) => ({
                    label: quality,
                    value: quality
                  })),
                  defaultValue,
                  style: { width: "100%" },
                  onChange: (value) => {
                    handleChooseQuality(record, value);
                  }
                }
              );
            }
          },
          // 格式
          {
            title: "格式",
            key: "format",
            width: 150,
            align: "center",
            render: (_2, record) => {
              const qualityList = getFileQualityList(record);
              const qualityColorMap = {
                flac: "green",
                ape: "volcano",
                320: "blue",
                m4a: "orange",
                128: "gray"
              };
              const qualityTextMap = {
                flac: "FLAC",
                ape: "APE",
                320: "320k",
                m4a: "M4A",
                128: "128k"
              };
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Space, { wrap: true, children: qualityList.map((quality) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: qualityColorMap[quality], children: qualityTextMap[quality] || quality }, quality)) });
            }
          },
          {
            title: "时长",
            dataIndex: "interval",
            key: "interval",
            width: 100,
            align: "center",
            render: (interval) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Text$4, { className: styles$7["song-duration"], children: [
              Math.floor((interval || 0) / 60),
              ":",
              ((interval || 0) % 60).toString().padStart(2, "0")
            ] })
          },
          {
            title: "操作",
            key: "action",
            width: 200,
            align: "center",
            fixed: "right",
            render: (_2, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "播放", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "link",
                  size: "small",
                  icon: isPlaying === record.songmid ? /* @__PURE__ */ jsxRuntimeExports.jsx(PauseCircleOutlined, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                  onClick: () => handlePlay(record),
                  children: "播放"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "下载", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}),
                  loading: downloading === record.songmid,
                  onClick: () => handleDownload(record),
                  children: "下载"
                }
              ) })
            ] })
          }
        ];
        const [selectedRowKeys, setSelectedRowKeys] = useState([]);
        const [selectedRows, setSelectedRows] = useState([]);
        const rowSelection = {
          preserveSelectedRowKeys: true,
          selectedRowKeys,
          onChange: (selectedRowKeys2, selectedRows2) => {
            setSelectedRowKeys(selectedRowKeys2);
            setSelectedRows(selectedRows2);
            console.log("selectedRowKeys", selectedRowKeys2);
            console.log("selectedRows", selectedRows2);
          }
        };
        const renderTitle = () => {
          const albumName = detail?.name || "专辑详情";
          const singerName = detail?.singername || "";
          const publishDate = detail?.aDate || "";
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7["modal-header"], children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Title$3, { level: 4, className: styles$7["modal-title"], children: "专辑详情" }),
            detail && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7["album-basic-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Image,
                {
                  src: currentMid ? getAlbumPicUrl(currentMid) : "",
                  alt: albumName,
                  width: 80,
                  height: 80,
                  style: { borderRadius: 8 },
                  fallback: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3Ik1RnG4W+FgYxN"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7["album-info"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Title$3, { level: 5, className: styles$7["album-name"], children: albumName }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7["album-meta"], children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Text$4, { type: "secondary", className: styles$7["singer-name"], children: singerName || "未知歌手" }),
                  publishDate && /* @__PURE__ */ jsxRuntimeExports.jsxs(Text$4, { type: "secondary", className: styles$7["publish-date"], children: [
                    "· ",
                    publishDate
                  ] })
                ] })
              ] })
            ] })
          ] });
        };
        const handleBatchDownload = async () => {
          if (selectedRows.length === 0) {
            msgWarning("请先选择要下载的歌曲");
            return;
          }
          const loadingKey = "download-album-song";
          try {
            message$1.loading({
              key: loadingKey,
              content: `正在准备下载 ${selectedRows.length} 首歌曲...`,
              duration: 0
            });
            let index2 = 1;
            for (const song of selectedRows) {
              message$1.loading({
                key: loadingKey,
                content: `正在下载第 ${index2} 首歌曲 ${song.songname}...`,
                duration: 0
              });
              const finalQuality = getQuality$3(song, defaultQuality);
              await download(song.songmid, finalQuality);
              message$1.success({
                key: loadingKey,
                content: `第 ${index2} 首歌曲 ${song.songname} 下载成功！`,
                duration: 1
              });
              index2++;
            }
            message$1.success({
              key: loadingKey,
              content: `成功下载 ${selectedRows.length} 首歌曲！`,
              duration: 1
            });
          } catch (error) {
            console.error("批量下载失败:", error);
            message$1.destroy(loadingKey);
            msgError("批量下载失败: " + error.message);
          } finally {
            message$1.destroy(loadingKey);
          }
        };
        const handleBatchDownloadNeteaseMusic = async () => {
          if (selectedRows.length === 0) {
            msgWarning("请先选择要转存网易云的歌曲");
            return;
          }
          const loadingKey = "download-album-song-netease";
          try {
            message$1.loading({
              key: loadingKey,
              content: `正在准备转存网易云 ${selectedRows.length} 首歌曲...`,
              duration: 0
            });
            let index2 = 1;
            for (const song of selectedRows) {
              console.log("song", song);
              const record = song;
              const finalQuality = getQuality$3(record, defaultQuality, record.quality);
              message$1.loading({
                key: loadingKey,
                content: `正在转存第 ${index2} 首歌曲 ${song.songname}...`,
                duration: 0
              });
              await convertToNeteaseMusic(song.songmid, { quality: finalQuality });
              message$1.success({
                content: `第 ${index2} 首歌曲 ${song.songname} 转存成功！`,
                duration: 1
              });
              index2++;
            }
            message$1.success({
              key: loadingKey,
              content: `成功转存 ${selectedRows.length} 首歌曲！`,
              duration: 1
            });
          } catch (error) {
            console.error("批量转存网易云失败:", error);
            msgError("批量转存网易云失败: " + error.message);
          } finally {
            message$1.destroy(loadingKey);
          }
        };
        const handleDownloadAllJson = async () => {
          if (!currentMid) return;
          const loadingKey = "download-album-json";
          try {
            message$1.loading({
              key: loadingKey,
              content: `正在下载专辑JSON...`,
              duration: 0
            });
            const res = await getDownLoadJson(currentMid);
            downloadAsJson([res], `${detail?.name}.json`);
            message$1.destroy(loadingKey);
            msgSuccess("成功下载专辑JSON！");
          } catch (error) {
            console.log("error", error);
          } finally {
            message$1.destroy(loadingKey);
          }
        };
        const renderFooter = () => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7["footer"], children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7["selected-count"], children: [
              "已选择 ",
              selectedRows.length,
              " 首歌曲"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
              selectedRowKeys?.length < list.length ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    setSelectedRowKeys(list?.map((item) => item.songmid) || []);
                    setSelectedRows(list || []);
                  },
                  children: "全部选择"
                }
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    setSelectedRowKeys([]);
                    setSelectedRows([]);
                  },
                  children: "清空选择"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(MyButton, { type: "primary", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}), onClick: handleBatchDownload, children: [
                "下载选中歌曲",
                selectedRows?.length ? `(${selectedRows?.length})` : ""
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                MyButton,
                {
                  type: "primary",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CloudDownloadOutlined, {}),
                  onClick: handleBatchDownloadNeteaseMusic,
                  children: [
                    "转存网易云",
                    selectedRows?.length ? `(${selectedRows?.length})` : ""
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FileOutlined, {}), type: "primary", onClick: handleDownloadAllJson, children: "下载全部歌曲JSON" })
            ] })
          ] });
        };
        const handleInputChange = (e) => {
          setInputMid(e.target.value.trim());
        };
        const handleOpenById = () => {
          if (!inputMid) return;
          setCurrentMid(inputMid);
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            title: renderTitle(),
            open: visible,
            onCancel: close,
            width: 1200,
            centered: true,
            destroyOnHidden: true,
            className: styles$7["album-detail-modal"],
            footer: renderFooter(),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: 12, display: "flex", gap: 8 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    placeholder: "请输入专辑ID/MID，如 003rJSwm3TechU",
                    value: inputMid,
                    onChange: handleInputChange,
                    onPressEnter: handleOpenById,
                    allowClear: true,
                    "aria-label": "专辑ID输入框"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "primary",
                    onClick: handleOpenById,
                    loading: loading2 || detailLoading || isLoading,
                    children: "打开"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Table,
                {
                  columns: songColumns,
                  dataSource: list || [],
                  rowSelection,
                  rowKey: "songmid",
                  loading: loading2 || detailLoading || isLoading,
                  scroll: { y: 400, x: 600 },
                  pagination: {
                    showSizeChanger: true,
                    showQuickJumper: true,
                    showTotal: (total) => `共 ${total} 首歌曲`
                  },
                  className: styles$7["song-table"]
                }
              )
            ]
          }
        );
      });
      const getQuality$3 = (record, defaultQuality, chooseQuality) => {
        const qualityList = getFileQualityList(record);
        const songDefaultQuality = qualityList.includes(defaultQuality) ? defaultQuality : qualityList[0];
        const finalQuality = chooseQuality || songDefaultQuality;
        return finalQuality;
      };
      const { Link, Text: Text$3 } = Typography;
      const GITHUB_CONFIG = {
        owner: "520Qiuyu",
        repo: "QQMusic",
        homepage: "https://github.com/520Qiuyu/QQMusic",
        authorUrl: "https://github.com/520Qiuyu",
        scriptUrl: "https://raw.githubusercontent.com/520Qiuyu/QQMusic/main/dist/qqmusic.user.js"
      };
      const GithubInfo = forwardRef((_props, ref) => {
        const { visible, close } = useVisible(
          {
            onOpen: () => {
              fetchRepoInfo();
            }
          },
          ref
        );
        const [repoInfo, setRepoInfo] = useState(null);
        const [loading2, setLoading] = useState(false);
        const { functionConfig, setFunctionConfig } = useConfig();
        const fetchRepoInfo = async () => {
          setLoading(true);
          try {
            const response = await fetch(
              `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}`
            );
            if (response.ok) {
              const data = await response.json();
              setRepoInfo({
                stars: data.stargazers_count || 0,
                forks: data.forks_count || 0,
                watchers: data.watchers_count || 0,
                description: data.description || "",
                language: data.language || "",
                updatedAt: data.updated_at || "",
                createdAt: data.created_at || "",
                openIssues: data.open_issues_count || 0,
                license: data.license?.name || "无",
                defaultBranch: data.default_branch || "main",
                avatarUrl: data.owner?.avatar_url || "",
                authorName: data.owner?.login || GITHUB_CONFIG.owner
              });
            }
          } catch (error) {
            console.error("获取 GitHub 信息失败:", error);
          } finally {
            setLoading(false);
          }
        };
        const formatDate = (dateString) => {
          if (!dateString) return "-";
          const date = new Date(dateString);
          return date.toLocaleDateString("zh-CN", {
            year: "numeric",
            month: "long",
            day: "numeric"
          });
        };
        const handleDoubleClickDefaultBranch = () => {
          setFunctionConfig({
            ...functionConfig,
            enableTestModal: !functionConfig.enableTestModal
          });
          close();
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            title: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(GithubOutlined, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "GitHub 信息" })
            ] }),
            open: visible,
            onCancel: close,
            footer: null,
            centered: true,
            width: 700,
            zIndex: 99999,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Spin, { spinning: loading2, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Descriptions, { column: 1, bordered: true, size: "small", styles: { label: { width: 120 } }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "项目主页", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Space, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { href: GITHUB_CONFIG.homepage, target: "_blank", rel: "noopener noreferrer", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(LinkOutlined, {}),
                " ",
                GITHUB_CONFIG.homepage
              ] }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "作者主页", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                repoInfo?.avatarUrl && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Image,
                  {
                    src: repoInfo.avatarUrl,
                    alt: repoInfo.authorName || "作者头像",
                    width: 60,
                    height: 60,
                    style: {
                      borderRadius: "50%",
                      objectFit: "cover",
                      cursor: "pointer"
                    }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { href: GITHUB_CONFIG.authorUrl, target: "_blank", rel: "noopener noreferrer", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(GithubOutlined, {}),
                  " ",
                  GITHUB_CONFIG.authorUrl
                ] })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "项目描述", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { children: repoInfo?.description || "暂无描述" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "统计信息", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "large", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(StarOutlined, { style: { color: "#faad14" } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { strong: true, children: repoInfo?.stars || 0 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { type: "secondary", children: "Stars" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(ForkOutlined, { style: { color: "#1890ff" } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { strong: true, children: repoInfo?.forks || 0 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { type: "secondary", children: "Forks" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOutlined, { style: { color: "#52c41a" } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { strong: true, children: repoInfo?.watchers || 0 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { type: "secondary", children: "Watchers" })
                ] })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "主要语言", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { children: repoInfo?.language || "未知" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "默认分支", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Text$3,
                {
                  code: true,
                  onDoubleClick: handleDoubleClickDefaultBranch,
                  style: { cursor: "pointer", userSelect: "none" },
                  children: repoInfo?.defaultBranch || "main"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "许可证", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { children: repoInfo?.license || "无" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "开放 Issues", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { children: repoInfo?.openIssues || 0 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "创建时间", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { children: formatDate(repoInfo?.createdAt) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "更新时间", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { children: formatDate(repoInfo?.updatedAt) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "操作", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "primary",
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(GithubOutlined, {}),
                    href: GITHUB_CONFIG.homepage,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: "访问仓库"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(StarOutlined, {}),
                    href: `${GITHUB_CONFIG.homepage}/stargazers`,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: "查看 Stars"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "primary",
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UploadOutlined, {}),
                    href: GITHUB_CONFIG.scriptUrl,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: "更新脚本"
                  }
                )
              ] }) })
            ] }) })
          }
        );
      });
      var lodash$1 = { exports: {} };
      /**
       * @license
       * Lodash <https://lodash.com/>
       * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
       * Released under MIT license <https://lodash.com/license>
       * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
       * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
       */
      var lodash = lodash$1.exports;
      var hasRequiredLodash;
      function requireLodash() {
        if (hasRequiredLodash) return lodash$1.exports;
        hasRequiredLodash = 1;
        (function(module, exports) {
          (function() {
            var undefined$1;
            var VERSION = "4.17.21";
            var LARGE_ARRAY_SIZE = 200;
            var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
            var HASH_UNDEFINED = "__lodash_hash_undefined__";
            var MAX_MEMOIZE_SIZE = 500;
            var PLACEHOLDER = "__lodash_placeholder__";
            var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
            var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
            var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
            var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
            var HOT_COUNT = 800, HOT_SPAN = 16;
            var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
            var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
            var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
            var wrapFlags = [
              ["ary", WRAP_ARY_FLAG],
              ["bind", WRAP_BIND_FLAG],
              ["bindKey", WRAP_BIND_KEY_FLAG],
              ["curry", WRAP_CURRY_FLAG],
              ["curryRight", WRAP_CURRY_RIGHT_FLAG],
              ["flip", WRAP_FLIP_FLAG],
              ["partial", WRAP_PARTIAL_FLAG],
              ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
              ["rearg", WRAP_REARG_FLAG]
            ];
            var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
            var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
            var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
            var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
            var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
            var reTrimStart = /^\s+/;
            var reWhitespace = /\s/;
            var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
            var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
            var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
            var reEscapeChar = /\\(\\)?/g;
            var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
            var reFlags = /\w*$/;
            var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
            var reIsBinary = /^0b[01]+$/i;
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            var reIsOctal = /^0o[0-7]+$/i;
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
            var reNoMatch = /($^)/;
            var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
            var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
            var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
            var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
            var reApos = RegExp(rsApos, "g");
            var reComboMark = RegExp(rsCombo, "g");
            var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
            var reUnicodeWord = RegExp([
              rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
              rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
              rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
              rsUpper + "+" + rsOptContrUpper,
              rsOrdUpper,
              rsOrdLower,
              rsDigits,
              rsEmoji
            ].join("|"), "g");
            var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
            var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
            var contextProps = [
              "Array",
              "Buffer",
              "DataView",
              "Date",
              "Error",
              "Float32Array",
              "Float64Array",
              "Function",
              "Int8Array",
              "Int16Array",
              "Int32Array",
              "Map",
              "Math",
              "Object",
              "Promise",
              "RegExp",
              "Set",
              "String",
              "Symbol",
              "TypeError",
              "Uint8Array",
              "Uint8ClampedArray",
              "Uint16Array",
              "Uint32Array",
              "WeakMap",
              "_",
              "clearTimeout",
              "isFinite",
              "parseInt",
              "setTimeout"
            ];
            var templateCounter = -1;
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
            var cloneableTags = {};
            cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
            cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
            var deburredLetters = {
              // Latin-1 Supplement block.
              "À": "A",
              "Á": "A",
              "Â": "A",
              "Ã": "A",
              "Ä": "A",
              "Å": "A",
              "à": "a",
              "á": "a",
              "â": "a",
              "ã": "a",
              "ä": "a",
              "å": "a",
              "Ç": "C",
              "ç": "c",
              "Ð": "D",
              "ð": "d",
              "È": "E",
              "É": "E",
              "Ê": "E",
              "Ë": "E",
              "è": "e",
              "é": "e",
              "ê": "e",
              "ë": "e",
              "Ì": "I",
              "Í": "I",
              "Î": "I",
              "Ï": "I",
              "ì": "i",
              "í": "i",
              "î": "i",
              "ï": "i",
              "Ñ": "N",
              "ñ": "n",
              "Ò": "O",
              "Ó": "O",
              "Ô": "O",
              "Õ": "O",
              "Ö": "O",
              "Ø": "O",
              "ò": "o",
              "ó": "o",
              "ô": "o",
              "õ": "o",
              "ö": "o",
              "ø": "o",
              "Ù": "U",
              "Ú": "U",
              "Û": "U",
              "Ü": "U",
              "ù": "u",
              "ú": "u",
              "û": "u",
              "ü": "u",
              "Ý": "Y",
              "ý": "y",
              "ÿ": "y",
              "Æ": "Ae",
              "æ": "ae",
              "Þ": "Th",
              "þ": "th",
              "ß": "ss",
              // Latin Extended-A block.
              "Ā": "A",
              "Ă": "A",
              "Ą": "A",
              "ā": "a",
              "ă": "a",
              "ą": "a",
              "Ć": "C",
              "Ĉ": "C",
              "Ċ": "C",
              "Č": "C",
              "ć": "c",
              "ĉ": "c",
              "ċ": "c",
              "č": "c",
              "Ď": "D",
              "Đ": "D",
              "ď": "d",
              "đ": "d",
              "Ē": "E",
              "Ĕ": "E",
              "Ė": "E",
              "Ę": "E",
              "Ě": "E",
              "ē": "e",
              "ĕ": "e",
              "ė": "e",
              "ę": "e",
              "ě": "e",
              "Ĝ": "G",
              "Ğ": "G",
              "Ġ": "G",
              "Ģ": "G",
              "ĝ": "g",
              "ğ": "g",
              "ġ": "g",
              "ģ": "g",
              "Ĥ": "H",
              "Ħ": "H",
              "ĥ": "h",
              "ħ": "h",
              "Ĩ": "I",
              "Ī": "I",
              "Ĭ": "I",
              "Į": "I",
              "İ": "I",
              "ĩ": "i",
              "ī": "i",
              "ĭ": "i",
              "į": "i",
              "ı": "i",
              "Ĵ": "J",
              "ĵ": "j",
              "Ķ": "K",
              "ķ": "k",
              "ĸ": "k",
              "Ĺ": "L",
              "Ļ": "L",
              "Ľ": "L",
              "Ŀ": "L",
              "Ł": "L",
              "ĺ": "l",
              "ļ": "l",
              "ľ": "l",
              "ŀ": "l",
              "ł": "l",
              "Ń": "N",
              "Ņ": "N",
              "Ň": "N",
              "Ŋ": "N",
              "ń": "n",
              "ņ": "n",
              "ň": "n",
              "ŋ": "n",
              "Ō": "O",
              "Ŏ": "O",
              "Ő": "O",
              "ō": "o",
              "ŏ": "o",
              "ő": "o",
              "Ŕ": "R",
              "Ŗ": "R",
              "Ř": "R",
              "ŕ": "r",
              "ŗ": "r",
              "ř": "r",
              "Ś": "S",
              "Ŝ": "S",
              "Ş": "S",
              "Š": "S",
              "ś": "s",
              "ŝ": "s",
              "ş": "s",
              "š": "s",
              "Ţ": "T",
              "Ť": "T",
              "Ŧ": "T",
              "ţ": "t",
              "ť": "t",
              "ŧ": "t",
              "Ũ": "U",
              "Ū": "U",
              "Ŭ": "U",
              "Ů": "U",
              "Ű": "U",
              "Ų": "U",
              "ũ": "u",
              "ū": "u",
              "ŭ": "u",
              "ů": "u",
              "ű": "u",
              "ų": "u",
              "Ŵ": "W",
              "ŵ": "w",
              "Ŷ": "Y",
              "ŷ": "y",
              "Ÿ": "Y",
              "Ź": "Z",
              "Ż": "Z",
              "Ž": "Z",
              "ź": "z",
              "ż": "z",
              "ž": "z",
              "Ĳ": "IJ",
              "ĳ": "ij",
              "Œ": "Oe",
              "œ": "oe",
              "ŉ": "'n",
              "ſ": "s"
            };
            var htmlEscapes = {
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;"
            };
            var htmlUnescapes = {
              "&amp;": "&",
              "&lt;": "<",
              "&gt;": ">",
              "&quot;": '"',
              "&#39;": "'"
            };
            var stringEscapes = {
              "\\": "\\",
              "'": "'",
              "\n": "n",
              "\r": "r",
              "\u2028": "u2028",
              "\u2029": "u2029"
            };
            var freeParseFloat = parseFloat, freeParseInt = parseInt;
            var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
            var freeSelf = typeof self == "object" && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function("return this")();
            var freeExports = exports && !exports.nodeType && exports;
            var freeModule = freeExports && true && module && !module.nodeType && module;
            var moduleExports = freeModule && freeModule.exports === freeExports;
            var freeProcess = moduleExports && freeGlobal.process;
            var nodeUtil = (function() {
              try {
                var types = freeModule && freeModule.require && freeModule.require("util").types;
                if (types) {
                  return types;
                }
                return freeProcess && freeProcess.binding && freeProcess.binding("util");
              } catch (e) {
              }
            })();
            var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
            function apply(func, thisArg, args) {
              switch (args.length) {
                case 0:
                  return func.call(thisArg);
                case 1:
                  return func.call(thisArg, args[0]);
                case 2:
                  return func.call(thisArg, args[0], args[1]);
                case 3:
                  return func.call(thisArg, args[0], args[1], args[2]);
              }
              return func.apply(thisArg, args);
            }
            function arrayAggregator(array, setter, iteratee, accumulator) {
              var index2 = -1, length = array == null ? 0 : array.length;
              while (++index2 < length) {
                var value = array[index2];
                setter(accumulator, value, iteratee(value), array);
              }
              return accumulator;
            }
            function arrayEach(array, iteratee) {
              var index2 = -1, length = array == null ? 0 : array.length;
              while (++index2 < length) {
                if (iteratee(array[index2], index2, array) === false) {
                  break;
                }
              }
              return array;
            }
            function arrayEachRight(array, iteratee) {
              var length = array == null ? 0 : array.length;
              while (length--) {
                if (iteratee(array[length], length, array) === false) {
                  break;
                }
              }
              return array;
            }
            function arrayEvery(array, predicate) {
              var index2 = -1, length = array == null ? 0 : array.length;
              while (++index2 < length) {
                if (!predicate(array[index2], index2, array)) {
                  return false;
                }
              }
              return true;
            }
            function arrayFilter(array, predicate) {
              var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
              while (++index2 < length) {
                var value = array[index2];
                if (predicate(value, index2, array)) {
                  result[resIndex++] = value;
                }
              }
              return result;
            }
            function arrayIncludes(array, value) {
              var length = array == null ? 0 : array.length;
              return !!length && baseIndexOf(array, value, 0) > -1;
            }
            function arrayIncludesWith(array, value, comparator) {
              var index2 = -1, length = array == null ? 0 : array.length;
              while (++index2 < length) {
                if (comparator(value, array[index2])) {
                  return true;
                }
              }
              return false;
            }
            function arrayMap(array, iteratee) {
              var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
              while (++index2 < length) {
                result[index2] = iteratee(array[index2], index2, array);
              }
              return result;
            }
            function arrayPush(array, values) {
              var index2 = -1, length = values.length, offset = array.length;
              while (++index2 < length) {
                array[offset + index2] = values[index2];
              }
              return array;
            }
            function arrayReduce(array, iteratee, accumulator, initAccum) {
              var index2 = -1, length = array == null ? 0 : array.length;
              if (initAccum && length) {
                accumulator = array[++index2];
              }
              while (++index2 < length) {
                accumulator = iteratee(accumulator, array[index2], index2, array);
              }
              return accumulator;
            }
            function arrayReduceRight(array, iteratee, accumulator, initAccum) {
              var length = array == null ? 0 : array.length;
              if (initAccum && length) {
                accumulator = array[--length];
              }
              while (length--) {
                accumulator = iteratee(accumulator, array[length], length, array);
              }
              return accumulator;
            }
            function arraySome(array, predicate) {
              var index2 = -1, length = array == null ? 0 : array.length;
              while (++index2 < length) {
                if (predicate(array[index2], index2, array)) {
                  return true;
                }
              }
              return false;
            }
            var asciiSize = baseProperty("length");
            function asciiToArray(string) {
              return string.split("");
            }
            function asciiWords(string) {
              return string.match(reAsciiWord) || [];
            }
            function baseFindKey(collection, predicate, eachFunc) {
              var result;
              eachFunc(collection, function(value, key, collection2) {
                if (predicate(value, key, collection2)) {
                  result = key;
                  return false;
                }
              });
              return result;
            }
            function baseFindIndex(array, predicate, fromIndex, fromRight) {
              var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
              while (fromRight ? index2-- : ++index2 < length) {
                if (predicate(array[index2], index2, array)) {
                  return index2;
                }
              }
              return -1;
            }
            function baseIndexOf(array, value, fromIndex) {
              return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
            }
            function baseIndexOfWith(array, value, fromIndex, comparator) {
              var index2 = fromIndex - 1, length = array.length;
              while (++index2 < length) {
                if (comparator(array[index2], value)) {
                  return index2;
                }
              }
              return -1;
            }
            function baseIsNaN(value) {
              return value !== value;
            }
            function baseMean(array, iteratee) {
              var length = array == null ? 0 : array.length;
              return length ? baseSum(array, iteratee) / length : NAN;
            }
            function baseProperty(key) {
              return function(object) {
                return object == null ? undefined$1 : object[key];
              };
            }
            function basePropertyOf(object) {
              return function(key) {
                return object == null ? undefined$1 : object[key];
              };
            }
            function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
              eachFunc(collection, function(value, index2, collection2) {
                accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
              });
              return accumulator;
            }
            function baseSortBy(array, comparer) {
              var length = array.length;
              array.sort(comparer);
              while (length--) {
                array[length] = array[length].value;
              }
              return array;
            }
            function baseSum(array, iteratee) {
              var result, index2 = -1, length = array.length;
              while (++index2 < length) {
                var current = iteratee(array[index2]);
                if (current !== undefined$1) {
                  result = result === undefined$1 ? current : result + current;
                }
              }
              return result;
            }
            function baseTimes(n, iteratee) {
              var index2 = -1, result = Array(n);
              while (++index2 < n) {
                result[index2] = iteratee(index2);
              }
              return result;
            }
            function baseToPairs(object, props) {
              return arrayMap(props, function(key) {
                return [key, object[key]];
              });
            }
            function baseTrim(string) {
              return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
            }
            function baseUnary(func) {
              return function(value) {
                return func(value);
              };
            }
            function baseValues(object, props) {
              return arrayMap(props, function(key) {
                return object[key];
              });
            }
            function cacheHas(cache, key) {
              return cache.has(key);
            }
            function charsStartIndex(strSymbols, chrSymbols) {
              var index2 = -1, length = strSymbols.length;
              while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
              }
              return index2;
            }
            function charsEndIndex(strSymbols, chrSymbols) {
              var index2 = strSymbols.length;
              while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
              }
              return index2;
            }
            function countHolders(array, placeholder) {
              var length = array.length, result = 0;
              while (length--) {
                if (array[length] === placeholder) {
                  ++result;
                }
              }
              return result;
            }
            var deburrLetter = basePropertyOf(deburredLetters);
            var escapeHtmlChar = basePropertyOf(htmlEscapes);
            function escapeStringChar(chr) {
              return "\\" + stringEscapes[chr];
            }
            function getValue(object, key) {
              return object == null ? undefined$1 : object[key];
            }
            function hasUnicode(string) {
              return reHasUnicode.test(string);
            }
            function hasUnicodeWord(string) {
              return reHasUnicodeWord.test(string);
            }
            function iteratorToArray(iterator) {
              var data, result = [];
              while (!(data = iterator.next()).done) {
                result.push(data.value);
              }
              return result;
            }
            function mapToArray(map) {
              var index2 = -1, result = Array(map.size);
              map.forEach(function(value, key) {
                result[++index2] = [key, value];
              });
              return result;
            }
            function overArg(func, transform) {
              return function(arg) {
                return func(transform(arg));
              };
            }
            function replaceHolders(array, placeholder) {
              var index2 = -1, length = array.length, resIndex = 0, result = [];
              while (++index2 < length) {
                var value = array[index2];
                if (value === placeholder || value === PLACEHOLDER) {
                  array[index2] = PLACEHOLDER;
                  result[resIndex++] = index2;
                }
              }
              return result;
            }
            function setToArray(set) {
              var index2 = -1, result = Array(set.size);
              set.forEach(function(value) {
                result[++index2] = value;
              });
              return result;
            }
            function setToPairs(set) {
              var index2 = -1, result = Array(set.size);
              set.forEach(function(value) {
                result[++index2] = [value, value];
              });
              return result;
            }
            function strictIndexOf(array, value, fromIndex) {
              var index2 = fromIndex - 1, length = array.length;
              while (++index2 < length) {
                if (array[index2] === value) {
                  return index2;
                }
              }
              return -1;
            }
            function strictLastIndexOf(array, value, fromIndex) {
              var index2 = fromIndex + 1;
              while (index2--) {
                if (array[index2] === value) {
                  return index2;
                }
              }
              return index2;
            }
            function stringSize(string) {
              return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
            }
            function stringToArray(string) {
              return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
            }
            function trimmedEndIndex(string) {
              var index2 = string.length;
              while (index2-- && reWhitespace.test(string.charAt(index2))) {
              }
              return index2;
            }
            var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
            function unicodeSize(string) {
              var result = reUnicode.lastIndex = 0;
              while (reUnicode.test(string)) {
                ++result;
              }
              return result;
            }
            function unicodeToArray(string) {
              return string.match(reUnicode) || [];
            }
            function unicodeWords(string) {
              return string.match(reUnicodeWord) || [];
            }
            var runInContext = (function runInContext2(context) {
              context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
              var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
              var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
              var coreJsData = context["__core-js_shared__"];
              var funcToString = funcProto.toString;
              var hasOwnProperty = objectProto.hasOwnProperty;
              var idCounter = 0;
              var maskSrcKey = (function() {
                var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                return uid ? "Symbol(src)_1." + uid : "";
              })();
              var nativeObjectToString = objectProto.toString;
              var objectCtorString = funcToString.call(Object2);
              var oldDash = root._;
              var reIsNative = RegExp2(
                "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
              );
              var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
              var defineProperty2 = (function() {
                try {
                  var func = getNative(Object2, "defineProperty");
                  func({}, "", {});
                  return func;
                } catch (e) {
                }
              })();
              var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
              var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
              var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
              var metaMap = WeakMap2 && new WeakMap2();
              var realNames = {};
              var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
              var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
              function lodash2(value) {
                if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                  if (value instanceof LodashWrapper) {
                    return value;
                  }
                  if (hasOwnProperty.call(value, "__wrapped__")) {
                    return wrapperClone(value);
                  }
                }
                return new LodashWrapper(value);
              }
              var baseCreate = /* @__PURE__ */ (function() {
                function object() {
                }
                return function(proto) {
                  if (!isObject(proto)) {
                    return {};
                  }
                  if (objectCreate) {
                    return objectCreate(proto);
                  }
                  object.prototype = proto;
                  var result2 = new object();
                  object.prototype = undefined$1;
                  return result2;
                };
              })();
              function baseLodash() {
              }
              function LodashWrapper(value, chainAll) {
                this.__wrapped__ = value;
                this.__actions__ = [];
                this.__chain__ = !!chainAll;
                this.__index__ = 0;
                this.__values__ = undefined$1;
              }
              lodash2.templateSettings = {
                /**
                 * Used to detect `data` property values to be HTML-escaped.
                 *
                 * @memberOf _.templateSettings
                 * @type {RegExp}
                 */
                "escape": reEscape,
                /**
                 * Used to detect code to be evaluated.
                 *
                 * @memberOf _.templateSettings
                 * @type {RegExp}
                 */
                "evaluate": reEvaluate,
                /**
                 * Used to detect `data` property values to inject.
                 *
                 * @memberOf _.templateSettings
                 * @type {RegExp}
                 */
                "interpolate": reInterpolate,
                /**
                 * Used to reference the data object in the template text.
                 *
                 * @memberOf _.templateSettings
                 * @type {string}
                 */
                "variable": "",
                /**
                 * Used to import variables into the compiled template.
                 *
                 * @memberOf _.templateSettings
                 * @type {Object}
                 */
                "imports": {
                  /**
                   * A reference to the `lodash` function.
                   *
                   * @memberOf _.templateSettings.imports
                   * @type {Function}
                   */
                  "_": lodash2
                }
              };
              lodash2.prototype = baseLodash.prototype;
              lodash2.prototype.constructor = lodash2;
              LodashWrapper.prototype = baseCreate(baseLodash.prototype);
              LodashWrapper.prototype.constructor = LodashWrapper;
              function LazyWrapper(value) {
                this.__wrapped__ = value;
                this.__actions__ = [];
                this.__dir__ = 1;
                this.__filtered__ = false;
                this.__iteratees__ = [];
                this.__takeCount__ = MAX_ARRAY_LENGTH;
                this.__views__ = [];
              }
              function lazyClone() {
                var result2 = new LazyWrapper(this.__wrapped__);
                result2.__actions__ = copyArray(this.__actions__);
                result2.__dir__ = this.__dir__;
                result2.__filtered__ = this.__filtered__;
                result2.__iteratees__ = copyArray(this.__iteratees__);
                result2.__takeCount__ = this.__takeCount__;
                result2.__views__ = copyArray(this.__views__);
                return result2;
              }
              function lazyReverse() {
                if (this.__filtered__) {
                  var result2 = new LazyWrapper(this);
                  result2.__dir__ = -1;
                  result2.__filtered__ = true;
                } else {
                  result2 = this.clone();
                  result2.__dir__ *= -1;
                }
                return result2;
              }
              function lazyValue() {
                var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
                if (!isArr || !isRight && arrLength == length && takeCount == length) {
                  return baseWrapperValue(array, this.__actions__);
                }
                var result2 = [];
                outer:
                  while (length-- && resIndex < takeCount) {
                    index2 += dir;
                    var iterIndex = -1, value = array[index2];
                    while (++iterIndex < iterLength) {
                      var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                      if (type == LAZY_MAP_FLAG) {
                        value = computed;
                      } else if (!computed) {
                        if (type == LAZY_FILTER_FLAG) {
                          continue outer;
                        } else {
                          break outer;
                        }
                      }
                    }
                    result2[resIndex++] = value;
                  }
                return result2;
              }
              LazyWrapper.prototype = baseCreate(baseLodash.prototype);
              LazyWrapper.prototype.constructor = LazyWrapper;
              function Hash(entries) {
                var index2 = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index2 < length) {
                  var entry = entries[index2];
                  this.set(entry[0], entry[1]);
                }
              }
              function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {};
                this.size = 0;
              }
              function hashDelete(key) {
                var result2 = this.has(key) && delete this.__data__[key];
                this.size -= result2 ? 1 : 0;
                return result2;
              }
              function hashGet(key) {
                var data = this.__data__;
                if (nativeCreate) {
                  var result2 = data[key];
                  return result2 === HASH_UNDEFINED ? undefined$1 : result2;
                }
                return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
              }
              function hashHas(key) {
                var data = this.__data__;
                return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty.call(data, key);
              }
              function hashSet(key, value) {
                var data = this.__data__;
                this.size += this.has(key) ? 0 : 1;
                data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
                return this;
              }
              Hash.prototype.clear = hashClear;
              Hash.prototype["delete"] = hashDelete;
              Hash.prototype.get = hashGet;
              Hash.prototype.has = hashHas;
              Hash.prototype.set = hashSet;
              function ListCache(entries) {
                var index2 = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index2 < length) {
                  var entry = entries[index2];
                  this.set(entry[0], entry[1]);
                }
              }
              function listCacheClear() {
                this.__data__ = [];
                this.size = 0;
              }
              function listCacheDelete(key) {
                var data = this.__data__, index2 = assocIndexOf(data, key);
                if (index2 < 0) {
                  return false;
                }
                var lastIndex = data.length - 1;
                if (index2 == lastIndex) {
                  data.pop();
                } else {
                  splice.call(data, index2, 1);
                }
                --this.size;
                return true;
              }
              function listCacheGet(key) {
                var data = this.__data__, index2 = assocIndexOf(data, key);
                return index2 < 0 ? undefined$1 : data[index2][1];
              }
              function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1;
              }
              function listCacheSet(key, value) {
                var data = this.__data__, index2 = assocIndexOf(data, key);
                if (index2 < 0) {
                  ++this.size;
                  data.push([key, value]);
                } else {
                  data[index2][1] = value;
                }
                return this;
              }
              ListCache.prototype.clear = listCacheClear;
              ListCache.prototype["delete"] = listCacheDelete;
              ListCache.prototype.get = listCacheGet;
              ListCache.prototype.has = listCacheHas;
              ListCache.prototype.set = listCacheSet;
              function MapCache(entries) {
                var index2 = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index2 < length) {
                  var entry = entries[index2];
                  this.set(entry[0], entry[1]);
                }
              }
              function mapCacheClear() {
                this.size = 0;
                this.__data__ = {
                  "hash": new Hash(),
                  "map": new (Map2 || ListCache)(),
                  "string": new Hash()
                };
              }
              function mapCacheDelete(key) {
                var result2 = getMapData(this, key)["delete"](key);
                this.size -= result2 ? 1 : 0;
                return result2;
              }
              function mapCacheGet(key) {
                return getMapData(this, key).get(key);
              }
              function mapCacheHas(key) {
                return getMapData(this, key).has(key);
              }
              function mapCacheSet(key, value) {
                var data = getMapData(this, key), size2 = data.size;
                data.set(key, value);
                this.size += data.size == size2 ? 0 : 1;
                return this;
              }
              MapCache.prototype.clear = mapCacheClear;
              MapCache.prototype["delete"] = mapCacheDelete;
              MapCache.prototype.get = mapCacheGet;
              MapCache.prototype.has = mapCacheHas;
              MapCache.prototype.set = mapCacheSet;
              function SetCache(values2) {
                var index2 = -1, length = values2 == null ? 0 : values2.length;
                this.__data__ = new MapCache();
                while (++index2 < length) {
                  this.add(values2[index2]);
                }
              }
              function setCacheAdd(value) {
                this.__data__.set(value, HASH_UNDEFINED);
                return this;
              }
              function setCacheHas(value) {
                return this.__data__.has(value);
              }
              SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
              SetCache.prototype.has = setCacheHas;
              function Stack(entries) {
                var data = this.__data__ = new ListCache(entries);
                this.size = data.size;
              }
              function stackClear() {
                this.__data__ = new ListCache();
                this.size = 0;
              }
              function stackDelete(key) {
                var data = this.__data__, result2 = data["delete"](key);
                this.size = data.size;
                return result2;
              }
              function stackGet(key) {
                return this.__data__.get(key);
              }
              function stackHas(key) {
                return this.__data__.has(key);
              }
              function stackSet(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache) {
                  var pairs = data.__data__;
                  if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                    pairs.push([key, value]);
                    this.size = ++data.size;
                    return this;
                  }
                  data = this.__data__ = new MapCache(pairs);
                }
                data.set(key, value);
                this.size = data.size;
                return this;
              }
              Stack.prototype.clear = stackClear;
              Stack.prototype["delete"] = stackDelete;
              Stack.prototype.get = stackGet;
              Stack.prototype.has = stackHas;
              Stack.prototype.set = stackSet;
              function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType2, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
                for (var key in value) {
                  if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                  (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                  isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                  isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
                  isIndex(key, length)))) {
                    result2.push(key);
                  }
                }
                return result2;
              }
              function arraySample(array) {
                var length = array.length;
                return length ? array[baseRandom(0, length - 1)] : undefined$1;
              }
              function arraySampleSize(array, n) {
                return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
              }
              function arrayShuffle(array) {
                return shuffleSelf(copyArray(array));
              }
              function assignMergeValue(object, key, value) {
                if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
                  baseAssignValue(object, key, value);
                }
              }
              function assignValue(object, key, value) {
                var objValue = object[key];
                if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
                  baseAssignValue(object, key, value);
                }
              }
              function assocIndexOf(array, key) {
                var length = array.length;
                while (length--) {
                  if (eq(array[length][0], key)) {
                    return length;
                  }
                }
                return -1;
              }
              function baseAggregator(collection, setter, iteratee2, accumulator) {
                baseEach(collection, function(value, key, collection2) {
                  setter(accumulator, value, iteratee2(value), collection2);
                });
                return accumulator;
              }
              function baseAssign(object, source) {
                return object && copyObject(source, keys(source), object);
              }
              function baseAssignIn(object, source) {
                return object && copyObject(source, keysIn(source), object);
              }
              function baseAssignValue(object, key, value) {
                if (key == "__proto__" && defineProperty2) {
                  defineProperty2(object, key, {
                    "configurable": true,
                    "enumerable": true,
                    "value": value,
                    "writable": true
                  });
                } else {
                  object[key] = value;
                }
              }
              function baseAt(object, paths) {
                var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
                while (++index2 < length) {
                  result2[index2] = skip ? undefined$1 : get(object, paths[index2]);
                }
                return result2;
              }
              function baseClamp(number, lower, upper) {
                if (number === number) {
                  if (upper !== undefined$1) {
                    number = number <= upper ? number : upper;
                  }
                  if (lower !== undefined$1) {
                    number = number >= lower ? number : lower;
                  }
                }
                return number;
              }
              function baseClone(value, bitmask, customizer, key, object, stack) {
                var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                if (customizer) {
                  result2 = object ? customizer(value, key, object, stack) : customizer(value);
                }
                if (result2 !== undefined$1) {
                  return result2;
                }
                if (!isObject(value)) {
                  return value;
                }
                var isArr = isArray(value);
                if (isArr) {
                  result2 = initCloneArray(value);
                  if (!isDeep) {
                    return copyArray(value, result2);
                  }
                } else {
                  var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                  if (isBuffer(value)) {
                    return cloneBuffer(value, isDeep);
                  }
                  if (tag == objectTag || tag == argsTag || isFunc && !object) {
                    result2 = isFlat || isFunc ? {} : initCloneObject(value);
                    if (!isDeep) {
                      return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                    }
                  } else {
                    if (!cloneableTags[tag]) {
                      return object ? value : {};
                    }
                    result2 = initCloneByTag(value, tag, isDeep);
                  }
                }
                stack || (stack = new Stack());
                var stacked = stack.get(value);
                if (stacked) {
                  return stacked;
                }
                stack.set(value, result2);
                if (isSet(value)) {
                  value.forEach(function(subValue) {
                    result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
                  });
                } else if (isMap(value)) {
                  value.forEach(function(subValue, key2) {
                    result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
                  });
                }
                var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
                var props = isArr ? undefined$1 : keysFunc(value);
                arrayEach(props || value, function(subValue, key2) {
                  if (props) {
                    key2 = subValue;
                    subValue = value[key2];
                  }
                  assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
                });
                return result2;
              }
              function baseConforms(source) {
                var props = keys(source);
                return function(object) {
                  return baseConformsTo(object, source, props);
                };
              }
              function baseConformsTo(object, source, props) {
                var length = props.length;
                if (object == null) {
                  return !length;
                }
                object = Object2(object);
                while (length--) {
                  var key = props[length], predicate = source[key], value = object[key];
                  if (value === undefined$1 && !(key in object) || !predicate(value)) {
                    return false;
                  }
                }
                return true;
              }
              function baseDelay(func, wait, args) {
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                return setTimeout2(function() {
                  func.apply(undefined$1, args);
                }, wait);
              }
              function baseDifference(array, values2, iteratee2, comparator) {
                var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
                if (!length) {
                  return result2;
                }
                if (iteratee2) {
                  values2 = arrayMap(values2, baseUnary(iteratee2));
                }
                if (comparator) {
                  includes2 = arrayIncludesWith;
                  isCommon = false;
                } else if (values2.length >= LARGE_ARRAY_SIZE) {
                  includes2 = cacheHas;
                  isCommon = false;
                  values2 = new SetCache(values2);
                }
                outer:
                  while (++index2 < length) {
                    var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed === computed) {
                      var valuesIndex = valuesLength;
                      while (valuesIndex--) {
                        if (values2[valuesIndex] === computed) {
                          continue outer;
                        }
                      }
                      result2.push(value);
                    } else if (!includes2(values2, computed, comparator)) {
                      result2.push(value);
                    }
                  }
                return result2;
              }
              var baseEach = createBaseEach(baseForOwn);
              var baseEachRight = createBaseEach(baseForOwnRight, true);
              function baseEvery(collection, predicate) {
                var result2 = true;
                baseEach(collection, function(value, index2, collection2) {
                  result2 = !!predicate(value, index2, collection2);
                  return result2;
                });
                return result2;
              }
              function baseExtremum(array, iteratee2, comparator) {
                var index2 = -1, length = array.length;
                while (++index2 < length) {
                  var value = array[index2], current = iteratee2(value);
                  if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                    var computed = current, result2 = value;
                  }
                }
                return result2;
              }
              function baseFill(array, value, start, end) {
                var length = array.length;
                start = toInteger(start);
                if (start < 0) {
                  start = -start > length ? 0 : length + start;
                }
                end = end === undefined$1 || end > length ? length : toInteger(end);
                if (end < 0) {
                  end += length;
                }
                end = start > end ? 0 : toLength(end);
                while (start < end) {
                  array[start++] = value;
                }
                return array;
              }
              function baseFilter(collection, predicate) {
                var result2 = [];
                baseEach(collection, function(value, index2, collection2) {
                  if (predicate(value, index2, collection2)) {
                    result2.push(value);
                  }
                });
                return result2;
              }
              function baseFlatten(array, depth, predicate, isStrict, result2) {
                var index2 = -1, length = array.length;
                predicate || (predicate = isFlattenable);
                result2 || (result2 = []);
                while (++index2 < length) {
                  var value = array[index2];
                  if (depth > 0 && predicate(value)) {
                    if (depth > 1) {
                      baseFlatten(value, depth - 1, predicate, isStrict, result2);
                    } else {
                      arrayPush(result2, value);
                    }
                  } else if (!isStrict) {
                    result2[result2.length] = value;
                  }
                }
                return result2;
              }
              var baseFor = createBaseFor();
              var baseForRight = createBaseFor(true);
              function baseForOwn(object, iteratee2) {
                return object && baseFor(object, iteratee2, keys);
              }
              function baseForOwnRight(object, iteratee2) {
                return object && baseForRight(object, iteratee2, keys);
              }
              function baseFunctions(object, props) {
                return arrayFilter(props, function(key) {
                  return isFunction2(object[key]);
                });
              }
              function baseGet(object, path) {
                path = castPath(path, object);
                var index2 = 0, length = path.length;
                while (object != null && index2 < length) {
                  object = object[toKey(path[index2++])];
                }
                return index2 && index2 == length ? object : undefined$1;
              }
              function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result2 = keysFunc(object);
                return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
              }
              function baseGetTag(value) {
                if (value == null) {
                  return value === undefined$1 ? undefinedTag : nullTag;
                }
                return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString2(value);
              }
              function baseGt(value, other) {
                return value > other;
              }
              function baseHas(object, key) {
                return object != null && hasOwnProperty.call(object, key);
              }
              function baseHasIn(object, key) {
                return object != null && key in Object2(object);
              }
              function baseInRange(number, start, end) {
                return number >= nativeMin(start, end) && number < nativeMax(start, end);
              }
              function baseIntersection(arrays, iteratee2, comparator) {
                var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
                while (othIndex--) {
                  var array = arrays[othIndex];
                  if (othIndex && iteratee2) {
                    array = arrayMap(array, baseUnary(iteratee2));
                  }
                  maxLength = nativeMin(array.length, maxLength);
                  caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
                }
                array = arrays[0];
                var index2 = -1, seen2 = caches[0];
                outer:
                  while (++index2 < length && result2.length < maxLength) {
                    var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
                    value = comparator || value !== 0 ? value : 0;
                    if (!(seen2 ? cacheHas(seen2, computed) : includes2(result2, computed, comparator))) {
                      othIndex = othLength;
                      while (--othIndex) {
                        var cache = caches[othIndex];
                        if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                          continue outer;
                        }
                      }
                      if (seen2) {
                        seen2.push(computed);
                      }
                      result2.push(value);
                    }
                  }
                return result2;
              }
              function baseInverter(object, setter, iteratee2, accumulator) {
                baseForOwn(object, function(value, key, object2) {
                  setter(accumulator, iteratee2(value), key, object2);
                });
                return accumulator;
              }
              function baseInvoke(object, path, args) {
                path = castPath(path, object);
                object = parent(object, path);
                var func = object == null ? object : object[toKey(last(path))];
                return func == null ? undefined$1 : apply(func, object, args);
              }
              function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag;
              }
              function baseIsArrayBuffer(value) {
                return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
              }
              function baseIsDate(value) {
                return isObjectLike(value) && baseGetTag(value) == dateTag;
              }
              function baseIsEqual(value, other, bitmask, customizer, stack) {
                if (value === other) {
                  return true;
                }
                if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
                  return value !== value && other !== other;
                }
                return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
              }
              function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                objTag = objTag == argsTag ? objectTag : objTag;
                othTag = othTag == argsTag ? objectTag : othTag;
                var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                if (isSameTag && isBuffer(object)) {
                  if (!isBuffer(other)) {
                    return false;
                  }
                  objIsArr = true;
                  objIsObj = false;
                }
                if (isSameTag && !objIsObj) {
                  stack || (stack = new Stack());
                  return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                }
                if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                  var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                  if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                    stack || (stack = new Stack());
                    return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                  }
                }
                if (!isSameTag) {
                  return false;
                }
                stack || (stack = new Stack());
                return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
              }
              function baseIsMap(value) {
                return isObjectLike(value) && getTag(value) == mapTag;
              }
              function baseIsMatch(object, source, matchData, customizer) {
                var index2 = matchData.length, length = index2, noCustomizer = !customizer;
                if (object == null) {
                  return !length;
                }
                object = Object2(object);
                while (index2--) {
                  var data = matchData[index2];
                  if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                    return false;
                  }
                }
                while (++index2 < length) {
                  data = matchData[index2];
                  var key = data[0], objValue = object[key], srcValue = data[1];
                  if (noCustomizer && data[2]) {
                    if (objValue === undefined$1 && !(key in object)) {
                      return false;
                    }
                  } else {
                    var stack = new Stack();
                    if (customizer) {
                      var result2 = customizer(objValue, srcValue, key, object, source, stack);
                    }
                    if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                      return false;
                    }
                  }
                }
                return true;
              }
              function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) {
                  return false;
                }
                var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
                return pattern.test(toSource(value));
              }
              function baseIsRegExp(value) {
                return isObjectLike(value) && baseGetTag(value) == regexpTag;
              }
              function baseIsSet(value) {
                return isObjectLike(value) && getTag(value) == setTag;
              }
              function baseIsTypedArray(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
              }
              function baseIteratee(value) {
                if (typeof value == "function") {
                  return value;
                }
                if (value == null) {
                  return identity;
                }
                if (typeof value == "object") {
                  return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
                }
                return property(value);
              }
              function baseKeys(object) {
                if (!isPrototype(object)) {
                  return nativeKeys(object);
                }
                var result2 = [];
                for (var key in Object2(object)) {
                  if (hasOwnProperty.call(object, key) && key != "constructor") {
                    result2.push(key);
                  }
                }
                return result2;
              }
              function baseKeysIn(object) {
                if (!isObject(object)) {
                  return nativeKeysIn(object);
                }
                var isProto = isPrototype(object), result2 = [];
                for (var key in object) {
                  if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                    result2.push(key);
                  }
                }
                return result2;
              }
              function baseLt(value, other) {
                return value < other;
              }
              function baseMap(collection, iteratee2) {
                var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
                baseEach(collection, function(value, key, collection2) {
                  result2[++index2] = iteratee2(value, key, collection2);
                });
                return result2;
              }
              function baseMatches(source) {
                var matchData = getMatchData(source);
                if (matchData.length == 1 && matchData[0][2]) {
                  return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                }
                return function(object) {
                  return object === source || baseIsMatch(object, source, matchData);
                };
              }
              function baseMatchesProperty(path, srcValue) {
                if (isKey(path) && isStrictComparable(srcValue)) {
                  return matchesStrictComparable(toKey(path), srcValue);
                }
                return function(object) {
                  var objValue = get(object, path);
                  return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                };
              }
              function baseMerge(object, source, srcIndex, customizer, stack) {
                if (object === source) {
                  return;
                }
                baseFor(source, function(srcValue, key) {
                  stack || (stack = new Stack());
                  if (isObject(srcValue)) {
                    baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                  } else {
                    var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
                    if (newValue === undefined$1) {
                      newValue = srcValue;
                    }
                    assignMergeValue(object, key, newValue);
                  }
                }, keysIn);
              }
              function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
                if (stacked) {
                  assignMergeValue(object, key, stacked);
                  return;
                }
                var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
                var isCommon = newValue === undefined$1;
                if (isCommon) {
                  var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                  newValue = srcValue;
                  if (isArr || isBuff || isTyped) {
                    if (isArray(objValue)) {
                      newValue = objValue;
                    } else if (isArrayLikeObject(objValue)) {
                      newValue = copyArray(objValue);
                    } else if (isBuff) {
                      isCommon = false;
                      newValue = cloneBuffer(srcValue, true);
                    } else if (isTyped) {
                      isCommon = false;
                      newValue = cloneTypedArray(srcValue, true);
                    } else {
                      newValue = [];
                    }
                  } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    newValue = objValue;
                    if (isArguments(objValue)) {
                      newValue = toPlainObject(objValue);
                    } else if (!isObject(objValue) || isFunction2(objValue)) {
                      newValue = initCloneObject(srcValue);
                    }
                  } else {
                    isCommon = false;
                  }
                }
                if (isCommon) {
                  stack.set(srcValue, newValue);
                  mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                  stack["delete"](srcValue);
                }
                assignMergeValue(object, key, newValue);
              }
              function baseNth(array, n) {
                var length = array.length;
                if (!length) {
                  return;
                }
                n += n < 0 ? length : 0;
                return isIndex(n, length) ? array[n] : undefined$1;
              }
              function baseOrderBy(collection, iteratees, orders) {
                if (iteratees.length) {
                  iteratees = arrayMap(iteratees, function(iteratee2) {
                    if (isArray(iteratee2)) {
                      return function(value) {
                        return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                      };
                    }
                    return iteratee2;
                  });
                } else {
                  iteratees = [identity];
                }
                var index2 = -1;
                iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                var result2 = baseMap(collection, function(value, key, collection2) {
                  var criteria = arrayMap(iteratees, function(iteratee2) {
                    return iteratee2(value);
                  });
                  return { "criteria": criteria, "index": ++index2, "value": value };
                });
                return baseSortBy(result2, function(object, other) {
                  return compareMultiple(object, other, orders);
                });
              }
              function basePick(object, paths) {
                return basePickBy(object, paths, function(value, path) {
                  return hasIn(object, path);
                });
              }
              function basePickBy(object, paths, predicate) {
                var index2 = -1, length = paths.length, result2 = {};
                while (++index2 < length) {
                  var path = paths[index2], value = baseGet(object, path);
                  if (predicate(value, path)) {
                    baseSet(result2, castPath(path, object), value);
                  }
                }
                return result2;
              }
              function basePropertyDeep(path) {
                return function(object) {
                  return baseGet(object, path);
                };
              }
              function basePullAll(array, values2, iteratee2, comparator) {
                var indexOf3 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen2 = array;
                if (array === values2) {
                  values2 = copyArray(values2);
                }
                if (iteratee2) {
                  seen2 = arrayMap(array, baseUnary(iteratee2));
                }
                while (++index2 < length) {
                  var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
                  while ((fromIndex = indexOf3(seen2, computed, fromIndex, comparator)) > -1) {
                    if (seen2 !== array) {
                      splice.call(seen2, fromIndex, 1);
                    }
                    splice.call(array, fromIndex, 1);
                  }
                }
                return array;
              }
              function basePullAt(array, indexes) {
                var length = array ? indexes.length : 0, lastIndex = length - 1;
                while (length--) {
                  var index2 = indexes[length];
                  if (length == lastIndex || index2 !== previous) {
                    var previous = index2;
                    if (isIndex(index2)) {
                      splice.call(array, index2, 1);
                    } else {
                      baseUnset(array, index2);
                    }
                  }
                }
                return array;
              }
              function baseRandom(lower, upper) {
                return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
              }
              function baseRange(start, end, step, fromRight) {
                var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
                while (length--) {
                  result2[fromRight ? length : ++index2] = start;
                  start += step;
                }
                return result2;
              }
              function baseRepeat(string, n) {
                var result2 = "";
                if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                  return result2;
                }
                do {
                  if (n % 2) {
                    result2 += string;
                  }
                  n = nativeFloor(n / 2);
                  if (n) {
                    string += string;
                  }
                } while (n);
                return result2;
              }
              function baseRest(func, start) {
                return setToString(overRest(func, start, identity), func + "");
              }
              function baseSample(collection) {
                return arraySample(values(collection));
              }
              function baseSampleSize(collection, n) {
                var array = values(collection);
                return shuffleSelf(array, baseClamp(n, 0, array.length));
              }
              function baseSet(object, path, value, customizer) {
                if (!isObject(object)) {
                  return object;
                }
                path = castPath(path, object);
                var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
                while (nested != null && ++index2 < length) {
                  var key = toKey(path[index2]), newValue = value;
                  if (key === "__proto__" || key === "constructor" || key === "prototype") {
                    return object;
                  }
                  if (index2 != lastIndex) {
                    var objValue = nested[key];
                    newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
                    if (newValue === undefined$1) {
                      newValue = isObject(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
                    }
                  }
                  assignValue(nested, key, newValue);
                  nested = nested[key];
                }
                return object;
              }
              var baseSetData = !metaMap ? identity : function(func, data) {
                metaMap.set(func, data);
                return func;
              };
              var baseSetToString = !defineProperty2 ? identity : function(func, string) {
                return defineProperty2(func, "toString", {
                  "configurable": true,
                  "enumerable": false,
                  "value": constant(string),
                  "writable": true
                });
              };
              function baseShuffle(collection) {
                return shuffleSelf(values(collection));
              }
              function baseSlice(array, start, end) {
                var index2 = -1, length = array.length;
                if (start < 0) {
                  start = -start > length ? 0 : length + start;
                }
                end = end > length ? length : end;
                if (end < 0) {
                  end += length;
                }
                length = start > end ? 0 : end - start >>> 0;
                start >>>= 0;
                var result2 = Array2(length);
                while (++index2 < length) {
                  result2[index2] = array[index2 + start];
                }
                return result2;
              }
              function baseSome(collection, predicate) {
                var result2;
                baseEach(collection, function(value, index2, collection2) {
                  result2 = predicate(value, index2, collection2);
                  return !result2;
                });
                return !!result2;
              }
              function baseSortedIndex(array, value, retHighest) {
                var low = 0, high = array == null ? low : array.length;
                if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                  while (low < high) {
                    var mid = low + high >>> 1, computed = array[mid];
                    if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                      low = mid + 1;
                    } else {
                      high = mid;
                    }
                  }
                  return high;
                }
                return baseSortedIndexBy(array, value, identity, retHighest);
              }
              function baseSortedIndexBy(array, value, iteratee2, retHighest) {
                var low = 0, high = array == null ? 0 : array.length;
                if (high === 0) {
                  return 0;
                }
                value = iteratee2(value);
                var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
                while (low < high) {
                  var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                  if (valIsNaN) {
                    var setLow = retHighest || othIsReflexive;
                  } else if (valIsUndefined) {
                    setLow = othIsReflexive && (retHighest || othIsDefined);
                  } else if (valIsNull) {
                    setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                  } else if (valIsSymbol) {
                    setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                  } else if (othIsNull || othIsSymbol) {
                    setLow = false;
                  } else {
                    setLow = retHighest ? computed <= value : computed < value;
                  }
                  if (setLow) {
                    low = mid + 1;
                  } else {
                    high = mid;
                  }
                }
                return nativeMin(high, MAX_ARRAY_INDEX);
              }
              function baseSortedUniq(array, iteratee2) {
                var index2 = -1, length = array.length, resIndex = 0, result2 = [];
                while (++index2 < length) {
                  var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
                  if (!index2 || !eq(computed, seen2)) {
                    var seen2 = computed;
                    result2[resIndex++] = value === 0 ? 0 : value;
                  }
                }
                return result2;
              }
              function baseToNumber(value) {
                if (typeof value == "number") {
                  return value;
                }
                if (isSymbol(value)) {
                  return NAN;
                }
                return +value;
              }
              function baseToString(value) {
                if (typeof value == "string") {
                  return value;
                }
                if (isArray(value)) {
                  return arrayMap(value, baseToString) + "";
                }
                if (isSymbol(value)) {
                  return symbolToString ? symbolToString.call(value) : "";
                }
                var result2 = value + "";
                return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
              }
              function baseUniq(array, iteratee2, comparator) {
                var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen2 = result2;
                if (comparator) {
                  isCommon = false;
                  includes2 = arrayIncludesWith;
                } else if (length >= LARGE_ARRAY_SIZE) {
                  var set2 = iteratee2 ? null : createSet(array);
                  if (set2) {
                    return setToArray(set2);
                  }
                  isCommon = false;
                  includes2 = cacheHas;
                  seen2 = new SetCache();
                } else {
                  seen2 = iteratee2 ? [] : result2;
                }
                outer:
                  while (++index2 < length) {
                    var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed === computed) {
                      var seenIndex = seen2.length;
                      while (seenIndex--) {
                        if (seen2[seenIndex] === computed) {
                          continue outer;
                        }
                      }
                      if (iteratee2) {
                        seen2.push(computed);
                      }
                      result2.push(value);
                    } else if (!includes2(seen2, computed, comparator)) {
                      if (seen2 !== result2) {
                        seen2.push(computed);
                      }
                      result2.push(value);
                    }
                  }
                return result2;
              }
              function baseUnset(object, path) {
                path = castPath(path, object);
                object = parent(object, path);
                return object == null || delete object[toKey(last(path))];
              }
              function baseUpdate(object, path, updater, customizer) {
                return baseSet(object, path, updater(baseGet(object, path)), customizer);
              }
              function baseWhile(array, predicate, isDrop, fromRight) {
                var length = array.length, index2 = fromRight ? length : -1;
                while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
                }
                return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
              }
              function baseWrapperValue(value, actions) {
                var result2 = value;
                if (result2 instanceof LazyWrapper) {
                  result2 = result2.value();
                }
                return arrayReduce(actions, function(result3, action) {
                  return action.func.apply(action.thisArg, arrayPush([result3], action.args));
                }, result2);
              }
              function baseXor(arrays, iteratee2, comparator) {
                var length = arrays.length;
                if (length < 2) {
                  return length ? baseUniq(arrays[0]) : [];
                }
                var index2 = -1, result2 = Array2(length);
                while (++index2 < length) {
                  var array = arrays[index2], othIndex = -1;
                  while (++othIndex < length) {
                    if (othIndex != index2) {
                      result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
                    }
                  }
                }
                return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
              }
              function baseZipObject(props, values2, assignFunc) {
                var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
                while (++index2 < length) {
                  var value = index2 < valsLength ? values2[index2] : undefined$1;
                  assignFunc(result2, props[index2], value);
                }
                return result2;
              }
              function castArrayLikeObject(value) {
                return isArrayLikeObject(value) ? value : [];
              }
              function castFunction(value) {
                return typeof value == "function" ? value : identity;
              }
              function castPath(value, object) {
                if (isArray(value)) {
                  return value;
                }
                return isKey(value, object) ? [value] : stringToPath(toString(value));
              }
              var castRest = baseRest;
              function castSlice(array, start, end) {
                var length = array.length;
                end = end === undefined$1 ? length : end;
                return !start && end >= length ? array : baseSlice(array, start, end);
              }
              var clearTimeout = ctxClearTimeout || function(id) {
                return root.clearTimeout(id);
              };
              function cloneBuffer(buffer, isDeep) {
                if (isDeep) {
                  return buffer.slice();
                }
                var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                buffer.copy(result2);
                return result2;
              }
              function cloneArrayBuffer(arrayBuffer) {
                var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
                new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
                return result2;
              }
              function cloneDataView(dataView, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
              }
              function cloneRegExp(regexp) {
                var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                result2.lastIndex = regexp.lastIndex;
                return result2;
              }
              function cloneSymbol(symbol) {
                return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
              }
              function cloneTypedArray(typedArray, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
              }
              function compareAscending(value, other) {
                if (value !== other) {
                  var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
                  var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                  if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                    return 1;
                  }
                  if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                    return -1;
                  }
                }
                return 0;
              }
              function compareMultiple(object, other, orders) {
                var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
                while (++index2 < length) {
                  var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
                  if (result2) {
                    if (index2 >= ordersLength) {
                      return result2;
                    }
                    var order = orders[index2];
                    return result2 * (order == "desc" ? -1 : 1);
                  }
                }
                return object.index - other.index;
              }
              function composeArgs(args, partials, holders, isCurried) {
                var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
                while (++leftIndex < leftLength) {
                  result2[leftIndex] = partials[leftIndex];
                }
                while (++argsIndex < holdersLength) {
                  if (isUncurried || argsIndex < argsLength) {
                    result2[holders[argsIndex]] = args[argsIndex];
                  }
                }
                while (rangeLength--) {
                  result2[leftIndex++] = args[argsIndex++];
                }
                return result2;
              }
              function composeArgsRight(args, partials, holders, isCurried) {
                var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
                while (++argsIndex < rangeLength) {
                  result2[argsIndex] = args[argsIndex];
                }
                var offset = argsIndex;
                while (++rightIndex < rightLength) {
                  result2[offset + rightIndex] = partials[rightIndex];
                }
                while (++holdersIndex < holdersLength) {
                  if (isUncurried || argsIndex < argsLength) {
                    result2[offset + holders[holdersIndex]] = args[argsIndex++];
                  }
                }
                return result2;
              }
              function copyArray(source, array) {
                var index2 = -1, length = source.length;
                array || (array = Array2(length));
                while (++index2 < length) {
                  array[index2] = source[index2];
                }
                return array;
              }
              function copyObject(source, props, object, customizer) {
                var isNew = !object;
                object || (object = {});
                var index2 = -1, length = props.length;
                while (++index2 < length) {
                  var key = props[index2];
                  var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
                  if (newValue === undefined$1) {
                    newValue = source[key];
                  }
                  if (isNew) {
                    baseAssignValue(object, key, newValue);
                  } else {
                    assignValue(object, key, newValue);
                  }
                }
                return object;
              }
              function copySymbols(source, object) {
                return copyObject(source, getSymbols(source), object);
              }
              function copySymbolsIn(source, object) {
                return copyObject(source, getSymbolsIn(source), object);
              }
              function createAggregator(setter, initializer) {
                return function(collection, iteratee2) {
                  var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                  return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
                };
              }
              function createAssigner(assigner) {
                return baseRest(function(object, sources) {
                  var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
                  customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
                  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? undefined$1 : customizer;
                    length = 1;
                  }
                  object = Object2(object);
                  while (++index2 < length) {
                    var source = sources[index2];
                    if (source) {
                      assigner(object, source, index2, customizer);
                    }
                  }
                  return object;
                });
              }
              function createBaseEach(eachFunc, fromRight) {
                return function(collection, iteratee2) {
                  if (collection == null) {
                    return collection;
                  }
                  if (!isArrayLike(collection)) {
                    return eachFunc(collection, iteratee2);
                  }
                  var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
                  while (fromRight ? index2-- : ++index2 < length) {
                    if (iteratee2(iterable[index2], index2, iterable) === false) {
                      break;
                    }
                  }
                  return collection;
                };
              }
              function createBaseFor(fromRight) {
                return function(object, iteratee2, keysFunc) {
                  var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
                  while (length--) {
                    var key = props[fromRight ? length : ++index2];
                    if (iteratee2(iterable[key], key, iterable) === false) {
                      break;
                    }
                  }
                  return object;
                };
              }
              function createBind(func, bitmask, thisArg) {
                var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                function wrapper() {
                  var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                  return fn.apply(isBind ? thisArg : this, arguments);
                }
                return wrapper;
              }
              function createCaseFirst(methodName) {
                return function(string) {
                  string = toString(string);
                  var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
                  var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                  var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                  return chr[methodName]() + trailing;
                };
              }
              function createCompounder(callback) {
                return function(string) {
                  return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
                };
              }
              function createCtor(Ctor) {
                return function() {
                  var args = arguments;
                  switch (args.length) {
                    case 0:
                      return new Ctor();
                    case 1:
                      return new Ctor(args[0]);
                    case 2:
                      return new Ctor(args[0], args[1]);
                    case 3:
                      return new Ctor(args[0], args[1], args[2]);
                    case 4:
                      return new Ctor(args[0], args[1], args[2], args[3]);
                    case 5:
                      return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                    case 6:
                      return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                    case 7:
                      return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                  }
                  var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
                  return isObject(result2) ? result2 : thisBinding;
                };
              }
              function createCurry(func, bitmask, arity) {
                var Ctor = createCtor(func);
                function wrapper() {
                  var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
                  while (index2--) {
                    args[index2] = arguments[index2];
                  }
                  var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                  length -= holders.length;
                  if (length < arity) {
                    return createRecurry(
                      func,
                      bitmask,
                      createHybrid,
                      wrapper.placeholder,
                      undefined$1,
                      args,
                      holders,
                      undefined$1,
                      undefined$1,
                      arity - length
                    );
                  }
                  var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                  return apply(fn, this, args);
                }
                return wrapper;
              }
              function createFind(findIndexFunc) {
                return function(collection, predicate, fromIndex) {
                  var iterable = Object2(collection);
                  if (!isArrayLike(collection)) {
                    var iteratee2 = getIteratee(predicate, 3);
                    collection = keys(collection);
                    predicate = function(key) {
                      return iteratee2(iterable[key], key, iterable);
                    };
                  }
                  var index2 = findIndexFunc(collection, predicate, fromIndex);
                  return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
                };
              }
              function createFlow(fromRight) {
                return flatRest(function(funcs) {
                  var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
                  if (fromRight) {
                    funcs.reverse();
                  }
                  while (index2--) {
                    var func = funcs[index2];
                    if (typeof func != "function") {
                      throw new TypeError2(FUNC_ERROR_TEXT);
                    }
                    if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                      var wrapper = new LodashWrapper([], true);
                    }
                  }
                  index2 = wrapper ? index2 : length;
                  while (++index2 < length) {
                    func = funcs[index2];
                    var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
                    if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                      wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                    } else {
                      wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                    }
                  }
                  return function() {
                    var args = arguments, value = args[0];
                    if (wrapper && args.length == 1 && isArray(value)) {
                      return wrapper.plant(value).value();
                    }
                    var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
                    while (++index3 < length) {
                      result2 = funcs[index3].call(this, result2);
                    }
                    return result2;
                  };
                });
              }
              function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
                var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
                function wrapper() {
                  var length = arguments.length, args = Array2(length), index2 = length;
                  while (index2--) {
                    args[index2] = arguments[index2];
                  }
                  if (isCurried) {
                    var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                  }
                  if (partials) {
                    args = composeArgs(args, partials, holders, isCurried);
                  }
                  if (partialsRight) {
                    args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                  }
                  length -= holdersCount;
                  if (isCurried && length < arity) {
                    var newHolders = replaceHolders(args, placeholder);
                    return createRecurry(
                      func,
                      bitmask,
                      createHybrid,
                      wrapper.placeholder,
                      thisArg,
                      args,
                      newHolders,
                      argPos,
                      ary2,
                      arity - length
                    );
                  }
                  var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                  length = args.length;
                  if (argPos) {
                    args = reorder(args, argPos);
                  } else if (isFlip && length > 1) {
                    args.reverse();
                  }
                  if (isAry && ary2 < length) {
                    args.length = ary2;
                  }
                  if (this && this !== root && this instanceof wrapper) {
                    fn = Ctor || createCtor(fn);
                  }
                  return fn.apply(thisBinding, args);
                }
                return wrapper;
              }
              function createInverter(setter, toIteratee) {
                return function(object, iteratee2) {
                  return baseInverter(object, setter, toIteratee(iteratee2), {});
                };
              }
              function createMathOperation(operator, defaultValue) {
                return function(value, other) {
                  var result2;
                  if (value === undefined$1 && other === undefined$1) {
                    return defaultValue;
                  }
                  if (value !== undefined$1) {
                    result2 = value;
                  }
                  if (other !== undefined$1) {
                    if (result2 === undefined$1) {
                      return other;
                    }
                    if (typeof value == "string" || typeof other == "string") {
                      value = baseToString(value);
                      other = baseToString(other);
                    } else {
                      value = baseToNumber(value);
                      other = baseToNumber(other);
                    }
                    result2 = operator(value, other);
                  }
                  return result2;
                };
              }
              function createOver(arrayFunc) {
                return flatRest(function(iteratees) {
                  iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                  return baseRest(function(args) {
                    var thisArg = this;
                    return arrayFunc(iteratees, function(iteratee2) {
                      return apply(iteratee2, thisArg, args);
                    });
                  });
                });
              }
              function createPadding(length, chars) {
                chars = chars === undefined$1 ? " " : baseToString(chars);
                var charsLength = chars.length;
                if (charsLength < 2) {
                  return charsLength ? baseRepeat(chars, length) : chars;
                }
                var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
              }
              function createPartial(func, bitmask, thisArg, partials) {
                var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                function wrapper() {
                  var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                  while (++leftIndex < leftLength) {
                    args[leftIndex] = partials[leftIndex];
                  }
                  while (argsLength--) {
                    args[leftIndex++] = arguments[++argsIndex];
                  }
                  return apply(fn, isBind ? thisArg : this, args);
                }
                return wrapper;
              }
              function createRange(fromRight) {
                return function(start, end, step) {
                  if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                    end = step = undefined$1;
                  }
                  start = toFinite(start);
                  if (end === undefined$1) {
                    end = start;
                    start = 0;
                  } else {
                    end = toFinite(end);
                  }
                  step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
                  return baseRange(start, end, step, fromRight);
                };
              }
              function createRelationalOperation(operator) {
                return function(value, other) {
                  if (!(typeof value == "string" && typeof other == "string")) {
                    value = toNumber(value);
                    other = toNumber(other);
                  }
                  return operator(value, other);
                };
              }
              function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
                var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
                bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
                bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
                if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                  bitmask &= -4;
                }
                var newData = [
                  func,
                  bitmask,
                  thisArg,
                  newPartials,
                  newHolders,
                  newPartialsRight,
                  newHoldersRight,
                  argPos,
                  ary2,
                  arity
                ];
                var result2 = wrapFunc.apply(undefined$1, newData);
                if (isLaziable(func)) {
                  setData(result2, newData);
                }
                result2.placeholder = placeholder;
                return setWrapToString(result2, func, bitmask);
              }
              function createRound(methodName) {
                var func = Math2[methodName];
                return function(number, precision) {
                  number = toNumber(number);
                  precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
                  if (precision && nativeIsFinite(number)) {
                    var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                    pair = (toString(value) + "e").split("e");
                    return +(pair[0] + "e" + (+pair[1] - precision));
                  }
                  return func(number);
                };
              }
              var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
                return new Set2(values2);
              };
              function createToPairs(keysFunc) {
                return function(object) {
                  var tag = getTag(object);
                  if (tag == mapTag) {
                    return mapToArray(object);
                  }
                  if (tag == setTag) {
                    return setToPairs(object);
                  }
                  return baseToPairs(object, keysFunc(object));
                };
              }
              function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
                var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                if (!isBindKey && typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                var length = partials ? partials.length : 0;
                if (!length) {
                  bitmask &= -97;
                  partials = holders = undefined$1;
                }
                ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
                arity = arity === undefined$1 ? arity : toInteger(arity);
                length -= holders ? holders.length : 0;
                if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                  var partialsRight = partials, holdersRight = holders;
                  partials = holders = undefined$1;
                }
                var data = isBindKey ? undefined$1 : getData(func);
                var newData = [
                  func,
                  bitmask,
                  thisArg,
                  partials,
                  holders,
                  partialsRight,
                  holdersRight,
                  argPos,
                  ary2,
                  arity
                ];
                if (data) {
                  mergeData(newData, data);
                }
                func = newData[0];
                bitmask = newData[1];
                thisArg = newData[2];
                partials = newData[3];
                holders = newData[4];
                arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
                if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                  bitmask &= -25;
                }
                if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                  var result2 = createBind(func, bitmask, thisArg);
                } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                  result2 = createCurry(func, bitmask, arity);
                } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                  result2 = createPartial(func, bitmask, thisArg, partials);
                } else {
                  result2 = createHybrid.apply(undefined$1, newData);
                }
                var setter = data ? baseSetData : setData;
                return setWrapToString(setter(result2, newData), func, bitmask);
              }
              function customDefaultsAssignIn(objValue, srcValue, key, object) {
                if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  return srcValue;
                }
                return objValue;
              }
              function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
                if (isObject(objValue) && isObject(srcValue)) {
                  stack.set(srcValue, objValue);
                  baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
                  stack["delete"](srcValue);
                }
                return objValue;
              }
              function customOmitClone(value) {
                return isPlainObject(value) ? undefined$1 : value;
              }
              function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                  return false;
                }
                var arrStacked = stack.get(array);
                var othStacked = stack.get(other);
                if (arrStacked && othStacked) {
                  return arrStacked == other && othStacked == array;
                }
                var index2 = -1, result2 = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
                stack.set(array, other);
                stack.set(other, array);
                while (++index2 < arrLength) {
                  var arrValue = array[index2], othValue = other[index2];
                  if (customizer) {
                    var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
                  }
                  if (compared !== undefined$1) {
                    if (compared) {
                      continue;
                    }
                    result2 = false;
                    break;
                  }
                  if (seen2) {
                    if (!arraySome(other, function(othValue2, othIndex) {
                      if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                        return seen2.push(othIndex);
                      }
                    })) {
                      result2 = false;
                      break;
                    }
                  } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                    result2 = false;
                    break;
                  }
                }
                stack["delete"](array);
                stack["delete"](other);
                return result2;
              }
              function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                switch (tag) {
                  case dataViewTag:
                    if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                      return false;
                    }
                    object = object.buffer;
                    other = other.buffer;
                  case arrayBufferTag:
                    if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                      return false;
                    }
                    return true;
                  case boolTag:
                  case dateTag:
                  case numberTag:
                    return eq(+object, +other);
                  case errorTag:
                    return object.name == other.name && object.message == other.message;
                  case regexpTag:
                  case stringTag:
                    return object == other + "";
                  case mapTag:
                    var convert = mapToArray;
                  case setTag:
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                    convert || (convert = setToArray);
                    if (object.size != other.size && !isPartial) {
                      return false;
                    }
                    var stacked = stack.get(object);
                    if (stacked) {
                      return stacked == other;
                    }
                    bitmask |= COMPARE_UNORDERED_FLAG;
                    stack.set(object, other);
                    var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                    stack["delete"](object);
                    return result2;
                  case symbolTag:
                    if (symbolValueOf) {
                      return symbolValueOf.call(object) == symbolValueOf.call(other);
                    }
                }
                return false;
              }
              function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                if (objLength != othLength && !isPartial) {
                  return false;
                }
                var index2 = objLength;
                while (index2--) {
                  var key = objProps[index2];
                  if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                    return false;
                  }
                }
                var objStacked = stack.get(object);
                var othStacked = stack.get(other);
                if (objStacked && othStacked) {
                  return objStacked == other && othStacked == object;
                }
                var result2 = true;
                stack.set(object, other);
                stack.set(other, object);
                var skipCtor = isPartial;
                while (++index2 < objLength) {
                  key = objProps[index2];
                  var objValue = object[key], othValue = other[key];
                  if (customizer) {
                    var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                  }
                  if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                    result2 = false;
                    break;
                  }
                  skipCtor || (skipCtor = key == "constructor");
                }
                if (result2 && !skipCtor) {
                  var objCtor = object.constructor, othCtor = other.constructor;
                  if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                    result2 = false;
                  }
                }
                stack["delete"](object);
                stack["delete"](other);
                return result2;
              }
              function flatRest(func) {
                return setToString(overRest(func, undefined$1, flatten), func + "");
              }
              function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols);
              }
              function getAllKeysIn(object) {
                return baseGetAllKeys(object, keysIn, getSymbolsIn);
              }
              var getData = !metaMap ? noop : function(func) {
                return metaMap.get(func);
              };
              function getFuncName(func) {
                var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
                while (length--) {
                  var data = array[length], otherFunc = data.func;
                  if (otherFunc == null || otherFunc == func) {
                    return data.name;
                  }
                }
                return result2;
              }
              function getHolder(func) {
                var object = hasOwnProperty.call(lodash2, "placeholder") ? lodash2 : func;
                return object.placeholder;
              }
              function getIteratee() {
                var result2 = lodash2.iteratee || iteratee;
                result2 = result2 === iteratee ? baseIteratee : result2;
                return arguments.length ? result2(arguments[0], arguments[1]) : result2;
              }
              function getMapData(map2, key) {
                var data = map2.__data__;
                return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
              }
              function getMatchData(object) {
                var result2 = keys(object), length = result2.length;
                while (length--) {
                  var key = result2[length], value = object[key];
                  result2[length] = [key, value, isStrictComparable(value)];
                }
                return result2;
              }
              function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : undefined$1;
              }
              function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                try {
                  value[symToStringTag] = undefined$1;
                  var unmasked = true;
                } catch (e) {
                }
                var result2 = nativeObjectToString.call(value);
                if (unmasked) {
                  if (isOwn) {
                    value[symToStringTag] = tag;
                  } else {
                    delete value[symToStringTag];
                  }
                }
                return result2;
              }
              var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
                if (object == null) {
                  return [];
                }
                object = Object2(object);
                return arrayFilter(nativeGetSymbols(object), function(symbol) {
                  return propertyIsEnumerable.call(object, symbol);
                });
              };
              var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
                var result2 = [];
                while (object) {
                  arrayPush(result2, getSymbols(object));
                  object = getPrototype(object);
                }
                return result2;
              };
              var getTag = baseGetTag;
              if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
                getTag = function(value) {
                  var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
                  if (ctorString) {
                    switch (ctorString) {
                      case dataViewCtorString:
                        return dataViewTag;
                      case mapCtorString:
                        return mapTag;
                      case promiseCtorString:
                        return promiseTag;
                      case setCtorString:
                        return setTag;
                      case weakMapCtorString:
                        return weakMapTag;
                    }
                  }
                  return result2;
                };
              }
              function getView(start, end, transforms) {
                var index2 = -1, length = transforms.length;
                while (++index2 < length) {
                  var data = transforms[index2], size2 = data.size;
                  switch (data.type) {
                    case "drop":
                      start += size2;
                      break;
                    case "dropRight":
                      end -= size2;
                      break;
                    case "take":
                      end = nativeMin(end, start + size2);
                      break;
                    case "takeRight":
                      start = nativeMax(start, end - size2);
                      break;
                  }
                }
                return { "start": start, "end": end };
              }
              function getWrapDetails(source) {
                var match = source.match(reWrapDetails);
                return match ? match[1].split(reSplitDetails) : [];
              }
              function hasPath(object, path, hasFunc) {
                path = castPath(path, object);
                var index2 = -1, length = path.length, result2 = false;
                while (++index2 < length) {
                  var key = toKey(path[index2]);
                  if (!(result2 = object != null && hasFunc(object, key))) {
                    break;
                  }
                  object = object[key];
                }
                if (result2 || ++index2 != length) {
                  return result2;
                }
                length = object == null ? 0 : object.length;
                return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
              }
              function initCloneArray(array) {
                var length = array.length, result2 = new array.constructor(length);
                if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                  result2.index = array.index;
                  result2.input = array.input;
                }
                return result2;
              }
              function initCloneObject(object) {
                return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
              }
              function initCloneByTag(object, tag, isDeep) {
                var Ctor = object.constructor;
                switch (tag) {
                  case arrayBufferTag:
                    return cloneArrayBuffer(object);
                  case boolTag:
                  case dateTag:
                    return new Ctor(+object);
                  case dataViewTag:
                    return cloneDataView(object, isDeep);
                  case float32Tag:
                  case float64Tag:
                  case int8Tag:
                  case int16Tag:
                  case int32Tag:
                  case uint8Tag:
                  case uint8ClampedTag:
                  case uint16Tag:
                  case uint32Tag:
                    return cloneTypedArray(object, isDeep);
                  case mapTag:
                    return new Ctor();
                  case numberTag:
                  case stringTag:
                    return new Ctor(object);
                  case regexpTag:
                    return cloneRegExp(object);
                  case setTag:
                    return new Ctor();
                  case symbolTag:
                    return cloneSymbol(object);
                }
              }
              function insertWrapDetails(source, details) {
                var length = details.length;
                if (!length) {
                  return source;
                }
                var lastIndex = length - 1;
                details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
                details = details.join(length > 2 ? ", " : " ");
                return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
              }
              function isFlattenable(value) {
                return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
              }
              function isIndex(value, length) {
                var type = typeof value;
                length = length == null ? MAX_SAFE_INTEGER : length;
                return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
              }
              function isIterateeCall(value, index2, object) {
                if (!isObject(object)) {
                  return false;
                }
                var type = typeof index2;
                if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
                  return eq(object[index2], value);
                }
                return false;
              }
              function isKey(value, object) {
                if (isArray(value)) {
                  return false;
                }
                var type = typeof value;
                if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
                  return true;
                }
                return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
              }
              function isKeyable(value) {
                var type = typeof value;
                return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
              }
              function isLaziable(func) {
                var funcName = getFuncName(func), other = lodash2[funcName];
                if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
                  return false;
                }
                if (func === other) {
                  return true;
                }
                var data = getData(other);
                return !!data && func === data[0];
              }
              function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
              }
              var isMaskable = coreJsData ? isFunction2 : stubFalse;
              function isPrototype(value) {
                var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
                return value === proto;
              }
              function isStrictComparable(value) {
                return value === value && !isObject(value);
              }
              function matchesStrictComparable(key, srcValue) {
                return function(object) {
                  if (object == null) {
                    return false;
                  }
                  return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
                };
              }
              function memoizeCapped(func) {
                var result2 = memoize(func, function(key) {
                  if (cache.size === MAX_MEMOIZE_SIZE) {
                    cache.clear();
                  }
                  return key;
                });
                var cache = result2.cache;
                return result2;
              }
              function mergeData(data, source) {
                var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
                var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
                if (!(isCommon || isCombo)) {
                  return data;
                }
                if (srcBitmask & WRAP_BIND_FLAG) {
                  data[2] = source[2];
                  newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                }
                var value = source[3];
                if (value) {
                  var partials = data[3];
                  data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                  data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                }
                value = source[5];
                if (value) {
                  partials = data[5];
                  data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                  data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                }
                value = source[7];
                if (value) {
                  data[7] = value;
                }
                if (srcBitmask & WRAP_ARY_FLAG) {
                  data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                }
                if (data[9] == null) {
                  data[9] = source[9];
                }
                data[0] = source[0];
                data[1] = newBitmask;
                return data;
              }
              function nativeKeysIn(object) {
                var result2 = [];
                if (object != null) {
                  for (var key in Object2(object)) {
                    result2.push(key);
                  }
                }
                return result2;
              }
              function objectToString2(value) {
                return nativeObjectToString.call(value);
              }
              function overRest(func, start, transform2) {
                start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
                return function() {
                  var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
                  while (++index2 < length) {
                    array[index2] = args[start + index2];
                  }
                  index2 = -1;
                  var otherArgs = Array2(start + 1);
                  while (++index2 < start) {
                    otherArgs[index2] = args[index2];
                  }
                  otherArgs[start] = transform2(array);
                  return apply(func, this, otherArgs);
                };
              }
              function parent(object, path) {
                return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
              }
              function reorder(array, indexes) {
                var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
                while (length--) {
                  var index2 = indexes[length];
                  array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
                }
                return array;
              }
              function safeGet(object, key) {
                if (key === "constructor" && typeof object[key] === "function") {
                  return;
                }
                if (key == "__proto__") {
                  return;
                }
                return object[key];
              }
              var setData = shortOut(baseSetData);
              var setTimeout2 = ctxSetTimeout || function(func, wait) {
                return root.setTimeout(func, wait);
              };
              var setToString = shortOut(baseSetToString);
              function setWrapToString(wrapper, reference, bitmask) {
                var source = reference + "";
                return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
              }
              function shortOut(func) {
                var count = 0, lastCalled = 0;
                return function() {
                  var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                  lastCalled = stamp;
                  if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                      return arguments[0];
                    }
                  } else {
                    count = 0;
                  }
                  return func.apply(undefined$1, arguments);
                };
              }
              function shuffleSelf(array, size2) {
                var index2 = -1, length = array.length, lastIndex = length - 1;
                size2 = size2 === undefined$1 ? length : size2;
                while (++index2 < size2) {
                  var rand = baseRandom(index2, lastIndex), value = array[rand];
                  array[rand] = array[index2];
                  array[index2] = value;
                }
                array.length = size2;
                return array;
              }
              var stringToPath = memoizeCapped(function(string) {
                var result2 = [];
                if (string.charCodeAt(0) === 46) {
                  result2.push("");
                }
                string.replace(rePropName, function(match, number, quote, subString) {
                  result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
                });
                return result2;
              });
              function toKey(value) {
                if (typeof value == "string" || isSymbol(value)) {
                  return value;
                }
                var result2 = value + "";
                return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
              }
              function toSource(func) {
                if (func != null) {
                  try {
                    return funcToString.call(func);
                  } catch (e) {
                  }
                  try {
                    return func + "";
                  } catch (e) {
                  }
                }
                return "";
              }
              function updateWrapDetails(details, bitmask) {
                arrayEach(wrapFlags, function(pair) {
                  var value = "_." + pair[0];
                  if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                    details.push(value);
                  }
                });
                return details.sort();
              }
              function wrapperClone(wrapper) {
                if (wrapper instanceof LazyWrapper) {
                  return wrapper.clone();
                }
                var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                result2.__actions__ = copyArray(wrapper.__actions__);
                result2.__index__ = wrapper.__index__;
                result2.__values__ = wrapper.__values__;
                return result2;
              }
              function chunk(array, size2, guard) {
                if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
                  size2 = 1;
                } else {
                  size2 = nativeMax(toInteger(size2), 0);
                }
                var length = array == null ? 0 : array.length;
                if (!length || size2 < 1) {
                  return [];
                }
                var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
                while (index2 < length) {
                  result2[resIndex++] = baseSlice(array, index2, index2 += size2);
                }
                return result2;
              }
              function compact(array) {
                var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
                while (++index2 < length) {
                  var value = array[index2];
                  if (value) {
                    result2[resIndex++] = value;
                  }
                }
                return result2;
              }
              function concat() {
                var length = arguments.length;
                if (!length) {
                  return [];
                }
                var args = Array2(length - 1), array = arguments[0], index2 = length;
                while (index2--) {
                  args[index2 - 1] = arguments[index2];
                }
                return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
              }
              var difference = baseRest(function(array, values2) {
                return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
              });
              var differenceBy = baseRest(function(array, values2) {
                var iteratee2 = last(values2);
                if (isArrayLikeObject(iteratee2)) {
                  iteratee2 = undefined$1;
                }
                return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
              });
              var differenceWith = baseRest(function(array, values2) {
                var comparator = last(values2);
                if (isArrayLikeObject(comparator)) {
                  comparator = undefined$1;
                }
                return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
              });
              function drop(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined$1 ? 1 : toInteger(n);
                return baseSlice(array, n < 0 ? 0 : n, length);
              }
              function dropRight(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined$1 ? 1 : toInteger(n);
                n = length - n;
                return baseSlice(array, 0, n < 0 ? 0 : n);
              }
              function dropRightWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
              }
              function dropWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
              }
              function fill(array, value, start, end) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
                  start = 0;
                  end = length;
                }
                return baseFill(array, value, start, end);
              }
              function findIndex(array, predicate, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
                if (index2 < 0) {
                  index2 = nativeMax(length + index2, 0);
                }
                return baseFindIndex(array, getIteratee(predicate, 3), index2);
              }
              function findLastIndex(array, predicate, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index2 = length - 1;
                if (fromIndex !== undefined$1) {
                  index2 = toInteger(fromIndex);
                  index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
                }
                return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
              }
              function flatten(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseFlatten(array, 1) : [];
              }
              function flattenDeep(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseFlatten(array, INFINITY) : [];
              }
              function flattenDepth(array, depth) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                depth = depth === undefined$1 ? 1 : toInteger(depth);
                return baseFlatten(array, depth);
              }
              function fromPairs(pairs) {
                var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
                while (++index2 < length) {
                  var pair = pairs[index2];
                  result2[pair[0]] = pair[1];
                }
                return result2;
              }
              function head(array) {
                return array && array.length ? array[0] : undefined$1;
              }
              function indexOf2(array, value, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
                if (index2 < 0) {
                  index2 = nativeMax(length + index2, 0);
                }
                return baseIndexOf(array, value, index2);
              }
              function initial(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseSlice(array, 0, -1) : [];
              }
              var intersection = baseRest(function(arrays) {
                var mapped = arrayMap(arrays, castArrayLikeObject);
                return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
              });
              var intersectionBy = baseRest(function(arrays) {
                var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                if (iteratee2 === last(mapped)) {
                  iteratee2 = undefined$1;
                } else {
                  mapped.pop();
                }
                return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
              });
              var intersectionWith = baseRest(function(arrays) {
                var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                comparator = typeof comparator == "function" ? comparator : undefined$1;
                if (comparator) {
                  mapped.pop();
                }
                return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
              });
              function join(array, separator) {
                return array == null ? "" : nativeJoin.call(array, separator);
              }
              function last(array) {
                var length = array == null ? 0 : array.length;
                return length ? array[length - 1] : undefined$1;
              }
              function lastIndexOf(array, value, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index2 = length;
                if (fromIndex !== undefined$1) {
                  index2 = toInteger(fromIndex);
                  index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
                }
                return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
              }
              function nth(array, n) {
                return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
              }
              var pull = baseRest(pullAll);
              function pullAll(array, values2) {
                return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
              }
              function pullAllBy(array, values2, iteratee2) {
                return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
              }
              function pullAllWith(array, values2, comparator) {
                return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
              }
              var pullAt = flatRest(function(array, indexes) {
                var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
                basePullAt(array, arrayMap(indexes, function(index2) {
                  return isIndex(index2, length) ? +index2 : index2;
                }).sort(compareAscending));
                return result2;
              });
              function remove(array, predicate) {
                var result2 = [];
                if (!(array && array.length)) {
                  return result2;
                }
                var index2 = -1, indexes = [], length = array.length;
                predicate = getIteratee(predicate, 3);
                while (++index2 < length) {
                  var value = array[index2];
                  if (predicate(value, index2, array)) {
                    result2.push(value);
                    indexes.push(index2);
                  }
                }
                basePullAt(array, indexes);
                return result2;
              }
              function reverse(array) {
                return array == null ? array : nativeReverse.call(array);
              }
              function slice(array, start, end) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
                  start = 0;
                  end = length;
                } else {
                  start = start == null ? 0 : toInteger(start);
                  end = end === undefined$1 ? length : toInteger(end);
                }
                return baseSlice(array, start, end);
              }
              function sortedIndex(array, value) {
                return baseSortedIndex(array, value);
              }
              function sortedIndexBy(array, value, iteratee2) {
                return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
              }
              function sortedIndexOf(array, value) {
                var length = array == null ? 0 : array.length;
                if (length) {
                  var index2 = baseSortedIndex(array, value);
                  if (index2 < length && eq(array[index2], value)) {
                    return index2;
                  }
                }
                return -1;
              }
              function sortedLastIndex(array, value) {
                return baseSortedIndex(array, value, true);
              }
              function sortedLastIndexBy(array, value, iteratee2) {
                return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
              }
              function sortedLastIndexOf(array, value) {
                var length = array == null ? 0 : array.length;
                if (length) {
                  var index2 = baseSortedIndex(array, value, true) - 1;
                  if (eq(array[index2], value)) {
                    return index2;
                  }
                }
                return -1;
              }
              function sortedUniq(array) {
                return array && array.length ? baseSortedUniq(array) : [];
              }
              function sortedUniqBy(array, iteratee2) {
                return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
              }
              function tail(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseSlice(array, 1, length) : [];
              }
              function take(array, n, guard) {
                if (!(array && array.length)) {
                  return [];
                }
                n = guard || n === undefined$1 ? 1 : toInteger(n);
                return baseSlice(array, 0, n < 0 ? 0 : n);
              }
              function takeRight(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined$1 ? 1 : toInteger(n);
                n = length - n;
                return baseSlice(array, n < 0 ? 0 : n, length);
              }
              function takeRightWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
              }
              function takeWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
              }
              var union = baseRest(function(arrays) {
                return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
              });
              var unionBy = baseRest(function(arrays) {
                var iteratee2 = last(arrays);
                if (isArrayLikeObject(iteratee2)) {
                  iteratee2 = undefined$1;
                }
                return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
              });
              var unionWith = baseRest(function(arrays) {
                var comparator = last(arrays);
                comparator = typeof comparator == "function" ? comparator : undefined$1;
                return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
              });
              function uniq(array) {
                return array && array.length ? baseUniq(array) : [];
              }
              function uniqBy(array, iteratee2) {
                return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
              }
              function uniqWith(array, comparator) {
                comparator = typeof comparator == "function" ? comparator : undefined$1;
                return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
              }
              function unzip(array) {
                if (!(array && array.length)) {
                  return [];
                }
                var length = 0;
                array = arrayFilter(array, function(group) {
                  if (isArrayLikeObject(group)) {
                    length = nativeMax(group.length, length);
                    return true;
                  }
                });
                return baseTimes(length, function(index2) {
                  return arrayMap(array, baseProperty(index2));
                });
              }
              function unzipWith(array, iteratee2) {
                if (!(array && array.length)) {
                  return [];
                }
                var result2 = unzip(array);
                if (iteratee2 == null) {
                  return result2;
                }
                return arrayMap(result2, function(group) {
                  return apply(iteratee2, undefined$1, group);
                });
              }
              var without = baseRest(function(array, values2) {
                return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
              });
              var xor = baseRest(function(arrays) {
                return baseXor(arrayFilter(arrays, isArrayLikeObject));
              });
              var xorBy = baseRest(function(arrays) {
                var iteratee2 = last(arrays);
                if (isArrayLikeObject(iteratee2)) {
                  iteratee2 = undefined$1;
                }
                return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
              });
              var xorWith = baseRest(function(arrays) {
                var comparator = last(arrays);
                comparator = typeof comparator == "function" ? comparator : undefined$1;
                return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
              });
              var zip = baseRest(unzip);
              function zipObject(props, values2) {
                return baseZipObject(props || [], values2 || [], assignValue);
              }
              function zipObjectDeep(props, values2) {
                return baseZipObject(props || [], values2 || [], baseSet);
              }
              var zipWith = baseRest(function(arrays) {
                var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
                iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
                return unzipWith(arrays, iteratee2);
              });
              function chain(value) {
                var result2 = lodash2(value);
                result2.__chain__ = true;
                return result2;
              }
              function tap(value, interceptor) {
                interceptor(value);
                return value;
              }
              function thru(value, interceptor) {
                return interceptor(value);
              }
              var wrapperAt = flatRest(function(paths) {
                var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
                  return baseAt(object, paths);
                };
                if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
                  return this.thru(interceptor);
                }
                value = value.slice(start, +start + (length ? 1 : 0));
                value.__actions__.push({
                  "func": thru,
                  "args": [interceptor],
                  "thisArg": undefined$1
                });
                return new LodashWrapper(value, this.__chain__).thru(function(array) {
                  if (length && !array.length) {
                    array.push(undefined$1);
                  }
                  return array;
                });
              });
              function wrapperChain() {
                return chain(this);
              }
              function wrapperCommit() {
                return new LodashWrapper(this.value(), this.__chain__);
              }
              function wrapperNext() {
                if (this.__values__ === undefined$1) {
                  this.__values__ = toArray(this.value());
                }
                var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
                return { "done": done, "value": value };
              }
              function wrapperToIterator() {
                return this;
              }
              function wrapperPlant(value) {
                var result2, parent2 = this;
                while (parent2 instanceof baseLodash) {
                  var clone2 = wrapperClone(parent2);
                  clone2.__index__ = 0;
                  clone2.__values__ = undefined$1;
                  if (result2) {
                    previous.__wrapped__ = clone2;
                  } else {
                    result2 = clone2;
                  }
                  var previous = clone2;
                  parent2 = parent2.__wrapped__;
                }
                previous.__wrapped__ = value;
                return result2;
              }
              function wrapperReverse() {
                var value = this.__wrapped__;
                if (value instanceof LazyWrapper) {
                  var wrapped = value;
                  if (this.__actions__.length) {
                    wrapped = new LazyWrapper(this);
                  }
                  wrapped = wrapped.reverse();
                  wrapped.__actions__.push({
                    "func": thru,
                    "args": [reverse],
                    "thisArg": undefined$1
                  });
                  return new LodashWrapper(wrapped, this.__chain__);
                }
                return this.thru(reverse);
              }
              function wrapperValue() {
                return baseWrapperValue(this.__wrapped__, this.__actions__);
              }
              var countBy = createAggregator(function(result2, value, key) {
                if (hasOwnProperty.call(result2, key)) {
                  ++result2[key];
                } else {
                  baseAssignValue(result2, key, 1);
                }
              });
              function every(collection, predicate, guard) {
                var func = isArray(collection) ? arrayEvery : baseEvery;
                if (guard && isIterateeCall(collection, predicate, guard)) {
                  predicate = undefined$1;
                }
                return func(collection, getIteratee(predicate, 3));
              }
              function filter(collection, predicate) {
                var func = isArray(collection) ? arrayFilter : baseFilter;
                return func(collection, getIteratee(predicate, 3));
              }
              var find = createFind(findIndex);
              var findLast = createFind(findLastIndex);
              function flatMap(collection, iteratee2) {
                return baseFlatten(map(collection, iteratee2), 1);
              }
              function flatMapDeep(collection, iteratee2) {
                return baseFlatten(map(collection, iteratee2), INFINITY);
              }
              function flatMapDepth(collection, iteratee2, depth) {
                depth = depth === undefined$1 ? 1 : toInteger(depth);
                return baseFlatten(map(collection, iteratee2), depth);
              }
              function forEach(collection, iteratee2) {
                var func = isArray(collection) ? arrayEach : baseEach;
                return func(collection, getIteratee(iteratee2, 3));
              }
              function forEachRight(collection, iteratee2) {
                var func = isArray(collection) ? arrayEachRight : baseEachRight;
                return func(collection, getIteratee(iteratee2, 3));
              }
              var groupBy = createAggregator(function(result2, value, key) {
                if (hasOwnProperty.call(result2, key)) {
                  result2[key].push(value);
                } else {
                  baseAssignValue(result2, key, [value]);
                }
              });
              function includes(collection, value, fromIndex, guard) {
                collection = isArrayLike(collection) ? collection : values(collection);
                fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                var length = collection.length;
                if (fromIndex < 0) {
                  fromIndex = nativeMax(length + fromIndex, 0);
                }
                return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
              }
              var invokeMap = baseRest(function(collection, path, args) {
                var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
                baseEach(collection, function(value) {
                  result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
                });
                return result2;
              });
              var keyBy = createAggregator(function(result2, value, key) {
                baseAssignValue(result2, key, value);
              });
              function map(collection, iteratee2) {
                var func = isArray(collection) ? arrayMap : baseMap;
                return func(collection, getIteratee(iteratee2, 3));
              }
              function orderBy(collection, iteratees, orders, guard) {
                if (collection == null) {
                  return [];
                }
                if (!isArray(iteratees)) {
                  iteratees = iteratees == null ? [] : [iteratees];
                }
                orders = guard ? undefined$1 : orders;
                if (!isArray(orders)) {
                  orders = orders == null ? [] : [orders];
                }
                return baseOrderBy(collection, iteratees, orders);
              }
              var partition = createAggregator(function(result2, value, key) {
                result2[key ? 0 : 1].push(value);
              }, function() {
                return [[], []];
              });
              function reduce(collection, iteratee2, accumulator) {
                var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
              }
              function reduceRight(collection, iteratee2, accumulator) {
                var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
                return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
              }
              function reject(collection, predicate) {
                var func = isArray(collection) ? arrayFilter : baseFilter;
                return func(collection, negate(getIteratee(predicate, 3)));
              }
              function sample(collection) {
                var func = isArray(collection) ? arraySample : baseSample;
                return func(collection);
              }
              function sampleSize(collection, n, guard) {
                if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
                  n = 1;
                } else {
                  n = toInteger(n);
                }
                var func = isArray(collection) ? arraySampleSize : baseSampleSize;
                return func(collection, n);
              }
              function shuffle(collection) {
                var func = isArray(collection) ? arrayShuffle : baseShuffle;
                return func(collection);
              }
              function size(collection) {
                if (collection == null) {
                  return 0;
                }
                if (isArrayLike(collection)) {
                  return isString(collection) ? stringSize(collection) : collection.length;
                }
                var tag = getTag(collection);
                if (tag == mapTag || tag == setTag) {
                  return collection.size;
                }
                return baseKeys(collection).length;
              }
              function some(collection, predicate, guard) {
                var func = isArray(collection) ? arraySome : baseSome;
                if (guard && isIterateeCall(collection, predicate, guard)) {
                  predicate = undefined$1;
                }
                return func(collection, getIteratee(predicate, 3));
              }
              var sortBy = baseRest(function(collection, iteratees) {
                if (collection == null) {
                  return [];
                }
                var length = iteratees.length;
                if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                  iteratees = [];
                } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                  iteratees = [iteratees[0]];
                }
                return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
              });
              var now = ctxNow || function() {
                return root.Date.now();
              };
              function after(n, func) {
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                n = toInteger(n);
                return function() {
                  if (--n < 1) {
                    return func.apply(this, arguments);
                  }
                };
              }
              function ary(func, n, guard) {
                n = guard ? undefined$1 : n;
                n = func && n == null ? func.length : n;
                return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
              }
              function before(n, func) {
                var result2;
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                n = toInteger(n);
                return function() {
                  if (--n > 0) {
                    result2 = func.apply(this, arguments);
                  }
                  if (n <= 1) {
                    func = undefined$1;
                  }
                  return result2;
                };
              }
              var bind = baseRest(function(func, thisArg, partials) {
                var bitmask = WRAP_BIND_FLAG;
                if (partials.length) {
                  var holders = replaceHolders(partials, getHolder(bind));
                  bitmask |= WRAP_PARTIAL_FLAG;
                }
                return createWrap(func, bitmask, thisArg, partials, holders);
              });
              var bindKey = baseRest(function(object, key, partials) {
                var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                if (partials.length) {
                  var holders = replaceHolders(partials, getHolder(bindKey));
                  bitmask |= WRAP_PARTIAL_FLAG;
                }
                return createWrap(key, bitmask, object, partials, holders);
              });
              function curry(func, arity, guard) {
                arity = guard ? undefined$1 : arity;
                var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
                result2.placeholder = curry.placeholder;
                return result2;
              }
              function curryRight(func, arity, guard) {
                arity = guard ? undefined$1 : arity;
                var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
                result2.placeholder = curryRight.placeholder;
                return result2;
              }
              function debounce(func, wait, options) {
                var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                wait = toNumber(wait) || 0;
                if (isObject(options)) {
                  leading = !!options.leading;
                  maxing = "maxWait" in options;
                  maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                  trailing = "trailing" in options ? !!options.trailing : trailing;
                }
                function invokeFunc(time) {
                  var args = lastArgs, thisArg = lastThis;
                  lastArgs = lastThis = undefined$1;
                  lastInvokeTime = time;
                  result2 = func.apply(thisArg, args);
                  return result2;
                }
                function leadingEdge(time) {
                  lastInvokeTime = time;
                  timerId = setTimeout2(timerExpired, wait);
                  return leading ? invokeFunc(time) : result2;
                }
                function remainingWait(time) {
                  var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                  return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
                }
                function shouldInvoke(time) {
                  var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                  return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                }
                function timerExpired() {
                  var time = now();
                  if (shouldInvoke(time)) {
                    return trailingEdge(time);
                  }
                  timerId = setTimeout2(timerExpired, remainingWait(time));
                }
                function trailingEdge(time) {
                  timerId = undefined$1;
                  if (trailing && lastArgs) {
                    return invokeFunc(time);
                  }
                  lastArgs = lastThis = undefined$1;
                  return result2;
                }
                function cancel() {
                  if (timerId !== undefined$1) {
                    clearTimeout(timerId);
                  }
                  lastInvokeTime = 0;
                  lastArgs = lastCallTime = lastThis = timerId = undefined$1;
                }
                function flush() {
                  return timerId === undefined$1 ? result2 : trailingEdge(now());
                }
                function debounced() {
                  var time = now(), isInvoking = shouldInvoke(time);
                  lastArgs = arguments;
                  lastThis = this;
                  lastCallTime = time;
                  if (isInvoking) {
                    if (timerId === undefined$1) {
                      return leadingEdge(lastCallTime);
                    }
                    if (maxing) {
                      clearTimeout(timerId);
                      timerId = setTimeout2(timerExpired, wait);
                      return invokeFunc(lastCallTime);
                    }
                  }
                  if (timerId === undefined$1) {
                    timerId = setTimeout2(timerExpired, wait);
                  }
                  return result2;
                }
                debounced.cancel = cancel;
                debounced.flush = flush;
                return debounced;
              }
              var defer = baseRest(function(func, args) {
                return baseDelay(func, 1, args);
              });
              var delay = baseRest(function(func, wait, args) {
                return baseDelay(func, toNumber(wait) || 0, args);
              });
              function flip(func) {
                return createWrap(func, WRAP_FLIP_FLAG);
              }
              function memoize(func, resolver) {
                if (typeof func != "function" || resolver != null && typeof resolver != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                var memoized = function() {
                  var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                  if (cache.has(key)) {
                    return cache.get(key);
                  }
                  var result2 = func.apply(this, args);
                  memoized.cache = cache.set(key, result2) || cache;
                  return result2;
                };
                memoized.cache = new (memoize.Cache || MapCache)();
                return memoized;
              }
              memoize.Cache = MapCache;
              function negate(predicate) {
                if (typeof predicate != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                return function() {
                  var args = arguments;
                  switch (args.length) {
                    case 0:
                      return !predicate.call(this);
                    case 1:
                      return !predicate.call(this, args[0]);
                    case 2:
                      return !predicate.call(this, args[0], args[1]);
                    case 3:
                      return !predicate.call(this, args[0], args[1], args[2]);
                  }
                  return !predicate.apply(this, args);
                };
              }
              function once(func) {
                return before(2, func);
              }
              var overArgs = castRest(function(func, transforms) {
                transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
                var funcsLength = transforms.length;
                return baseRest(function(args) {
                  var index2 = -1, length = nativeMin(args.length, funcsLength);
                  while (++index2 < length) {
                    args[index2] = transforms[index2].call(this, args[index2]);
                  }
                  return apply(func, this, args);
                });
              });
              var partial = baseRest(function(func, partials) {
                var holders = replaceHolders(partials, getHolder(partial));
                return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
              });
              var partialRight = baseRest(function(func, partials) {
                var holders = replaceHolders(partials, getHolder(partialRight));
                return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
              });
              var rearg = flatRest(function(func, indexes) {
                return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
              });
              function rest(func, start) {
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                start = start === undefined$1 ? start : toInteger(start);
                return baseRest(func, start);
              }
              function spread(func, start) {
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                start = start == null ? 0 : nativeMax(toInteger(start), 0);
                return baseRest(function(args) {
                  var array = args[start], otherArgs = castSlice(args, 0, start);
                  if (array) {
                    arrayPush(otherArgs, array);
                  }
                  return apply(func, this, otherArgs);
                });
              }
              function throttle2(func, wait, options) {
                var leading = true, trailing = true;
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (isObject(options)) {
                  leading = "leading" in options ? !!options.leading : leading;
                  trailing = "trailing" in options ? !!options.trailing : trailing;
                }
                return debounce(func, wait, {
                  "leading": leading,
                  "maxWait": wait,
                  "trailing": trailing
                });
              }
              function unary(func) {
                return ary(func, 1);
              }
              function wrap(value, wrapper) {
                return partial(castFunction(wrapper), value);
              }
              function castArray() {
                if (!arguments.length) {
                  return [];
                }
                var value = arguments[0];
                return isArray(value) ? value : [value];
              }
              function clone(value) {
                return baseClone(value, CLONE_SYMBOLS_FLAG);
              }
              function cloneWith(value, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
              }
              function cloneDeep(value) {
                return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
              }
              function cloneDeepWith(value, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
              }
              function conformsTo(object, source) {
                return source == null || baseConformsTo(object, source, keys(source));
              }
              function eq(value, other) {
                return value === other || value !== value && other !== other;
              }
              var gt = createRelationalOperation(baseGt);
              var gte = createRelationalOperation(function(value, other) {
                return value >= other;
              });
              var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
                return arguments;
              })()) ? baseIsArguments : function(value) {
                return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
              };
              var isArray = Array2.isArray;
              var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
              function isArrayLike(value) {
                return value != null && isLength(value.length) && !isFunction2(value);
              }
              function isArrayLikeObject(value) {
                return isObjectLike(value) && isArrayLike(value);
              }
              function isBoolean(value) {
                return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
              }
              var isBuffer = nativeIsBuffer || stubFalse;
              var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
              function isElement(value) {
                return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
              }
              function isEmpty(value) {
                if (value == null) {
                  return true;
                }
                if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                  return !value.length;
                }
                var tag = getTag(value);
                if (tag == mapTag || tag == setTag) {
                  return !value.size;
                }
                if (isPrototype(value)) {
                  return !baseKeys(value).length;
                }
                for (var key in value) {
                  if (hasOwnProperty.call(value, key)) {
                    return false;
                  }
                }
                return true;
              }
              function isEqual(value, other) {
                return baseIsEqual(value, other);
              }
              function isEqualWith(value, other, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                var result2 = customizer ? customizer(value, other) : undefined$1;
                return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
              }
              function isError(value) {
                if (!isObjectLike(value)) {
                  return false;
                }
                var tag = baseGetTag(value);
                return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
              }
              function isFinite2(value) {
                return typeof value == "number" && nativeIsFinite(value);
              }
              function isFunction2(value) {
                if (!isObject(value)) {
                  return false;
                }
                var tag = baseGetTag(value);
                return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
              }
              function isInteger(value) {
                return typeof value == "number" && value == toInteger(value);
              }
              function isLength(value) {
                return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
              }
              function isObject(value) {
                var type = typeof value;
                return value != null && (type == "object" || type == "function");
              }
              function isObjectLike(value) {
                return value != null && typeof value == "object";
              }
              var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
              function isMatch(object, source) {
                return object === source || baseIsMatch(object, source, getMatchData(source));
              }
              function isMatchWith(object, source, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return baseIsMatch(object, source, getMatchData(source), customizer);
              }
              function isNaN2(value) {
                return isNumber(value) && value != +value;
              }
              function isNative(value) {
                if (isMaskable(value)) {
                  throw new Error2(CORE_ERROR_TEXT);
                }
                return baseIsNative(value);
              }
              function isNull(value) {
                return value === null;
              }
              function isNil(value) {
                return value == null;
              }
              function isNumber(value) {
                return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
              }
              function isPlainObject(value) {
                if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                  return false;
                }
                var proto = getPrototype(value);
                if (proto === null) {
                  return true;
                }
                var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
                return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
              }
              var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
              function isSafeInteger(value) {
                return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
              }
              var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
              function isString(value) {
                return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
              }
              function isSymbol(value) {
                return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
              }
              var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
              function isUndefined(value) {
                return value === undefined$1;
              }
              function isWeakMap(value) {
                return isObjectLike(value) && getTag(value) == weakMapTag;
              }
              function isWeakSet(value) {
                return isObjectLike(value) && baseGetTag(value) == weakSetTag;
              }
              var lt = createRelationalOperation(baseLt);
              var lte = createRelationalOperation(function(value, other) {
                return value <= other;
              });
              function toArray(value) {
                if (!value) {
                  return [];
                }
                if (isArrayLike(value)) {
                  return isString(value) ? stringToArray(value) : copyArray(value);
                }
                if (symIterator && value[symIterator]) {
                  return iteratorToArray(value[symIterator]());
                }
                var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
                return func(value);
              }
              function toFinite(value) {
                if (!value) {
                  return value === 0 ? value : 0;
                }
                value = toNumber(value);
                if (value === INFINITY || value === -INFINITY) {
                  var sign = value < 0 ? -1 : 1;
                  return sign * MAX_INTEGER;
                }
                return value === value ? value : 0;
              }
              function toInteger(value) {
                var result2 = toFinite(value), remainder = result2 % 1;
                return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
              }
              function toLength(value) {
                return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
              }
              function toNumber(value) {
                if (typeof value == "number") {
                  return value;
                }
                if (isSymbol(value)) {
                  return NAN;
                }
                if (isObject(value)) {
                  var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                  value = isObject(other) ? other + "" : other;
                }
                if (typeof value != "string") {
                  return value === 0 ? value : +value;
                }
                value = baseTrim(value);
                var isBinary = reIsBinary.test(value);
                return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
              }
              function toPlainObject(value) {
                return copyObject(value, keysIn(value));
              }
              function toSafeInteger(value) {
                return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
              }
              function toString(value) {
                return value == null ? "" : baseToString(value);
              }
              var assign = createAssigner(function(object, source) {
                if (isPrototype(source) || isArrayLike(source)) {
                  copyObject(source, keys(source), object);
                  return;
                }
                for (var key in source) {
                  if (hasOwnProperty.call(source, key)) {
                    assignValue(object, key, source[key]);
                  }
                }
              });
              var assignIn = createAssigner(function(object, source) {
                copyObject(source, keysIn(source), object);
              });
              var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
                copyObject(source, keysIn(source), object, customizer);
              });
              var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
                copyObject(source, keys(source), object, customizer);
              });
              var at = flatRest(baseAt);
              function create(prototype, properties) {
                var result2 = baseCreate(prototype);
                return properties == null ? result2 : baseAssign(result2, properties);
              }
              var defaults = baseRest(function(object, sources) {
                object = Object2(object);
                var index2 = -1;
                var length = sources.length;
                var guard = length > 2 ? sources[2] : undefined$1;
                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                  length = 1;
                }
                while (++index2 < length) {
                  var source = sources[index2];
                  var props = keysIn(source);
                  var propsIndex = -1;
                  var propsLength = props.length;
                  while (++propsIndex < propsLength) {
                    var key = props[propsIndex];
                    var value = object[key];
                    if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                      object[key] = source[key];
                    }
                  }
                }
                return object;
              });
              var defaultsDeep = baseRest(function(args) {
                args.push(undefined$1, customDefaultsMerge);
                return apply(mergeWith, undefined$1, args);
              });
              function findKey(object, predicate) {
                return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
              }
              function findLastKey(object, predicate) {
                return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
              }
              function forIn(object, iteratee2) {
                return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
              }
              function forInRight(object, iteratee2) {
                return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
              }
              function forOwn(object, iteratee2) {
                return object && baseForOwn(object, getIteratee(iteratee2, 3));
              }
              function forOwnRight(object, iteratee2) {
                return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
              }
              function functions(object) {
                return object == null ? [] : baseFunctions(object, keys(object));
              }
              function functionsIn(object) {
                return object == null ? [] : baseFunctions(object, keysIn(object));
              }
              function get(object, path, defaultValue) {
                var result2 = object == null ? undefined$1 : baseGet(object, path);
                return result2 === undefined$1 ? defaultValue : result2;
              }
              function has(object, path) {
                return object != null && hasPath(object, path, baseHas);
              }
              function hasIn(object, path) {
                return object != null && hasPath(object, path, baseHasIn);
              }
              var invert = createInverter(function(result2, value, key) {
                if (value != null && typeof value.toString != "function") {
                  value = nativeObjectToString.call(value);
                }
                result2[value] = key;
              }, constant(identity));
              var invertBy = createInverter(function(result2, value, key) {
                if (value != null && typeof value.toString != "function") {
                  value = nativeObjectToString.call(value);
                }
                if (hasOwnProperty.call(result2, value)) {
                  result2[value].push(key);
                } else {
                  result2[value] = [key];
                }
              }, getIteratee);
              var invoke = baseRest(baseInvoke);
              function keys(object) {
                return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
              }
              function keysIn(object) {
                return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
              }
              function mapKeys(object, iteratee2) {
                var result2 = {};
                iteratee2 = getIteratee(iteratee2, 3);
                baseForOwn(object, function(value, key, object2) {
                  baseAssignValue(result2, iteratee2(value, key, object2), value);
                });
                return result2;
              }
              function mapValues(object, iteratee2) {
                var result2 = {};
                iteratee2 = getIteratee(iteratee2, 3);
                baseForOwn(object, function(value, key, object2) {
                  baseAssignValue(result2, key, iteratee2(value, key, object2));
                });
                return result2;
              }
              var merge = createAssigner(function(object, source, srcIndex) {
                baseMerge(object, source, srcIndex);
              });
              var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
                baseMerge(object, source, srcIndex, customizer);
              });
              var omit = flatRest(function(object, paths) {
                var result2 = {};
                if (object == null) {
                  return result2;
                }
                var isDeep = false;
                paths = arrayMap(paths, function(path) {
                  path = castPath(path, object);
                  isDeep || (isDeep = path.length > 1);
                  return path;
                });
                copyObject(object, getAllKeysIn(object), result2);
                if (isDeep) {
                  result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
                }
                var length = paths.length;
                while (length--) {
                  baseUnset(result2, paths[length]);
                }
                return result2;
              });
              function omitBy(object, predicate) {
                return pickBy(object, negate(getIteratee(predicate)));
              }
              var pick = flatRest(function(object, paths) {
                return object == null ? {} : basePick(object, paths);
              });
              function pickBy(object, predicate) {
                if (object == null) {
                  return {};
                }
                var props = arrayMap(getAllKeysIn(object), function(prop) {
                  return [prop];
                });
                predicate = getIteratee(predicate);
                return basePickBy(object, props, function(value, path) {
                  return predicate(value, path[0]);
                });
              }
              function result(object, path, defaultValue) {
                path = castPath(path, object);
                var index2 = -1, length = path.length;
                if (!length) {
                  length = 1;
                  object = undefined$1;
                }
                while (++index2 < length) {
                  var value = object == null ? undefined$1 : object[toKey(path[index2])];
                  if (value === undefined$1) {
                    index2 = length;
                    value = defaultValue;
                  }
                  object = isFunction2(value) ? value.call(object) : value;
                }
                return object;
              }
              function set(object, path, value) {
                return object == null ? object : baseSet(object, path, value);
              }
              function setWith(object, path, value, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return object == null ? object : baseSet(object, path, value, customizer);
              }
              var toPairs = createToPairs(keys);
              var toPairsIn = createToPairs(keysIn);
              function transform(object, iteratee2, accumulator) {
                var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                iteratee2 = getIteratee(iteratee2, 4);
                if (accumulator == null) {
                  var Ctor = object && object.constructor;
                  if (isArrLike) {
                    accumulator = isArr ? new Ctor() : [];
                  } else if (isObject(object)) {
                    accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
                  } else {
                    accumulator = {};
                  }
                }
                (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
                  return iteratee2(accumulator, value, index2, object2);
                });
                return accumulator;
              }
              function unset(object, path) {
                return object == null ? true : baseUnset(object, path);
              }
              function update(object, path, updater) {
                return object == null ? object : baseUpdate(object, path, castFunction(updater));
              }
              function updateWith(object, path, updater, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
              }
              function values(object) {
                return object == null ? [] : baseValues(object, keys(object));
              }
              function valuesIn(object) {
                return object == null ? [] : baseValues(object, keysIn(object));
              }
              function clamp(number, lower, upper) {
                if (upper === undefined$1) {
                  upper = lower;
                  lower = undefined$1;
                }
                if (upper !== undefined$1) {
                  upper = toNumber(upper);
                  upper = upper === upper ? upper : 0;
                }
                if (lower !== undefined$1) {
                  lower = toNumber(lower);
                  lower = lower === lower ? lower : 0;
                }
                return baseClamp(toNumber(number), lower, upper);
              }
              function inRange(number, start, end) {
                start = toFinite(start);
                if (end === undefined$1) {
                  end = start;
                  start = 0;
                } else {
                  end = toFinite(end);
                }
                number = toNumber(number);
                return baseInRange(number, start, end);
              }
              function random2(lower, upper, floating) {
                if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
                  upper = floating = undefined$1;
                }
                if (floating === undefined$1) {
                  if (typeof upper == "boolean") {
                    floating = upper;
                    upper = undefined$1;
                  } else if (typeof lower == "boolean") {
                    floating = lower;
                    lower = undefined$1;
                  }
                }
                if (lower === undefined$1 && upper === undefined$1) {
                  lower = 0;
                  upper = 1;
                } else {
                  lower = toFinite(lower);
                  if (upper === undefined$1) {
                    upper = lower;
                    lower = 0;
                  } else {
                    upper = toFinite(upper);
                  }
                }
                if (lower > upper) {
                  var temp = lower;
                  lower = upper;
                  upper = temp;
                }
                if (floating || lower % 1 || upper % 1) {
                  var rand = nativeRandom();
                  return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
                }
                return baseRandom(lower, upper);
              }
              var camelCase = createCompounder(function(result2, word, index2) {
                word = word.toLowerCase();
                return result2 + (index2 ? capitalize(word) : word);
              });
              function capitalize(string) {
                return upperFirst(toString(string).toLowerCase());
              }
              function deburr(string) {
                string = toString(string);
                return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
              }
              function endsWith(string, target, position) {
                string = toString(string);
                target = baseToString(target);
                var length = string.length;
                position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
                var end = position;
                position -= target.length;
                return position >= 0 && string.slice(position, end) == target;
              }
              function escape2(string) {
                string = toString(string);
                return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
              }
              function escapeRegExp(string) {
                string = toString(string);
                return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
              }
              var kebabCase = createCompounder(function(result2, word, index2) {
                return result2 + (index2 ? "-" : "") + word.toLowerCase();
              });
              var lowerCase = createCompounder(function(result2, word, index2) {
                return result2 + (index2 ? " " : "") + word.toLowerCase();
              });
              var lowerFirst = createCaseFirst("toLowerCase");
              function pad(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                if (!length || strLength >= length) {
                  return string;
                }
                var mid = (length - strLength) / 2;
                return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
              }
              function padEnd(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
              }
              function padStart(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
              }
              function parseInt2(string, radix, guard) {
                if (guard || radix == null) {
                  radix = 0;
                } else if (radix) {
                  radix = +radix;
                }
                return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
              }
              function repeat(string, n, guard) {
                if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
                  n = 1;
                } else {
                  n = toInteger(n);
                }
                return baseRepeat(toString(string), n);
              }
              function replace() {
                var args = arguments, string = toString(args[0]);
                return args.length < 3 ? string : string.replace(args[1], args[2]);
              }
              var snakeCase = createCompounder(function(result2, word, index2) {
                return result2 + (index2 ? "_" : "") + word.toLowerCase();
              });
              function split(string, separator, limit) {
                if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
                  separator = limit = undefined$1;
                }
                limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
                if (!limit) {
                  return [];
                }
                string = toString(string);
                if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
                  separator = baseToString(separator);
                  if (!separator && hasUnicode(string)) {
                    return castSlice(stringToArray(string), 0, limit);
                  }
                }
                return string.split(separator, limit);
              }
              var startCase = createCompounder(function(result2, word, index2) {
                return result2 + (index2 ? " " : "") + upperFirst(word);
              });
              function startsWith(string, target, position) {
                string = toString(string);
                position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
                target = baseToString(target);
                return string.slice(position, position + target.length) == target;
              }
              function template(string, options, guard) {
                var settings = lodash2.templateSettings;
                if (guard && isIterateeCall(string, options, guard)) {
                  options = undefined$1;
                }
                string = toString(string);
                options = assignInWith({}, options, settings, customDefaultsAssignIn);
                var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
                var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                var reDelimiters = RegExp2(
                  (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
                  "g"
                );
                var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                  interpolateValue || (interpolateValue = esTemplateValue);
                  source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
                  if (escapeValue) {
                    isEscaping = true;
                    source += "' +\n__e(" + escapeValue + ") +\n'";
                  }
                  if (evaluateValue) {
                    isEvaluating = true;
                    source += "';\n" + evaluateValue + ";\n__p += '";
                  }
                  if (interpolateValue) {
                    source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                  }
                  index2 = offset + match.length;
                  return match;
                });
                source += "';\n";
                var variable = hasOwnProperty.call(options, "variable") && options.variable;
                if (!variable) {
                  source = "with (obj) {\n" + source + "\n}\n";
                } else if (reForbiddenIdentifierChars.test(variable)) {
                  throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
                }
                source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                var result2 = attempt(function() {
                  return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
                });
                result2.source = source;
                if (isError(result2)) {
                  throw result2;
                }
                return result2;
              }
              function toLower(value) {
                return toString(value).toLowerCase();
              }
              function toUpper(value) {
                return toString(value).toUpperCase();
              }
              function trim(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined$1)) {
                  return baseTrim(string);
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
                return castSlice(strSymbols, start, end).join("");
              }
              function trimEnd(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined$1)) {
                  return string.slice(0, trimmedEndIndex(string) + 1);
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                return castSlice(strSymbols, 0, end).join("");
              }
              function trimStart(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined$1)) {
                  return string.replace(reTrimStart, "");
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
                return castSlice(strSymbols, start).join("");
              }
              function truncate(string, options) {
                var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                if (isObject(options)) {
                  var separator = "separator" in options ? options.separator : separator;
                  length = "length" in options ? toInteger(options.length) : length;
                  omission = "omission" in options ? baseToString(options.omission) : omission;
                }
                string = toString(string);
                var strLength = string.length;
                if (hasUnicode(string)) {
                  var strSymbols = stringToArray(string);
                  strLength = strSymbols.length;
                }
                if (length >= strLength) {
                  return string;
                }
                var end = length - stringSize(omission);
                if (end < 1) {
                  return omission;
                }
                var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
                if (separator === undefined$1) {
                  return result2 + omission;
                }
                if (strSymbols) {
                  end += result2.length - end;
                }
                if (isRegExp(separator)) {
                  if (string.slice(end).search(separator)) {
                    var match, substring = result2;
                    if (!separator.global) {
                      separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                    }
                    separator.lastIndex = 0;
                    while (match = separator.exec(substring)) {
                      var newEnd = match.index;
                    }
                    result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
                  }
                } else if (string.indexOf(baseToString(separator), end) != end) {
                  var index2 = result2.lastIndexOf(separator);
                  if (index2 > -1) {
                    result2 = result2.slice(0, index2);
                  }
                }
                return result2 + omission;
              }
              function unescape2(string) {
                string = toString(string);
                return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
              }
              var upperCase = createCompounder(function(result2, word, index2) {
                return result2 + (index2 ? " " : "") + word.toUpperCase();
              });
              var upperFirst = createCaseFirst("toUpperCase");
              function words(string, pattern, guard) {
                string = toString(string);
                pattern = guard ? undefined$1 : pattern;
                if (pattern === undefined$1) {
                  return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
                }
                return string.match(pattern) || [];
              }
              var attempt = baseRest(function(func, args) {
                try {
                  return apply(func, undefined$1, args);
                } catch (e) {
                  return isError(e) ? e : new Error2(e);
                }
              });
              var bindAll = flatRest(function(object, methodNames) {
                arrayEach(methodNames, function(key) {
                  key = toKey(key);
                  baseAssignValue(object, key, bind(object[key], object));
                });
                return object;
              });
              function cond(pairs) {
                var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
                pairs = !length ? [] : arrayMap(pairs, function(pair) {
                  if (typeof pair[1] != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  return [toIteratee(pair[0]), pair[1]];
                });
                return baseRest(function(args) {
                  var index2 = -1;
                  while (++index2 < length) {
                    var pair = pairs[index2];
                    if (apply(pair[0], this, args)) {
                      return apply(pair[1], this, args);
                    }
                  }
                });
              }
              function conforms(source) {
                return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
              }
              function constant(value) {
                return function() {
                  return value;
                };
              }
              function defaultTo(value, defaultValue) {
                return value == null || value !== value ? defaultValue : value;
              }
              var flow = createFlow();
              var flowRight = createFlow(true);
              function identity(value) {
                return value;
              }
              function iteratee(func) {
                return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
              }
              function matches(source) {
                return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
              }
              function matchesProperty(path, srcValue) {
                return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
              }
              var method = baseRest(function(path, args) {
                return function(object) {
                  return baseInvoke(object, path, args);
                };
              });
              var methodOf = baseRest(function(object, args) {
                return function(path) {
                  return baseInvoke(object, path, args);
                };
              });
              function mixin(object, source, options) {
                var props = keys(source), methodNames = baseFunctions(source, props);
                if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
                  options = source;
                  source = object;
                  object = this;
                  methodNames = baseFunctions(source, keys(source));
                }
                var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
                arrayEach(methodNames, function(methodName) {
                  var func = source[methodName];
                  object[methodName] = func;
                  if (isFunc) {
                    object.prototype[methodName] = function() {
                      var chainAll = this.__chain__;
                      if (chain2 || chainAll) {
                        var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                        actions.push({ "func": func, "args": arguments, "thisArg": object });
                        result2.__chain__ = chainAll;
                        return result2;
                      }
                      return func.apply(object, arrayPush([this.value()], arguments));
                    };
                  }
                });
                return object;
              }
              function noConflict() {
                if (root._ === this) {
                  root._ = oldDash;
                }
                return this;
              }
              function noop() {
              }
              function nthArg(n) {
                n = toInteger(n);
                return baseRest(function(args) {
                  return baseNth(args, n);
                });
              }
              var over = createOver(arrayMap);
              var overEvery = createOver(arrayEvery);
              var overSome = createOver(arraySome);
              function property(path) {
                return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
              }
              function propertyOf(object) {
                return function(path) {
                  return object == null ? undefined$1 : baseGet(object, path);
                };
              }
              var range = createRange();
              var rangeRight = createRange(true);
              function stubArray() {
                return [];
              }
              function stubFalse() {
                return false;
              }
              function stubObject() {
                return {};
              }
              function stubString() {
                return "";
              }
              function stubTrue() {
                return true;
              }
              function times(n, iteratee2) {
                n = toInteger(n);
                if (n < 1 || n > MAX_SAFE_INTEGER) {
                  return [];
                }
                var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
                iteratee2 = getIteratee(iteratee2);
                n -= MAX_ARRAY_LENGTH;
                var result2 = baseTimes(length, iteratee2);
                while (++index2 < n) {
                  iteratee2(index2);
                }
                return result2;
              }
              function toPath(value) {
                if (isArray(value)) {
                  return arrayMap(value, toKey);
                }
                return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
              }
              function uniqueId(prefix) {
                var id = ++idCounter;
                return toString(prefix) + id;
              }
              var add = createMathOperation(function(augend, addend) {
                return augend + addend;
              }, 0);
              var ceil = createRound("ceil");
              var divide = createMathOperation(function(dividend, divisor) {
                return dividend / divisor;
              }, 1);
              var floor = createRound("floor");
              function max2(array) {
                return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
              }
              function maxBy(array, iteratee2) {
                return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
              }
              function mean(array) {
                return baseMean(array, identity);
              }
              function meanBy(array, iteratee2) {
                return baseMean(array, getIteratee(iteratee2, 2));
              }
              function min(array) {
                return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
              }
              function minBy(array, iteratee2) {
                return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
              }
              var multiply = createMathOperation(function(multiplier, multiplicand) {
                return multiplier * multiplicand;
              }, 1);
              var round = createRound("round");
              var subtract = createMathOperation(function(minuend, subtrahend) {
                return minuend - subtrahend;
              }, 0);
              function sum(array) {
                return array && array.length ? baseSum(array, identity) : 0;
              }
              function sumBy(array, iteratee2) {
                return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
              }
              lodash2.after = after;
              lodash2.ary = ary;
              lodash2.assign = assign;
              lodash2.assignIn = assignIn;
              lodash2.assignInWith = assignInWith;
              lodash2.assignWith = assignWith;
              lodash2.at = at;
              lodash2.before = before;
              lodash2.bind = bind;
              lodash2.bindAll = bindAll;
              lodash2.bindKey = bindKey;
              lodash2.castArray = castArray;
              lodash2.chain = chain;
              lodash2.chunk = chunk;
              lodash2.compact = compact;
              lodash2.concat = concat;
              lodash2.cond = cond;
              lodash2.conforms = conforms;
              lodash2.constant = constant;
              lodash2.countBy = countBy;
              lodash2.create = create;
              lodash2.curry = curry;
              lodash2.curryRight = curryRight;
              lodash2.debounce = debounce;
              lodash2.defaults = defaults;
              lodash2.defaultsDeep = defaultsDeep;
              lodash2.defer = defer;
              lodash2.delay = delay;
              lodash2.difference = difference;
              lodash2.differenceBy = differenceBy;
              lodash2.differenceWith = differenceWith;
              lodash2.drop = drop;
              lodash2.dropRight = dropRight;
              lodash2.dropRightWhile = dropRightWhile;
              lodash2.dropWhile = dropWhile;
              lodash2.fill = fill;
              lodash2.filter = filter;
              lodash2.flatMap = flatMap;
              lodash2.flatMapDeep = flatMapDeep;
              lodash2.flatMapDepth = flatMapDepth;
              lodash2.flatten = flatten;
              lodash2.flattenDeep = flattenDeep;
              lodash2.flattenDepth = flattenDepth;
              lodash2.flip = flip;
              lodash2.flow = flow;
              lodash2.flowRight = flowRight;
              lodash2.fromPairs = fromPairs;
              lodash2.functions = functions;
              lodash2.functionsIn = functionsIn;
              lodash2.groupBy = groupBy;
              lodash2.initial = initial;
              lodash2.intersection = intersection;
              lodash2.intersectionBy = intersectionBy;
              lodash2.intersectionWith = intersectionWith;
              lodash2.invert = invert;
              lodash2.invertBy = invertBy;
              lodash2.invokeMap = invokeMap;
              lodash2.iteratee = iteratee;
              lodash2.keyBy = keyBy;
              lodash2.keys = keys;
              lodash2.keysIn = keysIn;
              lodash2.map = map;
              lodash2.mapKeys = mapKeys;
              lodash2.mapValues = mapValues;
              lodash2.matches = matches;
              lodash2.matchesProperty = matchesProperty;
              lodash2.memoize = memoize;
              lodash2.merge = merge;
              lodash2.mergeWith = mergeWith;
              lodash2.method = method;
              lodash2.methodOf = methodOf;
              lodash2.mixin = mixin;
              lodash2.negate = negate;
              lodash2.nthArg = nthArg;
              lodash2.omit = omit;
              lodash2.omitBy = omitBy;
              lodash2.once = once;
              lodash2.orderBy = orderBy;
              lodash2.over = over;
              lodash2.overArgs = overArgs;
              lodash2.overEvery = overEvery;
              lodash2.overSome = overSome;
              lodash2.partial = partial;
              lodash2.partialRight = partialRight;
              lodash2.partition = partition;
              lodash2.pick = pick;
              lodash2.pickBy = pickBy;
              lodash2.property = property;
              lodash2.propertyOf = propertyOf;
              lodash2.pull = pull;
              lodash2.pullAll = pullAll;
              lodash2.pullAllBy = pullAllBy;
              lodash2.pullAllWith = pullAllWith;
              lodash2.pullAt = pullAt;
              lodash2.range = range;
              lodash2.rangeRight = rangeRight;
              lodash2.rearg = rearg;
              lodash2.reject = reject;
              lodash2.remove = remove;
              lodash2.rest = rest;
              lodash2.reverse = reverse;
              lodash2.sampleSize = sampleSize;
              lodash2.set = set;
              lodash2.setWith = setWith;
              lodash2.shuffle = shuffle;
              lodash2.slice = slice;
              lodash2.sortBy = sortBy;
              lodash2.sortedUniq = sortedUniq;
              lodash2.sortedUniqBy = sortedUniqBy;
              lodash2.split = split;
              lodash2.spread = spread;
              lodash2.tail = tail;
              lodash2.take = take;
              lodash2.takeRight = takeRight;
              lodash2.takeRightWhile = takeRightWhile;
              lodash2.takeWhile = takeWhile;
              lodash2.tap = tap;
              lodash2.throttle = throttle2;
              lodash2.thru = thru;
              lodash2.toArray = toArray;
              lodash2.toPairs = toPairs;
              lodash2.toPairsIn = toPairsIn;
              lodash2.toPath = toPath;
              lodash2.toPlainObject = toPlainObject;
              lodash2.transform = transform;
              lodash2.unary = unary;
              lodash2.union = union;
              lodash2.unionBy = unionBy;
              lodash2.unionWith = unionWith;
              lodash2.uniq = uniq;
              lodash2.uniqBy = uniqBy;
              lodash2.uniqWith = uniqWith;
              lodash2.unset = unset;
              lodash2.unzip = unzip;
              lodash2.unzipWith = unzipWith;
              lodash2.update = update;
              lodash2.updateWith = updateWith;
              lodash2.values = values;
              lodash2.valuesIn = valuesIn;
              lodash2.without = without;
              lodash2.words = words;
              lodash2.wrap = wrap;
              lodash2.xor = xor;
              lodash2.xorBy = xorBy;
              lodash2.xorWith = xorWith;
              lodash2.zip = zip;
              lodash2.zipObject = zipObject;
              lodash2.zipObjectDeep = zipObjectDeep;
              lodash2.zipWith = zipWith;
              lodash2.entries = toPairs;
              lodash2.entriesIn = toPairsIn;
              lodash2.extend = assignIn;
              lodash2.extendWith = assignInWith;
              mixin(lodash2, lodash2);
              lodash2.add = add;
              lodash2.attempt = attempt;
              lodash2.camelCase = camelCase;
              lodash2.capitalize = capitalize;
              lodash2.ceil = ceil;
              lodash2.clamp = clamp;
              lodash2.clone = clone;
              lodash2.cloneDeep = cloneDeep;
              lodash2.cloneDeepWith = cloneDeepWith;
              lodash2.cloneWith = cloneWith;
              lodash2.conformsTo = conformsTo;
              lodash2.deburr = deburr;
              lodash2.defaultTo = defaultTo;
              lodash2.divide = divide;
              lodash2.endsWith = endsWith;
              lodash2.eq = eq;
              lodash2.escape = escape2;
              lodash2.escapeRegExp = escapeRegExp;
              lodash2.every = every;
              lodash2.find = find;
              lodash2.findIndex = findIndex;
              lodash2.findKey = findKey;
              lodash2.findLast = findLast;
              lodash2.findLastIndex = findLastIndex;
              lodash2.findLastKey = findLastKey;
              lodash2.floor = floor;
              lodash2.forEach = forEach;
              lodash2.forEachRight = forEachRight;
              lodash2.forIn = forIn;
              lodash2.forInRight = forInRight;
              lodash2.forOwn = forOwn;
              lodash2.forOwnRight = forOwnRight;
              lodash2.get = get;
              lodash2.gt = gt;
              lodash2.gte = gte;
              lodash2.has = has;
              lodash2.hasIn = hasIn;
              lodash2.head = head;
              lodash2.identity = identity;
              lodash2.includes = includes;
              lodash2.indexOf = indexOf2;
              lodash2.inRange = inRange;
              lodash2.invoke = invoke;
              lodash2.isArguments = isArguments;
              lodash2.isArray = isArray;
              lodash2.isArrayBuffer = isArrayBuffer;
              lodash2.isArrayLike = isArrayLike;
              lodash2.isArrayLikeObject = isArrayLikeObject;
              lodash2.isBoolean = isBoolean;
              lodash2.isBuffer = isBuffer;
              lodash2.isDate = isDate;
              lodash2.isElement = isElement;
              lodash2.isEmpty = isEmpty;
              lodash2.isEqual = isEqual;
              lodash2.isEqualWith = isEqualWith;
              lodash2.isError = isError;
              lodash2.isFinite = isFinite2;
              lodash2.isFunction = isFunction2;
              lodash2.isInteger = isInteger;
              lodash2.isLength = isLength;
              lodash2.isMap = isMap;
              lodash2.isMatch = isMatch;
              lodash2.isMatchWith = isMatchWith;
              lodash2.isNaN = isNaN2;
              lodash2.isNative = isNative;
              lodash2.isNil = isNil;
              lodash2.isNull = isNull;
              lodash2.isNumber = isNumber;
              lodash2.isObject = isObject;
              lodash2.isObjectLike = isObjectLike;
              lodash2.isPlainObject = isPlainObject;
              lodash2.isRegExp = isRegExp;
              lodash2.isSafeInteger = isSafeInteger;
              lodash2.isSet = isSet;
              lodash2.isString = isString;
              lodash2.isSymbol = isSymbol;
              lodash2.isTypedArray = isTypedArray;
              lodash2.isUndefined = isUndefined;
              lodash2.isWeakMap = isWeakMap;
              lodash2.isWeakSet = isWeakSet;
              lodash2.join = join;
              lodash2.kebabCase = kebabCase;
              lodash2.last = last;
              lodash2.lastIndexOf = lastIndexOf;
              lodash2.lowerCase = lowerCase;
              lodash2.lowerFirst = lowerFirst;
              lodash2.lt = lt;
              lodash2.lte = lte;
              lodash2.max = max2;
              lodash2.maxBy = maxBy;
              lodash2.mean = mean;
              lodash2.meanBy = meanBy;
              lodash2.min = min;
              lodash2.minBy = minBy;
              lodash2.stubArray = stubArray;
              lodash2.stubFalse = stubFalse;
              lodash2.stubObject = stubObject;
              lodash2.stubString = stubString;
              lodash2.stubTrue = stubTrue;
              lodash2.multiply = multiply;
              lodash2.nth = nth;
              lodash2.noConflict = noConflict;
              lodash2.noop = noop;
              lodash2.now = now;
              lodash2.pad = pad;
              lodash2.padEnd = padEnd;
              lodash2.padStart = padStart;
              lodash2.parseInt = parseInt2;
              lodash2.random = random2;
              lodash2.reduce = reduce;
              lodash2.reduceRight = reduceRight;
              lodash2.repeat = repeat;
              lodash2.replace = replace;
              lodash2.result = result;
              lodash2.round = round;
              lodash2.runInContext = runInContext2;
              lodash2.sample = sample;
              lodash2.size = size;
              lodash2.snakeCase = snakeCase;
              lodash2.some = some;
              lodash2.sortedIndex = sortedIndex;
              lodash2.sortedIndexBy = sortedIndexBy;
              lodash2.sortedIndexOf = sortedIndexOf;
              lodash2.sortedLastIndex = sortedLastIndex;
              lodash2.sortedLastIndexBy = sortedLastIndexBy;
              lodash2.sortedLastIndexOf = sortedLastIndexOf;
              lodash2.startCase = startCase;
              lodash2.startsWith = startsWith;
              lodash2.subtract = subtract;
              lodash2.sum = sum;
              lodash2.sumBy = sumBy;
              lodash2.template = template;
              lodash2.times = times;
              lodash2.toFinite = toFinite;
              lodash2.toInteger = toInteger;
              lodash2.toLength = toLength;
              lodash2.toLower = toLower;
              lodash2.toNumber = toNumber;
              lodash2.toSafeInteger = toSafeInteger;
              lodash2.toString = toString;
              lodash2.toUpper = toUpper;
              lodash2.trim = trim;
              lodash2.trimEnd = trimEnd;
              lodash2.trimStart = trimStart;
              lodash2.truncate = truncate;
              lodash2.unescape = unescape2;
              lodash2.uniqueId = uniqueId;
              lodash2.upperCase = upperCase;
              lodash2.upperFirst = upperFirst;
              lodash2.each = forEach;
              lodash2.eachRight = forEachRight;
              lodash2.first = head;
              mixin(lodash2, (function() {
                var source = {};
                baseForOwn(lodash2, function(func, methodName) {
                  if (!hasOwnProperty.call(lodash2.prototype, methodName)) {
                    source[methodName] = func;
                  }
                });
                return source;
              })(), { "chain": false });
              lodash2.VERSION = VERSION;
              arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
                lodash2[methodName].placeholder = lodash2;
              });
              arrayEach(["drop", "take"], function(methodName, index2) {
                LazyWrapper.prototype[methodName] = function(n) {
                  n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
                  var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
                  if (result2.__filtered__) {
                    result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
                  } else {
                    result2.__views__.push({
                      "size": nativeMin(n, MAX_ARRAY_LENGTH),
                      "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                    });
                  }
                  return result2;
                };
                LazyWrapper.prototype[methodName + "Right"] = function(n) {
                  return this.reverse()[methodName](n).reverse();
                };
              });
              arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
                var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                LazyWrapper.prototype[methodName] = function(iteratee2) {
                  var result2 = this.clone();
                  result2.__iteratees__.push({
                    "iteratee": getIteratee(iteratee2, 3),
                    "type": type
                  });
                  result2.__filtered__ = result2.__filtered__ || isFilter;
                  return result2;
                };
              });
              arrayEach(["head", "last"], function(methodName, index2) {
                var takeName = "take" + (index2 ? "Right" : "");
                LazyWrapper.prototype[methodName] = function() {
                  return this[takeName](1).value()[0];
                };
              });
              arrayEach(["initial", "tail"], function(methodName, index2) {
                var dropName = "drop" + (index2 ? "" : "Right");
                LazyWrapper.prototype[methodName] = function() {
                  return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                };
              });
              LazyWrapper.prototype.compact = function() {
                return this.filter(identity);
              };
              LazyWrapper.prototype.find = function(predicate) {
                return this.filter(predicate).head();
              };
              LazyWrapper.prototype.findLast = function(predicate) {
                return this.reverse().find(predicate);
              };
              LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
                if (typeof path == "function") {
                  return new LazyWrapper(this);
                }
                return this.map(function(value) {
                  return baseInvoke(value, path, args);
                });
              });
              LazyWrapper.prototype.reject = function(predicate) {
                return this.filter(negate(getIteratee(predicate)));
              };
              LazyWrapper.prototype.slice = function(start, end) {
                start = toInteger(start);
                var result2 = this;
                if (result2.__filtered__ && (start > 0 || end < 0)) {
                  return new LazyWrapper(result2);
                }
                if (start < 0) {
                  result2 = result2.takeRight(-start);
                } else if (start) {
                  result2 = result2.drop(start);
                }
                if (end !== undefined$1) {
                  end = toInteger(end);
                  result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
                }
                return result2;
              };
              LazyWrapper.prototype.takeRightWhile = function(predicate) {
                return this.reverse().takeWhile(predicate).reverse();
              };
              LazyWrapper.prototype.toArray = function() {
                return this.take(MAX_ARRAY_LENGTH);
              };
              baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
                if (!lodashFunc) {
                  return;
                }
                lodash2.prototype[methodName] = function() {
                  var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
                  var interceptor = function(value2) {
                    var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
                    return isTaker && chainAll ? result3[0] : result3;
                  };
                  if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                    isLazy = useLazy = false;
                  }
                  var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                  if (!retUnwrapped && useLazy) {
                    value = onlyLazy ? value : new LazyWrapper(this);
                    var result2 = func.apply(value, args);
                    result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
                    return new LodashWrapper(result2, chainAll);
                  }
                  if (isUnwrapped && onlyLazy) {
                    return func.apply(this, args);
                  }
                  result2 = this.thru(interceptor);
                  return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
                };
              });
              arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
                var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                lodash2.prototype[methodName] = function() {
                  var args = arguments;
                  if (retUnwrapped && !this.__chain__) {
                    var value = this.value();
                    return func.apply(isArray(value) ? value : [], args);
                  }
                  return this[chainName](function(value2) {
                    return func.apply(isArray(value2) ? value2 : [], args);
                  });
                };
              });
              baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                var lodashFunc = lodash2[methodName];
                if (lodashFunc) {
                  var key = lodashFunc.name + "";
                  if (!hasOwnProperty.call(realNames, key)) {
                    realNames[key] = [];
                  }
                  realNames[key].push({ "name": methodName, "func": lodashFunc });
                }
              });
              realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
                "name": "wrapper",
                "func": undefined$1
              }];
              LazyWrapper.prototype.clone = lazyClone;
              LazyWrapper.prototype.reverse = lazyReverse;
              LazyWrapper.prototype.value = lazyValue;
              lodash2.prototype.at = wrapperAt;
              lodash2.prototype.chain = wrapperChain;
              lodash2.prototype.commit = wrapperCommit;
              lodash2.prototype.next = wrapperNext;
              lodash2.prototype.plant = wrapperPlant;
              lodash2.prototype.reverse = wrapperReverse;
              lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
              lodash2.prototype.first = lodash2.prototype.head;
              if (symIterator) {
                lodash2.prototype[symIterator] = wrapperToIterator;
              }
              return lodash2;
            });
            var _ = runInContext();
            if (freeModule) {
              (freeModule.exports = _)._ = _;
              freeExports._ = _;
            } else {
              root._ = _;
            }
          }).call(lodash);
        })(lodash$1, lodash$1.exports);
        return lodash$1.exports;
      }
      var lodashExports = requireLodash();
      const loading$1 = "_loading_jnpqx_59";
      const footer$1 = "_footer_jnpqx_161";
      const styles$6 = {
        "hot-song-modal": "_hot-song-modal_jnpqx_1",
        "modal-title": "_modal-title_jnpqx_1",
        "title-content": "_title-content_jnpqx_4",
        "title-stats": "_title-stats_jnpqx_10",
        "stat-item": "_stat-item_jnpqx_14",
        loading: loading$1,
        "stat-value": "_stat-value_jnpqx_62",
        "stat-label": "_stat-label_jnpqx_74",
        "song-table": "_song-table_jnpqx_97",
        "song-info": "_song-info_jnpqx_100",
        "album-cover": "_album-cover_jnpqx_100",
        "song-details": "_song-details_jnpqx_113",
        "song-name": "_song-name_jnpqx_117",
        "song-album": "_song-album_jnpqx_126",
        "singer-info": "_singer-info_jnpqx_90",
        "singer-name": "_singer-name_jnpqx_134",
        "singer-id": "_singer-id_jnpqx_142",
        "song-id-text": "_song-id-text_jnpqx_150",
        "song-mid-text": "_song-mid-text_jnpqx_151",
        footer: footer$1,
        "selected-count": "_selected-count_jnpqx_167"
      };
      const { Text: Text$2, Title: Title$2 } = Typography;
      const defaultLoadingData = {
        total: 0,
        loadedSong: 0,
        songList: [],
        totalSong: 0,
        totalAlbum: 0,
        totalMV: 0,
        extras: []
      };
      const HotSongModal = (props, ref) => {
        const { visible, close } = useVisible(
          {
            onOpen: (params) => {
              console.log("params", params);
              setSingerInfo(params);
            },
            onReset: () => {
              setSingerInfo({});
              setSelectedRowKeys([]);
              setSelectedRows([]);
              setLoadingData({
                ...defaultLoadingData
              });
            }
          },
          ref
        );
        const { downloadConfig } = useConfig();
        const { quality: defaultQuality } = downloadConfig;
        const { play, pause, isPlaying, download, getUrl, getLyric, convertToNeteaseMusic } = usePlayMusic();
        const [singerInfo, setSingerInfo] = useState({});
        const [loadingData, setLoadingData] = useState(defaultLoadingData);
        const { loading: loading2 } = useGetData(
          () => getSingerAllHotSong(singerInfo.singerMid, {
            onChange: (result) => {
              setLoadingData({
                total: result.total,
                loadedSong: result.songList.length,
                songList: result.songList,
                totalSong: result.total,
                totalAlbum: result.totalAlbum,
                totalMV: result.totalMV,
                extras: result.extras
              });
            }
          }),
          void 0,
          {
            monitors: [singerInfo.singerMid, visible],
            returnFunction: () => !visible || !singerInfo.singerMid
          }
        );
        const { songList = [], totalSong, totalAlbum, totalMV, extras } = loadingData;
        const [searchParams, setSearchParams] = useState({
          keyword: ""
        });
        const searchFormOptions = [
          {
            label: "歌曲名称",
            name: "name",
            type: "select",
            options: uniqueArrayByKey(songList, "name").map((item) => ({
              label: item.name,
              value: item.name
            })),
            inputProps: {
              mode: "multiple"
            }
          },
          {
            label: "专辑名称",
            name: "albumName",
            type: "select",
            options: uniqueArrayByKey(
              songList.map((item) => item.album),
              "name"
            ).map((item) => ({
              label: item.name,
              value: item.name
            })),
            inputProps: {
              mode: "multiple"
            }
          }
        ];
        const { filteredList, setFilteredList, handleFilter } = useFilter(songList, {
          fields: {
            name: {
              getValue: (item) => item.name
            },
            albumName: {
              getValue: (item) => item.album?.name
            }
          }
        });
        const handleChooseQuality = (record, quality) => {
          setFilteredList(
            filteredList.map((item) => {
              if (item.mid === record.mid) {
                return {
                  ...item,
                  quality
                };
              }
              return item;
            })
          );
        };
        const handlePlay = (record) => {
          console.log("record", record);
          const { mid, quality, file } = record;
          const finalQuality = getQuality$2(file, defaultQuality, quality);
          console.log("当前播放歌曲:", record.name, "音质:", finalQuality);
          play(mid, finalQuality);
        };
        const handleDownload = async (record) => {
          try {
            const { mid, name: name2, quality, file } = record;
            const finalQuality = getQuality$2(file, defaultQuality, quality);
            console.log("当前下载歌曲:", name2, "音质:", finalQuality);
            await download(mid, finalQuality);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleConvertToNeteaseMusic = async (record) => {
          try {
            const { mid, name: name2, quality, file } = record;
            const finalQuality = getQuality$2(file, defaultQuality, quality);
            console.log("当前转存网易云歌曲:", name2, "音质:", finalQuality);
            await convertToNeteaseMusic(mid, { quality: finalQuality });
          } catch (error) {
            console.log("error", error);
            msgError("转存网易云失败");
          }
        };
        const columns = [
          {
            title: "歌曲信息",
            dataIndex: "name",
            key: "name",
            width: 250,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$6["song-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6["album-cover"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Image,
                {
                  width: 40,
                  height: 40,
                  src: record.album?.mid ? getAlbumPicUrl(record.album.mid) : "",
                  alt: record.album?.name || "专辑封面"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6["song-details"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6["song-name"], title: text, children: text }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6["song-album"], title: record.album?.name || "未知专辑", children: record.album?.name || "未知专辑" })
              ] })
            ] })
          },
          {
            title: "歌手",
            dataIndex: "singer",
            key: "singer",
            width: 200,
            render: (singer) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "small", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}), src: singerInfo?.singerPic, size: 40 }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6["singer-info"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6["singer-name"], title: singer?.[0]?.name || "未知歌手", children: singer?.[0]?.name || "未知歌手" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6["singer-id"], title: singer?.[0]?.id?.toString() || "", children: singer?.[0]?.id || "" })
              ] })
            ] })
          },
          {
            title: "时长",
            dataIndex: "interval",
            key: "interval",
            width: 100,
            align: "center",
            render: (interval) => {
              const minutes = Math.floor(interval / 60);
              const seconds = interval % 60;
              return `${minutes}:${seconds.toString().padStart(2, "0")}`;
            }
          },
          {
            title: "音质",
            dataIndex: "file",
            key: "file",
            width: 100,
            align: "center",
            render: (file, record) => {
              const qualityList = getFile_qualityList(file);
              const defaultValue = qualityList.includes(defaultQuality) ? defaultQuality : qualityList[0];
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select,
                {
                  options: qualityList.map((quality) => ({
                    label: quality,
                    value: quality
                  })),
                  defaultValue,
                  style: { width: "100%" },
                  onChange: (value) => {
                    handleChooseQuality(record, value);
                  }
                }
              );
            }
          },
          // 格式
          {
            title: "格式",
            dataIndex: "format",
            key: "format",
            width: 150,
            align: "center",
            render: (_, record) => {
              const qualityList = getFile_qualityList(record.file);
              const qualityColorMap = {
                flac: "green",
                ape: "volcano",
                320: "blue",
                m4a: "orange",
                128: "gray"
              };
              const qualityTextMap = {
                flac: "FLAC",
                ape: "APE",
                320: "320k",
                m4a: "M4A",
                128: "128k"
              };
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Space, { wrap: true, children: qualityList.map((quality) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: qualityColorMap[quality], children: qualityTextMap[quality] || quality }, quality)) });
            }
          },
          {
            title: "发布时间",
            dataIndex: "time_public",
            key: "time_public",
            width: 150,
            align: "center",
            render: (_, __, index2) => {
              const extra = extras?.[index2];
              const uploadTime = extra?.upload_time || "";
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Text$2, { className: styles$6["upload-time"], title: uploadTime, children: uploadTime });
            }
          },
          {
            title: "歌曲ID",
            dataIndex: "id",
            key: "id",
            width: 120,
            align: "center",
            render: (id) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$6["song-id-text"], text: id + "" })
          },
          {
            title: "歌曲MID",
            dataIndex: "mid",
            key: "mid",
            width: 200,
            align: "center",
            render: (mid) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$6["song-mid-text"], text: mid })
          },
          {
            title: "操作",
            key: "action",
            width: 250,
            align: "center",
            fixed: "right",
            render: (_, record) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "small", wrap: true, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    icon: isPlaying === record.mid ? /* @__PURE__ */ jsxRuntimeExports.jsx(PauseCircleOutlined, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                    onClick: () => {
                      if (isPlaying === record.mid) {
                        pause();
                      } else {
                        handlePlay(record);
                      }
                    },
                    children: "播放"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MyButton,
                  {
                    type: "link",
                    size: "small",
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}),
                    onClick: () => handleDownload(record),
                    children: "下载"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MyButton,
                  {
                    type: "link",
                    size: "small",
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CloudDownloadOutlined, {}),
                    onClick: () => handleConvertToNeteaseMusic(record),
                    children: "转存网易云"
                  }
                )
              ] });
            }
          }
        ];
        const [selectedRowKeys, setSelectedRowKeys] = useState([]);
        const [selectedRows, setSelectedRows] = useState([]);
        const rowSelection = {
          preserveSelectedRowKeys: true,
          selectedRowKeys,
          onChange: (selectedRowKeys2, selectedRows2) => {
            setSelectedRowKeys(selectedRowKeys2);
            setSelectedRows(selectedRows2);
            console.log("selectedRowKeys", selectedRowKeys2);
            console.log("selectedRows", selectedRows2);
          }
        };
        const renderTitle = () => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6["modal-title"], children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6["title-content"], children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Title$2, { level: 4, style: { margin: 0 }, children: [
              singerInfo.singerName,
              " - 热门歌曲"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6["title-stats"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$6["stat-item"]} ${loading2 ? styles$6["loading"] : ""}`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6["stat-label"], children: "歌曲" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6["stat-value"], children: loading2 ? "..." : totalSong || 0 })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$6["stat-item"]} ${loading2 ? styles$6["loading"] : ""}`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6["stat-label"], children: "专辑" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6["stat-value"], children: loading2 ? "..." : totalAlbum || 0 })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$6["stat-item"]} ${loading2 ? styles$6["loading"] : ""}`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6["stat-label"], children: "MV" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6["stat-value"], children: loading2 ? "..." : totalMV || 0 })
              ] })
            ] })
          ] }) });
        };
        const handleBatchConvertToNeteaseMusic = async () => {
          try {
            if (selectedRows.length === 0) {
              msgWarning("请先选择要转存网易云的歌曲");
              return;
            }
            const loadingKey = "convert-to-netease-music";
            message$1.loading({
              key: loadingKey,
              content: `正在准备转存网易云 ${selectedRows.length} 首歌曲`,
              duration: 0
            });
            let songIndex = 1;
            for (const song of selectedRows) {
              const record = song;
              const finalQuality = getQuality$2(record.file, defaultQuality, record.quality);
              message$1.loading({
                key: loadingKey,
                content: `第 ${songIndex++} / ${selectedRows.length} 首歌曲：《${song.name}》 开始转存！`,
                duration: 0
              });
              await convertToNeteaseMusic(song.mid, { quality: finalQuality });
            }
            message$1.success({
              key: loadingKey,
              content: `成功转存 ${selectedRows.length} 首歌曲！`,
              duration: 0
            });
            message$1.destroy(loadingKey);
          } catch (error) {
            console.error("批量转存网易云失败:", error);
          }
        };
        const handleBatchDownloadJson = async () => {
          try {
            if (selectedRows.length === 0) {
              msgWarning("请先选择要下载的歌曲");
              return;
            }
            console.log("selectedRows", selectedRows);
            const groupData = lodashExports.groupBy(selectedRows, "album.mid");
            console.log("groupData", groupData);
            const result = [];
            const loadingKey = "download-json";
            message$1.loading({
              key: loadingKey,
              content: `正在准备下载 ${selectedRows.length} 首歌曲，其中包括 ${Object.keys(groupData).length} 个专辑`,
              duration: 0
            });
            let albumIndex = 1;
            let songIndex = 1;
            for (const albumMid in groupData) {
              const album = groupData[albumMid];
              const albumName = album[0].album.name;
              const albumCover = getAlbumPicUrl(albumMid);
              message$1.loading({
                key: loadingKey,
                content: `开始下载第 ${albumIndex} / ${Object.keys(groupData).length} 个专辑 ：《${albumName}》`,
                duration: 0
              });
              const promiseArr = album.map((song) => async () => {
                const lrcContent = await getLyric(song.mid);
                const finalQuality = getQuality$2(song.file, defaultQuality);
                const url = await getUrl(song.mid, finalQuality);
                message$1.loading({
                  key: loadingKey,
                  content: `第 ${songIndex++} / ${album.length} 首歌曲：《${song.name}》 下载完成！`,
                  duration: 0
                });
                return {
                  songName: song.name,
                  url,
                  lrcContent
                };
              });
              const albumSongs = await promiseLimit(promiseArr, 6);
              result.push({
                albumName,
                albumCover,
                list: albumSongs
              });
              message$1.success({
                key: loadingKey,
                content: `第 ${albumIndex++} / ${Object.keys(groupData).length} 个专辑：《${albumName}》下载完成！`,
                duration: 0
              });
            }
            message$1.destroy(loadingKey);
            downloadAsJson(result, `${singerInfo.singerName}-专辑`);
          } catch (error) {
            console.error("批量下载JSON失败:", error);
          }
        };
        const handleBatchDownload = async () => {
          try {
            if (selectedRows.length === 0) {
              msgWarning("请先选择要下载的歌曲");
              return;
            }
            const loadingKey = "download-song";
            message$1.loading({
              key: loadingKey,
              content: `正在准备下载 ${selectedRows.length} 首歌曲`,
              duration: 0
            });
            let songIndex = 1;
            for (const song of selectedRows) {
              const finalQuality = getQuality$2(song.file, defaultQuality);
              message$1.loading({
                key: loadingKey,
                content: `第 ${songIndex++} / ${selectedRows.length} 首歌曲：《${song.name}》 开始下载！`,
                duration: 0
              });
              await download(song.mid, finalQuality);
              message$1.success({
                key: loadingKey,
                content: `第 ${songIndex++} / ${selectedRows.length} 首歌曲：《${song.name}》 下载完成！`,
                duration: 0
              });
            }
            msgSuccess(`成功下载 ${selectedRows.length} 首歌曲！`);
            message$1.destroy(loadingKey);
          } catch (error) {
            console.error("批量下载失败:", error);
          }
        };
        const renderFooter = () => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6["footer"], children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6["selected-count"], children: [
              "已选择 ",
              selectedRows.length,
              " 首歌曲"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
              selectedRowKeys?.length < songList?.length ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    setSelectedRowKeys(songList?.map((item) => item.mid) || []);
                    setSelectedRows(songList || []);
                  },
                  children: "全部选择"
                }
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    setSelectedRowKeys([]);
                    setSelectedRows([]);
                  },
                  children: "清空选择"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                MyButton,
                {
                  type: "primary",
                  onClick: handleBatchConvertToNeteaseMusic,
                  disabled: !selectedRows?.length,
                  children: [
                    "转存网易云",
                    selectedRows?.length ? `(${selectedRows?.length})` : ""
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                MyButton,
                {
                  type: "primary",
                  onClick: handleBatchDownloadJson,
                  disabled: !selectedRows?.length,
                  children: [
                    "下载JSON",
                    selectedRows?.length ? `(${selectedRows?.length})` : ""
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(MyButton, { type: "primary", onClick: handleBatchDownload, disabled: !selectedRows?.length, children: [
                "下载选中歌曲",
                selectedRows?.length ? `(${selectedRows?.length})` : ""
              ] })
            ] })
          ] });
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            title: renderTitle(),
            open: visible,
            onCancel: close,
            footer: renderFooter(),
            width: 1200,
            centered: true,
            className: styles$6["hot-song-modal"],
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                SearchForm$1,
                {
                  options: searchFormOptions,
                  searchParams,
                  onSearch: handleFilter,
                  style: { marginBottom: 16 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Table,
                {
                  rowSelection,
                  columns,
                  dataSource: filteredList || [],
                  rowKey: "mid",
                  loading: loading2 && !loadingData.loadedSong,
                  pagination: {
                    showSizeChanger: true,
                    showQuickJumper: true,
                    showTotal: (total) => `共 ${total} 首歌曲`
                  },
                  scroll: { y: 500, x: 1100 },
                  className: styles$6["song-table"]
                }
              )
            ]
          }
        );
      };
      const HotSongModal$1 = forwardRef(HotSongModal);
      const getQuality$2 = (file, defaultQuality, chooseQuality) => {
        const qualityList = getFile_qualityList(file);
        const songDefaultQuality = qualityList.includes(defaultQuality) ? defaultQuality : qualityList[0];
        const finalQuality = chooseQuality || songDefaultQuality;
        return finalQuality;
      };
      const loading = "_loading_1fb5b_49";
      const footer = "_footer_1fb5b_152";
      const styles$5 = {
        "album-list-modal": "_album-list-modal_1fb5b_1",
        "modal-title": "_modal-title_1fb5b_1",
        "title-content": "_title-content_1fb5b_4",
        "title-stats": "_title-stats_1fb5b_10",
        "stat-item": "_stat-item_1fb5b_14",
        loading,
        "stat-value": "_stat-value_1fb5b_52",
        "stat-label": "_stat-label_1fb5b_60",
        "album-table": "_album-table_1fb5b_76",
        "album-info": "_album-info_1fb5b_79",
        "album-cover": "_album-cover_1fb5b_79",
        "album-details": "_album-details_1fb5b_92",
        "album-name": "_album-name_1fb5b_97",
        "album-trans-name": "_album-trans-name_1fb5b_106",
        "album-type": "_album-type_1fb5b_115",
        "singer-info": "_singer-info_1fb5b_118",
        "singer-name": "_singer-name_1fb5b_118",
        "singer-id": "_singer-id_1fb5b_126",
        "album-id-text": "_album-id-text_1fb5b_134",
        "album-mid-text": "_album-mid-text_1fb5b_135",
        "publish-date": "_publish-date_1fb5b_145",
        footer,
        "selected-count": "_selected-count_1fb5b_159",
        "selected-info": "_selected-info_1fb5b_163"
      };
      const { Text: Text$1, Title: Title$1 } = Typography;
      const AlbumListModal = forwardRef((props, ref) => {
        const { visible, close } = useVisible(
          {
            onOpen: (params) => {
              console.log("params", params);
              setSingerInfo(params);
            },
            onReset: () => {
              setSingerInfo({});
            }
          },
          ref
        );
        const [singerInfo, setSingerInfo] = useState({});
        const albumDetailRef = useCompRef();
        const { data, loading: loading2 } = useGetData(getSingerAllAlbum, singerInfo.singerMid, {
          monitors: [singerInfo.singerMid, visible],
          returnFunction: () => !visible || !singerInfo.singerMid,
          initialValue: [],
          callback: (data2) => {
            console.log("data", data2);
          }
        });
        const searchFormOptions = [
          {
            label: "专辑名称",
            name: "albumName",
            type: "select",
            options: uniqueArrayByKey(data, "albumName").map((item) => ({
              label: item.albumName,
              value: item.albumName
            })),
            inputProps: {
              mode: "multiple"
            }
          }
        ];
        const { filteredList, handleFilter } = useFilter(data, {
          fields: {
            albumName: {
              getValue: (item) => item.albumName
            }
          }
        });
        const { pause, isPlaying } = usePlayMusic();
        const {
          playAlbum,
          downloadAlbumSong,
          getDownLoadJson
        } = useGetAlbumDetail();
        const [playing, setPlaying] = useState();
        const handlePlay = async (record) => {
          try {
            setPlaying(record.albumMid);
            const { albumMid, albumName } = record;
            const hide = msgLoading(`正在加载《${albumName}》...`);
            await playAlbum(albumMid);
            hide();
            msgSuccess(`《${albumName}》开始播放`);
          } catch (error) {
            console.error("播放失败:", error);
          } finally {
            setPlaying(void 0);
          }
        };
        const [downloading, setDownloading] = useState();
        const handleDownload = async (record) => {
          try {
            setDownloading(record.albumMid);
            const { albumMid, albumName } = record;
            const hide = msgLoading(`正在准备下载《${albumName}》...`);
            await downloadAlbumSong(albumMid);
            hide();
            msgSuccess(`《${albumName}》下载成功！`);
          } catch (error) {
            console.error("下载失败:", error);
          } finally {
            setDownloading(void 0);
          }
        };
        const [downloadingJson, setDownloadingJson] = useState(void 0);
        const handleDownloadJson = async (record) => {
          try {
            setDownloadingJson(record.albumMid);
            const { albumMid, albumName } = record;
            const res = await getDownLoadJson(albumMid);
            downloadAsJson([res], `${albumName}-专辑`);
          } catch (error) {
            msgError("下载JSON失败: " + error.message);
          } finally {
            setDownloadingJson(void 0);
          }
        };
        const columns = [
          {
            title: "专辑信息",
            dataIndex: "albumName",
            key: "albumName",
            width: 300,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$5["album-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["album-cover"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Image,
                {
                  width: 60,
                  height: 60,
                  src: getAlbumPicUrl(record.albumMid),
                  alt: text,
                  fallback: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3Ik1RnG4W+FgYxN"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["album-details"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["album-name"], title: text, children: text }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["album-trans-name"], title: record.albumTranName || "", children: record.albumTranName || "" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["album-type"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: "blue", children: record.albumType || "专辑" }) })
              ] })
            ] })
          },
          {
            title: "歌手",
            dataIndex: "singerName",
            key: "singerName",
            width: 200,
            render: (singerName) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "small", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}), src: singerInfo?.singerPic, size: 40 }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["singer-info"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["singer-name"], title: singerName || "未知歌手", children: singerName || "未知歌手" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["singer-id"], title: singerInfo?.singerId?.toString() || "", children: singerInfo?.singerId || "" })
              ] })
            ] })
          },
          {
            title: "发行时间",
            dataIndex: "publishDate",
            key: "publishDate",
            width: 150,
            align: "center",
            render: (publishDate) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { className: styles$5["publish-date"], title: publishDate, children: publishDate || "未知" });
            }
          },
          {
            title: "歌曲数",
            dataIndex: "totalNum",
            key: "totalNum",
            width: 100,
            align: "center",
            render: (totalNum) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Tag, { color: "green", children: [
              totalNum || 0,
              " 首"
            ] })
          },
          {
            title: "专辑ID",
            dataIndex: "albumID",
            key: "albumID",
            width: 120,
            align: "center",
            render: (albumID) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$5["album-id-text"], text: albumID + "" })
          },
          {
            title: "专辑MID",
            dataIndex: "albumMid",
            key: "albumMid",
            width: 200,
            align: "center",
            render: (albumMid) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$5["album-mid-text"], text: albumMid })
          },
          {
            title: "操作",
            key: "action",
            width: 300,
            align: "center",
            fixed: "right",
            onCell: () => ({
              style: {
                cursor: "default"
              },
              onClick: (e) => e.stopPropagation()
            }),
            render: (_, record) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    loading: playing === record.albumMid,
                    icon: playing === record.albumMid ? /* @__PURE__ */ jsxRuntimeExports.jsx(PauseCircleOutlined, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                    onClick: () => {
                      if (isPlaying === record.albumMid) {
                        pause();
                      } else {
                        handlePlay(record);
                        return;
                      }
                    },
                    title: "播放专辑",
                    children: "播放"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    loading: downloadingJson === record.albumMid,
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SaveOutlined, {}),
                    onClick: () => handleDownloadJson(record),
                    title: "下载JSON",
                    children: "下载JSON"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    loading: downloading === record.albumMid,
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}),
                    onClick: () => handleDownload(record),
                    title: "下载专辑",
                    children: "下载"
                  }
                )
              ] });
            }
          }
        ];
        const [selectedRowKeys, setSelectedRowKeys] = useState([]);
        const [selectedRows, setSelectedRows] = useState([]);
        const rowSelection = {
          preserveSelectedRowKeys: true,
          selectedRowKeys,
          onChange: (selectedRowKeys2, selectedRows2) => {
            setSelectedRowKeys(selectedRowKeys2);
            setSelectedRows(selectedRows2);
            console.log("selectedRowKeys", selectedRowKeys2);
            console.log("selectedRows", selectedRows2);
          }
        };
        const renderTitle = () => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["modal-title"], children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["title-content"], children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Title$1, { level: 4, style: { margin: 0 }, children: [
              singerInfo.singerName,
              " - 专辑列表"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["title-stats"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$5["stat-item"]} ${loading2 ? styles$5["loading"] : ""}`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5["stat-label"], children: "专辑" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5["stat-value"], children: loading2 ? "..." : data?.length || 0 })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$5["stat-item"]} ${loading2 ? styles$5["loading"] : ""}`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5["stat-label"], children: "歌曲" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5["stat-value"], children: loading2 ? "..." : data?.reduce((sum, album) => sum + (album.totalNum || 0), 0) || 0 })
              ] })
            ] })
          ] }) });
        };
        const handleBatchDownload = async () => {
          if (selectedRows.length === 0) {
            msgWarning("请先选择要下载的专辑");
            return;
          }
          const loadingKey = "download-album";
          try {
            message$1.loading({
              key: loadingKey,
              content: `正在准备下载 ${selectedRows.length} 张专辑...`,
              duration: 0
            });
            let index2 = 1;
            for (const album of selectedRows) {
              message$1.loading({
                key: loadingKey,
                content: `正在下载第 ${index2} 张专辑 ${album.albumName}...`,
                duration: 0
              });
              await downloadAlbumSong(album.albumMid);
              message$1.success({
                key: loadingKey,
                content: `第 ${index2} 张专辑 ${album.albumName} 下载成功！`,
                duration: 1
              });
              index2++;
            }
          } catch (error) {
            msgError("批量下载失败: " + error.message);
            console.error("批量下载失败:", error);
          } finally {
            message$1.destroy(loadingKey);
          }
        };
        const handleBatchDownloadJson = async () => {
          if (selectedRows.length === 0) {
            msgWarning("请先选择要下载的专辑");
            return;
          }
          const loadingKey = "download-album-json";
          try {
            message$1.loading({
              key: loadingKey,
              content: `正在准备下载 ${selectedRows.length} 张专辑...`,
              duration: 0
            });
            const result = [];
            let index2 = 1;
            for (const album of selectedRows) {
              console.log("album", album);
              message$1.loading({
                key: loadingKey,
                content: `正在下载第 ${index2} 张专辑 ${album.albumName}...`,
                duration: 0
              });
              const res = await getDownLoadJson(album.albumMid);
              result.push(res);
              message$1.success({
                key: loadingKey,
                content: `第 ${index2} 张专辑 ${album.albumName} 下载成功！`,
                duration: 1
              });
              index2++;
            }
            downloadAsJson(result, `${singerInfo.singerName}-专辑`);
            message$1.success({
              key: loadingKey,
              content: `成功下载 ${selectedRows.length} 张专辑！`,
              duration: 1
            });
          } catch (error) {
            console.error("批量下载JSON失败:", error);
            message$1.destroy(loadingKey);
            msgError("批量下载JSON失败: " + error.message);
          } finally {
            message$1.destroy(loadingKey);
          }
        };
        const renderFooter = () => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["footer"], children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["selected-count"], children: [
              "已选择 ",
              selectedRows.length,
              " 张专辑",
              selectedRows.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5["selected-info"], children: [
                "（共 ",
                selectedRows.reduce((sum, album) => sum + (album.totalNum || 0), 0),
                " 首歌曲）"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    setSelectedRowKeys(filteredList?.map((item) => item.albumMid) || []);
                    setSelectedRows(filteredList || []);
                  },
                  disabled: filteredList?.length === 0,
                  children: "全部选择"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    setSelectedRowKeys([]);
                    setSelectedRows([]);
                  },
                  disabled: selectedRows.length === 0,
                  children: "清空选择"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                MyButton,
                {
                  type: "primary",
                  onClick: handleBatchDownloadJson,
                  disabled: selectedRows.length === 0,
                  children: [
                    "下载Json",
                    selectedRows?.length ? `(${selectedRows?.length})` : ""
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                MyButton,
                {
                  type: "primary",
                  onClick: handleBatchDownload,
                  disabled: selectedRows.length === 0,
                  children: [
                    "下载选中专辑",
                    selectedRows?.length ? `(${selectedRows?.length})` : ""
                  ]
                }
              )
            ] })
          ] });
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            title: renderTitle(),
            open: visible,
            onCancel: close,
            footer: renderFooter(),
            width: 1200,
            centered: true,
            className: styles$5["album-list-modal"],
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                SearchForm$1,
                {
                  options: searchFormOptions,
                  onSearch: handleFilter,
                  style: { marginBottom: 16 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Table,
                {
                  rowSelection,
                  columns,
                  dataSource: filteredList || [],
                  rowKey: "albumMid",
                  loading: loading2,
                  scroll: { y: 500, x: 1100 },
                  className: styles$5["album-table"],
                  onRow: (record) => ({
                    style: {
                      cursor: "pointer"
                    },
                    onClick: () => {
                      albumDetailRef.current?.open({ albummid: record.albumMid });
                    }
                  }),
                  pagination: {
                    showSizeChanger: true,
                    showQuickJumper: true,
                    align: "end",
                    showTotal: (total) => `共 ${total} 张专辑`
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(AlbumDetail, { ref: albumDetailRef })
            ]
          }
        );
      });
      const styles$4 = {
        "singer-search-modal": "_singer-search-modal_1jeib_2",
        "singer-info": "_singer-info_1jeib_8",
        "singer-avatar": "_singer-avatar_1jeib_12",
        "singer-details": "_singer-details_1jeib_21",
        "singer-name": "_singer-name_1jeib_26",
        "singer-country": "_singer-country_1jeib_32",
        "singer-id": "_singer-id_1jeib_43",
        "singer-id-text": "_singer-id-text_1jeib_54",
        "singer-mid-text": "_singer-mid-text_1jeib_64"
      };
      const defaultSearchParams$2 = {
        cur_page: 1,
        area: Area.全部,
        sex: Sex.全部,
        genre: Genre.全部
      };
      const SingerSearch = forwardRef((props, ref) => {
        const { visible, close } = useVisible({}, ref);
        const [keyword, setKeyword] = useState("");
        const [searchParams, setSearchParams] = useState(defaultSearchParams$2);
        const searchFormOptions = [
          // 地区
          {
            label: "地区",
            name: "area",
            type: "select",
            options: AreaList
          },
          // 性别
          {
            label: "性别",
            name: "sex",
            type: "select",
            options: SexList
          },
          // 流派
          {
            label: "流派",
            name: "genre",
            type: "select",
            options: GenreList
          },
          // 歌手名称
          {
            label: "歌手名称",
            type: "input",
            inputProps: {
              placeholder: "请输入歌手名称",
              value: keyword,
              allowClear: true,
              onChange: (e) => {
                console.log("e", e);
                setKeyword(e.target.value);
              }
            }
          }
        ];
        const handleSearch = (values) => {
          const newParams = Object.fromEntries(
            searchFormOptions.filter((item) => item.name).map((item) => [item.name, values[item.name]])
          );
          setSearchParams({
            ...searchParams,
            ...newParams
          });
        };
        const hotSongModalRef = useCompRef();
        const handleHotSong = (record) => {
          hotSongModalRef.current.open({
            singerId: record.singer_id,
            singerMid: record.singer_mid,
            singerName: record.singer_name,
            singerPic: record.singer_pic
          });
        };
        const albumModalRef = useCompRef();
        const handleAlbum = (record) => {
          albumModalRef.current.open({
            singerId: record.singer_id,
            singerMid: record.singer_mid,
            singerName: record.singer_name,
            singerPic: record.singer_pic
          });
        };
        const columns = [
          {
            title: "歌手信息",
            dataIndex: "singer_name",
            key: "singer_name",
            width: 300,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$4["singer-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Avatar,
                {
                  src: record.singer_pic,
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}),
                  size: 48,
                  className: styles$4["singer-avatar"]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$4["singer-details"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$4["singer-name"], children: text }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$4["singer-country"], children: record.country || "未知地区" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$4["singer-id"], children: [
                  "ID: ",
                  record.singer_id
                ] })
              ] })
            ] })
          },
          {
            title: "歌手ID",
            dataIndex: "singer_id",
            key: "singer_id",
            width: 120,
            align: "center",
            render: (id) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$4["singer-id-text"], text: id + "" })
          },
          {
            title: "歌手MID",
            dataIndex: "singer_mid",
            key: "singer_mid",
            width: 200,
            align: "center",
            render: (mid) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$4["singer-mid-text"], text: mid })
          },
          {
            title: "操作",
            key: "action",
            width: 200,
            align: "center",
            render: (_, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}),
                  onClick: () => handleHotSong(record),
                  children: "查看热门歌曲"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "link",
                  color: "danger",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                  onClick: () => handleAlbum(record),
                  children: "查看专辑"
                }
              )
            ] })
          }
        ];
        const { data, loading: loading2 } = useGetData(getSingerList, searchParams, {
          monitors: [searchParams, visible],
          returnFunction: () => !visible
        });
        const renderList = useMemo(() => {
          return data.singerlist?.filter(
            (item) => item.singer_name.toLocaleLowerCase().includes(keyword.toLocaleLowerCase() || "")
          ) || [];
        }, [data, keyword]);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            title: "歌手查询",
            open: visible,
            onCancel: close,
            footer: null,
            width: 1200,
            centered: true,
            className: styles$4["singer-search-modal"],
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SearchForm$1, { options: searchFormOptions, searchParams, onSearch: handleSearch }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Table,
                {
                  columns,
                  dataSource: renderList,
                  rowKey: "singer_mid",
                  loading: loading2,
                  pagination: false,
                  scroll: { y: 500, x: 1e3 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Pagination,
                {
                  current: searchParams.cur_page,
                  total: data.total,
                  align: "end",
                  showSizeChanger: false,
                  showQuickJumper: true,
                  showTotal: (total) => `共 ${total} 位歌手`,
                  onChange: (page) => {
                    setSearchParams({
                      ...searchParams,
                      cur_page: page
                    });
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(HotSongModal$1, { ref: hotSongModalRef }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(AlbumListModal, { ref: albumModalRef })
            ]
          }
        );
      });
      function getQQAvatarUrl(qqNumber, size = 640, prefix = "q1") {
        const safeQQ = encodeURIComponent(qqNumber);
        const safeSize = Number(size) || 100;
        const safePrefix = ["q1", "q2", "q3", "q4"].includes(prefix) ? prefix : "q1";
        return `https://${safePrefix}.qlogo.cn/g?b=qq&nk=${safeQQ}&s=${safeSize}`;
      }
      const styles$3 = {
        "song-list-detail-modal": "_song-list-detail-modal_pu8y8_1",
        "modal-header": "_modal-header_pu8y8_1",
        "modal-title": "_modal-title_pu8y8_1",
        "playlist-basic-info": "_playlist-basic-info_pu8y8_4",
        "playlist-info": "_playlist-info_pu8y8_13",
        "playlist-name": "_playlist-name_pu8y8_19",
        "creator-info": "_creator-info_pu8y8_23",
        "creator-name": "_creator-name_pu8y8_28",
        "playlist-stats": "_playlist-stats_pu8y8_32",
        "playlist-desc": "_playlist-desc_pu8y8_41",
        "description-text": "_description-text_pu8y8_44",
        "song-info": "_song-info_pu8y8_68",
        "song-name": "_song-name_pu8y8_73",
        "song-artist": "_song-artist_pu8y8_79",
        "artist-item": "_artist-item_pu8y8_87",
        "artist-name": "_artist-name_pu8y8_91",
        "artist-separator": "_artist-separator_pu8y8_95",
        "song-id": "_song-id_pu8y8_100",
        "id-copy": "_id-copy_pu8y8_100",
        "album-info": "_album-info_pu8y8_103",
        "album-details": "_album-details_pu8y8_107",
        "album-name": "_album-name_pu8y8_114",
        "album-id": "_album-id_pu8y8_122",
        "singer-list": "_singer-list_pu8y8_125",
        "singer-item": "_singer-item_pu8y8_130",
        "singer-details": "_singer-details_pu8y8_134",
        "singer-name": "_singer-name_pu8y8_141"
      };
      const { Text, Title } = Typography;
      const SongListDetail = forwardRef((_, ref) => {
        const { visible, close } = useVisible(
          {
            onOpen(params) {
              if (params) {
                setCurrentDissid(params.dissid);
              }
            }
          },
          ref
        );
        const [currentDissid, setCurrentDissid] = useState("");
        const [inputMid, setInputMid] = useState("");
        const { downloadConfig, functionConfig } = useConfig();
        const { quality: defaultQuality } = downloadConfig;
        const { uploadConcurrency } = functionConfig;
        const {
          getPlaylistDetail,
          getPlaylistDownloadJson
        } = useGetSonglistDetail();
        const { play, isPlaying, pause, download, convertToNeteaseMusic } = usePlayMusic();
        const { data: detail, loading: loading2 } = useGetData(getPlaylistDetail, currentDissid, {
          initialValue: {},
          returnFunction: () => !currentDissid || !visible,
          monitors: [currentDissid, visible],
          callback: (data) => {
            console.log("data", data);
          }
        });
        const list = useMemo(() => {
          return detail?.songlist || [];
        }, [detail]);
        const { filteredList, handleFilter, setFilteredList } = useFilter(list || [], {
          fields: {
            name: {
              getValue: (item) => item.name
            },
            albumName: {
              getValue: (item) => item.album.name
            },
            singer: {
              getValue: (item) => item.singer.map((s) => s.name).join(" / ")
            }
          }
        });
        const searchFormOptions = [
          {
            label: "名字",
            name: "name",
            type: "select",
            inputProps: {
              mode: "multiple"
            },
            options: uniqueArrayByKey(list, "name").map((item) => ({
              label: item.name,
              value: item.name
            }))
          },
          // 歌手
          {
            label: "歌手",
            name: "singer",
            type: "select",
            inputProps: {
              mode: "multiple"
            },
            options: Object.entries(
              lodashExports.groupBy(list, (item) => item.singer.map((s) => s.name).join(" / "))
            ).map(([key]) => ({
              label: key,
              value: key
            }))
          },
          // 专辑
          {
            label: "专辑",
            name: "albumName",
            type: "select",
            inputProps: {
              mode: "multiple"
            },
            options: Object.entries(lodashExports.groupBy(list, (item) => item.album.name)).map(([key]) => ({
              label: key,
              value: key
            }))
          },
          // 歌单ID
          {
            label: "歌单ID",
            type: "input",
            inputProps: {
              placeholder: "请输入歌单ID",
              value: inputMid,
              onChange: (e) => setInputMid(e.target.value.trim()),
              onPressEnter: () => {
                if (inputMid) {
                  setCurrentDissid(inputMid);
                }
              }
            }
          }
        ];
        const handleChooseQuality = (record, quality) => {
          setFilteredList(
            filteredList.map((item) => {
              if (item.mid === record.mid) {
                return {
                  ...item,
                  quality
                };
              }
              return item;
            })
          );
        };
        const handlePlay = (record) => {
          if (isPlaying) {
            pause();
          } else {
            const { file, quality } = record;
            const finalQuality = getQuality$1(file, defaultQuality, quality);
            play(record.mid, finalQuality);
          }
        };
        const handleDownload = async (record) => {
          try {
            const { file, quality } = record;
            const finalQuality = getQuality$1(file, defaultQuality, quality);
            await download(record.mid, finalQuality);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleDownloadNeteaseMusic = async (record) => {
          try {
            const { file, quality } = record;
            const finalQuality = getQuality$1(file, defaultQuality, quality);
            await convertToNeteaseMusic(record.mid, { quality: finalQuality });
            msgSuccess("歌曲转存网易云成功");
          } catch (error) {
            console.log("error", error);
            msgError("歌曲转存网易云失败");
          }
        };
        const songColumns = [
          {
            title: "歌曲信息",
            dataIndex: "name",
            key: "name",
            width: 280,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3["song-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["song-name"], children: text }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["song-artist"], children: record.singer?.map((s, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$3["artist-item"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3["artist-name"], children: s.name }),
                index2 < record.singer.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3["artist-separator"], children: "/" })
              ] }, s.mid || index2)) || "-" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["song-id"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { text: record.mid, className: styles$3["id-copy"] }) })
            ] })
          },
          {
            title: "专辑信息",
            dataIndex: "album",
            key: "album",
            width: 280,
            render: (album) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$3["album-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Image,
                {
                  width: 60,
                  height: 60,
                  src: album?.mid ? getAlbumPicUrl(album.mid, { size: "300x300" }) : "",
                  alt: album?.name || "",
                  fallback: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3Ik1RnG4W+FgYxN",
                  style: { borderRadius: 4 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3["album-details"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["album-name"], title: album?.name || "-", children: album?.name || "-" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["album-id"], children: album?.mid ? /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { text: album.mid, className: styles$3["id-copy"] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { type: "secondary", children: "-" }) })
              ] })
            ] })
          },
          {
            title: "歌手信息",
            dataIndex: "singer",
            key: "singer",
            width: 220,
            render: (singers) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["singer-list"], children: singers?.map((singer, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3["singer-item"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Avatar,
                {
                  src: getSingerPic(singer.mid),
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}),
                  size: 32,
                  style: { marginRight: 8 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3["singer-details"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["singer-name"], children: singer.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { text: singer.mid, className: styles$3["id-copy"] })
              ] })
            ] }, singer.mid || index2)) || "-" })
          },
          {
            title: "音质",
            dataIndex: "file",
            key: "file",
            width: 120,
            align: "center",
            render: (file, record) => {
              const qualityList = getFile_qualityList(file);
              const defaultValue = qualityList.includes(defaultQuality) ? defaultQuality : qualityList[0];
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select,
                {
                  options: qualityList.map((quality) => ({
                    label: quality,
                    value: quality
                  })),
                  defaultValue,
                  style: { width: "100%" },
                  onChange: (value) => {
                    handleChooseQuality(record, value);
                  }
                }
              );
            }
          },
          // 格式
          {
            title: "格式",
            dataIndex: "format",
            key: "format",
            width: 150,
            align: "center",
            render: (_2, record) => {
              const qualityList = getFile_qualityList(record.file);
              const qualityColorMap = {
                flac: "green",
                ape: "volcano",
                320: "blue",
                m4a: "orange",
                128: "gray"
              };
              const qualityTextMap = {
                flac: "FLAC",
                ape: "APE",
                320: "320k",
                m4a: "M4A",
                128: "128k"
              };
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Space, { wrap: true, children: qualityList.map((quality) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: qualityColorMap[quality], children: qualityTextMap[quality] || quality }, quality)) });
            }
          },
          {
            title: "操作",
            key: "action",
            width: 200,
            align: "center",
            fixed: "right",
            render: (_2, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "small", wrap: true, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "link",
                  size: "small",
                  icon: isPlaying === record.mid ? /* @__PURE__ */ jsxRuntimeExports.jsx(PauseCircleOutlined, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                  onClick: () => handlePlay(record),
                  children: "播放"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                MyButton,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}),
                  onClick: () => handleDownload(record),
                  children: "下载"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                MyButton,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CloudDownloadOutlined, {}),
                  onClick: () => handleDownloadNeteaseMusic(record),
                  children: "转存网易云"
                }
              )
            ] })
          }
        ];
        const renderTitle = () => {
          const { pic_mid, dissname, nickname, isvip, visitnum, scoreavage, songnum, desc, uin } = detail || {};
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3["modal-header"], children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Title, { level: 4, className: styles$3["modal-title"], children: "歌单详情" }),
            detail && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3["playlist-basic-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Image,
                {
                  src: pic_mid ? `https://y.gtimg.cn/music/photo_new/T002R300x300M000${pic_mid}.jpg` : "",
                  alt: dissname,
                  width: 80,
                  height: 80,
                  style: { borderRadius: 8 },
                  fallback: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3Ik1RnG4W+FgYxN"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3["playlist-info"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Title, { level: 5, className: styles$3["playlist-name"], children: dissname }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3["creator-info"], children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Avatar,
                    {
                      src: getQQAvatarUrl(uin),
                      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}),
                      size: 24,
                      style: { marginRight: 8 }
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { className: styles$3["creator-name"], children: nickname || "未知用户" }),
                  isvip === 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: "gold", children: "VIP" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["playlist-stats"], children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { type: "secondary", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOutlined, {}),
                    " ",
                    visitnum?.toLocaleString() || 0,
                    " 播放"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { type: "secondary", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(StarOutlined, {}),
                    " ",
                    scoreavage || "-",
                    " 评分"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { type: "secondary", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(TrophyOutlined, {}),
                    " ",
                    songnum || 0,
                    " 首歌曲"
                  ] })
                ] }) }),
                desc && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["playlist-desc"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { type: "secondary", className: styles$3["description-text"], children: desc }) })
              ] })
            ] })
          ] });
        };
        const [selectedRowKeys, setSelectedRowKeys] = useState([]);
        const [selectedRows, setSelectedRows] = useState([]);
        const rowSelection = {
          preserveSelectedRowKeys: true,
          selectedRowKeys,
          onChange: (selectedRowKeys2, selectedRows2) => {
            setSelectedRowKeys(selectedRowKeys2);
            setSelectedRows(selectedRows2);
          }
        };
        const handleBatchDownload = async () => {
          try {
            if (selectedRows.length === 0) {
              msgWarning("请先选择要下载的歌曲");
              return;
            }
            const loadingKey = "download-song";
            message$1.loading({
              key: loadingKey,
              content: `正在准备下载 ${selectedRows.length} 首歌曲`,
              duration: 0
            });
            let songIndex = 1;
            for (const song of selectedRows) {
              message$1.loading({
                key: loadingKey,
                content: `正在下载第 ${songIndex} 首歌曲 ${song.name}...`,
                duration: 0
              });
              const finalQuality = getQuality$1(song.file, defaultQuality);
              await download(song.mid, finalQuality);
              message$1.success({
                key: loadingKey,
                content: `第 ${songIndex} 首歌曲 ${song.name} 下载成功！`,
                duration: 0
              });
              songIndex++;
            }
            msgSuccess(`成功下载 ${selectedRows.length} 首歌曲！`);
            message$1.destroy(loadingKey);
          } catch (error) {
            console.error("下载选中歌曲失败:", error);
          }
        };
        const handleDownloadAllJson = async () => {
          if (!currentDissid) return;
          try {
            const data = await getPlaylistDownloadJson(currentDissid);
            console.log("data", data);
            downloadAsJson(data, `${data.playlistName}.json`);
          } catch (error) {
            console.error("下载歌单JSON失败:", error);
          }
        };
        const handleConvertToNeteaseMusicPlaylistSong = async () => {
          if (!selectedRows.length) return;
          const loadingKey = "convert-to-netease-music-playlist-song";
          message$1.loading({
            key: loadingKey,
            content: `正在转存歌单歌曲...`,
            duration: 0
          });
          try {
            const task = selectedRows.map((item) => async () => {
              await convertToNeteaseMusic(item.mid, {
                onChange: (msg) => {
                  message$1.loading({
                    key: loadingKey,
                    content: msg,
                    duration: 0
                  });
                }
              });
            });
            await promiseLimit(task, uploadConcurrency);
            message$1.success({
              key: loadingKey,
              content: `转存歌单歌曲成功`,
              duration: 0
            });
          } catch (error) {
            console.error("转存网易云歌单歌曲失败:", error);
          }
        };
        const renderFooter = () => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
            selectedRowKeys?.length < list.length ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectOutlined, {}),
                onClick: () => {
                  setSelectedRowKeys(list?.map((item) => item.mid) || []);
                  setSelectedRows(list || []);
                },
                children: "全部选择"
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectOutlined, {}),
                onClick: () => {
                  setSelectedRowKeys([]);
                  setSelectedRows([]);
                },
                children: "清空选择"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              MyButton,
              {
                type: "primary",
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}),
                onClick: handleBatchDownload,
                disabled: !selectedRows?.length,
                children: [
                  "下载选中歌曲",
                  selectedRows?.length ? `(${selectedRows?.length})` : ""
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              MyButton,
              {
                type: "primary",
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FileOutlined, {}),
                onClick: handleDownloadAllJson,
                disabled: !list?.length,
                children: [
                  "下载全部JSON",
                  list?.length ? `(${list?.length})` : ""
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              MyButton,
              {
                type: "primary",
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CloudDownloadOutlined, {}),
                onClick: handleConvertToNeteaseMusicPlaylistSong,
                disabled: !selectedRows?.length,
                children: [
                  "转存网易云歌单选中歌曲",
                  selectedRows?.length ? `(${selectedRows?.length})` : ""
                ]
              }
            )
          ] });
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            title: renderTitle(),
            open: visible,
            onCancel: close,
            footer: renderFooter(),
            width: 1200,
            centered: true,
            className: styles$3["song-list-detail-modal"],
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                SearchForm$1,
                {
                  options: searchFormOptions,
                  onSearch: handleFilter,
                  style: {
                    marginBottom: 0
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Table,
                {
                  columns: songColumns,
                  dataSource: filteredList,
                  rowSelection,
                  rowKey: "mid",
                  loading: loading2,
                  scroll: { y: 400, x: 800 },
                  pagination: {
                    showSizeChanger: true,
                    showQuickJumper: true,
                    showTotal: (total) => `共 ${total} 首歌曲`
                  }
                }
              )
            ]
          }
        );
      });
      const getQuality$1 = (file, defaultQuality, chooseQuality) => {
        const qualityList = getFile_qualityList(file);
        const songDefaultQuality = qualityList.includes(defaultQuality) ? defaultQuality : qualityList[0];
        const finalQuality = chooseQuality || songDefaultQuality;
        return finalQuality;
      };
      const introduction = "_introduction_1h6z1_47";
      const styles$2 = {
        "song-list-search-modal": "_song-list-search-modal_1h6z1_1",
        "play-count-overlay": "_play-count-overlay_1h6z1_1",
        "playlist-cover-container": "_playlist-cover-container_1h6z1_19",
        "playlist-info": "_playlist-info_1h6z1_23",
        "playlist-name": "_playlist-name_1h6z1_28",
        "creator-info": "_creator-info_1h6z1_32",
        "creator-name": "_creator-name_1h6z1_39",
        "creator-qq": "_creator-qq_1h6z1_43",
        introduction,
        "time-info": "_time-info_1h6z1_79",
        "create-time": "_create-time_1h6z1_85",
        "commit-time": "_commit-time_1h6z1_91",
        "playlist-id": "_playlist-id_1h6z1_95"
      };
      const { Option } = Select;
      const defaultSearchParams$1 = {
        pageNum: 0,
        pageSize: 20
      };
      const SongListSearch = forwardRef((props, ref) => {
        const { visible, close } = useVisible({}, ref);
        const [searchParams, setSearchParams] = useState(defaultSearchParams$1);
        const {
          playPlaylist,
          downloadPlaylistSong,
          getPlaylistDownloadJson
        } = useGetSonglistDetail();
        const { data: songListCategory } = useGetData(getSongListCategory, void 0, {
          monitors: [visible],
          returnFunction: () => !visible,
          initialValue: [],
          callback: (data2) => {
            console.log("data", data2);
          }
        });
        const categoryOptions = useMemo(() => {
          return songListCategory?.map((item) => ({
            label: item.categoryGroupName,
            value: item.categoryGroupName,
            checkable: false,
            children: item.items.map((item2) => ({
              label: item2.categoryName,
              value: item2.categoryId
            }))
          }));
        }, [songListCategory]);
        const searchFormOptions = [
          // 分类
          {
            label: "分类",
            name: "categoryIds",
            type: "treeSelect",
            inputProps: {
              treeData: categoryOptions
            }
          },
          // 排序
          {
            label: "排序",
            name: "sortId",
            type: "select",
            options: [
              { label: "默认", value: 1 },
              { label: "最新", value: 2 },
              { label: "最热", value: 3 },
              { label: "评分", value: 4 },
              { label: "none", value: 5 }
            ],
            inputProps: {
              mode: void 0,
              allowClear: true
            }
          }
        ];
        const handleSearch = (values) => {
          const newParams = Object.fromEntries(
            searchFormOptions.filter((item) => item.name).map((item) => [item.name, values[item.name]])
          );
          setSearchParams({
            ...searchParams,
            ...newParams
          });
        };
        const handlePlay = async (record) => {
          console.log("播放歌单:", record);
          try {
            await playPlaylist(record.dissid);
          } catch (error) {
            console.error("播放歌单失败:", error);
          }
        };
        const songListDetailRef = useCompRef();
        const handleViewDetail = async (record) => {
          console.log("查看歌单详情:", record);
          songListDetailRef.current?.open({
            dissid: record.dissid
          });
        };
        const handleDownload = async (record) => {
          console.log("下载歌单:", record);
          try {
            await downloadPlaylistSong(record.dissid);
          } catch (error) {
            console.error("下载歌单失败:", error);
          }
        };
        const handleDownloadJson = async (record) => {
          console.log("下载歌单json:", record);
          try {
            const data2 = await getPlaylistDownloadJson(record.dissid);
            console.log("data", data2);
            downloadAsJson(data2, `${data2.playlistName}.json`);
          } catch (error) {
            console.error("下载歌单json失败:", error);
          }
        };
        const columns = [
          {
            title: "歌单信息",
            dataIndex: "dissname",
            key: "dissname",
            width: 400,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2["playlist-cover-container"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Image,
                  {
                    src: record.imgurl,
                    alt: text,
                    width: 60,
                    height: 60,
                    style: { borderRadius: 8 },
                    fallback: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3Ik1RnG4W+FgYxN"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2["play-count-overlay"], children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: formatPlayCount(record.listennum || 0) }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2["playlist-info"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2["playlist-name"], children: text }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2["creator-info"], children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Avatar,
                    {
                      src: getQQAvatarUrl(record.creator?.qq),
                      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}),
                      size: 20,
                      style: { marginRight: 8 }
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$2["creator-name"], children: record.creator?.name || "未知用户" }),
                  record.creator?.isVip === 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: "gold", children: "VIP" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2["creator-qq"], children: [
                  "QQ: ",
                  record.creator?.qq || "-"
                ] }),
                record.introduction && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2["introduction"], children: record.introduction })
              ] })
            ] })
          },
          {
            title: "时间信息",
            key: "time-info",
            width: 180,
            render: (_, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2["time-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2["create-time"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ClockCircleOutlined, { style: { color: "#666" } }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: record.createtime ? new Date(record.createtime).toLocaleDateString() : "-" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2["commit-time"], children: [
                "提交: ",
                record.commit_time ? new Date(record.commit_time).toLocaleDateString() : "-"
              ] })
            ] })
          },
          {
            title: "歌单ID",
            dataIndex: "dissid",
            key: "dissid",
            width: 150,
            align: "center",
            render: (dissid) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { text: dissid, className: styles$2["playlist-id"] })
          },
          {
            title: "操作",
            key: "action",
            width: 350,
            align: "center",
            fixed: "right",
            onCell: () => ({
              style: {
                cursor: "default"
              },
              onClick: (e) => e.stopPropagation()
            }),
            render: (_, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                MyButton,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                  onClick: () => handlePlay(record),
                  children: "播放"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                MyButton,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}),
                  onClick: () => handleDownload(record),
                  children: "下载"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                MyButton,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FileOutlined, {}),
                  onClick: () => handleDownloadJson(record),
                  children: "下载json"
                }
              )
            ] })
          }
        ];
        const { data, loading: loading2 } = useGetData(
          getSongList,
          {
            ...searchParams,
            limit: searchParams.pageSize,
            page: searchParams.pageNum
          },
          {
            returnFunction: () => !visible,
            monitors: [searchParams, visible],
            callback: (data2) => {
              console.log("data", data2);
            }
          }
        );
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            title: "歌单查询",
            open: visible,
            onCancel: close,
            footer: null,
            width: 1200,
            centered: true,
            className: styles$2["song-list-search-modal"],
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                SearchForm$1,
                {
                  options: searchFormOptions,
                  searchParams,
                  onSearch: handleSearch,
                  style: {
                    marginBottom: 16
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Table,
                {
                  columns,
                  dataSource: data?.list || [],
                  rowKey: "dissid",
                  loading: loading2,
                  onRow: (record) => ({
                    style: {
                      cursor: "pointer"
                    },
                    onClick: () => handleViewDetail(record)
                  }),
                  scroll: { y: 500, x: 970 },
                  pagination: false
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Pagination,
                {
                  align: "end",
                  total: data?.sum || 0,
                  current: searchParams.pageNum,
                  pageSize: searchParams.pageSize,
                  showSizeChanger: true,
                  showTotal: (total) => `共 ${total} 个歌单`,
                  onChange: (page, pageSize) => {
                    setSearchParams({ ...searchParams, pageNum: page, pageSize });
                  },
                  style: { marginTop: 16 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SongListDetail, { ref: songListDetailRef })
            ]
          }
        );
      });
      const formatPlayCount = (count) => {
        if (count >= 1e8) {
          return `${(count / 1e8).toFixed(1)}亿`;
        } else if (count >= 1e4) {
          return `${(count / 1e4).toFixed(1)}万`;
        } else {
          return count.toString();
        }
      };
      const typeMap = {
        song: 0,
        album: 8,
        user: 9,
        playlist: 2,
        lyric: 7,
        mv: 12
      };
      const getSearchResult = async (keyword, type = "song", options) => {
        const { pageNum = 1, pageSize = 20 } = options || {};
        const params = {
          w: keyword,
          n: pageSize,
          p: pageNum,
          catZhida: 1,
          format: "json",
          outCharset: "utf-8",
          t: typeMap[type],
          cr: 1,
          lossless: 0,
          flag_qc: 0,
          platform: "yqq.json",
          g_tk: 5381
        };
        console.log("params", params);
        const res = await qqMusicRequest(
          `/soso/fcgi-bin/client_search_cp?${new URLSearchParams(params).toString()}`,
          {
            method: "GET"
          },
          "c"
        );
        if (res.code === 0) {
          return res.data;
        }
        throw new Error("搜索失败");
      };
      const getWebSearchResult = async (keyword, type = "song", options) => {
        const { pageNum = 1, pageSize = 20 } = {};
        const params = {
          req_1: {
            method: "DoSearchForQQMusicDesktop",
            module: "music.search.SearchCgiService",
            param: {
              num_per_page: Number(pageSize),
              page_num: Number(pageNum),
              query: keyword,
              search_type: Number(typeMap[type])
            }
          }
        };
        console.log("params", params);
        const res = await qqMusicRequest(
          `/cgi-bin/musicu.fcg`,
          {
            method: "POST",
            data: JSON.stringify(params)
          },
          "u"
        );
        console.log("res", res);
      };
      const styles$1 = {
        "song-search-modal": "_song-search-modal_15iqn_1",
        "modal-title": "_modal-title_15iqn_1",
        "title-content": "_title-content_15iqn_6",
        "title-text": "_title-text_15iqn_11",
        "song-table": "_song-table_15iqn_16",
        "song-info": "_song-info_15iqn_16",
        "song-cover": "_song-cover_15iqn_21",
        "song-details": "_song-details_15iqn_31",
        "song-name": "_song-name_15iqn_36",
        "song-album": "_song-album_15iqn_46",
        "singer-info": "_singer-info_15iqn_55",
        "singer-name": "_singer-name_15iqn_60",
        "song-mid-text": "_song-mid-text_15iqn_75"
      };
      const SongTab$1 = ({ data, loading: loading2 }) => {
        const { downloadConfig } = useConfig();
        const { quality: defaultQuality } = downloadConfig;
        const { play, download, isPlaying, pause, getLyric, convertToNeteaseMusic } = usePlayMusic();
        const [list, setList] = useState(data);
        useEffect(() => {
          setList(data);
        }, [data]);
        const handleChooseQuality = (record, quality) => {
          setList(
            list.map((item) => {
              if (item.songmid === record.songmid) {
                return {
                  ...item,
                  quality
                };
              }
              return item;
            })
          );
        };
        const handlePlay = (record) => {
          console.log("播放歌曲:", record);
          if (isPlaying) {
            pause();
          } else {
            const finalQuality = getQuality(record, defaultQuality, record.quality);
            play(record.songmid, finalQuality);
          }
        };
        const handleDownload = async (record) => {
          try {
            const finalQuality = getQuality(record, defaultQuality, record.quality);
            await download(record.songmid, finalQuality);
          } catch (error) {
            console.error("下载歌曲失败:", error);
          }
        };
        const handleDownloadLyric = async (record) => {
          try {
            const lyric = await getLyric(record.songmid);
            downloadAsLRC(lyric, record.songname);
          } catch (error) {
            console.error("下载歌词失败:", error);
          }
        };
        const handleDownloadNeteaseMusic = async (record) => {
          try {
            await convertToNeteaseMusic(record.songmid);
            msgSuccess("歌曲转存网易云成功");
          } catch (error) {
            console.log("error", error);
            msgError("歌曲转存网易云失败");
          }
        };
        const columns_song = [
          {
            title: "歌曲信息",
            dataIndex: "songname",
            width: 300,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$1["song-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-cover"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { src: getAlbumPicUrl(record.albummid) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1["song-details"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-name"], title: text, children: text }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-album"], title: record.albumname || "", children: record.albumname || "" })
              ] })
            ] })
          },
          {
            title: "歌手",
            dataIndex: "singer",
            width: 200,
            render: (singers) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "small", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { src: getSingerPic(singers[0].mid), width: 40, height: 40 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["singer-info"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: styles$1["singer-name"],
                  title: singers?.map((s) => s.name).join("/") || "未知歌手",
                  children: singers?.map((s) => s.name).join("/") || "未知歌手"
                }
              ) })
            ] })
          },
          {
            title: "专辑",
            dataIndex: "albumname",
            width: 200,
            ellipsis: true
          },
          {
            title: "大小",
            dataIndex: "size128",
            width: 120,
            align: "center",
            render: (_, record) => {
              const quality = record.quality || defaultQuality;
              const sizeKey = `size${quality}`;
              if (record.quality) {
                console.log("quality", quality);
                console.log("sizeKey", sizeKey);
              }
              const size = record[sizeKey] || 0;
              return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                Math.round(size / 1024 / 1024),
                "MB"
              ] });
            }
          },
          // 音质选择器
          {
            title: "音质",
            key: "quality",
            width: 150,
            align: "center",
            render: (_, record) => {
              const qualityList = getFileQualityList(record);
              const defaultValue = qualityList.includes(defaultQuality) ? defaultQuality : qualityList[0];
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select,
                {
                  options: qualityList.map((quality) => ({
                    label: quality,
                    value: quality
                  })),
                  defaultValue,
                  style: { width: "100%" },
                  onChange: (value) => {
                    handleChooseQuality(record, value);
                  }
                }
              );
            }
          },
          {
            title: "格式",
            key: "format",
            width: 150,
            align: "center",
            render: (_, record) => {
              const qualityList = getFileQualityList(record);
              const qualityColorMap = {
                flac: "green",
                ape: "volcano",
                320: "blue",
                m4a: "orange",
                128: "gray"
              };
              const qualityTextMap = {
                flac: "FLAC",
                ape: "APE",
                320: "320k",
                m4a: "M4A",
                128: "128k"
              };
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Space, { wrap: true, children: qualityList.map((quality) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: qualityColorMap[quality], children: qualityTextMap[quality] || quality }, quality)) });
            }
          },
          {
            title: "歌曲ID",
            dataIndex: "songmid",
            width: 200,
            align: "center",
            render: (songmid) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$1["song-mid-text"], text: songmid })
          },
          {
            title: "操作",
            key: "action",
            width: 300,
            align: "center",
            fixed: "right",
            render: (_, record) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "small", wrap: true, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    icon: isPlaying === record.songmid ? /* @__PURE__ */ jsxRuntimeExports.jsx(PauseCircleOutlined, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                    onClick: () => handlePlay(record),
                    title: "播放歌曲",
                    children: "播放"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MyButton,
                  {
                    type: "link",
                    size: "small",
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}),
                    onClick: () => handleDownload(record),
                    title: "下载歌曲",
                    children: "下载"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MyButton,
                  {
                    type: "link",
                    size: "small",
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FileOutlined, {}),
                    onClick: () => handleDownloadLyric(record),
                    title: "下载歌词",
                    children: "下载歌词"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MyButton,
                  {
                    type: "link",
                    size: "small",
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CloudDownloadOutlined, {}),
                    onClick: () => handleDownloadNeteaseMusic(record),
                    title: "转存网易云",
                    children: "转存网易云"
                  }
                )
              ] });
            }
          }
        ];
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Table,
          {
            columns: columns_song,
            dataSource: list,
            rowKey: "songmid",
            loading: loading2,
            scroll: { y: 500, x: 1100 },
            className: styles$1["song-table"],
            pagination: false
          }
        );
      };
      const getQuality = (record, defaultQuality, chooseQuality) => {
        const qualityList = getFileQualityList(record);
        const songDefaultQuality = qualityList.includes(defaultQuality) ? defaultQuality : qualityList[0];
        const finalQuality = chooseQuality || songDefaultQuality;
        return finalQuality;
      };
      const AlbumTab$1 = ({ data, loading: loading2 }) => {
        const albumDetailRef = useCompRef();
        const { pause, isPlaying } = usePlayMusic();
        const {
          playAlbum,
          downloadAlbumSong,
          getDownLoadJson
        } = useGetAlbumDetail();
        const [playing, setPlaying] = useState();
        const handlePlay = async (record) => {
          try {
            setPlaying(record.albumMID);
            const { albumMID, albumName } = record;
            const hide = msgLoading(`正在加载《${albumName}》...`);
            await playAlbum(albumMID);
            hide();
            msgSuccess(`《${albumName}》开始播放`);
          } catch (error) {
            console.error("播放失败:", error);
          } finally {
            setPlaying(void 0);
          }
        };
        const [downloading, setDownloading] = useState();
        const handleDownload = async (record) => {
          const loadingKey = "download-album-song";
          try {
            setDownloading(record.albumMID);
            const { albumMID, albumName } = record;
            message$1.loading({
              key: loadingKey,
              content: `正在下载专辑歌曲《${albumName}》...`,
              duration: 0
            });
            await downloadAlbumSong(albumMID, {
              onChange: (options) => {
                message$1.loading({
                  key: loadingKey,
                  content: `正在下载第${options.index}首歌曲《${options.songList[options.index - 1].songname}》...`,
                  duration: 0
                });
              }
            });
            message$1.destroy(loadingKey);
            msgSuccess(`《${albumName}》下载成功！`);
          } catch (error) {
            console.error("下载失败:", error);
          } finally {
            setDownloading(void 0);
            message$1.destroy(loadingKey);
          }
        };
        const [downloadingJson, setDownloadingJson] = useState(void 0);
        const handleDownloadJson = async (record) => {
          if (!record.albumMID) return;
          try {
            setDownloadingJson(record.albumMID);
            const { albumMID, albumName } = record;
            const res = await getDownLoadJson(albumMID);
            downloadAsJson([res], `${albumName}-专辑`);
          } catch (error) {
            msgError("下载JSON失败: " + error.message);
          } finally {
            setDownloadingJson(void 0);
          }
        };
        const columns_album = [
          {
            title: "专辑信息",
            dataIndex: "albumName",
            width: 300,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$1["song-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-cover"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { src: getAlbumPicUrl(record.albumMID) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: styles$1["song-details"],
                  style: {
                    cursor: "pointer"
                  },
                  onClick: () => albumDetailRef.current?.open({ albummid: record.albumMID }),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-name"], title: text, children: text }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-album"], title: record.singerName || "", children: record.singerName || "" })
                  ]
                }
              )
            ] })
          },
          {
            title: "歌手",
            dataIndex: "singerName",
            width: 200,
            ellipsis: true
          },
          {
            title: "发布时间",
            dataIndex: "publicTime",
            width: 150,
            align: "center"
          },
          {
            title: "歌曲数量",
            dataIndex: "song_count",
            width: 100,
            align: "center"
          },
          {
            title: "专辑ID",
            dataIndex: "albumMID",
            width: 200,
            align: "center",
            render: (albumMID) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$1["song-mid-text"], text: albumMID })
          },
          {
            title: "操作",
            key: "action",
            width: 300,
            align: "center",
            fixed: "right",
            render: (_, record) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    loading: playing === record.albumMID,
                    icon: playing === record.albumMID ? /* @__PURE__ */ jsxRuntimeExports.jsx(PauseCircleOutlined, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                    onClick: () => {
                      if (isPlaying === record.albumMID) {
                        pause();
                      } else {
                        handlePlay(record);
                        return;
                      }
                    },
                    title: "播放专辑",
                    children: "播放"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    loading: downloadingJson === record.albumMID,
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SaveOutlined, {}),
                    onClick: () => handleDownloadJson(record),
                    title: "下载JSON",
                    children: "下载JSON"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    loading: downloading === record.albumMID,
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}),
                    onClick: () => handleDownload(record),
                    title: "下载专辑",
                    children: "下载"
                  }
                )
              ] });
            }
          }
        ];
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Table,
            {
              columns: columns_album,
              dataSource: data,
              rowKey: "albumMID",
              loading: loading2,
              scroll: { y: 500, x: 1100 },
              className: styles$1["song-table"],
              pagination: false
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(AlbumDetail, { ref: albumDetailRef })
        ] });
      };
      const SingerTab$1 = ({ data, loading: loading2 }) => {
        const hotSongModalRef = useCompRef();
        const handleHotSong = (record) => {
          hotSongModalRef.current.open({
            singerId: record.singerID,
            singerMid: record.singerMID,
            singerName: record.singerName,
            singerPic: record.singerPic
          });
        };
        const albumModalRef = useCompRef();
        const handleAlbum = (record) => {
          albumModalRef.current.open({
            singerId: record.singerID,
            singerMid: record.singerMID,
            singerName: record.singerName,
            singerPic: record.singerPic
          });
        };
        const columns_singer = [
          {
            title: "歌手信息",
            dataIndex: "singerName",
            width: 300,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$1["song-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-cover"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { src: record.singerPic }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-details"], children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-name"], title: text, children: text }) })
            ] })
          },
          {
            title: "歌曲数量",
            dataIndex: "songNum",
            width: 100,
            align: "center"
          },
          {
            title: "专辑数量",
            dataIndex: "albumNum",
            width: 100,
            align: "center"
          },
          {
            title: "MV数量",
            dataIndex: "mvNum",
            width: 100,
            align: "center"
          },
          {
            title: "歌手ID",
            dataIndex: "singerMID",
            width: 200,
            align: "center",
            render: (singerMID) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$1["song-mid-text"], text: singerMID })
          },
          {
            title: "操作",
            key: "action",
            width: 200,
            align: "center",
            render: (_, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}),
                  onClick: () => handleHotSong(record),
                  children: "查看热门歌曲"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "link",
                  color: "danger",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                  onClick: () => handleAlbum(record),
                  children: "查看专辑"
                }
              )
            ] })
          }
        ];
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Table,
            {
              columns: columns_singer,
              dataSource: data,
              rowKey: "singerMID",
              loading: loading2,
              scroll: { y: 500, x: 1100 },
              className: styles$1["song-table"],
              pagination: false
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(HotSongModal$1, { ref: hotSongModalRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(AlbumListModal, { ref: albumModalRef })
        ] });
      };
      const MvTab = ({ data, loading: loading2 }) => {
        const columns_mv = [
          {
            title: "MV信息",
            dataIndex: "mv_name",
            width: 300,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$1["song-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-cover"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { src: record.mv_pic_url }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1["song-details"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-name"], title: text, children: text }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-album"], title: record.singer_name || "", children: record.singer_name || "" })
              ] })
            ] })
          },
          {
            title: "歌手",
            dataIndex: "singer_name",
            width: 200,
            ellipsis: true
          },
          {
            title: "时长",
            dataIndex: "duration",
            width: 100,
            align: "center",
            render: (duration) => {
              const minutes = Math.floor(duration / 60);
              const seconds = duration % 60;
              return `${minutes}:${seconds.toString().padStart(2, "0")}`;
            }
          },
          {
            title: "播放次数",
            dataIndex: "play_count",
            width: 120,
            align: "center",
            render: (count) => {
              if (count >= 1e4) {
                return `${(count / 1e4).toFixed(1)}万`;
              }
              return count.toString();
            }
          },
          {
            title: "发布时间",
            dataIndex: "publish_date",
            width: 150,
            align: "center"
          },
          {
            title: "MV ID",
            dataIndex: "mv_id",
            width: 150,
            align: "center",
            render: (mv_id) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$1["song-mid-text"], text: mv_id.toString() })
          }
        ];
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Table,
          {
            columns: columns_mv,
            dataSource: data,
            rowKey: "mv_id",
            loading: loading2,
            scroll: { y: 500, x: 1100 },
            className: styles$1["song-table"],
            pagination: false
          }
        );
      };
      const LyricTab = ({ data, loading: loading2 }) => {
        const columns_lyric = [
          {
            title: "歌曲信息",
            dataIndex: "songname",
            width: 300,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$1["song-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-cover"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { src: getAlbumPicUrl(record.albummid) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1["song-details"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-name"], title: text, children: text }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-album"], title: record.albumname || "", children: record.albumname || "" })
              ] })
            ] })
          },
          {
            title: "歌手",
            dataIndex: "singer",
            width: 200,
            render: (singers) => /* @__PURE__ */ jsxRuntimeExports.jsx(Space, { size: "small", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["singer-info"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: styles$1["singer-name"],
                title: singers?.map((s) => s.name).join("/") || "未知歌手",
                children: singers?.map((s) => s.name).join("/") || "未知歌手"
              }
            ) }) })
          },
          {
            title: "歌词预览",
            dataIndex: "content",
            width: 300,
            ellipsis: true,
            render: (content) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { title: content, style: { maxWidth: 300 }, children: [
              content?.substring(0, 50),
              "..."
            ] })
          },
          {
            title: "歌曲ID",
            dataIndex: "songmid",
            width: 200,
            align: "center",
            render: (songmid) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$1["song-mid-text"], text: songmid })
          }
        ];
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Table,
          {
            columns: columns_lyric,
            dataSource: data,
            rowKey: "songmid",
            loading: loading2,
            scroll: { y: 500, x: 1100 },
            className: styles$1["song-table"],
            pagination: false
          }
        );
      };
      const defaultSearchParams = {
        pageNum: 1,
        pageSize: 20,
        type: "song"
      };
      const SongSearch = forwardRef((props, ref) => {
        const { visible, close } = useVisible({}, ref);
        const [searchParams, setSearchParams] = useState(defaultSearchParams);
        const searchFormOptions = [
          // 歌曲名称
          {
            label: "歌曲名称",
            name: "keyword",
            type: "input",
            inputProps: {
              placeholder: "请输入歌曲名称"
            }
          }
        ];
        const handleSearch = (values) => {
          const newParams = Object.fromEntries(
            searchFormOptions.filter((item) => item.name).map((item) => [item.name, values[item.name]])
          );
          setSearchParams({
            ...searchParams,
            ...newParams
          });
        };
        const { data, loading: loading2 } = useGetData(
          () => getSearchResult(searchParams.keyword, searchParams.type, searchParams),
          void 0,
          {
            returnFunction: () => !searchParams.keyword || !visible,
            monitors: [searchParams, visible]
          }
        );
        const renderTitle = () => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["modal-title"], children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["title-content"], children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$1["title-text"], children: "歌曲查询" }) }) });
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            title: renderTitle(),
            open: visible,
            onCancel: close,
            width: 1200,
            centered: true,
            className: styles$1["song-search-modal"],
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                SearchForm$1,
                {
                  options: searchFormOptions,
                  onSearch: handleSearch,
                  style: { marginBottom: 16 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Tabs,
                {
                  activeKey: searchParams.type,
                  onChange: (key) => setSearchParams({ ...searchParams, type: key, pageNum: 1 }),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs.TabPane, { tab: "歌曲", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SongTab$1, { data: data?.song?.list || [], loading: loading2 }) }, "song"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs.TabPane, { tab: "专辑", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlbumTab$1, { data: data?.album?.list || [], loading: loading2 }) }, "album"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs.TabPane, { tab: "歌手", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SingerTab$1, { data: data?.singer?.list || [], loading: loading2 }) }, "user"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs.TabPane, { tab: "MV", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MvTab, { data: data?.mv?.list || [], loading: loading2 }) }, "mv"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs.TabPane, { tab: "歌词", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LyricTab, { data: data?.lyric?.list || [], loading: loading2 }) }, "lyric")
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Pagination,
                {
                  align: "end",
                  total: (() => {
                    switch (searchParams.type) {
                      case "song":
                        return data?.song?.totalnum || 0;
                      case "album":
                        return data?.album?.totalnum || 0;
                      case "user":
                        return data?.singer?.totalnum || 0;
                      case "mv":
                        return data?.mv?.totalnum || 0;
                      case "lyric":
                        return data?.lyric?.totalnum || 0;
                      default:
                        return 0;
                    }
                  })(),
                  current: searchParams.pageNum,
                  pageSize: searchParams.pageSize,
                  showSizeChanger: true,
                  showTotal: (total) => {
                    const typeMap2 = {
                      song: "首歌曲",
                      album: "张专辑",
                      user: "位歌手",
                      mv: "个MV",
                      lyric: "首歌词"
                    };
                    return `共 ${total} ${typeMap2[searchParams.type] || "条记录"}`;
                  },
                  onChange: (page, pageSize) => {
                    setSearchParams({ ...searchParams, pageNum: page, pageSize });
                  },
                  style: { marginTop: 16 }
                }
              )
            ]
          }
        );
      });
      const AlbumTab = () => {
        const [albummid, setAlbummid] = useState("0016l2F430zMux");
        const [getAlbumInfoLoading, setGetAlbumInfoLoading] = useState(false);
        const handleGetAlbumInfo = async () => {
          try {
            setGetAlbumInfoLoading(true);
            const res = await getAlbumInfo(albummid);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setGetAlbumInfoLoading(false);
          }
        };
        const [getAlbumPicUrlLoading, setGetAlbumPicUrlLoading] = useState(false);
        const handleGetAlbumPicUrl = async () => {
          try {
            setGetAlbumPicUrlLoading(true);
            const res = getAlbumPicUrl(albummid);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setGetAlbumPicUrlLoading(false);
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取专辑信息", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              placeholder: "请输入专辑mid",
              style: { width: 300 },
              value: albummid,
              onChange: (e) => setAlbummid(e.target.value)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetAlbumInfo, loading: getAlbumInfoLoading, children: "获取专辑信息" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetAlbumPicUrl, loading: getAlbumPicUrlLoading, children: "获取专辑图片" })
        ] }) }) });
      };
      function SettingItem(props) {
        const { value, onChange, type = "switch", disabled, ...otherProps } = props;
        switch (type) {
          case "input":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                value,
                onChange: (e) => onChange?.(e.target.value),
                disabled,
                ...otherProps
              }
            );
          case "select":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              Select,
              {
                value,
                onChange,
                disabled,
                ...otherProps
              }
            );
          case "radio":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              Radio.Group,
              {
                value,
                onChange: (e) => onChange?.(e.target.value),
                disabled,
                ...otherProps
              }
            );
          case "checkbox":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              Checkbox.Group,
              {
                value,
                onChange,
                disabled,
                ...otherProps
              }
            );
          case "date":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              DatePicker,
              {
                value,
                onChange,
                disabled,
                ...otherProps
              }
            );
          case "time":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              TimePicker,
              {
                value,
                onChange,
                disabled,
                ...otherProps
              }
            );
          case "switch":
          default:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              Switch,
              {
                checked: value,
                onChange,
                disabled,
                ...otherProps
              }
            );
        }
      }
      const { Item: Item$1 } = Descriptions;
      const getQualityOptions = () => {
        return [
          { label: "128k MP3", value: "128" },
          { label: "320k MP3", value: "320" },
          { label: "FLAC", value: "flac" }
        ];
      };
      const DOWNLOAD_SETTING_STRATEGIES = [
        {
          label: "下载音质",
          key: "quality",
          type: "select",
          options: getQualityOptions(),
          style: { width: "100%" }
        },
        {
          label: "是否下载歌词",
          key: "downloadLyric",
          type: "switch"
        },
        {
          label: "是否内嵌歌词封面",
          key: "embedLyricCover",
          type: "switch"
        }
      ];
      const DownloadSettingTab = () => {
        const { downloadConfig, setDownloadConfig } = useConfig();
        const handleConfigChange = (key, value) => {
          setDownloadConfig({
            ...downloadConfig,
            [key]: value
          });
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Descriptions,
          {
            column: 3,
            size: "default",
            bordered: true,
            style: {
              minWidth: 800
            },
            children: DOWNLOAD_SETTING_STRATEGIES.map((strategy) => {
              const { type, key, label, ...rest } = strategy;
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Item$1, { label, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                SettingItem,
                {
                  value: downloadConfig[key],
                  onChange: ((value) => handleConfigChange(key, value)),
                  type,
                  ...rest
                }
              ) }, key);
            })
          }
        );
      };
      const FlacTab = () => {
        const [flacFile, setFlacFile] = useState(null);
        const [flacTagName, setFlacTagName] = useState("all");
        const [flacTagValue, setFlacTagValue] = useState("");
        const [flacPicture, setFlacPicture] = useState(null);
        const [picturePreview, setPicturePreview] = useState(null);
        const [flacTags, setFlacTags] = useState({});
        const [flacFileList, setFlacFileList] = useState([]);
        const [pictureFileList, setPictureFileList] = useState([]);
        const loadFlacTags = async (file) => {
          if (!file) return;
          try {
            if (flacTags.cover) {
              URL.revokeObjectURL(flacTags.cover);
            }
            const tags = await readAllFlacTag(file);
            const covers = await readFlacPictures(file) || [];
            const cover = covers.length > 0 ? URL.createObjectURL(covers[covers.length - 1]) : null;
            setFlacTags({
              ...tags,
              cover
            });
            console.log("FLAC 标签:", tags);
          } catch (error) {
            console.error("读取 FLAC 标签失败:", error);
            msgError("读取 FLAC 标签失败");
          }
        };
        useEffect(() => {
          if (flacFile) {
            loadFlacTags(flacFile);
          }
          return () => {
            if (flacTags.cover) {
              URL.revokeObjectURL(flacTags.cover);
            }
          };
        }, [flacFile]);
        const handleFlacFileChange = ({ fileList }) => {
          setFlacFileList(fileList);
          if (fileList.length > 0 && fileList[0].originFileObj) {
            const file = fileList[0].originFileObj;
            setFlacFile(file);
          } else {
            setFlacFile(null);
            setFlacTags({});
          }
        };
        const handlePictureChange = ({ fileList }) => {
          setPictureFileList(fileList);
          if (fileList.length > 0 && fileList[0].originFileObj) {
            const file = fileList[0].originFileObj;
            setFlacPicture(file);
            const reader = new FileReader();
            reader.onload = (e) => {
              setPicturePreview(e.target?.result);
            };
            reader.readAsDataURL(file);
          } else {
            setFlacPicture(null);
            setPicturePreview(null);
          }
        };
        const handleReadFlacTag = async () => {
          try {
            if (!flacFile) {
              msgError("请选择文件");
              return;
            }
            if (flacTagName === "all") {
              const res = await readAllFlacTag(flacFile);
              setFlacTags(res);
              msgSuccess("读取所有标签成功，请查看下方信息");
              console.log("res", res);
            } else {
              const res = await readFlacTag(flacFile, flacTagName);
              msgSuccess(`读取标签 ${FLAC_TAGS[flacTagName]} 成功: ${res || "无值"}`);
              console.log("res", res);
            }
          } catch (error) {
            console.log("error", error);
            msgError("读取标签失败");
          }
        };
        const handleWriteFlacTag = async () => {
          try {
            if (!flacFile) {
              msgError("请选择文件");
              return;
            }
            if (flacTagName === "all") {
              msgError("请选择具体标签");
              return;
            }
            if (!flacTagValue.trim()) {
              msgError("请输入标签值");
              return;
            }
            const res = await writeFlacTag(flacFile, flacTagName, flacTagValue);
            if (res) {
              console.log("res", res);
              setFlacFile(new File([res], flacFile.name));
              msgSuccess("写入标签成功");
            }
          } catch (error) {
            console.log("error", error);
            msgError("写入标签失败");
          }
        };
        const handleEmbedFlacPicture = async () => {
          try {
            if (!flacFile) {
              msgError("请选择文件");
              return;
            }
            if (!flacPicture) {
              msgError("请选择图片");
              return;
            }
            const res = await embedFlacPicture(flacFile, flacPicture);
            if (res) {
              console.log("res", res);
              setFlacFile(new File([res], flacFile.name));
              msgSuccess("嵌入图片成功");
            }
          } catch (error) {
            console.log("error", error);
            msgError("嵌入图片失败");
          }
        };
        const handleDownloadFlacFile = async () => {
          try {
            if (!flacFile) {
              msgError("请选择文件");
              return;
            }
            downloadFileWithBlob(flacFile, flacFile.name || "test.flac");
            msgSuccess("文件下载成功");
          } catch (error) {
            console.log("error", error);
            msgError("文件下载失败");
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "FLAC 文件", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Upload,
            {
              fileList: flacFileList,
              accept: ".flac",
              maxCount: 1,
              beforeUpload: async () => {
                return false;
              },
              onChange: handleFlacFileChange,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UploadOutlined, {}), children: "选择 FLAC 文件" })
            }
          ) }),
          Object.keys(flacTags).length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "FLAC 标签信息", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { size: "small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions, { column: 2, size: "small", children: Object.entries(flacTags).map(([key, value]) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Descriptions.Item,
            {
              label: FLAC_TAGS[key] || key.toUpperCase(),
              children: key === "cover" && value ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                Image,
                {
                  src: value,
                  alt: "封面",
                  width: 100,
                  height: 100,
                  style: { objectFit: "cover", borderRadius: 4 },
                  preview: true
                }
              ) : key === "cover" ? "无封面" : value
            },
            key
          )) }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "标签操作", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { wrap: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Select,
              {
                style: { width: 150 },
                options: [
                  { label: "全部", value: "all" },
                  ...Object.entries(FLAC_TAGS).map(([key, value]) => ({
                    label: value,
                    value: key
                  }))
                ],
                value: flacTagName,
                onChange: (value) => setFlacTagName(value)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                placeholder: "请输入标签值",
                value: flacTagValue,
                onChange: (e) => setFlacTagValue(e.target.value),
                style: { width: 200 }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleReadFlacTag, children: "读取标签" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleWriteFlacTag, children: "写入标签" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "封面图片", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { wrap: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Upload,
              {
                fileList: pictureFileList,
                accept: ".jpg,.png,.jpeg",
                maxCount: 1,
                beforeUpload: async () => {
                  return false;
                },
                onChange: handlePictureChange,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(PictureOutlined, {}), children: "选择图片" })
              }
            ),
            picturePreview && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Image,
              {
                src: picturePreview,
                alt: "封面预览",
                width: 100,
                height: 100,
                style: { objectFit: "cover", borderRadius: 4 },
                preview: true
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleEmbedFlacPicture, children: "嵌入图片" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "文件操作", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleDownloadFlacFile, children: "下载最新文件" }) })
        ] });
      };
      const { Item } = Descriptions;
      const FUNCTION_SWITCH_STRATEGIES = [
        {
          label: "搜索",
          key: "enableSearch",
          type: "switch"
        },
        {
          label: "GitHub信息",
          key: "enableGithubInfo",
          type: "switch"
        },
        {
          label: "功能开关Tab",
          key: "enableFunctionSwitchTab",
          type: "switch",
          disabled: true
        },
        {
          label: "下载设置Tab",
          key: "enableDownloadSetting",
          type: "switch"
        },
        {
          label: "并发上传歌曲数量",
          key: "uploadConcurrency",
          type: "input"
        },
        {
          label: "演唱会关键词",
          key: "liveKeywords",
          type: "select",
          mode: "tags",
          tokenSeparators: [",", "，", " "],
          style: { width: "100%" }
        },
        {
          label: "测试Modal",
          key: "enableTestModal",
          type: "switch"
        }
      ];
      const FunctionSwitchTab = () => {
        const { functionConfig, setFunctionConfig } = useConfig();
        const handleSwitchChange = (key, checked) => {
          setFunctionConfig({
            ...functionConfig,
            [key]: checked
          });
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions, { column: 3, bordered: true, children: FUNCTION_SWITCH_STRATEGIES.map((strategy) => {
          const { type, key, label, disabled, ...rest } = strategy;
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Item, { label, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            SettingItem,
            {
              value: functionConfig[key],
              onChange: (value) => handleSwitchChange(key, value),
              type,
              disabled,
              ...rest
            }
          ) }, key);
        }) });
      };
      const SearchTab = () => {
        const [getSearchResultLoading, setGetSearchResultLoading] = useState(false);
        const [getSearchResultParams, setGetSearchResultParams] = useState({
          keyword: "",
          type: "song"
        });
        const handleGetSearchResult = async () => {
          try {
            setGetSearchResultLoading(true);
            const res = await getSearchResult(getSearchResultParams.keyword, getSearchResultParams.type);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setGetSearchResultLoading(false);
          }
        };
        const [getWebSearchResultLoading, setGetWebSearchResultLoading] = useState(false);
        const handleGetWebSearchResult = async () => {
          try {
            setGetWebSearchResultLoading(true);
            const res = await getWebSearchResult(
              getSearchResultParams.keyword,
              getSearchResultParams.type
            );
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setGetWebSearchResultLoading(false);
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取搜索结果", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              placeholder: "请输入搜索关键词",
              style: { width: 300 },
              value: getSearchResultParams.keyword,
              onChange: (e) => setGetSearchResultParams({ ...getSearchResultParams, keyword: e.target.value })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Select,
            {
              options: Object.entries(ResourceType).map(([key, value]) => ({
                label: key,
                value
              })),
              style: { width: 150 },
              value: getSearchResultParams.type,
              onChange: (value) => setGetSearchResultParams({ ...getSearchResultParams, type: value }),
              allowClear: true
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetSearchResult, loading: getSearchResultLoading, children: "获取搜索结果" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              onClick: handleGetWebSearchResult,
              loading: getWebSearchResultLoading,
              children: "获取web搜索结果"
            }
          )
        ] }) }) });
      };
      const SingerTab = () => {
        const [getSingerListParams, setGetSingerListParams] = useState({
          area: -100,
          sex: -100,
          genre: -100,
          cur_page: 1
        });
        const handleGetSingerList = async () => {
          try {
            const res = await getSingerList(getSingerListParams);
            console.log("res", res);
            msgSuccess("获取歌手列表成功,请打开控制台查看");
          } catch (error) {
            console.log("error", error);
          }
        };
        const [mid, setMid] = useState("003fA5G40k6hKc");
        const handleGetSingerInfo = async () => {
          try {
            const res = await getSingerInfo(mid);
            console.log("res", res);
            msgSuccess("获取歌手信息成功,请打开控制台查看");
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetSingerAlbum = async () => {
          try {
            const res = await getSingerAlbum(mid);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetSingerAllAlbum = async () => {
          try {
            const res = await getSingerAllAlbum(mid);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetSingerFollowCount = async () => {
          try {
            const res = await getSingerFollowCount(mid);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetSingerHotSong = async () => {
          try {
            const res = await getSingerHotSong(mid);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetSingerAllHotSong = async () => {
          try {
            const res = await getSingerAllHotSong(mid);
            console.log("res", res);
            msgSuccess("获取歌手全部热门歌曲成功,请打开控制台查看");
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetSimilarSinger = async () => {
          try {
            const res = await getSimilarSinger(mid);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取歌手列表", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Select,
              {
                options: AreaList,
                style: {
                  width: 150
                },
                value: getSingerListParams.area,
                onChange: (value) => setGetSingerListParams({ ...getSingerListParams, area: value })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Select,
              {
                options: GenreList,
                style: {
                  width: 150
                },
                value: getSingerListParams.genre,
                onChange: (value) => setGetSingerListParams({ ...getSingerListParams, genre: value })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Select,
              {
                options: SexList,
                style: {
                  width: 150
                },
                value: getSingerListParams.sex,
                onChange: (value) => setGetSingerListParams({ ...getSingerListParams, sex: value })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSingerList, children: "获取歌手列表" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取歌手信息", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { wrap: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                placeholder: "请输入歌手mid",
                style: { width: 300 },
                value: mid,
                onChange: (e) => setMid(e.target.value)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSingerInfo, children: "获取歌手信息" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSingerAlbum, children: "获取歌手专辑" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSingerAllAlbum, children: "获取歌手所有专辑" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSingerFollowCount, children: "获取歌手被关注数量" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSingerHotSong, children: "获取歌手热门歌曲" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSingerAllHotSong, children: "获取歌手全部热门歌曲" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSimilarSinger, children: "获取相似歌手" })
          ] }) })
        ] });
      };
      const SongListTab = () => {
        const [getSongListLoading, setGetSongListLoading] = useState(false);
        const [getSongListCategoryLoading, setGetSongListCategoryLoading] = useState(false);
        const handleGetSongListCategory = async () => {
          try {
            setGetSongListCategoryLoading(true);
            const res = await getSongListCategory();
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setGetSongListCategoryLoading(false);
          }
        };
        const handleGetSongList = async () => {
          try {
            setGetSongListLoading(true);
            const res = await getSongList();
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setGetSongListLoading(false);
          }
        };
        const [disstid, setDisstid] = useState("7011264340");
        const [getSongListDetailLoading, setGetSongListDetailLoading] = useState(false);
        const handleGetSongListDetail = async () => {
          try {
            setGetSongListDetailLoading(true);
            const res = await getSongListDetail(disstid);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setGetSongListDetailLoading(false);
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取歌单列表", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                type: "primary",
                onClick: handleGetSongListCategory,
                loading: getSongListCategoryLoading,
                children: "获取歌单分类列表"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetSongList, loading: getSongListLoading, children: "获取歌单列表" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取歌单详情", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                placeholder: "请输入歌单id",
                style: { width: 300 },
                value: disstid,
                onChange: (e) => setDisstid(e.target.value)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                type: "primary",
                onClick: handleGetSongListDetail,
                loading: getSongListDetailLoading,
                children: "获取歌单详情"
              }
            )
          ] }) })
        ] });
      };
      const SongTab = () => {
        const { convertToNeteaseMusic } = usePlayMusic();
        const [songmid, setSongmid] = useState("003rJSwm3TechU");
        const handleGetSongLyric = async () => {
          try {
            const res = await getSongLyric(songmid);
            console.log("res", res);
            msgSuccess("歌曲歌词获取成功");
          } catch (error) {
            console.log("error", error);
            msgError("歌曲歌词获取失败");
          }
        };
        const handleGetSongPlayUrl = async () => {
          try {
            const res = await getSongPlayUrl(songmid.split(","));
            console.log("res", res);
            msgSuccess("歌曲播放链接获取成功");
          } catch (error) {
            console.log("error", error);
            msgError("歌曲播放链接获取失败");
          }
        };
        const handleGetSongInfo = async () => {
          try {
            const res = await getSongInfo(songmid);
            console.log("res", res);
            msgSuccess("歌曲信息获取成功");
          } catch (error) {
            console.log("error", error);
            msgError("歌曲信息获取失败");
          }
        };
        const handleConvertToNeteaseMusic = async () => {
          try {
            const res = await convertToNeteaseMusic(songmid);
            msgSuccess("歌曲转存网易云成功");
          } catch (error) {
            console.log("error", error);
            msgError("歌曲转存网易云失败");
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取歌曲信息", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              placeholder: "请输入歌曲mid",
              style: { width: 300 },
              value: songmid,
              onChange: (e) => setSongmid(e.target.value)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSongLyric, children: "获取歌曲歌词" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSongPlayUrl, children: "获取歌曲播放链接" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSongInfo, children: "获取歌曲信息" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleConvertToNeteaseMusic, children: "歌曲转存网易云" })
        ] }) }) });
      };
      const NeteaseMusicTab = () => {
        const handleGetUserAccount = async () => {
          const res = await getUserAccount();
          console.log("res", res);
        };
        const [file, setFile] = useState(null);
        const handleUploadLocalSong = async () => {
          if (!file) return;
          const res = await uploadLocalSong(file);
          console.log("res", res);
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "网易云用户信息", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetUserAccount, children: "获取用户信息" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "上传本地歌曲", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { wrap: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Upload,
              {
                accept: ".mp3,.flac,.wav,.m4a,.aac,.ogg,.ape",
                maxCount: 1,
                beforeUpload: async (file2) => {
                  return false;
                },
                onChange: (info) => {
                  setFile(info.fileList[0].originFileObj);
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UploadOutlined, {}), children: "选择本地歌曲" })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleUploadLocalSong, children: "上传本地歌曲" })
          ] }) })
        ] });
      };
      const TestModal = forwardRef((_, ref) => {
        const { visible, close } = useVisible({}, ref);
        const { functionConfig } = useConfig();
        const { enableFunctionSwitchTab, enableDownloadSetting } = functionConfig;
        const tabItems = [
          {
            key: "singer",
            label: "歌手",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(SingerTab, {})
          },
          {
            key: "album",
            label: "专辑",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlbumTab, {})
          },
          {
            key: "song",
            label: "歌曲",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(SongTab, {})
          },
          {
            key: "songList",
            label: "歌单",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(SongListTab, {})
          },
          {
            key: "search",
            label: "搜索",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(SearchTab, {})
          },
          {
            key: "neteaseMusic",
            label: "网易云音乐",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(NeteaseMusicTab, {})
          },
          {
            key: "flac",
            label: "FLAC",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(FlacTab, {})
          },
          enableFunctionSwitchTab && {
            key: "functionSwitchTab",
            label: "功能开关",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(FunctionSwitchTab, {})
          },
          enableDownloadSetting && {
            key: "downloadSetting",
            label: "下载设置",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadSettingTab, {})
          }
        ].filter(Boolean);
        const [cookie, setCookie] = useLocalStorageState("neteaseMusicCookie", {
          defaultValue: "",
          listenStorageChange: true
        });
        const handleGetUserAccount = async () => {
          if (!cookie) return;
          const res = await getUserAccount();
          console.log("res", res);
          if (res.code !== 200) {
            console.log("cookie无效，已置空。");
            setCookie("");
            return;
          }
        };
        useEffect(() => {
          handleGetUserAccount();
        }, []);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            title: "测试Modal",
            open: visible,
            onCancel: close,
            width: 1200,
            styles: {
              body: {
                maxHeight: "75vh",
                overflowY: "auto"
              }
            },
            footer: null,
            centered: true,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs, { items: tabItems })
          }
        );
      });
      const styles = {
        "button-group": "_button-group_fmug6_1"
      };
      const ButtonGroup = () => {
        const { functionConfig } = useConfig();
        const { enableSearch, enableGithubInfo, enableTestModal } = functionConfig;
        const singerSearchRef = useCompRef();
        const handleSingerSearch = () => {
          singerSearchRef.current.open();
        };
        const songListSearchRef = useCompRef();
        const handleSongListSearch = () => {
          songListSearchRef.current.open();
        };
        const songSearchRef = useCompRef();
        const handleSongSearch = () => {
          songSearchRef.current.open();
        };
        const songListDetailRef = useCompRef();
        const handleSongListDetail = () => {
          songListDetailRef.current.open();
        };
        const albumDetailRef = useCompRef();
        const handleAlbumDetail = () => {
          albumDetailRef.current.open();
        };
        const testModalRef = useCompRef();
        const handleTestModal = () => {
          testModalRef.current.open();
        };
        const githubInfoRef = useCompRef();
        const handleGithubInfo = () => {
          githubInfoRef.current.open();
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles["button-group"], children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "歌手查询", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}),
              onClick: handleSingerSearch,
              className: styles["button"]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "歌单查询", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UnorderedListOutlined, {}),
              onClick: handleSongListSearch,
              className: styles["button"]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "歌单详情", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerOutlined, {}),
              onClick: handleSongListDetail,
              className: styles["button"]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "专辑详情", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(BookOutlined, {}),
              onClick: handleAlbumDetail,
              className: styles["button"]
            }
          ) }),
          enableSearch && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "歌曲查询", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SearchOutlined, {}),
              onClick: handleSongSearch,
              className: styles["button"]
            }
          ) }),
          enableTestModal && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "testModal", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoCircleOutlined, {}),
              onClick: handleTestModal,
              className: styles["button"]
            }
          ) }),
          enableGithubInfo && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "githubInfo", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(GithubOutlined, {}),
              onClick: handleGithubInfo,
              className: styles["button"]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TestModal, { ref: testModalRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SingerSearch, { ref: singerSearchRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SongListSearch, { ref: songListSearchRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SongListDetail, { ref: songListDetailRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(AlbumDetail, { ref: albumDetailRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SongSearch, { ref: songSearchRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(GithubInfo, { ref: githubInfoRef })
        ] });
      };
      function App() {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "App", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ConfigProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(App$1, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ModalUtils, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonGroup, {})
        ] }) }) });
      }
      const themeToken = {
        colorPrimary: "#31C27C",
        // QQ音乐特征绿色
        colorPrimaryHover: "#2DB573",
        colorPrimaryActive: "#28A069",
        // 文字颜色
        colorText: "#333333",
        colorTextSecondary: "#666666",
        colorTextTertiary: "#999999",
        colorTextDescription: "#666666",
        // 背景色
        colorBgContainer: "#FFFFFF",
        colorBgLayout: "#F5F5F5",
        colorBgMask: "rgba(0, 0, 0, 0.45)",
        // 边框颜色
        colorBorder: "#E1E1E1",
        colorBorderSecondary: "#F0F0F0",
        // 链接颜色
        colorLink: "#31C27C",
        colorLinkHover: "#2DB573",
        colorLinkActive: "#28A069",
        // 成功、警告、错误状态色
        colorSuccess: "#52C41A",
        colorWarning: "#FAAD14",
        colorError: "#FF4D4F",
        // 字体
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif',
        fontSize: 14,
        // 圆角
        borderRadius: 4,
        borderRadiusLG: 8,
        borderRadiusSM: 2,
        // 间距
        marginXS: 8,
        marginSM: 12,
        margin: 16,
        marginMD: 20,
        marginLG: 24,
        marginXL: 32,
        // 动画
        motionDurationFast: "0.1s",
        motionDurationMid: "0.2s",
        motionDurationSlow: "0.3s",
        motionEaseInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
        motionEaseOut: "cubic-bezier(0.0, 0, 0.2, 1)"
      };
      const themeComponentsToken = {
        // 组件级别的样式定制
        Button: {
          colorPrimary: "#31C27C",
          algorithm: true
          // 启用算法
        },
        Input: {
          colorBorder: "#E1E1E1",
          algorithm: true
        },
        Table: {}
      };
      const theme = {
        token: themeToken,
        components: themeComponentsToken
      };
      ReactDOM.createRoot(
        (() => {
          const app = document.createElement("div");
          document.body.append(app);
          return app;
        })()
      ).render(
        /* @__PURE__ */ jsxRuntimeExports.jsx(require$$0.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ConfigProvider,
          {
            locale: zhCN,
            theme,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {})
          }
        ) })
      );

    })
  };
}));

System.register("./MpegParser-DyX8Q9zG-DQ-hFEy_.js", ['./main-cGY5pIDA-DL9qX_J1.js', './AbstractID3Parser-VsE1AWmF-6kl3V0zG.js', 'react', 'antd', 'react-dom', '@ant-design/icons', './ID3v2Parser-C6PymtiX-BXaBboLM.js'], (function (exports, module) {
  'use strict';
  var EndOfStreamError, initDebug, getBitAllignedNumber, INT16_BE, Uint8ArrayType, StringType, stripNulls, isBitSet$1, makeUnexpectedFileContentError, UINT32_BE, UINT16_BE, UINT8, AbstractID3Parser;
  return {
    setters: [module => {
      EndOfStreamError = module.E;
      initDebug = module.i;
      getBitAllignedNumber = module.g;
      INT16_BE = module.I;
      Uint8ArrayType = module.U;
      StringType = module.S;
      stripNulls = module.s;
      isBitSet$1 = module.a;
      makeUnexpectedFileContentError = module.m;
      UINT32_BE = module.b;
      UINT16_BE = module.c;
      UINT8 = module.d;
    }, module => {
      AbstractID3Parser = module.A;
    }, null, null, null, null, null],
    execute: (function () {

      const ReplayGain = {
        len: 2,
        get: (buf, off) => {
          const gain_type = getBitAllignedNumber(buf, off, 0, 3);
          const sign = getBitAllignedNumber(buf, off, 6, 1);
          const gain_adj = getBitAllignedNumber(buf, off, 7, 9) / 10;
          if (gain_type > 0) {
            return {
              type: getBitAllignedNumber(buf, off, 0, 3),
              origin: getBitAllignedNumber(buf, off, 3, 3),
              adjustment: sign ? -gain_adj : gain_adj
            };
          }
          return void 0;
        }
      };
      const ExtendedLameHeader = {
        len: 27,
        get: (buf, off) => {
          const track_peak = UINT32_BE.get(buf, off + 2);
          return {
            revision: getBitAllignedNumber(buf, off, 0, 4),
            vbr_method: getBitAllignedNumber(buf, off, 4, 4),
            lowpass_filter: 100 * UINT8.get(buf, off + 1),
            track_peak: track_peak === 0 ? null : track_peak / 2 ** 23,
            track_gain: ReplayGain.get(buf, 6),
            album_gain: ReplayGain.get(buf, 8),
            music_length: UINT32_BE.get(buf, off + 20),
            music_crc: UINT8.get(buf, off + 24),
            header_crc: UINT16_BE.get(buf, off + 24)
          };
        }
      };
      const InfoTagHeaderTag = new StringType(4, "ascii");
      const LameEncoderVersion = new StringType(6, "ascii");
      const XingHeaderFlags = {
        len: 4,
        get: (buf, off) => {
          return {
            frames: isBitSet$1(buf, off, 31),
            bytes: isBitSet$1(buf, off, 30),
            toc: isBitSet$1(buf, off, 29),
            vbrScale: isBitSet$1(buf, off, 28)
          };
        }
      };
      async function readXingHeader(tokenizer) {
        const flags = await tokenizer.readToken(XingHeaderFlags);
        const xingInfoTag = { numFrames: null, streamSize: null, vbrScale: null };
        if (flags.frames) {
          xingInfoTag.numFrames = await tokenizer.readToken(UINT32_BE);
        }
        if (flags.bytes) {
          xingInfoTag.streamSize = await tokenizer.readToken(UINT32_BE);
        }
        if (flags.toc) {
          xingInfoTag.toc = new Uint8Array(100);
          await tokenizer.readBuffer(xingInfoTag.toc);
        }
        if (flags.vbrScale) {
          xingInfoTag.vbrScale = await tokenizer.readToken(UINT32_BE);
        }
        const lameTag = await tokenizer.peekToken(new StringType(4, "ascii"));
        if (lameTag === "LAME") {
          await tokenizer.ignore(4);
          xingInfoTag.lame = {
            version: await tokenizer.readToken(new StringType(5, "ascii"))
          };
          const match = xingInfoTag.lame.version.match(/\d+.\d+/g);
          if (match !== null) {
            const majorMinorVersion = match[0];
            const version = majorMinorVersion.split(".").map((n) => Number.parseInt(n, 10));
            if (version[0] >= 3 && version[1] >= 90) {
              xingInfoTag.lame.extended = await tokenizer.readToken(ExtendedLameHeader);
            }
          }
        }
        return xingInfoTag;
      }
      const debug = initDebug("music-metadata:parser:mpeg");
      class MpegContentError extends makeUnexpectedFileContentError("MPEG") {
      } exports("MpegContentError", MpegContentError);
      const maxPeekLen = 1024;
      const MPEG4 = {
        /**
         * Audio Object Types
         */
        AudioObjectTypes: [
          "AAC Main",
          "AAC LC",
          // Low Complexity
          "AAC SSR",
          // Scalable Sample Rate
          "AAC LTP"
          // Long Term Prediction
        ],
        /**
         * Sampling Frequencies
         * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies
         */
        SamplingFrequencies: [
          96e3,
          88200,
          64e3,
          48e3,
          44100,
          32e3,
          24e3,
          22050,
          16e3,
          12e3,
          11025,
          8e3,
          7350,
          null,
          null,
          -1
        ]
        /**
         * Channel Configurations
         */
      };
      const MPEG4_ChannelConfigurations = [
        void 0,
        ["front-center"],
        ["front-left", "front-right"],
        ["front-center", "front-left", "front-right"],
        ["front-center", "front-left", "front-right", "back-center"],
        ["front-center", "front-left", "front-right", "back-left", "back-right"],
        ["front-center", "front-left", "front-right", "back-left", "back-right", "LFE-channel"],
        ["front-center", "front-left", "front-right", "side-left", "side-right", "back-left", "back-right", "LFE-channel"]
      ];
      class MpegFrameHeader {
        constructor(buf, off) {
          this.bitrateIndex = null;
          this.sampRateFreqIndex = null;
          this.padding = null;
          this.privateBit = null;
          this.channelModeIndex = null;
          this.modeExtension = null;
          this.isOriginalMedia = null;
          this.version = null;
          this.bitrate = null;
          this.samplingRate = null;
          this.frameLength = 0;
          this.versionIndex = getBitAllignedNumber(buf, off + 1, 3, 2);
          this.layer = MpegFrameHeader.LayerDescription[getBitAllignedNumber(buf, off + 1, 5, 2)];
          if (this.versionIndex > 1 && this.layer === 0) {
            this.parseAdtsHeader(buf, off);
          } else {
            this.parseMpegHeader(buf, off);
          }
          this.isProtectedByCRC = !isBitSet$1(buf, off + 1, 7);
        }
        calcDuration(numFrames) {
          return this.samplingRate == null ? null : numFrames * this.calcSamplesPerFrame() / this.samplingRate;
        }
        calcSamplesPerFrame() {
          return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];
        }
        calculateSideInfoLength() {
          if (this.layer !== 3)
            return 2;
          if (this.channelModeIndex === 3) {
            if (this.version === 1) {
              return 17;
            }
            if (this.version === 2 || this.version === 2.5) {
              return 9;
            }
          } else {
            if (this.version === 1) {
              return 32;
            }
            if (this.version === 2 || this.version === 2.5) {
              return 17;
            }
          }
          return null;
        }
        calcSlotSize() {
          return [null, 4, 1, 1][this.layer];
        }
        parseMpegHeader(buf, off) {
          this.container = "MPEG";
          this.bitrateIndex = getBitAllignedNumber(buf, off + 2, 0, 4);
          this.sampRateFreqIndex = getBitAllignedNumber(buf, off + 2, 4, 2);
          this.padding = isBitSet$1(buf, off + 2, 6);
          this.privateBit = isBitSet$1(buf, off + 2, 7);
          this.channelModeIndex = getBitAllignedNumber(buf, off + 3, 0, 2);
          this.modeExtension = getBitAllignedNumber(buf, off + 3, 2, 2);
          this.isCopyrighted = isBitSet$1(buf, off + 3, 4);
          this.isOriginalMedia = isBitSet$1(buf, off + 3, 5);
          this.emphasis = getBitAllignedNumber(buf, off + 3, 7, 2);
          this.version = MpegFrameHeader.VersionID[this.versionIndex];
          this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];
          this.codec = `MPEG ${this.version} Layer ${this.layer}`;
          const bitrateInKbps = this.calcBitrate();
          if (!bitrateInKbps) {
            throw new MpegContentError("Cannot determine bit-rate");
          }
          this.bitrate = bitrateInKbps * 1e3;
          this.samplingRate = this.calcSamplingRate();
          if (this.samplingRate == null) {
            throw new MpegContentError("Cannot determine sampling-rate");
          }
        }
        parseAdtsHeader(buf, off) {
          debug("layer=0 => ADTS");
          this.version = this.versionIndex === 2 ? 4 : 2;
          this.container = `ADTS/MPEG-${this.version}`;
          const profileIndex = getBitAllignedNumber(buf, off + 2, 0, 2);
          this.codec = "AAC";
          this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];
          debug(`MPEG-4 audio-codec=${this.codec}`);
          const samplingFrequencyIndex = getBitAllignedNumber(buf, off + 2, 2, 4);
          this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];
          debug(`sampling-rate=${this.samplingRate}`);
          const channelIndex = getBitAllignedNumber(buf, off + 2, 7, 3);
          this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];
          debug(`channel-config=${this.mp4ChannelConfig ? this.mp4ChannelConfig.join("+") : "?"}`);
          this.frameLength = getBitAllignedNumber(buf, off + 3, 6, 2) << 11;
        }
        calcBitrate() {
          if (this.bitrateIndex === 0 || // free
          this.bitrateIndex === 15) {
            return null;
          }
          if (this.version && this.bitrateIndex) {
            const codecIndex = 10 * Math.floor(this.version) + this.layer;
            return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];
          }
          return null;
        }
        calcSamplingRate() {
          if (this.sampRateFreqIndex === 3 || this.version === null || this.sampRateFreqIndex == null)
            return null;
          return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];
        }
      }
      MpegFrameHeader.SyncByte1 = 255;
      MpegFrameHeader.SyncByte2 = 224;
      MpegFrameHeader.VersionID = [2.5, null, 2, 1];
      MpegFrameHeader.LayerDescription = [0, 3, 2, 1];
      MpegFrameHeader.ChannelMode = ["stereo", "joint_stereo", "dual_channel", "mono"];
      MpegFrameHeader.bitrate_index = {
        1: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },
        2: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },
        3: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },
        4: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },
        5: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },
        6: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },
        7: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },
        8: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },
        9: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },
        10: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },
        11: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },
        12: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },
        13: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },
        14: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }
      };
      MpegFrameHeader.sampling_rate_freq_index = {
        1: { 0: 44100, 1: 48e3, 2: 32e3 },
        2: { 0: 22050, 1: 24e3, 2: 16e3 },
        2.5: { 0: 11025, 1: 12e3, 2: 8e3 }
      };
      MpegFrameHeader.samplesInFrameTable = [
        /* Layer   I    II   III */
        [0, 384, 1152, 1152],
        // MPEG-1
        [0, 384, 1152, 576]
        // MPEG-2(.5
      ];
      const FrameHeader = {
        len: 4,
        get: (buf, off) => {
          return new MpegFrameHeader(buf, off);
        }
      };
      function getVbrCodecProfile(vbrScale) {
        return `V${Math.floor((100 - vbrScale) / 10)}`;
      }
      class MpegParser extends AbstractID3Parser {
        constructor() {
          super(...arguments);
          this.frameCount = 0;
          this.syncFrameCount = -1;
          this.countSkipFrameData = 0;
          this.totalDataLength = 0;
          this.bitrates = [];
          this.offset = 0;
          this.frame_size = 0;
          this.crc = null;
          this.calculateEofDuration = false;
          this.samplesPerFrame = null;
          this.buf_frame_header = new Uint8Array(4);
          this.mpegOffset = null;
          this.syncPeek = {
            buf: new Uint8Array(maxPeekLen),
            len: 0
          };
        }
        /**
         * Called after ID3 headers have been parsed
         */
        async postId3v2Parse() {
          this.metadata.setFormat("lossless", false);
          this.metadata.setAudioOnly();
          try {
            let quit = false;
            while (!quit) {
              await this.sync();
              quit = await this.parseCommonMpegHeader();
            }
          } catch (err) {
            if (err instanceof EndOfStreamError) {
              debug("End-of-stream");
              if (this.calculateEofDuration) {
                if (this.samplesPerFrame !== null) {
                  const numberOfSamples = this.frameCount * this.samplesPerFrame;
                  this.metadata.setFormat("numberOfSamples", numberOfSamples);
                  if (this.metadata.format.sampleRate) {
                    const duration = numberOfSamples / this.metadata.format.sampleRate;
                    debug(`Calculate duration at EOF: ${duration} sec.`, duration);
                    this.metadata.setFormat("duration", duration);
                  }
                }
              }
            } else {
              throw err;
            }
          }
        }
        /**
         * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length
         */
        finalize() {
          const format = this.metadata.format;
          const hasID3v1 = !!this.metadata.native.ID3v1;
          if (this.mpegOffset !== null) {
            if (format.duration && this.tokenizer.fileInfo.size) {
              const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);
              if (format.codecProfile && format.codecProfile[0] === "V") {
                this.metadata.setFormat("bitrate", mpegSize * 8 / format.duration);
              }
            }
            if (this.tokenizer.fileInfo.size && format.codecProfile === "CBR") {
              const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);
              if (this.frame_size !== null && this.samplesPerFrame !== null) {
                const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;
                this.metadata.setFormat("numberOfSamples", numberOfSamples);
                if (format.sampleRate && !format.duration) {
                  const duration = numberOfSamples / format.sampleRate;
                  debug("Calculate CBR duration based on file size: %s", duration);
                  this.metadata.setFormat("duration", duration);
                }
              }
            }
          }
        }
        async sync() {
          let gotFirstSync = false;
          while (true) {
            let bo = 0;
            this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: true });
            if (this.syncPeek.len <= 163) {
              throw new EndOfStreamError();
            }
            while (true) {
              if (gotFirstSync && (this.syncPeek.buf[bo] & 224) === 224) {
                this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;
                this.buf_frame_header[1] = this.syncPeek.buf[bo];
                await this.tokenizer.ignore(bo);
                debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);
                if (this.syncFrameCount === this.frameCount) {
                  debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);
                  this.frameCount = 0;
                  this.frame_size = 0;
                }
                this.syncFrameCount = this.frameCount;
                return;
              }
              gotFirstSync = false;
              bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);
              if (bo === -1) {
                if (this.syncPeek.len < this.syncPeek.buf.length) {
                  throw new EndOfStreamError();
                }
                await this.tokenizer.ignore(this.syncPeek.len);
                break;
              }
              ++bo;
              gotFirstSync = true;
            }
          }
        }
        /**
         * Combined ADTS & MPEG (MP2 & MP3) header handling
         * @return {Promise<boolean>} true if parser should quit
         */
        async parseCommonMpegHeader() {
          if (this.frameCount === 0) {
            this.mpegOffset = this.tokenizer.position - 1;
          }
          await this.tokenizer.peekBuffer(this.buf_frame_header.subarray(1), { length: 3 });
          let header;
          try {
            header = FrameHeader.get(this.buf_frame_header, 0);
          } catch (err) {
            await this.tokenizer.ignore(1);
            if (err instanceof Error) {
              this.metadata.addWarning(`Parse error: ${err.message}`);
              return false;
            }
            throw err;
          }
          await this.tokenizer.ignore(3);
          this.metadata.setFormat("container", header.container);
          this.metadata.setFormat("codec", header.codec);
          this.metadata.setFormat("lossless", false);
          this.metadata.setFormat("sampleRate", header.samplingRate);
          this.frameCount++;
          return header.version !== null && header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);
        }
        /**
         * @return {Promise<boolean>} true if parser should quit
         */
        async parseAudioFrameHeader(header) {
          this.metadata.setFormat("numberOfChannels", header.channelMode === "mono" ? 1 : 2);
          this.metadata.setFormat("bitrate", header.bitrate);
          if (this.frameCount < 20 * 1e4) {
            debug("offset=%s MP%s bitrate=%s sample-rate=%s", this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);
          }
          const slot_size = header.calcSlotSize();
          if (slot_size === null) {
            throw new MpegContentError("invalid slot_size");
          }
          const samples_per_frame = header.calcSamplesPerFrame();
          debug(`samples_per_frame=${samples_per_frame}`);
          const bps = samples_per_frame / 8;
          if (header.bitrate !== null && header.samplingRate != null) {
            const fsize = bps * header.bitrate / header.samplingRate + (header.padding ? slot_size : 0);
            this.frame_size = Math.floor(fsize);
          }
          this.audioFrameHeader = header;
          if (header.bitrate !== null) {
            this.bitrates.push(header.bitrate);
          }
          if (this.frameCount === 1) {
            this.offset = FrameHeader.len;
            await this.skipSideInformation();
            return false;
          }
          if (this.frameCount === 3) {
            if (this.areAllSame(this.bitrates)) {
              this.samplesPerFrame = samples_per_frame;
              this.metadata.setFormat("codecProfile", "CBR");
              if (this.tokenizer.fileInfo.size)
                return true;
            } else if (this.metadata.format.duration) {
              return true;
            }
            if (!this.options.duration) {
              return true;
            }
          }
          if (this.options.duration && this.frameCount === 4) {
            this.samplesPerFrame = samples_per_frame;
            this.calculateEofDuration = true;
          }
          this.offset = 4;
          if (header.isProtectedByCRC) {
            await this.parseCrc();
            return false;
          }
          await this.skipSideInformation();
          return false;
        }
        async parseAdts(header) {
          const buf = new Uint8Array(3);
          await this.tokenizer.readBuffer(buf);
          header.frameLength += getBitAllignedNumber(buf, 0, 0, 11);
          this.totalDataLength += header.frameLength;
          this.samplesPerFrame = 1024;
          if (header.samplingRate !== null) {
            const framesPerSec = header.samplingRate / this.samplesPerFrame;
            const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;
            const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;
            this.metadata.setFormat("bitrate", bitrate);
            debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);
          }
          await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);
          if (this.frameCount === 3) {
            this.metadata.setFormat("codecProfile", header.codecProfile);
            if (header.mp4ChannelConfig) {
              this.metadata.setFormat("numberOfChannels", header.mp4ChannelConfig.length);
            }
            if (this.options.duration) {
              this.calculateEofDuration = true;
            } else {
              return true;
            }
          }
          return false;
        }
        async parseCrc() {
          this.crc = await this.tokenizer.readNumber(INT16_BE);
          this.offset += 2;
          return this.skipSideInformation();
        }
        async skipSideInformation() {
          if (this.audioFrameHeader) {
            const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();
            if (sideinfo_length !== null) {
              await this.tokenizer.readToken(new Uint8ArrayType(sideinfo_length));
              this.offset += sideinfo_length;
              await this.readXtraInfoHeader();
              return;
            }
          }
        }
        async readXtraInfoHeader() {
          const headerTag = await this.tokenizer.readToken(InfoTagHeaderTag);
          this.offset += InfoTagHeaderTag.len;
          switch (headerTag) {
            case "Info":
              this.metadata.setFormat("codecProfile", "CBR");
              return this.readXingInfoHeader();
            case "Xing": {
              const infoTag = await this.readXingInfoHeader();
              if (infoTag.vbrScale !== null) {
                const codecProfile = getVbrCodecProfile(infoTag.vbrScale);
                this.metadata.setFormat("codecProfile", codecProfile);
              }
              return null;
            }
            case "Xtra":
              break;
            case "LAME": {
              const version = await this.tokenizer.readToken(LameEncoderVersion);
              if (this.frame_size !== null && this.frame_size >= this.offset + LameEncoderVersion.len) {
                this.offset += LameEncoderVersion.len;
                this.metadata.setFormat("tool", `LAME ${version}`);
                await this.skipFrameData(this.frame_size - this.offset);
                return null;
              }
              this.metadata.addWarning("Corrupt LAME header");
              break;
            }
          }
          const frameDataLeft = this.frame_size - this.offset;
          if (frameDataLeft < 0) {
            this.metadata.addWarning(`Frame ${this.frameCount}corrupt: negative frameDataLeft`);
          } else {
            await this.skipFrameData(frameDataLeft);
          }
          return null;
        }
        /**
         * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
         * @returns {Promise<string>}
         */
        async readXingInfoHeader() {
          const offset = this.tokenizer.position;
          const infoTag = await readXingHeader(this.tokenizer);
          this.offset += this.tokenizer.position - offset;
          if (infoTag.lame) {
            this.metadata.setFormat("tool", `LAME ${stripNulls(infoTag.lame.version)}`);
            if (infoTag.lame.extended) {
              this.metadata.setFormat("trackPeakLevel", infoTag.lame.extended.track_peak);
              if (infoTag.lame.extended.track_gain) {
                this.metadata.setFormat("trackGain", infoTag.lame.extended.track_gain.adjustment);
              }
              if (infoTag.lame.extended.album_gain) {
                this.metadata.setFormat("albumGain", infoTag.lame.extended.album_gain.adjustment);
              }
              this.metadata.setFormat("duration", infoTag.lame.extended.music_length / 1e3);
            }
          }
          if (infoTag.streamSize && this.audioFrameHeader && infoTag.numFrames !== null) {
            const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);
            this.metadata.setFormat("duration", duration);
            debug("Get duration from Xing header: %s", this.metadata.format.duration);
            return infoTag;
          }
          const frameDataLeft = this.frame_size - this.offset;
          await this.skipFrameData(frameDataLeft);
          return infoTag;
        }
        async skipFrameData(frameDataLeft) {
          if (frameDataLeft < 0)
            throw new MpegContentError("frame-data-left cannot be negative");
          await this.tokenizer.ignore(frameDataLeft);
          this.countSkipFrameData += frameDataLeft;
        }
        areAllSame(array) {
          const first = array[0];
          return array.every((element) => {
            return element === first;
          });
        }
      } exports("MpegParser", MpegParser);

    })
  };
}));

System.register("./AsfParser-kBS_Jzzd--TJ98UiQ.js", ['./main-cGY5pIDA-DL9qX_J1.js', 'react', 'antd', 'react-dom', '@ant-design/icons'], (function (exports, module) {
  'use strict';
  var BasicParser, initDebug, TrackType, UINT32_LE, UINT64_LE, uint8ArrayToHex, hexToUint8Array, makeUnexpectedFileContentError, getBit, UINT16_LE, stripNulls, decodeString, StringType, AttachedPictureType;
  return {
    setters: [module => {
      BasicParser = module.B;
      initDebug = module.i;
      TrackType = module.T;
      UINT32_LE = module.e;
      UINT64_LE = module.f;
      uint8ArrayToHex = module.u;
      hexToUint8Array = module.h;
      makeUnexpectedFileContentError = module.m;
      getBit = module.j;
      UINT16_LE = module.k;
      stripNulls = module.s;
      decodeString = module.l;
      StringType = module.S;
      AttachedPictureType = module.A;
    }, null, null, null, null],
    execute: (function () {

      class GUID {
        static fromBin(bin, offset = 0) {
          return new GUID(GUID.decode(bin, offset));
        }
        /**
         * Decode GUID in format like "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
         * @param objectId Binary GUID
         * @param offset Read offset in bytes, default 0
         * @returns GUID as dashed hexadecimal representation
         */
        static decode(objectId, offset = 0) {
          const view = new DataView(objectId.buffer, offset);
          const guid = `${view.getUint32(0, true).toString(16)}-${view.getUint16(4, true).toString(16)}-${view.getUint16(6, true).toString(16)}-${view.getUint16(8).toString(16)}-${uint8ArrayToHex(objectId.slice(offset + 10, offset + 16))}`;
          return guid.toUpperCase();
        }
        /**
         * Decode stream type
         * @param mediaType Media type GUID
         * @returns Media type
         */
        static decodeMediaType(mediaType) {
          switch (mediaType.str) {
            case GUID.AudioMedia.str:
              return "audio";
            case GUID.VideoMedia.str:
              return "video";
            case GUID.CommandMedia.str:
              return "command";
            case GUID.Degradable_JPEG_Media.str:
              return "degradable-jpeg";
            case GUID.FileTransferMedia.str:
              return "file-transfer";
            case GUID.BinaryMedia.str:
              return "binary";
          }
        }
        /**
         * Encode GUID
         * @param guid GUID like: "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
         * @returns Encoded Binary GUID
         */
        static encode(str) {
          const bin = new Uint8Array(16);
          const view = new DataView(bin.buffer);
          view.setUint32(0, Number.parseInt(str.slice(0, 8), 16), true);
          view.setUint16(4, Number.parseInt(str.slice(9, 13), 16), true);
          view.setUint16(6, Number.parseInt(str.slice(14, 18), 16), true);
          bin.set(hexToUint8Array(str.slice(19, 23)), 8);
          bin.set(hexToUint8Array(str.slice(24)), 10);
          return bin;
        }
        constructor(str) {
          this.str = str;
        }
        equals(guid) {
          return this.str === guid.str;
        }
        toBin() {
          return GUID.encode(this.str);
        }
      }
      GUID.HeaderObject = new GUID("75B22630-668E-11CF-A6D9-00AA0062CE6C");
      GUID.DataObject = new GUID("75B22636-668E-11CF-A6D9-00AA0062CE6C");
      GUID.SimpleIndexObject = new GUID("33000890-E5B1-11CF-89F4-00A0C90349CB");
      GUID.IndexObject = new GUID("D6E229D3-35DA-11D1-9034-00A0C90349BE");
      GUID.MediaObjectIndexObject = new GUID("FEB103F8-12AD-4C64-840F-2A1D2F7AD48C");
      GUID.TimecodeIndexObject = new GUID("3CB73FD0-0C4A-4803-953D-EDF7B6228F0C");
      GUID.FilePropertiesObject = new GUID("8CABDCA1-A947-11CF-8EE4-00C00C205365");
      GUID.StreamPropertiesObject = new GUID("B7DC0791-A9B7-11CF-8EE6-00C00C205365");
      GUID.HeaderExtensionObject = new GUID("5FBF03B5-A92E-11CF-8EE3-00C00C205365");
      GUID.CodecListObject = new GUID("86D15240-311D-11D0-A3A4-00A0C90348F6");
      GUID.ScriptCommandObject = new GUID("1EFB1A30-0B62-11D0-A39B-00A0C90348F6");
      GUID.MarkerObject = new GUID("F487CD01-A951-11CF-8EE6-00C00C205365");
      GUID.BitrateMutualExclusionObject = new GUID("D6E229DC-35DA-11D1-9034-00A0C90349BE");
      GUID.ErrorCorrectionObject = new GUID("75B22635-668E-11CF-A6D9-00AA0062CE6C");
      GUID.ContentDescriptionObject = new GUID("75B22633-668E-11CF-A6D9-00AA0062CE6C");
      GUID.ExtendedContentDescriptionObject = new GUID("D2D0A440-E307-11D2-97F0-00A0C95EA850");
      GUID.ContentBrandingObject = new GUID("2211B3FA-BD23-11D2-B4B7-00A0C955FC6E");
      GUID.StreamBitratePropertiesObject = new GUID("7BF875CE-468D-11D1-8D82-006097C9A2B2");
      GUID.ContentEncryptionObject = new GUID("2211B3FB-BD23-11D2-B4B7-00A0C955FC6E");
      GUID.ExtendedContentEncryptionObject = new GUID("298AE614-2622-4C17-B935-DAE07EE9289C");
      GUID.DigitalSignatureObject = new GUID("2211B3FC-BD23-11D2-B4B7-00A0C955FC6E");
      GUID.PaddingObject = new GUID("1806D474-CADF-4509-A4BA-9AABCB96AAE8");
      GUID.ExtendedStreamPropertiesObject = new GUID("14E6A5CB-C672-4332-8399-A96952065B5A");
      GUID.AdvancedMutualExclusionObject = new GUID("A08649CF-4775-4670-8A16-6E35357566CD");
      GUID.GroupMutualExclusionObject = new GUID("D1465A40-5A79-4338-B71B-E36B8FD6C249");
      GUID.StreamPrioritizationObject = new GUID("D4FED15B-88D3-454F-81F0-ED5C45999E24");
      GUID.BandwidthSharingObject = new GUID("A69609E6-517B-11D2-B6AF-00C04FD908E9");
      GUID.LanguageListObject = new GUID("7C4346A9-EFE0-4BFC-B229-393EDE415C85");
      GUID.MetadataObject = new GUID("C5F8CBEA-5BAF-4877-8467-AA8C44FA4CCA");
      GUID.MetadataLibraryObject = new GUID("44231C94-9498-49D1-A141-1D134E457054");
      GUID.IndexParametersObject = new GUID("D6E229DF-35DA-11D1-9034-00A0C90349BE");
      GUID.MediaObjectIndexParametersObject = new GUID("6B203BAD-3F11-48E4-ACA8-D7613DE2CFA7");
      GUID.TimecodeIndexParametersObject = new GUID("F55E496D-9797-4B5D-8C8B-604DFE9BFB24");
      GUID.CompatibilityObject = new GUID("26F18B5D-4584-47EC-9F5F-0E651F0452C9");
      GUID.AdvancedContentEncryptionObject = new GUID("43058533-6981-49E6-9B74-AD12CB86D58C");
      GUID.AudioMedia = new GUID("F8699E40-5B4D-11CF-A8FD-00805F5C442B");
      GUID.VideoMedia = new GUID("BC19EFC0-5B4D-11CF-A8FD-00805F5C442B");
      GUID.CommandMedia = new GUID("59DACFC0-59E6-11D0-A3AC-00A0C90348F6");
      GUID.JFIF_Media = new GUID("B61BE100-5B4E-11CF-A8FD-00805F5C442B");
      GUID.Degradable_JPEG_Media = new GUID("35907DE0-E415-11CF-A917-00805F5C442B");
      GUID.FileTransferMedia = new GUID("91BD222C-F21C-497A-8B6D-5AA86BFC0185");
      GUID.BinaryMedia = new GUID("3AFB65E2-47EF-40F2-AC2C-70A90D71D343");
      GUID.ASF_Index_Placeholder_Object = new GUID("D9AADE20-7C17-4F9C-BC28-8555DD98E2A2");
      function getParserForAttr(i) {
        return attributeParsers[i];
      }
      function parseUnicodeAttr(uint8Array) {
        return stripNulls(decodeString(uint8Array, "utf-16le"));
      }
      const attributeParsers = [
        parseUnicodeAttr,
        parseByteArrayAttr,
        parseBoolAttr,
        parseDWordAttr,
        parseQWordAttr,
        parseWordAttr,
        parseByteArrayAttr
      ];
      function parseByteArrayAttr(buf) {
        return new Uint8Array(buf);
      }
      function parseBoolAttr(buf, offset = 0) {
        return parseWordAttr(buf, offset) === 1;
      }
      function parseDWordAttr(buf, offset = 0) {
        return UINT32_LE.get(buf, offset);
      }
      function parseQWordAttr(buf, offset = 0) {
        return UINT64_LE.get(buf, offset);
      }
      function parseWordAttr(buf, offset = 0) {
        return UINT16_LE.get(buf, offset);
      }
      class AsfContentParseError extends makeUnexpectedFileContentError("ASF") {
      }
      const TopLevelHeaderObjectToken = {
        len: 30,
        get: (buf, off) => {
          return {
            objectId: GUID.fromBin(buf, off),
            objectSize: Number(UINT64_LE.get(buf, off + 16)),
            numberOfHeaderObjects: UINT32_LE.get(buf, off + 24)
            // Reserved: 2 bytes
          };
        }
      };
      const HeaderObjectToken = {
        len: 24,
        get: (buf, off) => {
          return {
            objectId: GUID.fromBin(buf, off),
            objectSize: Number(UINT64_LE.get(buf, off + 16))
          };
        }
      };
      class State {
        constructor(header) {
          this.len = Number(header.objectSize) - HeaderObjectToken.len;
        }
        postProcessTag(tags, name, valueType, data) {
          if (name === "WM/Picture") {
            tags.push({ id: name, value: WmPictureToken.fromBuffer(data) });
          } else {
            const parseAttr = getParserForAttr(valueType);
            if (!parseAttr) {
              throw new AsfContentParseError(`unexpected value headerType: ${valueType}`);
            }
            tags.push({ id: name, value: parseAttr(data) });
          }
        }
      }
      class IgnoreObjectState extends State {
        get(_buf, _off) {
          return null;
        }
      }
      class FilePropertiesObject extends State {
        get(buf, off) {
          return {
            fileId: GUID.fromBin(buf, off),
            fileSize: UINT64_LE.get(buf, off + 16),
            creationDate: UINT64_LE.get(buf, off + 24),
            dataPacketsCount: UINT64_LE.get(buf, off + 32),
            playDuration: UINT64_LE.get(buf, off + 40),
            sendDuration: UINT64_LE.get(buf, off + 48),
            preroll: UINT64_LE.get(buf, off + 56),
            flags: {
              broadcast: getBit(buf, off + 64, 24),
              seekable: getBit(buf, off + 64, 25)
            },
            // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
            minimumDataPacketSize: UINT32_LE.get(buf, off + 68),
            maximumDataPacketSize: UINT32_LE.get(buf, off + 72),
            maximumBitrate: UINT32_LE.get(buf, off + 76)
          };
        }
      }
      FilePropertiesObject.guid = GUID.FilePropertiesObject;
      class StreamPropertiesObject extends State {
        get(buf, off) {
          return {
            streamType: GUID.decodeMediaType(GUID.fromBin(buf, off)),
            errorCorrectionType: GUID.fromBin(buf, off + 8)
            // ToDo
          };
        }
      }
      StreamPropertiesObject.guid = GUID.StreamPropertiesObject;
      class HeaderExtensionObject {
        constructor() {
          this.len = 22;
        }
        get(buf, off) {
          const view = new DataView(buf.buffer, off);
          return {
            reserved1: GUID.fromBin(buf, off),
            reserved2: view.getUint16(16, true),
            extensionDataSize: view.getUint16(18, true)
          };
        }
      }
      HeaderExtensionObject.guid = GUID.HeaderExtensionObject;
      const CodecListObjectHeader = {
        len: 20,
        get: (buf, off) => {
          const view = new DataView(buf.buffer, off);
          return {
            entryCount: view.getUint16(16, true)
          };
        }
      };
      async function readString(tokenizer) {
        const length = await tokenizer.readNumber(UINT16_LE);
        return (await tokenizer.readToken(new StringType(length * 2, "utf-16le"))).replace("\0", "");
      }
      async function readCodecEntries(tokenizer) {
        const codecHeader = await tokenizer.readToken(CodecListObjectHeader);
        const entries = [];
        for (let i = 0; i < codecHeader.entryCount; ++i) {
          entries.push(await readCodecEntry(tokenizer));
        }
        return entries;
      }
      async function readInformation(tokenizer) {
        const length = await tokenizer.readNumber(UINT16_LE);
        const buf = new Uint8Array(length);
        await tokenizer.readBuffer(buf);
        return buf;
      }
      async function readCodecEntry(tokenizer) {
        const type = await tokenizer.readNumber(UINT16_LE);
        return {
          type: {
            videoCodec: (type & 1) === 1,
            audioCodec: (type & 2) === 2
          },
          codecName: await readString(tokenizer),
          description: await readString(tokenizer),
          information: await readInformation(tokenizer)
        };
      }
      class ContentDescriptionObjectState extends State {
        get(buf, off) {
          const tags = [];
          const view = new DataView(buf.buffer, off);
          let pos = 10;
          for (let i = 0; i < ContentDescriptionObjectState.contentDescTags.length; ++i) {
            const length = view.getUint16(i * 2, true);
            if (length > 0) {
              const tagName = ContentDescriptionObjectState.contentDescTags[i];
              const end = pos + length;
              tags.push({ id: tagName, value: parseUnicodeAttr(buf.slice(off + pos, off + end)) });
              pos = end;
            }
          }
          return tags;
        }
      }
      ContentDescriptionObjectState.guid = GUID.ContentDescriptionObject;
      ContentDescriptionObjectState.contentDescTags = ["Title", "Author", "Copyright", "Description", "Rating"];
      class ExtendedContentDescriptionObjectState extends State {
        get(buf, off) {
          const tags = [];
          const view = new DataView(buf.buffer, off);
          const attrCount = view.getUint16(0, true);
          let pos = 2;
          for (let i = 0; i < attrCount; i += 1) {
            const nameLen = view.getUint16(pos, true);
            pos += 2;
            const name = parseUnicodeAttr(buf.slice(off + pos, off + pos + nameLen));
            pos += nameLen;
            const valueType = view.getUint16(pos, true);
            pos += 2;
            const valueLen = view.getUint16(pos, true);
            pos += 2;
            const value = buf.slice(off + pos, off + pos + valueLen);
            pos += valueLen;
            this.postProcessTag(tags, name, valueType, value);
          }
          return tags;
        }
      }
      ExtendedContentDescriptionObjectState.guid = GUID.ExtendedContentDescriptionObject;
      class ExtendedStreamPropertiesObjectState extends State {
        get(buf, off) {
          const view = new DataView(buf.buffer, off);
          return {
            startTime: UINT64_LE.get(buf, off),
            endTime: UINT64_LE.get(buf, off + 8),
            dataBitrate: view.getInt32(12, true),
            bufferSize: view.getInt32(16, true),
            initialBufferFullness: view.getInt32(20, true),
            alternateDataBitrate: view.getInt32(24, true),
            alternateBufferSize: view.getInt32(28, true),
            alternateInitialBufferFullness: view.getInt32(32, true),
            maximumObjectSize: view.getInt32(36, true),
            flags: {
              reliableFlag: getBit(buf, off + 40, 0),
              seekableFlag: getBit(buf, off + 40, 1),
              resendLiveCleanpointsFlag: getBit(buf, off + 40, 2)
            },
            // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
            streamNumber: view.getInt16(42, true),
            streamLanguageId: view.getInt16(44, true),
            averageTimePerFrame: view.getInt32(52, true),
            streamNameCount: view.getInt32(54, true),
            payloadExtensionSystems: view.getInt32(56, true),
            streamNames: [],
            // ToDo
            streamPropertiesObject: null
          };
        }
      }
      ExtendedStreamPropertiesObjectState.guid = GUID.ExtendedStreamPropertiesObject;
      class MetadataObjectState extends State {
        get(uint8Array, off) {
          const tags = [];
          const view = new DataView(uint8Array.buffer, off);
          const descriptionRecordsCount = view.getUint16(0, true);
          let pos = 2;
          for (let i = 0; i < descriptionRecordsCount; i += 1) {
            pos += 4;
            const nameLen = view.getUint16(pos, true);
            pos += 2;
            const dataType = view.getUint16(pos, true);
            pos += 2;
            const dataLen = view.getUint32(pos, true);
            pos += 4;
            const name = parseUnicodeAttr(uint8Array.slice(off + pos, off + pos + nameLen));
            pos += nameLen;
            const data = uint8Array.slice(off + pos, off + pos + dataLen);
            pos += dataLen;
            this.postProcessTag(tags, name, dataType, data);
          }
          return tags;
        }
      }
      MetadataObjectState.guid = GUID.MetadataObject;
      class MetadataLibraryObjectState extends MetadataObjectState {
      }
      MetadataLibraryObjectState.guid = GUID.MetadataLibraryObject;
      class WmPictureToken {
        static fromBuffer(buffer) {
          const pic = new WmPictureToken(buffer.length);
          return pic.get(buffer, 0);
        }
        constructor(len) {
          this.len = len;
        }
        get(buffer, offset) {
          const view = new DataView(buffer.buffer, offset);
          const typeId = view.getUint8(0);
          const size = view.getInt32(1, true);
          let index = 5;
          while (view.getUint16(index) !== 0) {
            index += 2;
          }
          const format = new StringType(index - 5, "utf-16le").get(buffer, 5);
          while (view.getUint16(index) !== 0) {
            index += 2;
          }
          const description = new StringType(index - 5, "utf-16le").get(buffer, 5);
          return {
            type: AttachedPictureType[typeId],
            format,
            description,
            size,
            data: buffer.slice(index + 4)
          };
        }
      }
      const debug = initDebug("music-metadata:parser:ASF");
      const headerType = "asf";
      class AsfParser extends BasicParser {
        async parse() {
          const header = await this.tokenizer.readToken(TopLevelHeaderObjectToken);
          if (!header.objectId.equals(GUID.HeaderObject)) {
            throw new AsfContentParseError(`expected asf header; but was not found; got: ${header.objectId.str}`);
          }
          try {
            await this.parseObjectHeader(header.numberOfHeaderObjects);
          } catch (err) {
            debug("Error while parsing ASF: %s", err);
          }
        }
        async parseObjectHeader(numberOfObjectHeaders) {
          let tags;
          do {
            const header = await this.tokenizer.readToken(HeaderObjectToken);
            debug("header GUID=%s", header.objectId.str);
            switch (header.objectId.str) {
              case FilePropertiesObject.guid.str: {
                const fpo = await this.tokenizer.readToken(new FilePropertiesObject(header));
                this.metadata.setFormat("duration", Number(fpo.playDuration / BigInt(1e3)) / 1e4 - Number(fpo.preroll) / 1e3);
                this.metadata.setFormat("bitrate", fpo.maximumBitrate);
                break;
              }
              case StreamPropertiesObject.guid.str: {
                const spo = await this.tokenizer.readToken(new StreamPropertiesObject(header));
                this.metadata.setFormat("container", `ASF/${spo.streamType}`);
                break;
              }
              case HeaderExtensionObject.guid.str: {
                const extHeader = await this.tokenizer.readToken(new HeaderExtensionObject());
                await this.parseExtensionObject(extHeader.extensionDataSize);
                break;
              }
              case ContentDescriptionObjectState.guid.str:
                tags = await this.tokenizer.readToken(new ContentDescriptionObjectState(header));
                await this.addTags(tags);
                break;
              case ExtendedContentDescriptionObjectState.guid.str:
                tags = await this.tokenizer.readToken(new ExtendedContentDescriptionObjectState(header));
                await this.addTags(tags);
                break;
              case GUID.CodecListObject.str: {
                const codecs = await readCodecEntries(this.tokenizer);
                codecs.forEach((codec) => {
                  this.metadata.addStreamInfo({
                    type: codec.type.videoCodec ? TrackType.video : TrackType.audio,
                    codecName: codec.codecName
                  });
                });
                const audioCodecs = codecs.filter((codec) => codec.type.audioCodec).map((codec) => codec.codecName).join("/");
                this.metadata.setFormat("codec", audioCodecs);
                break;
              }
              case GUID.StreamBitratePropertiesObject.str:
                await this.tokenizer.ignore(header.objectSize - HeaderObjectToken.len);
                break;
              case GUID.PaddingObject.str:
                debug("Padding: %s bytes", header.objectSize - HeaderObjectToken.len);
                await this.tokenizer.ignore(header.objectSize - HeaderObjectToken.len);
                break;
              default:
                this.metadata.addWarning(`Ignore ASF-Object-GUID: ${header.objectId.str}`);
                debug("Ignore ASF-Object-GUID: %s", header.objectId.str);
                await this.tokenizer.readToken(new IgnoreObjectState(header));
            }
          } while (--numberOfObjectHeaders);
        }
        async addTags(tags) {
          await Promise.all(tags.map(({ id, value }) => this.metadata.addTag(headerType, id, value)));
        }
        async parseExtensionObject(extensionSize) {
          do {
            const header = await this.tokenizer.readToken(HeaderObjectToken);
            const remaining = header.objectSize - HeaderObjectToken.len;
            switch (header.objectId.str) {
              case ExtendedStreamPropertiesObjectState.guid.str:
                await this.tokenizer.readToken(new ExtendedStreamPropertiesObjectState(header));
                break;
              case MetadataObjectState.guid.str: {
                const moTags = await this.tokenizer.readToken(new MetadataObjectState(header));
                await this.addTags(moTags);
                break;
              }
              case MetadataLibraryObjectState.guid.str: {
                const mlTags = await this.tokenizer.readToken(new MetadataLibraryObjectState(header));
                await this.addTags(mlTags);
                break;
              }
              case GUID.PaddingObject.str:
                await this.tokenizer.ignore(remaining);
                break;
              case GUID.CompatibilityObject.str:
                await this.tokenizer.ignore(remaining);
                break;
              case GUID.ASF_Index_Placeholder_Object.str:
                await this.tokenizer.ignore(remaining);
                break;
              default:
                this.metadata.addWarning(`Ignore ASF-Object-GUID: ${header.objectId.str}`);
                await this.tokenizer.readToken(new IgnoreObjectState(header));
                break;
            }
            extensionSize -= header.objectSize;
          } while (extensionSize > 0);
        }
      } exports("AsfParser", AsfParser);

    })
  };
}));

System.register("./DsdiffParser-Cj-IrqyX-XWY5qgSL.js", ['./main-cGY5pIDA-DL9qX_J1.js', './ID3v2Parser-C6PymtiX-BXaBboLM.js', 'react', 'antd', 'react-dom', '@ant-design/icons'], (function (exports, module) {
  'use strict';
  var BasicParser, FourCcToken, initDebug, Uint8ArrayType, fromBuffer, UINT32_LE, UINT16_BE, UINT8, UINT32_BE, StringType, INT64_BE, makeUnexpectedFileContentError, ID3v2Parser;
  return {
    setters: [module => {
      BasicParser = module.B;
      FourCcToken = module.F;
      initDebug = module.i;
      Uint8ArrayType = module.U;
      fromBuffer = module.n;
      UINT32_LE = module.e;
      UINT16_BE = module.c;
      UINT8 = module.d;
      UINT32_BE = module.b;
      StringType = module.S;
      INT64_BE = module.o;
      makeUnexpectedFileContentError = module.m;
    }, module => {
      ID3v2Parser = module.I;
    }, null, null, null, null],
    execute: (function () {

      const ChunkHeader64 = {
        len: 12,
        get: (buf, off) => {
          return {
            // Group-ID
            chunkID: FourCcToken.get(buf, off),
            // Size
            chunkSize: INT64_BE.get(buf, off + 4)
          };
        }
      };
      const debug = initDebug("music-metadata:parser:aiff");
      class DsdiffContentParseError extends makeUnexpectedFileContentError("DSDIFF") {
      } exports("DsdiffContentParseError", DsdiffContentParseError);
      class DsdiffParser extends BasicParser {
        async parse() {
          const header = await this.tokenizer.readToken(ChunkHeader64);
          if (header.chunkID !== "FRM8")
            throw new DsdiffContentParseError("Unexpected chunk-ID");
          this.metadata.setAudioOnly();
          const type = (await this.tokenizer.readToken(FourCcToken)).trim();
          switch (type) {
            case "DSD":
              this.metadata.setFormat("container", `DSDIFF/${type}`);
              this.metadata.setFormat("lossless", true);
              return this.readFmt8Chunks(header.chunkSize - BigInt(FourCcToken.len));
            default:
              throw new DsdiffContentParseError(`Unsupported DSDIFF type: ${type}`);
          }
        }
        async readFmt8Chunks(remainingSize) {
          while (remainingSize >= ChunkHeader64.len) {
            const chunkHeader = await this.tokenizer.readToken(ChunkHeader64);
            debug(`Chunk id=${chunkHeader.chunkID}`);
            await this.readData(chunkHeader);
            remainingSize -= BigInt(ChunkHeader64.len) + chunkHeader.chunkSize;
          }
        }
        async readData(header) {
          debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);
          const p0 = this.tokenizer.position;
          switch (header.chunkID.trim()) {
            case "FVER": {
              const version = await this.tokenizer.readToken(UINT32_LE);
              debug(`DSDIFF version=${version}`);
              break;
            }
            case "PROP": {
              const propType = await this.tokenizer.readToken(FourCcToken);
              if (propType !== "SND ")
                throw new DsdiffContentParseError("Unexpected PROP-chunk ID");
              await this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCcToken.len));
              break;
            }
            case "ID3": {
              const id3_data = await this.tokenizer.readToken(new Uint8ArrayType(Number(header.chunkSize)));
              const rst = fromBuffer(id3_data);
              await new ID3v2Parser().parse(this.metadata, rst, this.options);
              break;
            }
            case "DSD":
              if (this.metadata.format.numberOfChannels) {
                this.metadata.setFormat("numberOfSamples", Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels)));
              }
              if (this.metadata.format.numberOfSamples && this.metadata.format.sampleRate) {
                this.metadata.setFormat("duration", this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);
              }
              break;
            default:
              debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);
              break;
          }
          const remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);
          if (remaining > 0) {
            debug(`After Parsing chunk, remaining ${remaining} bytes`);
            await this.tokenizer.ignore(Number(remaining));
          }
        }
        async handleSoundPropertyChunks(remainingSize) {
          debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);
          while (remainingSize > 0) {
            const sndPropHeader = await this.tokenizer.readToken(ChunkHeader64);
            debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);
            const p0 = this.tokenizer.position;
            switch (sndPropHeader.chunkID.trim()) {
              case "FS": {
                const sampleRate = await this.tokenizer.readToken(UINT32_BE);
                this.metadata.setFormat("sampleRate", sampleRate);
                break;
              }
              case "CHNL": {
                const numChannels = await this.tokenizer.readToken(UINT16_BE);
                this.metadata.setFormat("numberOfChannels", numChannels);
                await this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(UINT16_BE.len));
                break;
              }
              case "CMPR": {
                const compressionIdCode = (await this.tokenizer.readToken(FourCcToken)).trim();
                const count = await this.tokenizer.readToken(UINT8);
                const compressionName = await this.tokenizer.readToken(new StringType(count, "ascii"));
                if (compressionIdCode === "DSD") {
                  this.metadata.setFormat("lossless", true);
                  this.metadata.setFormat("bitsPerSample", 1);
                }
                this.metadata.setFormat("codec", `${compressionIdCode} (${compressionName})`);
                break;
              }
              case "ABSS": {
                const hours = await this.tokenizer.readToken(UINT16_BE);
                const minutes = await this.tokenizer.readToken(UINT8);
                const seconds = await this.tokenizer.readToken(UINT8);
                const samples = await this.tokenizer.readToken(UINT32_BE);
                debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);
                break;
              }
              case "LSCO": {
                const lsConfig = await this.tokenizer.readToken(UINT16_BE);
                debug(`LSCO lsConfig=${lsConfig}`);
                break;
              }
              default:
                debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);
                await this.tokenizer.ignore(Number(sndPropHeader.chunkSize));
            }
            const remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);
            if (remaining > 0) {
              debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);
              await this.tokenizer.ignore(Number(remaining));
            }
            remainingSize -= BigInt(ChunkHeader64.len) + sndPropHeader.chunkSize;
            debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);
          }
          if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {
            const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;
            this.metadata.setFormat("bitrate", bitrate);
          }
        }
        async handleChannelChunks(remainingSize) {
          debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);
          const channels = [];
          while (remainingSize >= FourCcToken.len) {
            const channelId = await this.tokenizer.readToken(FourCcToken);
            debug(`Channel[ID=${channelId}]`);
            channels.push(channelId);
            remainingSize -= BigInt(FourCcToken.len);
          }
          debug(`Channels: ${channels.join(", ")}`);
          return channels;
        }
      } exports("DsdiffParser", DsdiffParser);

    })
  };
}));

System.register("./AiffParser-D5_3j2lV-CIoGOP9Z.js", ['./main-cGY5pIDA-DL9qX_J1.js', './ID3v2Parser-C6PymtiX-BXaBboLM.js', 'react', 'antd', 'react-dom', '@ant-design/icons'], (function (exports, module) {
  'use strict';
  var BasicParser, FourCcToken, initDebug, EndOfStreamError, Uint8ArrayType, fromBuffer, StringType, UINT32_BE, makeUnexpectedFileContentError, UINT16_BE, UINT8, ID3v2Parser;
  return {
    setters: [module => {
      BasicParser = module.B;
      FourCcToken = module.F;
      initDebug = module.i;
      EndOfStreamError = module.E;
      Uint8ArrayType = module.U;
      fromBuffer = module.n;
      StringType = module.S;
      UINT32_BE = module.b;
      makeUnexpectedFileContentError = module.m;
      UINT16_BE = module.c;
      UINT8 = module.d;
    }, module => {
      ID3v2Parser = module.I;
    }, null, null, null, null],
    execute: (function () {

      const compressionTypes = {
        NONE: "not compressed	PCM	Apple Computer",
        sowt: "PCM (byte swapped)",
        fl32: "32-bit floating point IEEE 32-bit float",
        fl64: "64-bit floating point IEEE 64-bit float	Apple Computer",
        alaw: "ALaw 2:1	8-bit ITU-T G.711 A-law",
        ulaw: "µLaw 2:1	8-bit ITU-T G.711 µ-law	Apple Computer",
        ULAW: "CCITT G.711 u-law 8-bit ITU-T G.711 µ-law",
        ALAW: "CCITT G.711 A-law 8-bit ITU-T G.711 A-law",
        FL32: "Float 32	IEEE 32-bit float "
      };
      class AiffContentError extends makeUnexpectedFileContentError("AIFF") {
      }
      class Common {
        constructor(header, isAifc) {
          this.isAifc = isAifc;
          const minimumChunkSize = isAifc ? 22 : 18;
          if (header.chunkSize < minimumChunkSize)
            throw new AiffContentError(`COMMON CHUNK size should always be at least ${minimumChunkSize}`);
          this.len = header.chunkSize;
        }
        get(buf, off) {
          const shift = UINT16_BE.get(buf, off + 8) - 16398;
          const baseSampleRate = UINT16_BE.get(buf, off + 8 + 2);
          const res = {
            numChannels: UINT16_BE.get(buf, off),
            numSampleFrames: UINT32_BE.get(buf, off + 2),
            sampleSize: UINT16_BE.get(buf, off + 6),
            sampleRate: shift < 0 ? baseSampleRate >> Math.abs(shift) : baseSampleRate << shift
          };
          if (this.isAifc) {
            res.compressionType = FourCcToken.get(buf, off + 18);
            if (this.len > 22) {
              const strLen = UINT8.get(buf, off + 22);
              if (strLen > 0) {
                const padding = (strLen + 1) % 2;
                if (23 + strLen + padding === this.len) {
                  res.compressionName = new StringType(strLen, "latin1").get(buf, off + 23);
                } else {
                  throw new AiffContentError("Illegal pstring length");
                }
              } else {
                res.compressionName = void 0;
              }
            }
          } else {
            res.compressionName = "PCM";
          }
          return res;
        }
      }
      const Header = {
        len: 8,
        get: (buf, off) => {
          return {
            // Chunk type ID
            chunkID: FourCcToken.get(buf, off),
            // Chunk size
            chunkSize: Number(BigInt(UINT32_BE.get(buf, off + 4)))
          };
        }
      };
      const debug = initDebug("music-metadata:parser:aiff");
      class AIFFParser extends BasicParser {
        constructor() {
          super(...arguments);
          this.isCompressed = null;
        }
        async parse() {
          const header = await this.tokenizer.readToken(Header);
          if (header.chunkID !== "FORM")
            throw new AiffContentError("Invalid Chunk-ID, expected 'FORM'");
          const type = await this.tokenizer.readToken(FourCcToken);
          switch (type) {
            case "AIFF":
              this.metadata.setFormat("container", type);
              this.isCompressed = false;
              break;
            case "AIFC":
              this.metadata.setFormat("container", "AIFF-C");
              this.isCompressed = true;
              break;
            default:
              throw new AiffContentError(`Unsupported AIFF type: ${type}`);
          }
          this.metadata.setFormat("lossless", !this.isCompressed);
          this.metadata.setAudioOnly();
          try {
            while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= Header.len) {
              debug(`Reading AIFF chunk at offset=${this.tokenizer.position}`);
              const chunkHeader = await this.tokenizer.readToken(Header);
              const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);
              const bytesRead = await this.readData(chunkHeader);
              await this.tokenizer.ignore(nextChunk - bytesRead);
            }
          } catch (err) {
            if (err instanceof EndOfStreamError) {
              debug("End-of-stream");
            } else {
              throw err;
            }
          }
        }
        async readData(header) {
          switch (header.chunkID) {
            case "COMM": {
              if (this.isCompressed === null) {
                throw new AiffContentError("Failed to parse AIFF.COMM chunk when compression type is unknown");
              }
              const common = await this.tokenizer.readToken(new Common(header, this.isCompressed));
              this.metadata.setFormat("bitsPerSample", common.sampleSize);
              this.metadata.setFormat("sampleRate", common.sampleRate);
              this.metadata.setFormat("numberOfChannels", common.numChannels);
              this.metadata.setFormat("numberOfSamples", common.numSampleFrames);
              this.metadata.setFormat("duration", common.numSampleFrames / common.sampleRate);
              if (common.compressionName || common.compressionType) {
                this.metadata.setFormat("codec", common.compressionName ?? compressionTypes[common.compressionType]);
              }
              return header.chunkSize;
            }
            case "ID3 ": {
              const id3_data = await this.tokenizer.readToken(new Uint8ArrayType(header.chunkSize));
              const rst = fromBuffer(id3_data);
              await new ID3v2Parser().parse(this.metadata, rst, this.options);
              return header.chunkSize;
            }
            case "SSND":
              if (this.metadata.format.duration) {
                this.metadata.setFormat("bitrate", 8 * header.chunkSize / this.metadata.format.duration);
              }
              return 0;
            case "NAME":
            // Sample name chunk
            case "AUTH":
            // Author chunk
            case "(c) ":
            // Copyright chunk
            case "ANNO":
              return this.readTextChunk(header);
            default:
              debug(`Ignore chunk id=${header.chunkID}, size=${header.chunkSize}`);
              return 0;
          }
        }
        async readTextChunk(header) {
          const value = await this.tokenizer.readToken(new StringType(header.chunkSize, "ascii"));
          const values = value.split("\0").map((v) => v.trim()).filter((v) => v?.length);
          await Promise.all(values.map((v) => this.metadata.addTag("AIFF", header.chunkID, v)));
          return header.chunkSize;
        }
      } exports("AIFFParser", AIFFParser);

    })
  };
}));

System.register("./DsfParser-CXpMW3TW-C2hKRmVY.js", ['./main-cGY5pIDA-DL9qX_J1.js', './AbstractID3Parser-VsE1AWmF-6kl3V0zG.js', './ID3v2Parser-C6PymtiX-BXaBboLM.js', 'react', 'antd', 'react-dom', '@ant-design/icons'], (function (exports, module) {
  'use strict';
  var initDebug, UINT64_LE, FourCcToken, makeUnexpectedFileContentError, INT64_LE, INT32_LE, AbstractID3Parser, ID3v2Parser;
  return {
    setters: [module => {
      initDebug = module.i;
      UINT64_LE = module.f;
      FourCcToken = module.F;
      makeUnexpectedFileContentError = module.m;
      INT64_LE = module.p;
      INT32_LE = module.q;
    }, module => {
      AbstractID3Parser = module.A;
    }, module => {
      ID3v2Parser = module.I;
    }, null, null, null, null],
    execute: (function () {

      const ChunkHeader = {
        len: 12,
        get: (buf, off) => {
          return { id: FourCcToken.get(buf, off), size: UINT64_LE.get(buf, off + 4) };
        }
      };
      const DsdChunk = {
        len: 16,
        get: (buf, off) => {
          return {
            fileSize: INT64_LE.get(buf, off),
            metadataPointer: INT64_LE.get(buf, off + 8)
          };
        }
      };
      const FormatChunk = {
        len: 40,
        get: (buf, off) => {
          return {
            formatVersion: INT32_LE.get(buf, off),
            formatID: INT32_LE.get(buf, off + 4),
            channelType: INT32_LE.get(buf, off + 8),
            channelNum: INT32_LE.get(buf, off + 12),
            samplingFrequency: INT32_LE.get(buf, off + 16),
            bitsPerSample: INT32_LE.get(buf, off + 20),
            sampleCount: INT64_LE.get(buf, off + 24),
            blockSizePerChannel: INT32_LE.get(buf, off + 32)
          };
        }
      };
      const debug = initDebug("music-metadata:parser:DSF");
      class DsdContentParseError extends makeUnexpectedFileContentError("DSD") {
      } exports("DsdContentParseError", DsdContentParseError);
      class DsfParser extends AbstractID3Parser {
        async postId3v2Parse() {
          const p0 = this.tokenizer.position;
          const chunkHeader = await this.tokenizer.readToken(ChunkHeader);
          if (chunkHeader.id !== "DSD ")
            throw new DsdContentParseError("Invalid chunk signature");
          this.metadata.setFormat("container", "DSF");
          this.metadata.setFormat("lossless", true);
          this.metadata.setAudioOnly();
          const dsdChunk = await this.tokenizer.readToken(DsdChunk);
          if (dsdChunk.metadataPointer === BigInt(0)) {
            debug("No ID3v2 tag present");
          } else {
            debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);
            await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);
            await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);
            return new ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);
          }
        }
        async parseChunks(bytesRemaining) {
          while (bytesRemaining >= ChunkHeader.len) {
            const chunkHeader = await this.tokenizer.readToken(ChunkHeader);
            debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);
            switch (chunkHeader.id) {
              case "fmt ": {
                const formatChunk = await this.tokenizer.readToken(FormatChunk);
                this.metadata.setFormat("numberOfChannels", formatChunk.channelNum);
                this.metadata.setFormat("sampleRate", formatChunk.samplingFrequency);
                this.metadata.setFormat("bitsPerSample", formatChunk.bitsPerSample);
                this.metadata.setFormat("numberOfSamples", formatChunk.sampleCount);
                this.metadata.setFormat("duration", Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);
                const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;
                this.metadata.setFormat("bitrate", bitrate);
                return;
              }
              default:
                this.tokenizer.ignore(Number(chunkHeader.size) - ChunkHeader.len);
                break;
            }
            bytesRemaining -= chunkHeader.size;
          }
        }
      } exports("DsfParser", DsfParser);

    })
  };
}));

System.register("./MatroskaParser-CS7zPSHf-BBAz_su7.js", ['./main-cGY5pIDA-DL9qX_J1.js', 'react', 'antd', 'react-dom', '@ant-design/icons'], (function (exports, module) {
  'use strict';
  var BasicParser, initDebug, TargetType, TrackType, EndOfStreamError, UINT8, Float64_BE, Float32_BE, StringType, makeUnexpectedFileContentError, UINT64_BE;
  return {
    setters: [module => {
      BasicParser = module.B;
      initDebug = module.i;
      TargetType = module.r;
      TrackType = module.T;
      EndOfStreamError = module.E;
      UINT8 = module.d;
      Float64_BE = module.t;
      Float32_BE = module.v;
      StringType = module.S;
      makeUnexpectedFileContentError = module.m;
      UINT64_BE = module.w;
    }, null, null, null, null],
    execute: (function () {

      const DataType = {
        string: 0,
        uint: 1,
        uid: 2,
        bool: 3,
        binary: 4,
        float: 5
      };
      const matroskaDtd = {
        name: "dtd",
        container: {
          440786851: {
            name: "ebml",
            container: {
              17030: { name: "ebmlVersion", value: DataType.uint },
              // 5.1.1
              17143: { name: "ebmlReadVersion", value: DataType.uint },
              // 5.1.2
              17138: { name: "ebmlMaxIDWidth", value: DataType.uint },
              // 5.1.3
              17139: { name: "ebmlMaxSizeWidth", value: DataType.uint },
              // 5.1.4
              17026: { name: "docType", value: DataType.string },
              // 5.1.5
              17031: { name: "docTypeVersion", value: DataType.uint },
              // 5.1.6
              17029: { name: "docTypeReadVersion", value: DataType.uint }
              // 5.1.7
            }
          },
          // Matroska segments
          408125543: {
            name: "segment",
            container: {
              // Meta Seek Information (also known as MetaSeek)
              290298740: {
                name: "seekHead",
                container: {
                  19899: {
                    name: "seek",
                    multiple: true,
                    container: {
                      21419: { name: "id", value: DataType.binary },
                      21420: { name: "position", value: DataType.uint }
                    }
                  }
                }
              },
              // Segment Information
              357149030: {
                name: "info",
                container: {
                  29604: { name: "uid", value: DataType.uid },
                  29572: { name: "filename", value: DataType.string },
                  3979555: { name: "prevUID", value: DataType.uid },
                  3965867: { name: "prevFilename", value: DataType.string },
                  4110627: { name: "nextUID", value: DataType.uid },
                  4096955: { name: "nextFilename", value: DataType.string },
                  2807729: { name: "timecodeScale", value: DataType.uint },
                  17545: { name: "duration", value: DataType.float },
                  17505: { name: "dateUTC", value: DataType.uint },
                  31657: { name: "title", value: DataType.string },
                  19840: { name: "muxingApp", value: DataType.string },
                  22337: { name: "writingApp", value: DataType.string }
                }
              },
              // Cluster
              524531317: {
                name: "cluster",
                multiple: true,
                container: {
                  231: { name: "timecode", value: DataType.uid },
                  22743: { name: "silentTracks ", multiple: true },
                  167: { name: "position", value: DataType.uid },
                  171: { name: "prevSize", value: DataType.uid },
                  160: { name: "blockGroup" },
                  163: { name: "simpleBlock" }
                }
              },
              // Track
              374648427: {
                name: "tracks",
                container: {
                  174: {
                    name: "entries",
                    multiple: true,
                    container: {
                      215: { name: "trackNumber", value: DataType.uint },
                      29637: { name: "uid", value: DataType.uid },
                      131: { name: "trackType", value: DataType.uint },
                      185: { name: "flagEnabled", value: DataType.bool },
                      136: { name: "flagDefault", value: DataType.bool },
                      21930: { name: "flagForced", value: DataType.bool },
                      // extended
                      156: { name: "flagLacing", value: DataType.bool },
                      28135: { name: "minCache", value: DataType.uint },
                      28136: { name: "maxCache", value: DataType.uint },
                      2352003: { name: "defaultDuration", value: DataType.uint },
                      2306383: { name: "timecodeScale", value: DataType.float },
                      21358: { name: "name", value: DataType.string },
                      2274716: { name: "language", value: DataType.string },
                      134: { name: "codecID", value: DataType.string },
                      25506: { name: "codecPrivate", value: DataType.binary },
                      2459272: { name: "codecName", value: DataType.string },
                      3839639: { name: "codecSettings", value: DataType.string },
                      3883072: { name: "codecInfoUrl", value: DataType.string },
                      2536e3: { name: "codecDownloadUrl", value: DataType.string },
                      170: { name: "codecDecodeAll", value: DataType.bool },
                      28587: { name: "trackOverlay", value: DataType.uint },
                      // Video
                      224: {
                        name: "video",
                        container: {
                          154: { name: "flagInterlaced", value: DataType.bool },
                          21432: { name: "stereoMode", value: DataType.uint },
                          176: { name: "pixelWidth", value: DataType.uint },
                          186: { name: "pixelHeight", value: DataType.uint },
                          21680: { name: "displayWidth", value: DataType.uint },
                          21690: { name: "displayHeight", value: DataType.uint },
                          21683: { name: "aspectRatioType", value: DataType.uint },
                          3061028: { name: "colourSpace", value: DataType.uint },
                          3126563: { name: "gammaValue", value: DataType.float }
                        }
                      },
                      // Audio
                      225: {
                        name: "audio",
                        container: {
                          181: { name: "samplingFrequency", value: DataType.float },
                          30901: { name: "outputSamplingFrequency", value: DataType.float },
                          159: { name: "channels", value: DataType.uint },
                          // https://www.matroska.org/technical/specs/index.html
                          148: { name: "channels", value: DataType.uint },
                          32123: { name: "channelPositions", value: DataType.binary },
                          25188: { name: "bitDepth", value: DataType.uint }
                        }
                      },
                      // Content Encoding
                      28032: {
                        name: "contentEncodings",
                        container: {
                          25152: {
                            name: "contentEncoding",
                            container: {
                              20529: { name: "order", value: DataType.uint },
                              20530: { name: "scope", value: DataType.bool },
                              20531: { name: "type", value: DataType.uint },
                              20532: {
                                name: "contentEncoding",
                                container: {
                                  16980: { name: "contentCompAlgo", value: DataType.uint },
                                  16981: { name: "contentCompSettings", value: DataType.binary }
                                }
                              },
                              20533: {
                                name: "contentEncoding",
                                container: {
                                  18401: { name: "contentEncAlgo", value: DataType.uint },
                                  18402: { name: "contentEncKeyID", value: DataType.binary },
                                  18403: { name: "contentSignature ", value: DataType.binary },
                                  18404: { name: "ContentSigKeyID  ", value: DataType.binary },
                                  18405: { name: "contentSigAlgo ", value: DataType.uint },
                                  18406: { name: "contentSigHashAlgo ", value: DataType.uint }
                                }
                              },
                              25188: { name: "bitDepth", value: DataType.uint }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              // Cueing Data
              475249515: {
                name: "cues",
                container: {
                  187: {
                    name: "cuePoint",
                    container: {
                      179: { name: "cueTime", value: DataType.uid },
                      183: {
                        name: "positions",
                        container: {
                          247: { name: "track", value: DataType.uint },
                          241: { name: "clusterPosition", value: DataType.uint },
                          21368: { name: "blockNumber", value: DataType.uint },
                          234: { name: "codecState", value: DataType.uint },
                          219: {
                            name: "reference",
                            container: {
                              150: { name: "time", value: DataType.uint },
                              151: { name: "cluster", value: DataType.uint },
                              21343: { name: "number", value: DataType.uint },
                              235: { name: "codecState", value: DataType.uint }
                            }
                          },
                          240: { name: "relativePosition", value: DataType.uint }
                          // extended
                        }
                      }
                    }
                  }
                }
              },
              // Attachment
              423732329: {
                name: "attachments",
                container: {
                  24999: {
                    name: "attachedFiles",
                    multiple: true,
                    container: {
                      18046: { name: "description", value: DataType.string },
                      18030: { name: "name", value: DataType.string },
                      18016: { name: "mimeType", value: DataType.string },
                      18012: { name: "data", value: DataType.binary },
                      18094: { name: "uid", value: DataType.uid }
                    }
                  }
                }
              },
              // Chapters
              272869232: {
                name: "chapters",
                container: {
                  17849: {
                    name: "editionEntry",
                    container: {
                      182: {
                        name: "chapterAtom",
                        container: {
                          29636: { name: "uid", value: DataType.uid },
                          145: { name: "timeStart", value: DataType.uint },
                          146: { name: "timeEnd", value: DataType.uid },
                          152: { name: "hidden", value: DataType.bool },
                          17816: { name: "enabled", value: DataType.uid },
                          143: {
                            name: "track",
                            container: {
                              137: { name: "trackNumber", value: DataType.uid },
                              128: {
                                name: "display",
                                container: {
                                  133: { name: "string", value: DataType.string },
                                  17276: { name: "language ", value: DataType.string },
                                  17278: { name: "country ", value: DataType.string }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              // Tagging
              307544935: {
                name: "tags",
                container: {
                  29555: {
                    name: "tag",
                    multiple: true,
                    container: {
                      25536: {
                        name: "target",
                        container: {
                          25541: { name: "tagTrackUID", value: DataType.uid },
                          25540: { name: "tagChapterUID", value: DataType.uint },
                          25542: { name: "tagAttachmentUID", value: DataType.uid },
                          25546: { name: "targetType", value: DataType.string },
                          // extended
                          26826: { name: "targetTypeValue", value: DataType.uint },
                          // extended
                          25545: { name: "tagEditionUID", value: DataType.uid }
                          // extended
                        }
                      },
                      26568: {
                        name: "simpleTags",
                        multiple: true,
                        container: {
                          17827: { name: "name", value: DataType.string },
                          17543: { name: "string", value: DataType.string },
                          17541: { name: "binary", value: DataType.binary },
                          17530: { name: "language", value: DataType.string },
                          // extended
                          17531: { name: "languageIETF", value: DataType.string },
                          // extended
                          17540: { name: "default", value: DataType.bool }
                          // extended
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      };
      const debug$1 = initDebug("music-metadata:parser:ebml");
      class EbmlContentError extends makeUnexpectedFileContentError("EBML") {
      }
      const ParseAction = {
        ReadNext: 0,
        // Continue reading the next elements
        IgnoreElement: 2,
        // Ignore (do not read) this element
        SkipSiblings: 3,
        // Skip all remaining elements at the same level
        TerminateParsing: 4,
        // Terminate the parsing process
        SkipElement: 5
        // Consider the element has read, assume position is at the next element
      };
      class EbmlIterator {
        /**
         * @param {ITokenizer} tokenizer Input
         * @param tokenizer
         */
        constructor(tokenizer) {
          this.padding = 0;
          this.parserMap = /* @__PURE__ */ new Map();
          this.ebmlMaxIDLength = 4;
          this.ebmlMaxSizeLength = 8;
          this.tokenizer = tokenizer;
          this.parserMap.set(DataType.uint, (e) => this.readUint(e));
          this.parserMap.set(DataType.string, (e) => this.readString(e));
          this.parserMap.set(DataType.binary, (e) => this.readBuffer(e));
          this.parserMap.set(DataType.uid, async (e) => this.readBuffer(e));
          this.parserMap.set(DataType.bool, (e) => this.readFlag(e));
          this.parserMap.set(DataType.float, (e) => this.readFloat(e));
        }
        async iterate(dtdElement, posDone, listener) {
          return this.parseContainer(linkParents(dtdElement), posDone, listener);
        }
        async parseContainer(dtdElement, posDone, listener) {
          const tree = {};
          while (this.tokenizer.position < posDone) {
            let element;
            const elementPosition = this.tokenizer.position;
            try {
              element = await this.readElement();
            } catch (error) {
              if (error instanceof EndOfStreamError) {
                break;
              }
              throw error;
            }
            const child = dtdElement.container[element.id];
            if (child) {
              const action = listener.startNext(child);
              switch (action) {
                case ParseAction.ReadNext:
                  {
                    if (element.id === 524531317) ;
                    debug$1(`Read element: name=${getElementPath(child)}{id=0x${element.id.toString(16)}, container=${!!child.container}} at position=${elementPosition}`);
                    if (child.container) {
                      const res = await this.parseContainer(child, element.len >= 0 ? this.tokenizer.position + element.len : -1, listener);
                      if (child.multiple) {
                        if (!tree[child.name]) {
                          tree[child.name] = [];
                        }
                        tree[child.name].push(res);
                      } else {
                        tree[child.name] = res;
                      }
                      await listener.elementValue(child, res, elementPosition);
                    } else {
                      const parser = this.parserMap.get(child.value);
                      if (typeof parser === "function") {
                        const value = await parser(element);
                        tree[child.name] = value;
                        await listener.elementValue(child, value, elementPosition);
                      }
                    }
                  }
                  break;
                case ParseAction.SkipElement:
                  debug$1(`Go to next element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);
                  break;
                case ParseAction.IgnoreElement:
                  debug$1(`Ignore element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);
                  await this.tokenizer.ignore(element.len);
                  break;
                case ParseAction.SkipSiblings:
                  debug$1(`Ignore remaining container, at: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);
                  await this.tokenizer.ignore(posDone - this.tokenizer.position);
                  break;
                case ParseAction.TerminateParsing:
                  debug$1(`Terminate parsing at element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);
                  return tree;
              }
            } else {
              switch (element.id) {
                case 236:
                  this.padding += element.len;
                  await this.tokenizer.ignore(element.len);
                  break;
                default:
                  debug$1(`parseEbml: parent=${getElementPath(dtdElement)}, unknown child: id=${element.id.toString(16)} at position=${elementPosition}`);
                  this.padding += element.len;
                  await this.tokenizer.ignore(element.len);
              }
            }
          }
          return tree;
        }
        async readVintData(maxLength) {
          const msb = await this.tokenizer.peekNumber(UINT8);
          let mask = 128;
          let oc = 1;
          while ((msb & mask) === 0) {
            if (oc > maxLength) {
              throw new EbmlContentError("VINT value exceeding maximum size");
            }
            ++oc;
            mask >>= 1;
          }
          const id = new Uint8Array(oc);
          await this.tokenizer.readBuffer(id);
          return id;
        }
        async readElement() {
          const id = await this.readVintData(this.ebmlMaxIDLength);
          const lenField = await this.readVintData(this.ebmlMaxSizeLength);
          lenField[0] ^= 128 >> lenField.length - 1;
          return {
            id: readUIntBE(id, id.length),
            len: readUIntBE(lenField, lenField.length)
          };
        }
        async readFloat(e) {
          switch (e.len) {
            case 0:
              return 0;
            case 4:
              return this.tokenizer.readNumber(Float32_BE);
            case 8:
              return this.tokenizer.readNumber(Float64_BE);
            case 10:
              return this.tokenizer.readNumber(Float64_BE);
            default:
              throw new EbmlContentError(`Invalid IEEE-754 float length: ${e.len}`);
          }
        }
        async readFlag(e) {
          return await this.readUint(e) === 1;
        }
        async readUint(e) {
          const buf = await this.readBuffer(e);
          return readUIntBE(buf, e.len);
        }
        async readString(e) {
          const rawString = await this.tokenizer.readToken(new StringType(e.len, "utf-8"));
          return rawString.replace(/\x00.*$/g, "");
        }
        async readBuffer(e) {
          const buf = new Uint8Array(e.len);
          await this.tokenizer.readBuffer(buf);
          return buf;
        }
      }
      function readUIntBE(buf, len) {
        return Number(readUIntBeAsBigInt(buf, len));
      }
      function readUIntBeAsBigInt(buf, len) {
        const normalizedNumber = new Uint8Array(8);
        const cleanNumber = buf.subarray(0, len);
        try {
          normalizedNumber.set(cleanNumber, 8 - len);
          return UINT64_BE.get(normalizedNumber, 0);
        } catch (_error) {
          return BigInt(-1);
        }
      }
      function linkParents(element) {
        if (element.container) {
          Object.keys(element.container).map((id) => {
            const child = element.container[id];
            child.id = Number.parseInt(id);
            return child;
          }).forEach((child) => {
            child.parent = element;
            linkParents(child);
          });
        }
        return element;
      }
      function getElementPath(element) {
        let path = "";
        if (element.parent && element.parent.name !== "dtd") {
          path += `${getElementPath(element.parent)}/`;
        }
        return path + element.name;
      }
      const debug = initDebug("music-metadata:parser:matroska");
      class MatroskaParser extends BasicParser {
        constructor() {
          super(...arguments);
          this.seekHeadOffset = 0;
          this.flagUseIndexToSkipClusters = this.options.mkvUseIndex ?? false;
        }
        async parse() {
          const containerSize = this.tokenizer.fileInfo.size ?? Number.MAX_SAFE_INTEGER;
          const matroskaIterator = new EbmlIterator(this.tokenizer);
          debug("Initializing DTD end MatroskaIterator");
          await matroskaIterator.iterate(matroskaDtd, containerSize, {
            startNext: (element) => {
              switch (element.id) {
                // case 0x1f43b675: // cluster
                case 475249515:
                  debug(`Skip element: name=${element.name}, id=0x${element.id.toString(16)}`);
                  return ParseAction.IgnoreElement;
                case 524531317:
                  if (this.flagUseIndexToSkipClusters && this.seekHead) {
                    const index = this.seekHead.seek.find((index2) => index2.position + this.seekHeadOffset > this.tokenizer.position);
                    if (index) {
                      const ignoreSize = index.position + this.seekHeadOffset - this.tokenizer.position;
                      debug(`Use index to go to next position, ignoring ${ignoreSize} bytes`);
                      this.tokenizer.ignore(ignoreSize);
                      return ParseAction.SkipElement;
                    }
                  }
                  return ParseAction.IgnoreElement;
                default:
                  return ParseAction.ReadNext;
              }
            },
            elementValue: async (element, value, offset) => {
              debug(`Received: name=${element.name}, value=${value}`);
              switch (element.id) {
                case 17026:
                  this.metadata.setFormat("container", `EBML/${value}`);
                  break;
                case 290298740:
                  this.seekHead = value;
                  this.seekHeadOffset = offset;
                  break;
                case 357149030:
                  {
                    const info = value;
                    const timecodeScale = info.timecodeScale ? info.timecodeScale : 1e6;
                    if (typeof info.duration === "number") {
                      const duration = info.duration * timecodeScale / 1e9;
                      await this.addTag("segment:title", info.title);
                      this.metadata.setFormat("duration", Number(duration));
                    }
                  }
                  break;
                case 374648427:
                  {
                    const audioTracks = value;
                    if (audioTracks?.entries) {
                      audioTracks.entries.forEach((entry) => {
                        const stream = {
                          codecName: entry.codecID.replace("A_", "").replace("V_", ""),
                          codecSettings: entry.codecSettings,
                          flagDefault: entry.flagDefault,
                          flagLacing: entry.flagLacing,
                          flagEnabled: entry.flagEnabled,
                          language: entry.language,
                          name: entry.name,
                          type: entry.trackType,
                          audio: entry.audio,
                          video: entry.video
                        };
                        this.metadata.addStreamInfo(stream);
                      });
                      const audioTrack = audioTracks.entries.filter((entry) => entry.trackType === TrackType.audio).reduce((acc, cur) => {
                        if (!acc)
                          return cur;
                        if (cur.flagDefault && !acc.flagDefault)
                          return cur;
                        if (cur.trackNumber < acc.trackNumber)
                          return cur;
                        return acc;
                      }, null);
                      if (audioTrack) {
                        this.metadata.setFormat("codec", audioTrack.codecID.replace("A_", ""));
                        this.metadata.setFormat("sampleRate", audioTrack.audio.samplingFrequency);
                        this.metadata.setFormat("numberOfChannels", audioTrack.audio.channels);
                      }
                    }
                  }
                  break;
                case 307544935:
                  {
                    const tags = value;
                    await Promise.all(tags.tag.map(async (tag) => {
                      const target = tag.target;
                      const targetType = target?.targetTypeValue ? TargetType[target.targetTypeValue] : target?.targetType ? target.targetType : "track";
                      await Promise.all(tag.simpleTags.map(async (simpleTag) => {
                        const value2 = simpleTag.string ? simpleTag.string : simpleTag.binary;
                        await this.addTag(`${targetType}:${simpleTag.name}`, value2);
                      }));
                    }));
                  }
                  break;
                case 423732329:
                  {
                    const attachments = value;
                    await Promise.all(attachments.attachedFiles.filter((file) => file.mimeType.startsWith("image/")).map((file) => this.addTag("picture", {
                      data: file.data,
                      format: file.mimeType,
                      description: file.description,
                      name: file.name
                    })));
                  }
                  break;
              }
            }
          });
        }
        async addTag(tagId, value) {
          await this.metadata.addTag("matroska", tagId, value);
        }
      } exports("MatroskaParser", MatroskaParser);

    })
  };
}));

System.register("./MP4Parser-D4esQf31-DVt6cbno.js", ['./main-cGY5pIDA-DL9qX_J1.js', 'react', 'antd', 'react-dom', '@ant-design/icons'], (function (exports, module) {
  'use strict';
  var BasicParser, StringType, initDebug, UINT32_BE, Token, Uint8ArrayType, uint8ArrayToHex, textDecode, UINT16_BE, UINT8, Genres, TrackType, INT32_BE, INT24_BE, INT8, UINT24_BE, makeUnexpectedFileContentError, FourCcToken, UINT64_BE, getBit, INT16_BE;
  return {
    setters: [module => {
      BasicParser = module.B;
      StringType = module.S;
      initDebug = module.i;
      UINT32_BE = module.b;
      Token = module.x;
      Uint8ArrayType = module.U;
      uint8ArrayToHex = module.u;
      textDecode = module.y;
      UINT16_BE = module.c;
      UINT8 = module.d;
      Genres = module.G;
      TrackType = module.T;
      INT32_BE = module.z;
      INT24_BE = module.C;
      INT8 = module.D;
      UINT24_BE = module.H;
      makeUnexpectedFileContentError = module.m;
      FourCcToken = module.F;
      UINT64_BE = module.w;
      getBit = module.j;
      INT16_BE = module.I;
    }, null, null, null, null],
    execute: (function () {

      const debug$2 = initDebug("music-metadata:parser:MP4:atom");
      class Mp4ContentError extends makeUnexpectedFileContentError("MP4") {
      }
      const Header = {
        len: 8,
        get: (buf, off) => {
          const length = UINT32_BE.get(buf, off);
          if (length < 0)
            throw new Mp4ContentError("Invalid atom header length");
          return {
            length: BigInt(length),
            name: new StringType(4, "latin1").get(buf, off + 4)
          };
        },
        put: (buf, off, hdr) => {
          UINT32_BE.put(buf, off, Number(hdr.length));
          return FourCcToken.put(buf, off + 4, hdr.name);
        }
      };
      const ExtendedSize = UINT64_BE;
      const ftyp = {
        len: 4,
        get: (buf, off) => {
          return {
            type: new StringType(4, "ascii").get(buf, off)
          };
        }
      };
      class FixedLengthAtom {
        /**
         *
         * @param {number} len Length as specified in the size field
         * @param {number} expLen Total length of sum of specified fields in the standard
         * @param atomId Atom ID
         */
        constructor(len, expLen, atomId) {
          if (len < expLen) {
            throw new Mp4ContentError(`Atom ${atomId} expected to be ${expLen}, but specifies ${len} bytes long.`);
          }
          if (len > expLen) {
            debug$2(`Warning: atom ${atomId} expected to be ${expLen}, but was actually ${len} bytes long.`);
          }
          this.len = len;
        }
      }
      const SecondsSinceMacEpoch = {
        len: 4,
        get: (buf, off) => {
          const secondsSinceUnixEpoch = UINT32_BE.get(buf, off) - 2082844800;
          return new Date(secondsSinceUnixEpoch * 1e3);
        }
      };
      class MdhdAtom extends FixedLengthAtom {
        constructor(len) {
          super(len, 24, "mdhd");
        }
        get(buf, off) {
          return {
            version: UINT8.get(buf, off + 0),
            flags: UINT24_BE.get(buf, off + 1),
            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
            timeScale: UINT32_BE.get(buf, off + 12),
            duration: UINT32_BE.get(buf, off + 16),
            language: UINT16_BE.get(buf, off + 20),
            quality: UINT16_BE.get(buf, off + 22)
          };
        }
      }
      class MvhdAtom extends FixedLengthAtom {
        constructor(len) {
          super(len, 100, "mvhd");
        }
        get(buf, off) {
          return {
            version: UINT8.get(buf, off),
            flags: UINT24_BE.get(buf, off + 1),
            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
            timeScale: UINT32_BE.get(buf, off + 12),
            duration: UINT32_BE.get(buf, off + 16),
            preferredRate: UINT32_BE.get(buf, off + 20),
            preferredVolume: UINT16_BE.get(buf, off + 24),
            // ignore reserver: 10 bytes
            // ignore matrix structure: 36 bytes
            previewTime: UINT32_BE.get(buf, off + 72),
            previewDuration: UINT32_BE.get(buf, off + 76),
            posterTime: UINT32_BE.get(buf, off + 80),
            selectionTime: UINT32_BE.get(buf, off + 84),
            selectionDuration: UINT32_BE.get(buf, off + 88),
            currentTime: UINT32_BE.get(buf, off + 92),
            nextTrackID: UINT32_BE.get(buf, off + 96)
          };
        }
      }
      class DataAtom {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          return {
            type: {
              set: UINT8.get(buf, off + 0),
              type: UINT24_BE.get(buf, off + 1)
            },
            locale: UINT24_BE.get(buf, off + 4),
            value: new Uint8ArrayType(this.len - 8).get(buf, off + 8)
          };
        }
      }
      class NameAtom {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          return {
            version: UINT8.get(buf, off),
            flags: UINT24_BE.get(buf, off + 1),
            name: new StringType(this.len - 4, "utf-8").get(buf, off + 4)
          };
        }
      }
      class TrackHeaderAtom {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          return {
            version: UINT8.get(buf, off),
            flags: UINT24_BE.get(buf, off + 1),
            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
            trackId: UINT32_BE.get(buf, off + 12),
            // reserved 4 bytes
            duration: UINT32_BE.get(buf, off + 20),
            layer: UINT16_BE.get(buf, off + 24),
            alternateGroup: UINT16_BE.get(buf, off + 26),
            volume: UINT16_BE.get(buf, off + 28)
            // ToDo: fixed point
            // ToDo: add remaining fields
          };
        }
      }
      const stsdHeader = {
        len: 8,
        get: (buf, off) => {
          return {
            version: UINT8.get(buf, off),
            flags: UINT24_BE.get(buf, off + 1),
            numberOfEntries: UINT32_BE.get(buf, off + 4)
          };
        }
      };
      class SampleDescriptionTable {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          const descrLen = this.len - 12;
          return {
            dataFormat: FourCcToken.get(buf, off),
            dataReferenceIndex: UINT16_BE.get(buf, off + 10),
            description: descrLen > 0 ? new Uint8ArrayType(descrLen).get(buf, off + 12) : void 0
          };
        }
      }
      class StsdAtom {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          const header = stsdHeader.get(buf, off);
          off += stsdHeader.len;
          const table = [];
          for (let n = 0; n < header.numberOfEntries; ++n) {
            const size = UINT32_BE.get(buf, off);
            off += UINT32_BE.len;
            table.push(new SampleDescriptionTable(size - UINT32_BE.len).get(buf, off));
            off += size;
          }
          return {
            header,
            table
          };
        }
      }
      const SoundSampleDescriptionVersion = {
        len: 8,
        get(buf, off) {
          return {
            version: INT16_BE.get(buf, off),
            revision: INT16_BE.get(buf, off + 2),
            vendor: INT32_BE.get(buf, off + 4)
          };
        }
      };
      const SoundSampleDescriptionV0 = {
        len: 12,
        get(buf, off) {
          return {
            numAudioChannels: INT16_BE.get(buf, off + 0),
            sampleSize: INT16_BE.get(buf, off + 2),
            compressionId: INT16_BE.get(buf, off + 4),
            packetSize: INT16_BE.get(buf, off + 6),
            sampleRate: UINT16_BE.get(buf, off + 8) + UINT16_BE.get(buf, off + 10) / 1e4
          };
        }
      };
      class SimpleTableAtom {
        constructor(len, token) {
          this.len = len;
          this.token = token;
        }
        get(buf, off) {
          const nrOfEntries = INT32_BE.get(buf, off + 4);
          return {
            version: INT8.get(buf, off + 0),
            flags: INT24_BE.get(buf, off + 1),
            numberOfEntries: nrOfEntries,
            entries: readTokenTable(buf, this.token, off + 8, this.len - 8, nrOfEntries)
          };
        }
      }
      const TimeToSampleToken = {
        len: 8,
        get(buf, off) {
          return {
            count: INT32_BE.get(buf, off + 0),
            duration: INT32_BE.get(buf, off + 4)
          };
        }
      };
      class SttsAtom extends SimpleTableAtom {
        constructor(len) {
          super(len, TimeToSampleToken);
        }
      }
      const SampleToChunkToken = {
        len: 12,
        get(buf, off) {
          return {
            firstChunk: INT32_BE.get(buf, off),
            samplesPerChunk: INT32_BE.get(buf, off + 4),
            sampleDescriptionId: INT32_BE.get(buf, off + 8)
          };
        }
      };
      class StscAtom extends SimpleTableAtom {
        constructor(len) {
          super(len, SampleToChunkToken);
        }
      }
      class StszAtom {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          const nrOfEntries = INT32_BE.get(buf, off + 8);
          return {
            version: INT8.get(buf, off),
            flags: INT24_BE.get(buf, off + 1),
            sampleSize: INT32_BE.get(buf, off + 4),
            numberOfEntries: nrOfEntries,
            entries: readTokenTable(buf, INT32_BE, off + 12, this.len - 12, nrOfEntries)
          };
        }
      }
      class StcoAtom extends SimpleTableAtom {
        constructor(len) {
          super(len, INT32_BE);
          this.len = len;
        }
      }
      class ChapterText {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          const titleLen = INT16_BE.get(buf, off + 0);
          const str = new StringType(titleLen, "utf-8");
          return str.get(buf, off + 2);
        }
      }
      function readTokenTable(buf, token, off, remainingLen, numberOfEntries) {
        debug$2(`remainingLen=${remainingLen}, numberOfEntries=${numberOfEntries} * token-len=${token.len}`);
        if (remainingLen === 0)
          return [];
        if (remainingLen !== numberOfEntries * token.len)
          throw new Mp4ContentError("mismatch number-of-entries with remaining atom-length");
        const entries = [];
        for (let n = 0; n < numberOfEntries; ++n) {
          entries.push(token.get(buf, off));
          off += token.len;
        }
        return entries;
      }
      class TrackFragmentHeaderBox {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          const flagOffset = off + 1;
          const header = {
            version: INT8.get(buf, off),
            flags: {
              baseDataOffsetPresent: getBit(buf, flagOffset + 2, 0),
              sampleDescriptionIndexPresent: getBit(buf, flagOffset + 2, 1),
              defaultSampleDurationPresent: getBit(buf, flagOffset + 2, 3),
              defaultSampleSizePresent: getBit(buf, flagOffset + 2, 4),
              defaultSampleFlagsPresent: getBit(buf, flagOffset + 2, 5),
              defaultDurationIsEmpty: getBit(buf, flagOffset, 0),
              defaultBaseIsMoof: getBit(buf, flagOffset, 1)
            },
            trackId: UINT32_BE.get(buf, 4)
          };
          let dynOffset = 8;
          if (header.flags.baseDataOffsetPresent) {
            header.baseDataOffset = UINT64_BE.get(buf, dynOffset);
            dynOffset += 8;
          }
          if (header.flags.sampleDescriptionIndexPresent) {
            header.sampleDescriptionIndex = UINT32_BE.get(buf, dynOffset);
            dynOffset += 4;
          }
          if (header.flags.defaultSampleDurationPresent) {
            header.defaultSampleDuration = UINT32_BE.get(buf, dynOffset);
            dynOffset += 4;
          }
          if (header.flags.defaultSampleSizePresent) {
            header.defaultSampleSize = UINT32_BE.get(buf, dynOffset);
            dynOffset += 4;
          }
          if (header.flags.defaultSampleFlagsPresent) {
            header.defaultSampleFlags = UINT32_BE.get(buf, dynOffset);
          }
          return header;
        }
      }
      class TrackRunBox {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          const flagOffset = off + 1;
          const trun = {
            version: INT8.get(buf, off),
            flags: {
              dataOffsetPresent: getBit(buf, flagOffset + 2, 0),
              firstSampleFlagsPresent: getBit(buf, flagOffset + 2, 2),
              sampleDurationPresent: getBit(buf, flagOffset + 1, 0),
              sampleSizePresent: getBit(buf, flagOffset + 1, 1),
              sampleFlagsPresent: getBit(buf, flagOffset + 1, 2),
              sampleCompositionTimeOffsetsPresent: getBit(buf, flagOffset + 1, 3)
            },
            sampleCount: UINT32_BE.get(buf, off + 4),
            samples: []
          };
          let dynOffset = off + 8;
          if (trun.flags.dataOffsetPresent) {
            trun.dataOffset = UINT32_BE.get(buf, dynOffset);
            dynOffset += 4;
          }
          if (trun.flags.firstSampleFlagsPresent) {
            trun.firstSampleFlags = UINT32_BE.get(buf, dynOffset);
            dynOffset += 4;
          }
          for (let n = 0; n < trun.sampleCount; ++n) {
            if (dynOffset >= this.len) {
              debug$2("TrackRunBox size mismatch");
              break;
            }
            const sample = {};
            if (trun.flags.sampleDurationPresent) {
              sample.sampleDuration = UINT32_BE.get(buf, dynOffset);
              dynOffset += 4;
            }
            if (trun.flags.sampleSizePresent) {
              sample.sampleSize = UINT32_BE.get(buf, dynOffset);
              dynOffset += 4;
            }
            if (trun.flags.sampleFlagsPresent) {
              sample.sampleFlags = UINT32_BE.get(buf, dynOffset);
              dynOffset += 4;
            }
            if (trun.flags.sampleCompositionTimeOffsetsPresent) {
              sample.sampleCompositionTimeOffset = UINT32_BE.get(buf, dynOffset);
              dynOffset += 4;
            }
            trun.samples.push(sample);
          }
          return trun;
        }
      }
      class HandlerBox {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          const charTypeToken = new StringType(4, "utf-8");
          return {
            version: INT8.get(buf, off),
            flags: UINT24_BE.get(buf, off + 1),
            componentType: charTypeToken.get(buf, off + 4),
            handlerType: charTypeToken.get(buf, off + 8),
            componentName: new StringType(this.len - 28, "utf-8").get(buf, off + 28)
          };
        }
      }
      class ChapterTrackReferenceBox {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          let dynOffset = 0;
          const trackIds = [];
          while (dynOffset < this.len) {
            trackIds.push(UINT32_BE.get(buf, off + dynOffset));
            dynOffset += 4;
          }
          return trackIds;
        }
      }
      const debug$1 = initDebug("music-metadata:parser:MP4:Atom");
      class Atom {
        static async readAtom(tokenizer, dataHandler, parent, remaining) {
          const offset = tokenizer.position;
          debug$1(`Reading next token on offset=${offset}...`);
          const header = await tokenizer.readToken(Header);
          const extended = header.length === 1n;
          if (extended) {
            header.length = await tokenizer.readToken(ExtendedSize);
          }
          const atomBean = new Atom(header, extended, parent);
          const payloadLength = atomBean.getPayloadLength(remaining);
          debug$1(`parse atom name=${atomBean.atomPath}, extended=${atomBean.extended}, offset=${offset}, len=${atomBean.header.length}`);
          await atomBean.readData(tokenizer, dataHandler, payloadLength);
          return atomBean;
        }
        constructor(header, extended, parent) {
          this.header = header;
          this.extended = extended;
          this.parent = parent;
          this.children = [];
          this.atomPath = (this.parent ? `${this.parent.atomPath}.` : "") + this.header.name;
        }
        getHeaderLength() {
          return this.extended ? 16 : 8;
        }
        getPayloadLength(remaining) {
          return (this.header.length === 0n ? remaining : Number(this.header.length)) - this.getHeaderLength();
        }
        async readAtoms(tokenizer, dataHandler, size) {
          while (size > 0) {
            const atomBean = await Atom.readAtom(tokenizer, dataHandler, this, size);
            this.children.push(atomBean);
            size -= atomBean.header.length === 0n ? size : Number(atomBean.header.length);
          }
        }
        async readData(tokenizer, dataHandler, remaining) {
          switch (this.header.name) {
            // "Container" atoms, contains nested atoms
            case "moov":
            // The Movie Atom: contains other atoms
            case "udta":
            // User defined atom
            case "mdia":
            // Media atom
            case "minf":
            // Media Information Atom
            case "stbl":
            // The Sample Table Atom
            case "<id>":
            case "ilst":
            case "tref":
            case "moof":
              return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining));
            case "meta": {
              const peekHeader = await tokenizer.peekToken(Header);
              const paddingLength = peekHeader.name === "hdlr" ? 0 : 4;
              await tokenizer.ignore(paddingLength);
              return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining) - paddingLength);
            }
            default:
              return dataHandler(this, remaining);
          }
        }
      }
      const debug = initDebug("music-metadata:parser:MP4");
      const tagFormat = "iTunes";
      const encoderDict = {
        raw: {
          lossy: false,
          format: "raw"
        },
        MAC3: {
          lossy: true,
          format: "MACE 3:1"
        },
        MAC6: {
          lossy: true,
          format: "MACE 6:1"
        },
        ima4: {
          lossy: true,
          format: "IMA 4:1"
        },
        ulaw: {
          lossy: true,
          format: "uLaw 2:1"
        },
        alaw: {
          lossy: true,
          format: "uLaw 2:1"
        },
        Qclp: {
          lossy: true,
          format: "QUALCOMM PureVoice"
        },
        ".mp3": {
          lossy: true,
          format: "MPEG-1 layer 3"
        },
        alac: {
          lossy: false,
          format: "ALAC"
        },
        "ac-3": {
          lossy: true,
          format: "AC-3"
        },
        mp4a: {
          lossy: true,
          format: "MPEG-4/AAC"
        },
        mp4s: {
          lossy: true,
          format: "MP4S"
        },
        // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87
        c608: {
          lossy: true,
          format: "CEA-608"
        },
        c708: {
          lossy: true,
          format: "CEA-708"
        }
      };
      function distinct(value, index, self) {
        return self.indexOf(value) === index;
      }
      class MP4Parser extends BasicParser {
        constructor() {
          super(...arguments);
          this.tracks = /* @__PURE__ */ new Map();
          this.hasVideoTrack = false;
          this.hasAudioTrack = true;
          this.atomParsers = {
            /**
             * Parse movie header (mvhd) atom
             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313
             */
            mvhd: async (len) => {
              const mvhd = await this.tokenizer.readToken(new MvhdAtom(len));
              this.metadata.setFormat("creationTime", mvhd.creationTime);
              this.metadata.setFormat("modificationTime", mvhd.modificationTime);
            },
            chap: async (len) => {
              const td = this.getTrackDescription();
              const trackIds = [];
              while (len >= UINT32_BE.len) {
                trackIds.push(await this.tokenizer.readNumber(UINT32_BE));
                len -= UINT32_BE.len;
              }
              td.chapterList = trackIds;
            },
            /**
             * Parse mdat atom.
             * Will scan for chapters
             */
            mdat: async (len) => {
              this.audioLengthInBytes = len;
              this.calculateBitRate();
              if (this.options.includeChapters) {
                const trackWithChapters = [...this.tracks.values()].filter((track) => track.chapterList);
                if (trackWithChapters.length === 1) {
                  const chapterTrackIds = trackWithChapters[0].chapterList;
                  const chapterTracks = [...this.tracks.values()].filter((track) => chapterTrackIds.indexOf(track.header.trackId) !== -1);
                  if (chapterTracks.length === 1) {
                    return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);
                  }
                }
              }
              await this.tokenizer.ignore(len);
            },
            ftyp: async (len) => {
              const types = [];
              while (len > 0) {
                const ftype = await this.tokenizer.readToken(ftyp);
                len -= ftyp.len;
                const value = ftype.type.replace(/\W/g, "");
                if (value.length > 0) {
                  types.push(value);
                }
              }
              debug(`ftyp: ${types.join("/")}`);
              const x = types.filter(distinct).join("/");
              this.metadata.setFormat("container", x);
            },
            /**
             * Parse sample description atom
             */
            stsd: async (len) => {
              const stsd = await this.tokenizer.readToken(new StsdAtom(len));
              const trackDescription = this.getTrackDescription();
              trackDescription.soundSampleDescription = stsd.table.map((dfEntry) => this.parseSoundSampleDescription(dfEntry));
            },
            /**
             * Parse sample-sizes atom ('stsz')
             */
            stsz: async (len) => {
              const stsz = await this.tokenizer.readToken(new StszAtom(len));
              const td = this.getTrackDescription();
              td.sampleSize = stsz.sampleSize;
              td.sampleSizeTable = stsz.entries;
            },
            date: async (len) => {
              const date = await this.tokenizer.readToken(new StringType(len, "utf-8"));
              await this.addTag("date", date);
            }
          };
        }
        static read_BE_Integer(array, signed) {
          const integerType = (signed ? "INT" : "UINT") + array.length * 8 + (array.length > 1 ? "_BE" : "");
          const token = Token[integerType];
          if (!token) {
            throw new Mp4ContentError(`Token for integer type not found: "${integerType}"`);
          }
          return Number(token.get(array, 0));
        }
        async parse() {
          this.hasVideoTrack = false;
          this.hasAudioTrack = true;
          this.tracks.clear();
          let remainingFileSize = this.tokenizer.fileInfo.size || 0;
          while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {
            try {
              const token = await this.tokenizer.peekToken(Header);
              if (token.name === "\0\0\0\0") {
                const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;
                debug(errMsg);
                this.addWarning(errMsg);
                break;
              }
            } catch (error) {
              if (error instanceof Error) {
                const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;
                debug(errMsg);
                this.addWarning(errMsg);
              } else
                throw error;
              break;
            }
            const rootAtom = await Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);
            remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);
          }
          const formatList = [];
          this.tracks.forEach((track) => {
            const trackFormats = [];
            track.soundSampleDescription.forEach((ssd) => {
              const streamInfo = {};
              const encoderInfo = encoderDict[ssd.dataFormat];
              if (encoderInfo) {
                trackFormats.push(encoderInfo.format);
                streamInfo.codecName = encoderInfo.format;
              } else {
                streamInfo.codecName = `<${ssd.dataFormat}>`;
              }
              if (ssd.description) {
                const { description } = ssd;
                if (description.sampleRate > 0) {
                  streamInfo.type = TrackType.audio;
                  streamInfo.audio = {
                    samplingFrequency: description.sampleRate,
                    bitDepth: description.sampleSize,
                    channels: description.numAudioChannels
                  };
                }
              }
              this.metadata.addStreamInfo(streamInfo);
            });
            if (trackFormats.length >= 1) {
              formatList.push(trackFormats.join("/"));
            }
          });
          if (formatList.length > 0) {
            this.metadata.setFormat("codec", formatList.filter(distinct).join("+"));
          }
          const audioTracks = [...this.tracks.values()].filter((track) => {
            return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;
          });
          if (audioTracks.length >= 1) {
            const audioTrack = audioTracks[0];
            if (audioTrack.media.header && audioTrack.media.header.timeScale > 0) {
              if (audioTrack.media.header.duration > 0) {
                debug("Using duration defined on audio track");
                const duration = audioTrack.media.header.duration / audioTrack.media.header.timeScale;
                this.metadata.setFormat("duration", duration);
              } else if (audioTrack.fragments.length > 0) {
                debug("Calculate duration defined in track fragments");
                let totalTimeUnits = 0;
                for (const fragment of audioTrack.fragments) {
                  const defaultDuration = fragment.header.defaultSampleDuration;
                  for (const sample of fragment.trackRun.samples) {
                    const dur = sample.sampleDuration ?? defaultDuration;
                    if (dur == null) {
                      throw new Error("Missing sampleDuration and no default_sample_duration in tfhd");
                    }
                    totalTimeUnits += dur;
                  }
                }
                this.metadata.setFormat("duration", totalTimeUnits / audioTrack.media.header.timeScale);
              }
            }
            const ssd = audioTrack.soundSampleDescription[0];
            if (ssd.description && audioTrack.media.header) {
              this.metadata.setFormat("sampleRate", ssd.description.sampleRate);
              this.metadata.setFormat("bitsPerSample", ssd.description.sampleSize);
              this.metadata.setFormat("numberOfChannels", ssd.description.numAudioChannels);
              if (audioTrack.media.header.timeScale === 0 && audioTrack.timeToSampleTable.length > 0) {
                const totalSampleSize = audioTrack.timeToSampleTable.map((ttstEntry) => ttstEntry.count * ttstEntry.duration).reduce((total, sampleSize) => total + sampleSize);
                const duration = totalSampleSize / ssd.description.sampleRate;
                this.metadata.setFormat("duration", duration);
              }
            }
            const encoderInfo = encoderDict[ssd.dataFormat];
            if (encoderInfo) {
              this.metadata.setFormat("lossless", !encoderInfo.lossy);
            }
            this.calculateBitRate();
          }
          this.metadata.setFormat("hasAudio", this.hasAudioTrack);
          this.metadata.setFormat("hasVideo", this.hasVideoTrack);
        }
        async handleAtom(atom, remaining) {
          if (atom.parent) {
            switch (atom.parent.header.name) {
              case "ilst":
              case "<id>":
                return this.parseMetadataItemData(atom);
              case "moov":
                switch (atom.header.name) {
                  case "trak":
                    return this.parseTrackBox(atom);
                }
                break;
              case "moof":
                switch (atom.header.name) {
                  case "traf":
                    return this.parseTrackFragmentBox(atom);
                }
            }
          }
          if (this.atomParsers[atom.header.name]) {
            return this.atomParsers[atom.header.name](remaining);
          }
          debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);
          await this.tokenizer.ignore(remaining);
        }
        getTrackDescription() {
          const tracks = [...this.tracks.values()];
          return tracks[tracks.length - 1];
        }
        calculateBitRate() {
          if (this.audioLengthInBytes && this.metadata.format.duration) {
            this.metadata.setFormat("bitrate", 8 * this.audioLengthInBytes / this.metadata.format.duration);
          }
        }
        async addTag(id, value) {
          await this.metadata.addTag(tagFormat, id, value);
        }
        addWarning(message) {
          debug(`Warning: ${message}`);
          this.metadata.addWarning(message);
        }
        /**
         * Parse data of Meta-item-list-atom (item of 'ilst' atom)
         * @param metaAtom
         * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
         */
        parseMetadataItemData(metaAtom) {
          let tagKey = metaAtom.header.name;
          return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {
            const payLoadLength = child.getPayloadLength(remaining);
            switch (child.header.name) {
              case "data":
                return this.parseValueAtom(tagKey, child);
              case "name":
              // name atom (optional)
              case "mean":
              case "rate": {
                const name = await this.tokenizer.readToken(new NameAtom(payLoadLength));
                tagKey += `:${name.name}`;
                break;
              }
              default: {
                const uint8Array = await this.tokenizer.readToken(new Uint8ArrayType(payLoadLength));
                this.addWarning(`Unsupported meta-item: ${tagKey}[${child.header.name}] => value=${uint8ArrayToHex(uint8Array)} ascii=${textDecode(uint8Array, "ascii")}`);
              }
            }
          }, metaAtom.getPayloadLength(0));
        }
        async parseValueAtom(tagKey, metaAtom) {
          const dataAtom = await this.tokenizer.readToken(new DataAtom(Number(metaAtom.header.length) - Header.len));
          if (dataAtom.type.set !== 0) {
            throw new Mp4ContentError(`Unsupported type-set != 0: ${dataAtom.type.set}`);
          }
          switch (dataAtom.type.type) {
            case 0:
              switch (tagKey) {
                case "trkn":
                case "disk": {
                  const num = UINT8.get(dataAtom.value, 3);
                  const of = UINT8.get(dataAtom.value, 5);
                  await this.addTag(tagKey, `${num}/${of}`);
                  break;
                }
                case "gnre": {
                  const genreInt = UINT8.get(dataAtom.value, 1);
                  const genreStr = Genres[genreInt - 1];
                  await this.addTag(tagKey, genreStr);
                  break;
                }
                case "rate": {
                  const rate = textDecode(dataAtom.value, "ascii");
                  await this.addTag(tagKey, rate);
                  break;
                }
                default:
                  debug(`unknown proprietary value type for: ${metaAtom.atomPath}`);
              }
              break;
            case 1:
            // UTF-8: Without any count or NULL terminator
            case 18:
              await this.addTag(tagKey, textDecode(dataAtom.value));
              break;
            case 13:
              if (this.options.skipCovers)
                break;
              await this.addTag(tagKey, {
                format: "image/jpeg",
                data: Uint8Array.from(dataAtom.value)
              });
              break;
            case 14:
              if (this.options.skipCovers)
                break;
              await this.addTag(tagKey, {
                format: "image/png",
                data: Uint8Array.from(dataAtom.value)
              });
              break;
            case 21:
              await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, true));
              break;
            case 22:
              await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, false));
              break;
            case 65:
              await this.addTag(tagKey, UINT8.get(dataAtom.value, 0));
              break;
            case 66:
              await this.addTag(tagKey, UINT16_BE.get(dataAtom.value, 0));
              break;
            case 67:
              await this.addTag(tagKey, UINT32_BE.get(dataAtom.value, 0));
              break;
            default:
              this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);
          }
        }
        async parseTrackBox(trakBox) {
          const track = {
            media: {},
            fragments: []
          };
          await trakBox.readAtoms(this.tokenizer, async (child, remaining) => {
            const payLoadLength = child.getPayloadLength(remaining);
            switch (child.header.name) {
              case "chap": {
                const chap = await this.tokenizer.readToken(new ChapterTrackReferenceBox(remaining));
                track.chapterList = chap;
                break;
              }
              case "tkhd":
                track.header = await this.tokenizer.readToken(new TrackHeaderAtom(payLoadLength));
                break;
              case "hdlr":
                track.handler = await this.tokenizer.readToken(new HandlerBox(payLoadLength));
                switch (track.handler.handlerType) {
                  case "audi":
                    debug("Contains audio track");
                    this.hasAudioTrack = true;
                    break;
                  case "vide":
                    debug("Contains video track");
                    this.hasVideoTrack = true;
                    break;
                }
                break;
              case "mdhd": {
                const mdhd_data = await this.tokenizer.readToken(new MdhdAtom(payLoadLength));
                track.media.header = mdhd_data;
                break;
              }
              case "stco": {
                const stco = await this.tokenizer.readToken(new StcoAtom(payLoadLength));
                track.chunkOffsetTable = stco.entries;
                break;
              }
              case "stsc": {
                const stsc = await this.tokenizer.readToken(new StscAtom(payLoadLength));
                track.sampleToChunkTable = stsc.entries;
                break;
              }
              case "stsd": {
                const stsd = await this.tokenizer.readToken(new StsdAtom(payLoadLength));
                track.soundSampleDescription = stsd.table.map((dfEntry) => this.parseSoundSampleDescription(dfEntry));
                break;
              }
              case "stts": {
                const stts = await this.tokenizer.readToken(new SttsAtom(payLoadLength));
                track.timeToSampleTable = stts.entries;
                break;
              }
              case "stsz": {
                const stsz = await this.tokenizer.readToken(new StszAtom(payLoadLength));
                track.sampleSize = stsz.sampleSize;
                track.sampleSizeTable = stsz.entries;
                break;
              }
              case "dinf":
              case "vmhd":
              case "smhd":
                debug(`Ignoring: ${child.header.name}`);
                await this.tokenizer.ignore(payLoadLength);
                break;
              default: {
                debug(`Unexpected track box: ${child.header.name}`);
                await this.tokenizer.ignore(payLoadLength);
              }
            }
          }, trakBox.getPayloadLength(0));
          this.tracks.set(track.header.trackId, track);
        }
        parseTrackFragmentBox(trafBox) {
          let tfhd;
          return trafBox.readAtoms(this.tokenizer, async (child, remaining) => {
            const payLoadLength = child.getPayloadLength(remaining);
            switch (child.header.name) {
              case "tfhd": {
                const fragmentHeaderBox = new TrackFragmentHeaderBox(child.getPayloadLength(remaining));
                tfhd = await this.tokenizer.readToken(fragmentHeaderBox);
                break;
              }
              case "tfdt":
                await this.tokenizer.ignore(payLoadLength);
                break;
              case "trun": {
                const trackRunBox = new TrackRunBox(payLoadLength);
                const trun = await this.tokenizer.readToken(trackRunBox);
                if (tfhd) {
                  const track = this.tracks.get(tfhd.trackId);
                  track?.fragments.push({ header: tfhd, trackRun: trun });
                }
                break;
              }
              default: {
                debug(`Unexpected box: ${child.header.name}`);
                await this.tokenizer.ignore(payLoadLength);
              }
            }
          }, trafBox.getPayloadLength(0));
        }
        /**
         * @param sampleDescription
         * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916
         */
        parseSoundSampleDescription(sampleDescription) {
          const ssd = {
            dataFormat: sampleDescription.dataFormat,
            dataReferenceIndex: sampleDescription.dataReferenceIndex
          };
          let offset = 0;
          if (sampleDescription.description) {
            const version = SoundSampleDescriptionVersion.get(sampleDescription.description, offset);
            offset += SoundSampleDescriptionVersion.len;
            if (version.version === 0 || version.version === 1) {
              ssd.description = SoundSampleDescriptionV0.get(sampleDescription.description, offset);
            } else {
              debug(`Warning: sound-sample-description ${version} not implemented`);
            }
          }
          return ssd;
        }
        async parseChapterTrack(chapterTrack, track, len) {
          if (!chapterTrack.sampleSize) {
            if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)
              throw new Error("Expected equal chunk-offset-table & sample-size-table length.");
          }
          const chapters = [];
          for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {
            const start = chapterTrack.timeToSampleTable.slice(0, i).reduce((acc, cur) => acc + cur.duration, 0);
            const chunkOffset = chapterTrack.chunkOffsetTable[i];
            const nextChunkLen = chunkOffset - this.tokenizer.position;
            const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];
            len -= nextChunkLen + sampleSize;
            if (len < 0)
              throw new Mp4ContentError("Chapter chunk exceeding token length");
            await this.tokenizer.ignore(nextChunkLen);
            const title = await this.tokenizer.readToken(new ChapterText(sampleSize));
            debug(`Chapter ${i + 1}: ${title}`);
            const chapter = {
              title,
              timeScale: chapterTrack.media.header ? chapterTrack.media.header.timeScale : 0,
              start,
              sampleOffset: this.findSampleOffset(track, this.tokenizer.position)
            };
            debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${track.header.duration}`);
            chapters.push(chapter);
          }
          this.metadata.setFormat("chapters", chapters);
          await this.tokenizer.ignore(len);
        }
        findSampleOffset(track, chapterOffset) {
          let chunkIndex = 0;
          while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {
            ++chunkIndex;
          }
          return this.getChunkDuration(chunkIndex + 1, track);
        }
        getChunkDuration(chunkId, track) {
          let ttsi = 0;
          let ttsc = track.timeToSampleTable[ttsi].count;
          let ttsd = track.timeToSampleTable[ttsi].duration;
          let curChunkId = 1;
          let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);
          let totalDuration = 0;
          while (curChunkId < chunkId) {
            const nrOfSamples = Math.min(ttsc, samplesPerChunk);
            totalDuration += nrOfSamples * ttsd;
            ttsc -= nrOfSamples;
            samplesPerChunk -= nrOfSamples;
            if (samplesPerChunk === 0) {
              ++curChunkId;
              samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);
            } else {
              ++ttsi;
              ttsc = track.timeToSampleTable[ttsi].count;
              ttsd = track.timeToSampleTable[ttsi].duration;
            }
          }
          return totalDuration;
        }
        getSamplesPerChunk(chunkId, stcTable) {
          for (let i = 0; i < stcTable.length - 1; ++i) {
            if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {
              return stcTable[i].samplesPerChunk;
            }
          }
          return stcTable[stcTable.length - 1].samplesPerChunk;
        }
      } exports("MP4Parser", MP4Parser);

    })
  };
}));

System.register("./MusepackParser-DjtwqjaL-D_aeNfDv.js", ['./main-cGY5pIDA-DL9qX_J1.js', './AbstractID3Parser-VsE1AWmF-6kl3V0zG.js', 'react', 'antd', 'react-dom', '@ant-design/icons', './ID3v2Parser-C6PymtiX-BXaBboLM.js'], (function (exports, module) {
  'use strict';
  var StringType, initDebug, makeUnexpectedFileContentError, BasicParser, FourCcToken, tryParseApeHeader, UINT8, isBitSet$1, UINT32_LE, UINT16_LE, getBitAllignedNumber, textDecode, AbstractID3Parser;
  return {
    setters: [module => {
      StringType = module.S;
      initDebug = module.i;
      makeUnexpectedFileContentError = module.m;
      BasicParser = module.B;
      FourCcToken = module.F;
      tryParseApeHeader = module.J;
      UINT8 = module.d;
      isBitSet$1 = module.a;
      UINT32_LE = module.e;
      UINT16_LE = module.k;
      getBitAllignedNumber = module.g;
      textDecode = module.y;
    }, module => {
      AbstractID3Parser = module.A;
    }, null, null, null, null, null],
    execute: (function () {

      const debug$3 = initDebug("music-metadata:parser:musepack:sv8");
      const PacketKey = new StringType(2, "latin1");
      const SH_part1 = {
        len: 5,
        get: (buf, off) => {
          return {
            crc: UINT32_LE.get(buf, off),
            streamVersion: UINT8.get(buf, off + 4)
          };
        }
      };
      const SH_part3 = {
        len: 2,
        get: (buf, off) => {
          return {
            sampleFrequency: [44100, 48e3, 37800, 32e3][getBitAllignedNumber(buf, off, 0, 3)],
            maxUsedBands: getBitAllignedNumber(buf, off, 3, 5),
            channelCount: getBitAllignedNumber(buf, off + 1, 0, 4) + 1,
            msUsed: isBitSet$1(buf, off + 1, 4),
            audioBlockFrames: getBitAllignedNumber(buf, off + 1, 5, 3)
          };
        }
      };
      class StreamReader {
        get tokenizer() {
          return this._tokenizer;
        }
        set tokenizer(value) {
          this._tokenizer = value;
        }
        constructor(_tokenizer) {
          this._tokenizer = _tokenizer;
        }
        async readPacketHeader() {
          const key = await this.tokenizer.readToken(PacketKey);
          const size = await this.readVariableSizeField();
          return {
            key,
            payloadLength: size.value - 2 - size.len
          };
        }
        async readStreamHeader(size) {
          const streamHeader = {};
          debug$3(`Reading SH at offset=${this.tokenizer.position}`);
          const part1 = await this.tokenizer.readToken(SH_part1);
          size -= SH_part1.len;
          Object.assign(streamHeader, part1);
          debug$3(`SH.streamVersion = ${part1.streamVersion}`);
          const sampleCount = await this.readVariableSizeField();
          size -= sampleCount.len;
          streamHeader.sampleCount = sampleCount.value;
          const bs = await this.readVariableSizeField();
          size -= bs.len;
          streamHeader.beginningOfSilence = bs.value;
          const part3 = await this.tokenizer.readToken(SH_part3);
          size -= SH_part3.len;
          Object.assign(streamHeader, part3);
          await this.tokenizer.ignore(size);
          return streamHeader;
        }
        async readVariableSizeField(len = 1, hb = 0) {
          let n = await this.tokenizer.readNumber(UINT8);
          if ((n & 128) === 0) {
            return { len, value: hb + n };
          }
          n &= 127;
          n += hb;
          return this.readVariableSizeField(len + 1, n << 7);
        }
      }
      class MusepackContentError extends makeUnexpectedFileContentError("Musepack") {
      }
      const debug$2 = initDebug("music-metadata:parser:musepack");
      class MpcSv8Parser extends BasicParser {
        constructor() {
          super(...arguments);
          this.audioLength = 0;
        }
        async parse() {
          const signature = await this.tokenizer.readToken(FourCcToken);
          if (signature !== "MPCK")
            throw new MusepackContentError("Invalid Magic number");
          this.metadata.setFormat("container", "Musepack, SV8");
          return this.parsePacket();
        }
        async parsePacket() {
          const sv8reader = new StreamReader(this.tokenizer);
          do {
            const header = await sv8reader.readPacketHeader();
            debug$2(`packet-header key=${header.key}, payloadLength=${header.payloadLength}`);
            switch (header.key) {
              case "SH": {
                const sh = await sv8reader.readStreamHeader(header.payloadLength);
                this.metadata.setFormat("numberOfSamples", sh.sampleCount);
                this.metadata.setFormat("sampleRate", sh.sampleFrequency);
                this.metadata.setFormat("duration", sh.sampleCount / sh.sampleFrequency);
                this.metadata.setFormat("numberOfChannels", sh.channelCount);
                break;
              }
              case "AP":
                this.audioLength += header.payloadLength;
                await this.tokenizer.ignore(header.payloadLength);
                break;
              case "RG":
              // Replaygain
              case "EI":
              // Encoder Info
              case "SO":
              // Seek Table Offset
              case "ST":
              // Seek Table
              case "CT":
                await this.tokenizer.ignore(header.payloadLength);
                break;
              case "SE":
                if (this.metadata.format.duration) {
                  this.metadata.setFormat("bitrate", this.audioLength * 8 / this.metadata.format.duration);
                }
                return tryParseApeHeader(this.metadata, this.tokenizer, this.options);
              default:
                throw new MusepackContentError(`Unexpected header: ${header.key}`);
            }
          } while (true);
        }
      }
      class BitReader {
        constructor(tokenizer) {
          this.pos = 0;
          this.dword = null;
          this.tokenizer = tokenizer;
        }
        /**
         *
         * @param bits 1..30 bits
         */
        async read(bits) {
          while (this.dword === null) {
            this.dword = await this.tokenizer.readToken(UINT32_LE);
          }
          let out = this.dword;
          this.pos += bits;
          if (this.pos < 32) {
            out >>>= 32 - this.pos;
            return out & (1 << bits) - 1;
          }
          this.pos -= 32;
          if (this.pos === 0) {
            this.dword = null;
            return out & (1 << bits) - 1;
          }
          this.dword = await this.tokenizer.readToken(UINT32_LE);
          if (this.pos) {
            out <<= this.pos;
            out |= this.dword >>> 32 - this.pos;
          }
          return out & (1 << bits) - 1;
        }
        async ignore(bits) {
          if (this.pos > 0) {
            const remaining = 32 - this.pos;
            this.dword = null;
            bits -= remaining;
            this.pos = 0;
          }
          const remainder = bits % 32;
          const numOfWords = (bits - remainder) / 32;
          await this.tokenizer.ignore(numOfWords * 4);
          return this.read(remainder);
        }
      }
      const Header = {
        len: 6 * 4,
        get: (buf, off) => {
          const header = {
            // word 0
            signature: textDecode(buf.subarray(off, off + 3), "latin1"),
            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
            streamMinorVersion: getBitAllignedNumber(buf, off + 3, 0, 4),
            streamMajorVersion: getBitAllignedNumber(buf, off + 3, 4, 4),
            // word 1
            frameCount: UINT32_LE.get(buf, off + 4),
            // word 2
            maxLevel: UINT16_LE.get(buf, off + 8),
            sampleFrequency: [44100, 48e3, 37800, 32e3][getBitAllignedNumber(buf, off + 10, 0, 2)],
            link: getBitAllignedNumber(buf, off + 10, 2, 2),
            profile: getBitAllignedNumber(buf, off + 10, 4, 4),
            maxBand: getBitAllignedNumber(buf, off + 11, 0, 6),
            intensityStereo: isBitSet$1(buf, off + 11, 6),
            midSideStereo: isBitSet$1(buf, off + 11, 7),
            // word 3
            titlePeak: UINT16_LE.get(buf, off + 12),
            titleGain: UINT16_LE.get(buf, off + 14),
            // word 4
            albumPeak: UINT16_LE.get(buf, off + 16),
            albumGain: UINT16_LE.get(buf, off + 18),
            // word
            lastFrameLength: UINT32_LE.get(buf, off + 20) >>> 20 & 2047,
            trueGapless: isBitSet$1(buf, off + 23, 0)
          };
          header.lastFrameLength = header.trueGapless ? UINT32_LE.get(buf, 20) >>> 20 & 2047 : 0;
          return header;
        }
      };
      const debug$1 = initDebug("music-metadata:parser:musepack");
      class MpcSv7Parser extends BasicParser {
        constructor() {
          super(...arguments);
          this.bitreader = null;
          this.audioLength = 0;
          this.duration = null;
        }
        async parse() {
          const header = await this.tokenizer.readToken(Header);
          if (header.signature !== "MP+")
            throw new MusepackContentError("Unexpected magic number");
          debug$1(`stream-version=${header.streamMajorVersion}.${header.streamMinorVersion}`);
          this.metadata.setFormat("container", "Musepack, SV7");
          this.metadata.setFormat("sampleRate", header.sampleFrequency);
          const numberOfSamples = 1152 * (header.frameCount - 1) + header.lastFrameLength;
          this.metadata.setFormat("numberOfSamples", numberOfSamples);
          this.duration = numberOfSamples / header.sampleFrequency;
          this.metadata.setFormat("duration", this.duration);
          this.bitreader = new BitReader(this.tokenizer);
          this.metadata.setFormat("numberOfChannels", header.midSideStereo || header.intensityStereo ? 2 : 1);
          const version = await this.bitreader.read(8);
          this.metadata.setFormat("codec", (version / 100).toFixed(2));
          await this.skipAudioData(header.frameCount);
          debug$1(`End of audio stream, switching to APEv2, offset=${this.tokenizer.position}`);
          return tryParseApeHeader(this.metadata, this.tokenizer, this.options);
        }
        async skipAudioData(frameCount) {
          while (frameCount-- > 0) {
            const frameLength = await this.bitreader.read(20);
            this.audioLength += 20 + frameLength;
            await this.bitreader.ignore(frameLength);
          }
          const lastFrameLength = await this.bitreader.read(11);
          this.audioLength += lastFrameLength;
          if (this.duration !== null) {
            this.metadata.setFormat("bitrate", this.audioLength / this.duration);
          }
        }
      }
      const debug = initDebug("music-metadata:parser:musepack");
      class MusepackParser extends AbstractID3Parser {
        async postId3v2Parse() {
          const signature = await this.tokenizer.peekToken(new StringType(3, "latin1"));
          let mpcParser;
          switch (signature) {
            case "MP+": {
              debug("Stream-version 7");
              mpcParser = new MpcSv7Parser(this.metadata, this.tokenizer, this.options);
              break;
            }
            case "MPC": {
              debug("Stream-version 8");
              mpcParser = new MpcSv8Parser(this.metadata, this.tokenizer, this.options);
              break;
            }
            default: {
              throw new MusepackContentError("Invalid signature prefix");
            }
          }
          this.metadata.setAudioOnly();
          return mpcParser.parse();
        }
      } exports("MusepackParser", MusepackParser);

    })
  };
}));

System.register("./OggParser-ClkMM5gt-DEny-a2U.js", ['./main-cGY5pIDA-DL9qX_J1.js', './FlacParser-CAsVRrMV-DZB68qaX.js', 'react', 'antd', 'react-dom', '@ant-design/icons', './AbstractID3Parser-VsE1AWmF-6kl3V0zG.js', './ID3v2Parser-C6PymtiX-BXaBboLM.js'], (function (exports, module) {
  'use strict';
  var BasicParser, initDebug, EndOfStreamError, UINT8, UINT32_LE, getBit, StringType, UINT64_LE, makeUnexpectedFileContentError, Uint8ArrayType, FourCcToken, UINT24_BE, UINT16_BE, INT32_LE, trimRightNull, UINT16_LE, VorbisStream, FlacParser, BlockHeader, BlockType, VorbisPictureToken, BlockStreamInfo;
  return {
    setters: [module => {
      BasicParser = module.B;
      initDebug = module.i;
      EndOfStreamError = module.E;
      UINT8 = module.d;
      UINT32_LE = module.e;
      getBit = module.j;
      StringType = module.S;
      UINT64_LE = module.f;
      makeUnexpectedFileContentError = module.m;
      Uint8ArrayType = module.U;
      FourCcToken = module.F;
      UINT24_BE = module.H;
      UINT16_BE = module.c;
      INT32_LE = module.q;
      trimRightNull = module.K;
      UINT16_LE = module.k;
    }, module => {
      VorbisStream = module.V;
      FlacParser = module.F;
      BlockHeader = module.B;
      BlockType = module.a;
      VorbisPictureToken = module.b;
      BlockStreamInfo = module.c;
    }, null, null, null, null, null, null],
    execute: (function () {

      class OpusContentError extends makeUnexpectedFileContentError("Opus") {
      }
      class IdHeader {
        constructor(len) {
          if (len < 19) {
            throw new OpusContentError("ID-header-page 0 should be at least 19 bytes long");
          }
          this.len = len;
        }
        get(buf, off) {
          return {
            magicSignature: new StringType(8, "ascii").get(buf, off + 0),
            version: UINT8.get(buf, off + 8),
            channelCount: UINT8.get(buf, off + 9),
            preSkip: UINT16_LE.get(buf, off + 10),
            inputSampleRate: UINT32_LE.get(buf, off + 12),
            outputGain: UINT16_LE.get(buf, off + 16),
            channelMapping: UINT8.get(buf, off + 18)
          };
        }
      }
      class OpusStream extends VorbisStream {
        constructor(metadata, options, tokenizer) {
          super(metadata, options);
          this.idHeader = null;
          this.lastPos = -1;
          this.tokenizer = tokenizer;
          this.durationOnLastPage = true;
        }
        /**
         * Parse first Opus Ogg page
         * @param {IPageHeader} header
         * @param {Uint8Array} pageData
         */
        parseFirstPage(_header, pageData) {
          this.metadata.setFormat("codec", "Opus");
          this.idHeader = new IdHeader(pageData.length).get(pageData, 0);
          if (this.idHeader.magicSignature !== "OpusHead")
            throw new OpusContentError("Illegal ogg/Opus magic-signature");
          this.metadata.setFormat("sampleRate", this.idHeader.inputSampleRate);
          this.metadata.setFormat("numberOfChannels", this.idHeader.channelCount);
          this.metadata.setAudioOnly();
        }
        async parseFullPage(pageData) {
          const magicSignature = new StringType(8, "ascii").get(pageData, 0);
          switch (magicSignature) {
            case "OpusTags":
              await this.parseUserCommentList(pageData, 8);
              this.lastPos = this.tokenizer.position - pageData.length;
              break;
          }
        }
        calculateDuration() {
          if (this.lastPageHeader && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {
            const pos_48bit = this.lastPageHeader.absoluteGranulePosition - this.idHeader.preSkip;
            this.metadata.setFormat("numberOfSamples", pos_48bit);
            this.metadata.setFormat("duration", pos_48bit / 48e3);
            if (this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {
              const dataSize = this.tokenizer.fileInfo.size - this.lastPos;
              this.metadata.setFormat("bitrate", 8 * dataSize / this.metadata.format.duration);
            }
          }
        }
      }
      const Header = {
        len: 80,
        get: (buf, off) => {
          return {
            speex: new StringType(8, "ascii").get(buf, off + 0),
            version: trimRightNull(new StringType(20, "ascii").get(buf, off + 8)),
            version_id: INT32_LE.get(buf, off + 28),
            header_size: INT32_LE.get(buf, off + 32),
            rate: INT32_LE.get(buf, off + 36),
            mode: INT32_LE.get(buf, off + 40),
            mode_bitstream_version: INT32_LE.get(buf, off + 44),
            nb_channels: INT32_LE.get(buf, off + 48),
            bitrate: INT32_LE.get(buf, off + 52),
            frame_size: INT32_LE.get(buf, off + 56),
            vbr: INT32_LE.get(buf, off + 60),
            frames_per_packet: INT32_LE.get(buf, off + 64),
            extra_headers: INT32_LE.get(buf, off + 68),
            reserved1: INT32_LE.get(buf, off + 72),
            reserved2: INT32_LE.get(buf, off + 76)
          };
        }
      };
      const debug$3 = initDebug("music-metadata:parser:ogg:speex");
      class SpeexStream extends VorbisStream {
        constructor(metadata, options, _tokenizer) {
          super(metadata, options);
        }
        /**
         * Parse first Speex Ogg page
         * @param {IPageHeader} header
         * @param {Uint8Array} pageData
         */
        parseFirstPage(_header, pageData) {
          debug$3("First Ogg/Speex page");
          const speexHeader = Header.get(pageData, 0);
          this.metadata.setFormat("codec", `Speex ${speexHeader.version}`);
          this.metadata.setFormat("numberOfChannels", speexHeader.nb_channels);
          this.metadata.setFormat("sampleRate", speexHeader.rate);
          if (speexHeader.bitrate !== -1) {
            this.metadata.setFormat("bitrate", speexHeader.bitrate);
          }
          this.metadata.setAudioOnly();
        }
      }
      const IdentificationHeader = {
        len: 42,
        get: (buf, off) => {
          return {
            id: new StringType(7, "ascii").get(buf, off),
            vmaj: UINT8.get(buf, off + 7),
            vmin: UINT8.get(buf, off + 8),
            vrev: UINT8.get(buf, off + 9),
            vmbw: UINT16_BE.get(buf, off + 10),
            vmbh: UINT16_BE.get(buf, off + 17),
            nombr: UINT24_BE.get(buf, off + 37),
            nqual: UINT8.get(buf, off + 40)
          };
        }
      };
      const debug$2 = initDebug("music-metadata:parser:ogg:theora");
      class TheoraStream {
        constructor(metadata, _options, _tokenizer) {
          this.durationOnLastPage = false;
          this.metadata = metadata;
        }
        /**
         * Vorbis 1 parser
         * @param header Ogg Page Header
         * @param pageData Page data
         */
        async parsePage(header, pageData) {
          if (header.headerType.firstPage) {
            await this.parseFirstPage(header, pageData);
          }
        }
        calculateDuration() {
          debug$2("duration calculation not implemented");
        }
        /**
         * Parse first Theora Ogg page. the initial identification header packet
         */
        async parseFirstPage(_header, pageData) {
          debug$2("First Ogg/Theora page");
          this.metadata.setFormat("codec", "Theora");
          const idHeader = IdentificationHeader.get(pageData, 0);
          this.metadata.setFormat("bitrate", idHeader.nombr);
          this.metadata.setFormat("hasVideo", true);
        }
        flush() {
          return Promise.resolve();
        }
      }
      const PageHeader = {
        len: 27,
        get: (buf, off) => {
          return {
            capturePattern: new StringType(4, "latin1").get(buf, off),
            version: UINT8.get(buf, off + 4),
            headerType: {
              continued: getBit(buf, off + 5, 0),
              firstPage: getBit(buf, off + 5, 1),
              lastPage: getBit(buf, off + 5, 2)
            },
            // packet_flag: Token.UINT8.get(buf, off + 5),
            absoluteGranulePosition: Number(UINT64_LE.get(buf, off + 6)),
            streamSerialNumber: UINT32_LE.get(buf, off + 14),
            pageSequenceNo: UINT32_LE.get(buf, off + 18),
            pageChecksum: UINT32_LE.get(buf, off + 22),
            page_segments: UINT8.get(buf, off + 26)
          };
        }
      };
      class SegmentTable {
        static sum(buf, off, len) {
          const dv = new DataView(buf.buffer, 0);
          let s = 0;
          for (let i = off; i < off + len; ++i) {
            s += dv.getUint8(i);
          }
          return s;
        }
        constructor(header) {
          this.len = header.page_segments;
        }
        get(buf, off) {
          return {
            totalPageSize: SegmentTable.sum(buf, off, this.len)
          };
        }
      }
      const debug$1 = initDebug("music-metadata:parser:ogg:theora");
      class FlacStream {
        constructor(metadata, options, tokenizer) {
          this.durationOnLastPage = false;
          this.metadata = metadata;
          this.options = options;
          this.tokenizer = tokenizer;
          this.flacParser = new FlacParser(this.metadata, this.tokenizer, options);
        }
        /**
         * Vorbis 1 parser
         * @param header Ogg Page Header
         * @param pageData Page data
         */
        async parsePage(header, pageData) {
          if (header.headerType.firstPage) {
            await this.parseFirstPage(header, pageData);
          }
        }
        calculateDuration() {
          debug$1("duration calculation not implemented");
        }
        /**
         * Parse first Theora Ogg page. the initial identification header packet
         */
        async parseFirstPage(_header, pageData) {
          debug$1("First Ogg/FLAC page");
          const fourCC = await FourCcToken.get(pageData, 9);
          if (fourCC.toString() !== "fLaC") {
            throw new Error("Invalid FLAC preamble");
          }
          const blockHeader = await BlockHeader.get(pageData, 13);
          await this.parseDataBlock(blockHeader, pageData.subarray(13 + BlockHeader.len));
        }
        async parseDataBlock(blockHeader, pageData) {
          debug$1(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);
          switch (blockHeader.type) {
            case BlockType.STREAMINFO: {
              const streamInfo = BlockStreamInfo.get(pageData, 0);
              return this.flacParser.processsStreamInfo(streamInfo);
            }
            case BlockType.PADDING:
              break;
            case BlockType.APPLICATION:
              break;
            case BlockType.SEEKTABLE:
              break;
            case BlockType.VORBIS_COMMENT:
              return this.flacParser.parseComment(pageData);
            case BlockType.PICTURE:
              if (!this.options.skipCovers) {
                const picture = new VorbisPictureToken(pageData.length).get(pageData, 0);
                return this.flacParser.addPictureTag(picture);
              }
              break;
            default:
              this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);
          }
          return this.tokenizer.ignore(blockHeader.length).then();
        }
        flush() {
          return Promise.resolve();
        }
      }
      class OggContentError extends makeUnexpectedFileContentError("Ogg") {
      } exports("OggContentError", OggContentError);
      const debug = initDebug("music-metadata:parser:ogg");
      class OggStream {
        constructor(metadata, streamSerial, options) {
          this.pageNumber = 0;
          this.closed = false;
          this.metadata = metadata;
          this.streamSerial = streamSerial;
          this.options = options;
        }
        async parsePage(tokenizer, header) {
          this.pageNumber = header.pageSequenceNo;
          debug("serial=%s page#=%s, Ogg.id=%s", header.streamSerialNumber, header.pageSequenceNo, header.capturePattern);
          const segmentTable = await tokenizer.readToken(new SegmentTable(header));
          debug("totalPageSize=%s", segmentTable.totalPageSize);
          const pageData = await tokenizer.readToken(new Uint8ArrayType(segmentTable.totalPageSize));
          debug("firstPage=%s, lastPage=%s, continued=%s", header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);
          if (header.headerType.firstPage) {
            this.metadata.setFormat("container", "Ogg");
            const idData = pageData.slice(0, 7);
            const asciiId = Array.from(idData).filter((b) => b >= 32 && b <= 126).map((b) => String.fromCharCode(b)).join("");
            switch (asciiId) {
              case "vorbis":
                debug(`Set Ogg stream serial ${header.streamSerialNumber}, codec=Vorbis`);
                this.pageConsumer = new VorbisStream(this.metadata, this.options);
                break;
              case "OpusHea":
                debug("Set page consumer to Ogg/Opus");
                this.pageConsumer = new OpusStream(this.metadata, this.options, tokenizer);
                break;
              case "Speex  ":
                debug("Set page consumer to Ogg/Speex");
                this.pageConsumer = new SpeexStream(this.metadata, this.options, tokenizer);
                break;
              case "fishead":
              case "theora":
                debug("Set page consumer to Ogg/Theora");
                this.pageConsumer = new TheoraStream(this.metadata, this.options, tokenizer);
                break;
              case "FLAC":
                debug("Set page consumer to Vorbis");
                this.pageConsumer = new FlacStream(this.metadata, this.options, tokenizer);
                break;
              default:
                throw new OggContentError(`Ogg codec not recognized (id=${asciiId}`);
            }
          }
          if (header.headerType.lastPage) {
            this.closed = true;
          }
          if (this.pageConsumer) {
            await this.pageConsumer.parsePage(header, pageData);
          } else
            throw new Error("pageConsumer should be initialized");
        }
      }
      class OggParser extends BasicParser {
        constructor() {
          super(...arguments);
          this.streams = /* @__PURE__ */ new Map();
        }
        /**
         * Parse page
         * @returns {Promise<void>}
         */
        async parse() {
          this.streams = /* @__PURE__ */ new Map();
          let header;
          try {
            do {
              header = await this.tokenizer.readToken(PageHeader);
              if (header.capturePattern !== "OggS")
                throw new OggContentError("Invalid Ogg capture pattern");
              let stream = this.streams.get(header.streamSerialNumber);
              if (!stream) {
                stream = new OggStream(this.metadata, header.streamSerialNumber, this.options);
                this.streams.set(header.streamSerialNumber, stream);
              }
              await stream.parsePage(this.tokenizer, header);
              if (stream.pageNumber > 12 && !(this.options.duration && [...this.streams.values()].find((stream2) => stream2.pageConsumer?.durationOnLastPage))) {
                debug("Stop processing Ogg stream");
                break;
              }
            } while (![...this.streams.values()].every((item) => item.closed));
          } catch (err) {
            if (err instanceof EndOfStreamError) {
              debug("Reached end-of-stream");
            } else if (err instanceof OggContentError) {
              this.metadata.addWarning(`Corrupt Ogg content at ${this.tokenizer.position}`);
            } else
              throw err;
          }
          for (const stream of this.streams.values()) {
            if (!stream.closed) {
              this.metadata.addWarning(`End-of-stream reached before reaching last page in Ogg stream serial=${stream.streamSerial}`);
              await stream.pageConsumer?.flush();
            }
            stream.pageConsumer?.calculateDuration();
          }
        }
      } exports("OggParser", OggParser);

    })
  };
}));

System.register("./FlacParser-CAsVRrMV-DZB68qaX.js", ['./main-cGY5pIDA-DL9qX_J1.js', './AbstractID3Parser-VsE1AWmF-6kl3V0zG.js'], (function (exports, module) {
  'use strict';
  var FourCcToken, initDebug, Uint8ArrayType, UINT32_LE, makeUnexpectedFileContentError, UINT24_BE, getBitAllignedNumber, getBit, UINT16_BE, textDecode, AttachedPictureType, UINT32_BE, StringType, UINT8, AbstractID3Parser;
  return {
    setters: [module => {
      FourCcToken = module.F;
      initDebug = module.i;
      Uint8ArrayType = module.U;
      UINT32_LE = module.e;
      makeUnexpectedFileContentError = module.m;
      UINT24_BE = module.H;
      getBitAllignedNumber = module.g;
      getBit = module.j;
      UINT16_BE = module.c;
      textDecode = module.y;
      AttachedPictureType = module.A;
      UINT32_BE = module.b;
      StringType = module.S;
      UINT8 = module.d;
    }, module => {
      AbstractID3Parser = module.A;
    }],
    execute: (function () {

      class VorbisPictureToken {
        static fromBase64(base64str) {
          return VorbisPictureToken.fromBuffer(Uint8Array.from(atob(base64str), (c) => c.charCodeAt(0)));
        }
        static fromBuffer(buffer) {
          const pic = new VorbisPictureToken(buffer.length);
          return pic.get(buffer, 0);
        }
        constructor(len) {
          this.len = len;
        }
        get(buffer, offset) {
          const type = AttachedPictureType[UINT32_BE.get(buffer, offset)];
          offset += 4;
          const mimeLen = UINT32_BE.get(buffer, offset);
          offset += 4;
          const format = new StringType(mimeLen, "utf-8").get(buffer, offset);
          offset += mimeLen;
          const descLen = UINT32_BE.get(buffer, offset);
          offset += 4;
          const description = new StringType(descLen, "utf-8").get(buffer, offset);
          offset += descLen;
          const width = UINT32_BE.get(buffer, offset);
          offset += 4;
          const height = UINT32_BE.get(buffer, offset);
          offset += 4;
          const colour_depth = UINT32_BE.get(buffer, offset);
          offset += 4;
          const indexed_color = UINT32_BE.get(buffer, offset);
          offset += 4;
          const picDataLen = UINT32_BE.get(buffer, offset);
          offset += 4;
          const data = Uint8Array.from(buffer.slice(offset, offset + picDataLen));
          return {
            type,
            format,
            description,
            width,
            height,
            colour_depth,
            indexed_color,
            data
          };
        }
      } exports("b", VorbisPictureToken);
      const CommonHeader = {
        len: 7,
        get: (buf, off) => {
          return {
            packetType: UINT8.get(buf, off),
            vorbis: new StringType(6, "ascii").get(buf, off + 1)
          };
        }
      };
      const IdentificationHeader = {
        len: 23,
        get: (uint8Array, off) => {
          return {
            version: UINT32_LE.get(uint8Array, off + 0),
            channelMode: UINT8.get(uint8Array, off + 4),
            sampleRate: UINT32_LE.get(uint8Array, off + 5),
            bitrateMax: UINT32_LE.get(uint8Array, off + 9),
            bitrateNominal: UINT32_LE.get(uint8Array, off + 13),
            bitrateMin: UINT32_LE.get(uint8Array, off + 17)
          };
        }
      };
      class VorbisDecoder {
        constructor(data, offset) {
          this.data = data;
          this.offset = offset;
        }
        readInt32() {
          const value = UINT32_LE.get(this.data, this.offset);
          this.offset += 4;
          return value;
        }
        readStringUtf8() {
          const len = this.readInt32();
          const value = textDecode(this.data.subarray(this.offset, this.offset + len), "utf-8");
          this.offset += len;
          return value;
        }
        parseUserComment() {
          const offset0 = this.offset;
          const v = this.readStringUtf8();
          const idx = v.indexOf("=");
          return {
            key: v.slice(0, idx).toUpperCase(),
            value: v.slice(idx + 1),
            len: this.offset - offset0
          };
        }
      }
      const debug$1 = initDebug("music-metadata:parser:ogg:vorbis1");
      class VorbisContentError extends makeUnexpectedFileContentError("Vorbis") {
      }
      class VorbisStream {
        constructor(metadata, options) {
          this.pageSegments = [];
          this.durationOnLastPage = true;
          this.metadata = metadata;
          this.options = options;
        }
        /**
         * Vorbis 1 parser
         * @param header Ogg Page Header
         * @param pageData Page data
         */
        async parsePage(header, pageData) {
          this.lastPageHeader = header;
          if (header.headerType.firstPage) {
            this.parseFirstPage(header, pageData);
          } else {
            if (header.headerType.continued) {
              if (this.pageSegments.length === 0) {
                throw new VorbisContentError("Cannot continue on previous page");
              }
              this.pageSegments.push(pageData);
            }
            if (header.headerType.lastPage || !header.headerType.continued) {
              if (this.pageSegments.length > 0) {
                const fullPage = VorbisStream.mergeUint8Arrays(this.pageSegments);
                await this.parseFullPage(fullPage);
              }
              this.pageSegments = header.headerType.lastPage ? [] : [pageData];
            }
          }
        }
        static mergeUint8Arrays(arrays) {
          const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);
          const merged = new Uint8Array(totalSize);
          arrays.forEach((array, i, _arrays) => {
            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);
            merged.set(array, offset);
          });
          return merged;
        }
        async flush() {
          await this.parseFullPage(VorbisStream.mergeUint8Arrays(this.pageSegments));
        }
        async parseUserComment(pageData, offset) {
          const decoder = new VorbisDecoder(pageData, offset);
          const tag = decoder.parseUserComment();
          await this.addTag(tag.key, tag.value);
          return tag.len;
        }
        async addTag(id, value) {
          if (id === "METADATA_BLOCK_PICTURE" && typeof value === "string") {
            if (this.options.skipCovers) {
              debug$1("Ignore picture");
              return;
            }
            value = VorbisPictureToken.fromBase64(value);
            debug$1(`Push picture: id=${id}, format=${value.format}`);
          } else {
            debug$1(`Push tag: id=${id}, value=${value}`);
          }
          await this.metadata.addTag("vorbis", id, value);
        }
        calculateDuration() {
          if (this.lastPageHeader && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {
            this.metadata.setFormat("numberOfSamples", this.lastPageHeader.absoluteGranulePosition);
            this.metadata.setFormat("duration", this.lastPageHeader.absoluteGranulePosition / this.metadata.format.sampleRate);
          }
        }
        /**
         * Parse first Ogg/Vorbis page
         * @param _header
         * @param pageData
         */
        parseFirstPage(_header, pageData) {
          this.metadata.setFormat("codec", "Vorbis I");
          this.metadata.setFormat("hasAudio", true);
          debug$1("Parse first page");
          const commonHeader = CommonHeader.get(pageData, 0);
          if (commonHeader.vorbis !== "vorbis")
            throw new VorbisContentError("Metadata does not look like Vorbis");
          if (commonHeader.packetType === 1) {
            const idHeader = IdentificationHeader.get(pageData, CommonHeader.len);
            this.metadata.setFormat("sampleRate", idHeader.sampleRate);
            this.metadata.setFormat("bitrate", idHeader.bitrateNominal);
            this.metadata.setFormat("numberOfChannels", idHeader.channelMode);
            debug$1("sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s", idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);
          } else
            throw new VorbisContentError("First Ogg page should be type 1: the identification header");
        }
        async parseFullPage(pageData) {
          const commonHeader = CommonHeader.get(pageData, 0);
          debug$1("Parse full page: type=%s, byteLength=%s", commonHeader.packetType, pageData.byteLength);
          switch (commonHeader.packetType) {
            case 3:
              return this.parseUserCommentList(pageData, CommonHeader.len);
          }
        }
        /**
         * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2
         */
        async parseUserCommentList(pageData, offset) {
          const strLen = UINT32_LE.get(pageData, offset);
          offset += 4;
          offset += strLen;
          let userCommentListLength = UINT32_LE.get(pageData, offset);
          offset += 4;
          while (userCommentListLength-- > 0) {
            offset += await this.parseUserComment(pageData, offset);
          }
        }
      } exports("V", VorbisStream);
      const BlockType = exports("a", {
        STREAMINFO: 0,
        // STREAMINFO
        PADDING: 1,
        // PADDING
        APPLICATION: 2,
        // APPLICATION
        SEEKTABLE: 3,
        // SEEKTABLE
        VORBIS_COMMENT: 4,
        // VORBIS_COMMENT
        CUESHEET: 5,
        // CUESHEET
        PICTURE: 6
        // PICTURE
      });
      const BlockHeader = exports("B", {
        len: 4,
        get: (buf, off) => {
          return {
            lastBlock: getBit(buf, off, 7),
            type: getBitAllignedNumber(buf, off, 1, 7),
            length: UINT24_BE.get(buf, off + 1)
          };
        }
      });
      const BlockStreamInfo = exports("c", {
        len: 34,
        get: (buf, off) => {
          return {
            // The minimum block size (in samples) used in the stream.
            minimumBlockSize: UINT16_BE.get(buf, off),
            // The maximum block size (in samples) used in the stream.
            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.
            maximumBlockSize: UINT16_BE.get(buf, off + 2) / 1e3,
            // The minimum frame size (in bytes) used in the stream.
            // May be 0 to imply the value is not known.
            minimumFrameSize: UINT24_BE.get(buf, off + 4),
            // The maximum frame size (in bytes) used in the stream.
            // May be 0 to imply the value is not known.
            maximumFrameSize: UINT24_BE.get(buf, off + 7),
            // Sample rate in Hz. Though 20 bits are available,
            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.
            // Also, a value of 0 is invalid.
            sampleRate: UINT24_BE.get(buf, off + 10) >> 4,
            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),
            // (number of channels)-1. FLAC supports from 1 to 8 channels
            channels: getBitAllignedNumber(buf, off + 12, 4, 3) + 1,
            // bits per sample)-1.
            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.
            bitsPerSample: getBitAllignedNumber(buf, off + 12, 7, 5) + 1,
            // Total samples in stream.
            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.
            // A value of zero here means the number of total samples is unknown.
            totalSamples: getBitAllignedNumber(buf, off + 13, 4, 36),
            // the MD5 hash of the file (see notes for usage... it's a littly tricky)
            fileMD5: new Uint8ArrayType(16).get(buf, off + 18)
          };
        }
      });
      const debug = initDebug("music-metadata:parser:FLAC");
      class FlacContentError extends makeUnexpectedFileContentError("FLAC") {
      }
      class FlacParser extends AbstractID3Parser {
        constructor() {
          super(...arguments);
          this.vorbisParser = new VorbisStream(this.metadata, this.options);
          this.padding = 0;
        }
        async postId3v2Parse() {
          const fourCC = await this.tokenizer.readToken(FourCcToken);
          if (fourCC.toString() !== "fLaC") {
            throw new FlacContentError("Invalid FLAC preamble");
          }
          let blockHeader;
          do {
            blockHeader = await this.tokenizer.readToken(BlockHeader);
            await this.parseDataBlock(blockHeader);
          } while (!blockHeader.lastBlock);
          if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {
            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;
            this.metadata.setFormat("bitrate", 8 * dataSize / this.metadata.format.duration);
          }
        }
        async parseDataBlock(blockHeader) {
          debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);
          switch (blockHeader.type) {
            case BlockType.STREAMINFO:
              return this.readBlockStreamInfo(blockHeader.length);
            case BlockType.PADDING:
              this.padding += blockHeader.length;
              break;
            case BlockType.APPLICATION:
              break;
            case BlockType.SEEKTABLE:
              break;
            case BlockType.VORBIS_COMMENT:
              return this.readComment(blockHeader.length);
            case BlockType.CUESHEET:
              break;
            case BlockType.PICTURE:
              await this.parsePicture(blockHeader.length);
              return;
            default:
              this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);
          }
          return this.tokenizer.ignore(blockHeader.length).then();
        }
        /**
         * Parse STREAMINFO
         */
        async readBlockStreamInfo(dataLen) {
          if (dataLen !== BlockStreamInfo.len)
            throw new FlacContentError("Unexpected block-stream-info length");
          const streamInfo = await this.tokenizer.readToken(BlockStreamInfo);
          this.metadata.setFormat("container", "FLAC");
          this.processsStreamInfo(streamInfo);
        }
        /**
         * Parse STREAMINFO
         */
        processsStreamInfo(streamInfo) {
          this.metadata.setFormat("codec", "FLAC");
          this.metadata.setFormat("hasAudio", true);
          this.metadata.setFormat("lossless", true);
          this.metadata.setFormat("numberOfChannels", streamInfo.channels);
          this.metadata.setFormat("bitsPerSample", streamInfo.bitsPerSample);
          this.metadata.setFormat("sampleRate", streamInfo.sampleRate);
          if (streamInfo.totalSamples > 0) {
            this.metadata.setFormat("duration", streamInfo.totalSamples / streamInfo.sampleRate);
          }
        }
        /**
         * Read VORBIS_COMMENT from tokenizer
         * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3
         */
        async readComment(dataLen) {
          const data = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));
          return this.parseComment(data);
        }
        /**
         * Parse VORBIS_COMMENT
         * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3
         */
        async parseComment(data) {
          const decoder = new VorbisDecoder(data, 0);
          decoder.readStringUtf8();
          const commentListLength = decoder.readInt32();
          const tags = new Array(commentListLength);
          for (let i = 0; i < commentListLength; i++) {
            tags[i] = decoder.parseUserComment();
          }
          await Promise.all(tags.map((tag) => this.addTag(tag.key, tag.value)));
        }
        async parsePicture(dataLen) {
          if (this.options.skipCovers) {
            return this.tokenizer.ignore(dataLen);
          }
          return this.addPictureTag(await this.tokenizer.readToken(new VorbisPictureToken(dataLen)));
        }
        addPictureTag(picture) {
          return this.addTag("METADATA_BLOCK_PICTURE", picture);
        }
        addTag(id, value) {
          return this.vorbisParser.addTag(id, value);
        }
      } exports("F", FlacParser);
      const FlacParser$1 = exports("d", /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        FlacParser
      }, Symbol.toStringTag, { value: "Module" })));

    })
  };
}));

System.register("./AbstractID3Parser-VsE1AWmF-6kl3V0zG.js", ['./main-cGY5pIDA-DL9qX_J1.js', './ID3v2Parser-C6PymtiX-BXaBboLM.js'], (function (exports, module) {
  'use strict';
  var BasicParser, ID3v2Header, EndOfStreamError, initDebug, ID3v1Parser, ID3v2Parser;
  return {
    setters: [module => {
      BasicParser = module.B;
      ID3v2Header = module.L;
      EndOfStreamError = module.E;
      initDebug = module.i;
      ID3v1Parser = module.M;
    }, module => {
      ID3v2Parser = module.I;
    }],
    execute: (function () {

      const debug = initDebug("music-metadata:parser:ID3");
      class AbstractID3Parser extends BasicParser {
        constructor() {
          super(...arguments);
          this.id3parser = new ID3v2Parser();
        }
        static async startsWithID3v2Header(tokenizer) {
          return (await tokenizer.peekToken(ID3v2Header)).fileIdentifier === "ID3";
        }
        async parse() {
          try {
            await this.parseID3v2();
          } catch (err) {
            if (err instanceof EndOfStreamError) {
              debug("End-of-stream");
            } else {
              throw err;
            }
          }
        }
        finalize() {
          return;
        }
        async parseID3v2() {
          await this.tryReadId3v2Headers();
          debug("End of ID3v2 header, go to MPEG-parser: pos=%s", this.tokenizer.position);
          await this.postId3v2Parse();
          if (this.options.skipPostHeaders && this.metadata.hasAny()) {
            this.finalize();
          } else {
            const id3v1parser = new ID3v1Parser(this.metadata, this.tokenizer, this.options);
            await id3v1parser.parse();
            this.finalize();
          }
        }
        async tryReadId3v2Headers() {
          const id3Header = await this.tokenizer.peekToken(ID3v2Header);
          if (id3Header.fileIdentifier === "ID3") {
            debug("Found ID3v2 header, pos=%s", this.tokenizer.position);
            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);
            return this.tryReadId3v2Headers();
          }
        }
      } exports("A", AbstractID3Parser);

    })
  };
}));

System.register("./WavPackParser-BLGhkLPg-CrOWnE7a.js", ['./main-cGY5pIDA-DL9qX_J1.js', 'react', 'antd', 'react-dom', '@ant-design/icons'], (function (exports, module) {
  'use strict';
  var BasicParser, tryParseApeHeader, FourCcToken, initDebug, UINT24_LE, UINT8, uint8ArrayToHex, UINT32_LE, Uint8ArrayType, UINT16_LE, makeUnexpectedFileContentError;
  return {
    setters: [module => {
      BasicParser = module.B;
      tryParseApeHeader = module.J;
      FourCcToken = module.F;
      initDebug = module.i;
      UINT24_LE = module.N;
      UINT8 = module.d;
      uint8ArrayToHex = module.u;
      UINT32_LE = module.e;
      Uint8ArrayType = module.U;
      UINT16_LE = module.k;
      makeUnexpectedFileContentError = module.m;
    }, null, null, null, null],
    execute: (function () {

      const SampleRates = [
        6e3,
        8e3,
        9600,
        11025,
        12e3,
        16e3,
        22050,
        24e3,
        32e3,
        44100,
        48e3,
        64e3,
        88200,
        96e3,
        192e3,
        -1
      ];
      const BlockHeaderToken = {
        len: 32,
        get: (buf, off) => {
          const flags = UINT32_LE.get(buf, off + 24);
          const res = {
            // should equal 'wvpk'
            BlockID: FourCcToken.get(buf, off),
            //  0x402 to 0x410 are valid for decode
            blockSize: UINT32_LE.get(buf, off + 4),
            //  0x402 (1026) to 0x410 are valid for decode
            version: UINT16_LE.get(buf, off + 8),
            //  40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
            totalSamples: (
              /* replace with bigint? (Token.UINT8.get(buf, off + 11) << 32) + */
              UINT32_LE.get(buf, off + 12)
            ),
            // 40-bit block_index
            blockIndex: (
              /* replace with bigint? (Token.UINT8.get(buf, off + 10) << 32) + */
              UINT32_LE.get(buf, off + 16)
            ),
            // 40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
            blockSamples: UINT32_LE.get(buf, off + 20),
            // various flags for id and decoding
            flags: {
              bitsPerSample: (1 + getBitAllignedNumber(flags, 0, 2)) * 8,
              isMono: isBitSet(flags, 2),
              isHybrid: isBitSet(flags, 3),
              isJointStereo: isBitSet(flags, 4),
              crossChannel: isBitSet(flags, 5),
              hybridNoiseShaping: isBitSet(flags, 6),
              floatingPoint: isBitSet(flags, 7),
              samplingRate: SampleRates[getBitAllignedNumber(flags, 23, 4)],
              isDSD: isBitSet(flags, 31)
            },
            // crc for actual decoded data
            crc: new Uint8ArrayType(4).get(buf, off + 28)
          };
          if (res.flags.isDSD) {
            res.totalSamples *= 8;
          }
          return res;
        }
      };
      const MetadataIdToken = {
        len: 1,
        get: (buf, off) => {
          return {
            functionId: getBitAllignedNumber(buf[off], 0, 6),
            // functionId overlaps with isOptional flag
            isOptional: isBitSet(buf[off], 5),
            isOddSize: isBitSet(buf[off], 6),
            largeBlock: isBitSet(buf[off], 7)
          };
        }
      };
      function isBitSet(flags, bitOffset) {
        return getBitAllignedNumber(flags, bitOffset, 1) === 1;
      }
      function getBitAllignedNumber(flags, bitOffset, len) {
        return flags >>> bitOffset & 4294967295 >>> 32 - len;
      }
      const debug = initDebug("music-metadata:parser:WavPack");
      class WavPackContentError extends makeUnexpectedFileContentError("WavPack") {
      } exports("WavPackContentError", WavPackContentError);
      class WavPackParser extends BasicParser {
        constructor() {
          super(...arguments);
          this.audioDataSize = 0;
        }
        async parse() {
          this.metadata.setAudioOnly();
          this.audioDataSize = 0;
          await this.parseWavPackBlocks();
          return tryParseApeHeader(this.metadata, this.tokenizer, this.options);
        }
        async parseWavPackBlocks() {
          do {
            const blockId = await this.tokenizer.peekToken(FourCcToken);
            if (blockId !== "wvpk")
              break;
            const header = await this.tokenizer.readToken(BlockHeaderToken);
            if (header.BlockID !== "wvpk")
              throw new WavPackContentError("Invalid WavPack Block-ID");
            debug(`WavPack header blockIndex=${header.blockIndex}, len=${BlockHeaderToken.len}`);
            if (header.blockIndex === 0 && !this.metadata.format.container) {
              this.metadata.setFormat("container", "WavPack");
              this.metadata.setFormat("lossless", !header.flags.isHybrid);
              this.metadata.setFormat("bitsPerSample", header.flags.bitsPerSample);
              if (!header.flags.isDSD) {
                this.metadata.setFormat("sampleRate", header.flags.samplingRate);
                this.metadata.setFormat("duration", header.totalSamples / header.flags.samplingRate);
              }
              this.metadata.setFormat("numberOfChannels", header.flags.isMono ? 1 : 2);
              this.metadata.setFormat("numberOfSamples", header.totalSamples);
              this.metadata.setFormat("codec", header.flags.isDSD ? "DSD" : "PCM");
            }
            const ignoreBytes = header.blockSize - (BlockHeaderToken.len - 8);
            await (header.blockIndex === 0 ? this.parseMetadataSubBlock(header, ignoreBytes) : this.tokenizer.ignore(ignoreBytes));
            if (header.blockSamples > 0) {
              this.audioDataSize += header.blockSize;
            }
          } while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= BlockHeaderToken.len);
          if (this.metadata.format.duration) {
            this.metadata.setFormat("bitrate", this.audioDataSize * 8 / this.metadata.format.duration);
          }
        }
        /**
         * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf, 3.0 Metadata Sub-blocks
         * @param header Header
         * @param remainingLength Remaining length
         */
        async parseMetadataSubBlock(header, remainingLength) {
          let remaining = remainingLength;
          while (remaining > MetadataIdToken.len) {
            const id = await this.tokenizer.readToken(MetadataIdToken);
            const dataSizeInWords = await this.tokenizer.readNumber(id.largeBlock ? UINT24_LE : UINT8);
            const data = new Uint8Array(dataSizeInWords * 2 - (id.isOddSize ? 1 : 0));
            await this.tokenizer.readBuffer(data);
            debug(`Metadata Sub-Blocks functionId=0x${id.functionId.toString(16)}, id.largeBlock=${id.largeBlock},data-size=${data.length}`);
            switch (id.functionId) {
              case 0:
                break;
              case 14: {
                debug("ID_DSD_BLOCK");
                const mp = 1 << UINT8.get(data, 0);
                const samplingRate = header.flags.samplingRate * mp * 8;
                if (!header.flags.isDSD)
                  throw new WavPackContentError("Only expect DSD block if DSD-flag is set");
                this.metadata.setFormat("sampleRate", samplingRate);
                this.metadata.setFormat("duration", header.totalSamples / samplingRate);
                break;
              }
              case 36:
                debug("ID_ALT_TRAILER: trailer for non-wav files");
                break;
              case 38:
                this.metadata.setFormat("audioMD5", data);
                break;
              case 47:
                debug(`ID_BLOCK_CHECKSUM: checksum=${uint8ArrayToHex(data)}`);
                break;
              default:
                debug(`Ignore unsupported meta-sub-block-id functionId=0x${id.functionId.toString(16)}`);
                break;
            }
            remaining -= MetadataIdToken.len + (id.largeBlock ? UINT24_LE.len : UINT8.len) + dataSizeInWords * 2;
            debug(`remainingLength=${remaining}`);
            if (id.isOddSize)
              this.tokenizer.ignore(1);
          }
          if (remaining !== 0)
            throw new WavPackContentError("metadata-sub-block should fit it remaining length");
        }
      } exports("WavPackParser", WavPackParser);

    })
  };
}));

System.register("./WaveParser-C8tUW5CK--zKdjNgH.js", ['./main-cGY5pIDA-DL9qX_J1.js', './ID3v2Parser-C6PymtiX-BXaBboLM.js', 'react', 'antd', 'react-dom', '@ant-design/icons'], (function (exports, module) {
  'use strict';
  var BasicParser, initDebug, EndOfStreamError, FourCcToken, Uint8ArrayType, fromBuffer, StringType, stripNulls, UINT32_LE, makeUnexpectedFileContentError, UINT16_LE, ID3v2Parser;
  return {
    setters: [module => {
      BasicParser = module.B;
      initDebug = module.i;
      EndOfStreamError = module.E;
      FourCcToken = module.F;
      Uint8ArrayType = module.U;
      fromBuffer = module.n;
      StringType = module.S;
      stripNulls = module.s;
      UINT32_LE = module.e;
      makeUnexpectedFileContentError = module.m;
      UINT16_LE = module.k;
    }, module => {
      ID3v2Parser = module.I;
    }, null, null, null, null],
    execute: (function () {

      const Header = {
        len: 8,
        get: (buf, off) => {
          return {
            // Group-ID
            chunkID: new StringType(4, "latin1").get(buf, off),
            // Size
            chunkSize: UINT32_LE.get(buf, off + 4)
          };
        }
      };
      class ListInfoTagValue {
        constructor(tagHeader) {
          this.tagHeader = tagHeader;
          this.len = tagHeader.chunkSize;
          this.len += this.len & 1;
        }
        get(buf, off) {
          return new StringType(this.tagHeader.chunkSize, "ascii").get(buf, off);
        }
      }
      class WaveContentError extends makeUnexpectedFileContentError("Wave") {
      }
      const WaveFormat = {
        PCM: 1,
        // MPEG-4 and AAC Audio Types
        ADPCM: 2,
        IEEE_FLOAT: 3,
        MPEG_ADTS_AAC: 5632,
        MPEG_LOAS: 5634,
        RAW_AAC1: 255,
        // Dolby Audio Types
        DOLBY_AC3_SPDIF: 146,
        DVM: 8192,
        RAW_SPORT: 576,
        ESST_AC3: 577,
        DRM: 9,
        DTS2: 8193,
        MPEG: 80
      };
      const WaveFormatNameMap = {
        [WaveFormat.PCM]: "PCM",
        [WaveFormat.ADPCM]: "ADPCM",
        [WaveFormat.IEEE_FLOAT]: "IEEE_FLOAT",
        [WaveFormat.MPEG_ADTS_AAC]: "MPEG_ADTS_AAC",
        [WaveFormat.MPEG_LOAS]: "MPEG_LOAS",
        [WaveFormat.RAW_AAC1]: "RAW_AAC1",
        [WaveFormat.DOLBY_AC3_SPDIF]: "DOLBY_AC3_SPDIF",
        [WaveFormat.DVM]: "DVM",
        [WaveFormat.RAW_SPORT]: "RAW_SPORT",
        [WaveFormat.ESST_AC3]: "ESST_AC3",
        [WaveFormat.DRM]: "DRM",
        [WaveFormat.DTS2]: "DTS2",
        [WaveFormat.MPEG]: "MPEG"
      };
      class Format {
        constructor(header) {
          if (header.chunkSize < 16)
            throw new WaveContentError("Invalid chunk size");
          this.len = header.chunkSize;
        }
        get(buf, off) {
          return {
            wFormatTag: UINT16_LE.get(buf, off),
            nChannels: UINT16_LE.get(buf, off + 2),
            nSamplesPerSec: UINT32_LE.get(buf, off + 4),
            nAvgBytesPerSec: UINT32_LE.get(buf, off + 8),
            nBlockAlign: UINT16_LE.get(buf, off + 12),
            wBitsPerSample: UINT16_LE.get(buf, off + 14)
          };
        }
      }
      class FactChunk {
        constructor(header) {
          if (header.chunkSize < 4) {
            throw new WaveContentError("Invalid fact chunk size.");
          }
          this.len = header.chunkSize;
        }
        get(buf, off) {
          return {
            dwSampleLength: UINT32_LE.get(buf, off)
          };
        }
      }
      const BroadcastAudioExtensionChunk = {
        len: 420,
        get: (uint8array, off) => {
          return {
            description: stripNulls(new StringType(256, "ascii").get(uint8array, off)).trim(),
            originator: stripNulls(new StringType(32, "ascii").get(uint8array, off + 256)).trim(),
            originatorReference: stripNulls(new StringType(32, "ascii").get(uint8array, off + 288)).trim(),
            originationDate: stripNulls(new StringType(10, "ascii").get(uint8array, off + 320)).trim(),
            originationTime: stripNulls(new StringType(8, "ascii").get(uint8array, off + 330)).trim(),
            timeReferenceLow: UINT32_LE.get(uint8array, off + 338),
            timeReferenceHigh: UINT32_LE.get(uint8array, off + 342),
            version: UINT16_LE.get(uint8array, off + 346),
            umid: new Uint8ArrayType(64).get(uint8array, off + 348),
            loudnessValue: UINT16_LE.get(uint8array, off + 412),
            maxTruePeakLevel: UINT16_LE.get(uint8array, off + 414),
            maxMomentaryLoudness: UINT16_LE.get(uint8array, off + 416),
            maxShortTermLoudness: UINT16_LE.get(uint8array, off + 418)
          };
        }
      };
      const debug = initDebug("music-metadata:parser:RIFF");
      class WaveParser extends BasicParser {
        constructor() {
          super(...arguments);
          this.blockAlign = 0;
        }
        async parse() {
          const riffHeader = await this.tokenizer.readToken(Header);
          debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);
          if (riffHeader.chunkID !== "RIFF")
            return;
          this.metadata.setAudioOnly();
          return this.parseRiffChunk(riffHeader.chunkSize).catch((err) => {
            if (!(err instanceof EndOfStreamError)) {
              throw err;
            }
          });
        }
        async parseRiffChunk(chunkSize) {
          const type = await this.tokenizer.readToken(FourCcToken);
          this.metadata.setFormat("container", type);
          switch (type) {
            case "WAVE":
              return this.readWaveChunk(chunkSize - FourCcToken.len);
            default:
              throw new WaveContentError(`Unsupported RIFF format: RIFF/${type}`);
          }
        }
        async readWaveChunk(remaining) {
          while (remaining >= Header.len) {
            const header = await this.tokenizer.readToken(Header);
            remaining -= Header.len + header.chunkSize;
            if (header.chunkSize > remaining) {
              this.metadata.addWarning("Data chunk size exceeds file size");
            }
            this.header = header;
            debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);
            switch (header.chunkID) {
              case "LIST":
                await this.parseListTag(header);
                break;
              case "fact":
                this.metadata.setFormat("lossless", false);
                this.fact = await this.tokenizer.readToken(new FactChunk(header));
                break;
              case "fmt ": {
                const fmt = await this.tokenizer.readToken(new Format(header));
                let subFormat = WaveFormatNameMap[fmt.wFormatTag];
                if (!subFormat) {
                  debug(`WAVE/non-PCM format=${fmt.wFormatTag}`);
                  subFormat = `non-PCM (${fmt.wFormatTag})`;
                }
                this.metadata.setFormat("codec", subFormat);
                this.metadata.setFormat("bitsPerSample", fmt.wBitsPerSample);
                this.metadata.setFormat("sampleRate", fmt.nSamplesPerSec);
                this.metadata.setFormat("numberOfChannels", fmt.nChannels);
                this.metadata.setFormat("bitrate", fmt.nBlockAlign * fmt.nSamplesPerSec * 8);
                this.blockAlign = fmt.nBlockAlign;
                break;
              }
              case "id3 ":
              // The way Picard, FooBar currently stores, ID3 meta-data
              case "ID3 ": {
                const id3_data = await this.tokenizer.readToken(new Uint8ArrayType(header.chunkSize));
                const rst = fromBuffer(id3_data);
                await new ID3v2Parser().parse(this.metadata, rst, this.options);
                break;
              }
              case "data": {
                if (this.metadata.format.lossless !== false) {
                  this.metadata.setFormat("lossless", true);
                }
                let chunkSize = header.chunkSize;
                if (this.tokenizer.fileInfo.size) {
                  const calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;
                  if (calcRemaining < chunkSize) {
                    this.metadata.addWarning("data chunk length exceeding file length");
                    chunkSize = calcRemaining;
                  }
                }
                const numberOfSamples = this.fact ? this.fact.dwSampleLength : chunkSize === 4294967295 ? void 0 : chunkSize / this.blockAlign;
                if (numberOfSamples) {
                  this.metadata.setFormat("numberOfSamples", numberOfSamples);
                  if (this.metadata.format.sampleRate) {
                    this.metadata.setFormat("duration", numberOfSamples / this.metadata.format.sampleRate);
                  }
                }
                if (this.metadata.format.codec === "ADPCM") {
                  this.metadata.setFormat("bitrate", 352e3);
                } else if (this.metadata.format.sampleRate) {
                  this.metadata.setFormat("bitrate", this.blockAlign * this.metadata.format.sampleRate * 8);
                }
                await this.tokenizer.ignore(header.chunkSize);
                break;
              }
              case "bext": {
                const bext = await this.tokenizer.readToken(BroadcastAudioExtensionChunk);
                Object.keys(bext).forEach((key) => {
                  this.metadata.addTag("exif", `bext.${key}`, bext[key]);
                });
                const bextRemaining = header.chunkSize - BroadcastAudioExtensionChunk.len;
                await this.tokenizer.ignore(bextRemaining);
                break;
              }
              case "\0\0\0\0":
                debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);
                this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);
                await this.tokenizer.ignore(header.chunkSize);
                break;
              default:
                debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);
                this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);
                await this.tokenizer.ignore(header.chunkSize);
            }
            if (this.header.chunkSize % 2 === 1) {
              debug("Read odd padding byte");
              await this.tokenizer.ignore(1);
            }
          }
        }
        async parseListTag(listHeader) {
          const listType = await this.tokenizer.readToken(new StringType(4, "latin1"));
          debug("pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s", this.tokenizer.position, listType);
          switch (listType) {
            case "INFO":
              return this.parseRiffInfoTags(listHeader.chunkSize - 4);
            default:
              this.metadata.addWarning(`Ignore chunk: RIFF/WAVE/LIST/${listType}`);
              debug(`Ignoring chunkID=RIFF/WAVE/LIST/${listType}`);
              return this.tokenizer.ignore(listHeader.chunkSize - 4).then();
          }
        }
        async parseRiffInfoTags(chunkSize) {
          while (chunkSize >= 8) {
            const header = await this.tokenizer.readToken(Header);
            const valueToken = new ListInfoTagValue(header);
            const value = await this.tokenizer.readToken(valueToken);
            this.addTag(header.chunkID, stripNulls(value));
            chunkSize -= 8 + valueToken.len;
          }
          if (chunkSize !== 0) {
            throw new WaveContentError(`Illegal remaining size: ${chunkSize}`);
          }
        }
        addTag(id, value) {
          this.metadata.addTag("exif", id, value);
        }
      } exports("WaveParser", WaveParser);

    })
  };
}));

System.register("./ID3v2Parser-C6PymtiX-BXaBboLM.js", ['./main-cGY5pIDA-DL9qX_J1.js'], (function (exports, module) {
  'use strict';
  var getBit, ID3v2Header, ExtendedHeader, Uint8ArrayType, UINT32SYNCSAFE, UINT32_BE, textDecode, UINT24_BE, TextEncodingToken, initDebug, decodeString, findZero, UINT8, TextHeader, SyncTextHeader, AttachedPictureType, makeUnexpectedFileContentError, Genres;
  return {
    setters: [module => {
      getBit = module.j;
      ID3v2Header = module.L;
      ExtendedHeader = module.O;
      Uint8ArrayType = module.U;
      UINT32SYNCSAFE = module.P;
      UINT32_BE = module.b;
      textDecode = module.y;
      UINT24_BE = module.H;
      TextEncodingToken = module.Q;
      initDebug = module.i;
      decodeString = module.l;
      findZero = module.R;
      UINT8 = module.d;
      TextHeader = module.V;
      SyncTextHeader = module.W;
      AttachedPictureType = module.A;
      makeUnexpectedFileContentError = module.m;
      Genres = module.G;
    }],
    execute: (function () {

      const debug = initDebug("music-metadata:id3v2:frame-parser");
      const defaultEnc = "latin1";
      function parseGenre(origVal) {
        const genres = [];
        let code;
        let word = "";
        for (const c of origVal) {
          if (typeof code === "string") {
            if (c === "(" && code === "") {
              word += "(";
              code = void 0;
            } else if (c === ")") {
              if (word !== "") {
                genres.push(word);
                word = "";
              }
              const genre = parseGenreCode(code);
              if (genre) {
                genres.push(genre);
              }
              code = void 0;
            } else
              code += c;
          } else if (c === "(") {
            code = "";
          } else {
            word += c;
          }
        }
        if (word) {
          if (genres.length === 0 && word.match(/^\d*$/)) {
            word = parseGenreCode(word);
          }
          if (word) {
            genres.push(word);
          }
        }
        return genres;
      }
      function parseGenreCode(code) {
        if (code === "RX")
          return "Remix";
        if (code === "CR")
          return "Cover";
        if (code.match(/^\d*$/)) {
          return Genres[Number.parseInt(code)];
        }
      }
      class FrameParser {
        /**
         * Create id3v2 frame parser
         * @param major - Major version, e.g. (4) for  id3v2.4
         * @param warningCollector - Used to collect decode issue
         */
        constructor(major, warningCollector) {
          this.major = major;
          this.warningCollector = warningCollector;
        }
        readData(uint8Array, type, includeCovers) {
          if (uint8Array.length === 0) {
            this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${type}`);
            return;
          }
          const { encoding, bom } = TextEncodingToken.get(uint8Array, 0);
          const length = uint8Array.length;
          let offset = 0;
          let output = [];
          const nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);
          let fzero;
          debug(`Parsing tag type=${type}, encoding=${encoding}, bom=${bom}`);
          switch (type !== "TXXX" && type[0] === "T" ? "T*" : type) {
            case "T*":
            // 4.2.1. Text information frames - details
            case "GRP1":
            // iTunes-specific ID3v2 grouping field
            case "IPLS":
            // v2.3: Involved people list
            case "MVIN":
            case "MVNM":
            case "PCS":
            case "PCST": {
              let text;
              try {
                text = decodeString(uint8Array.slice(1), encoding).replace(/\x00+$/, "");
              } catch (error) {
                if (error instanceof Error) {
                  this.warningCollector.addWarning(`id3v2.${this.major} type=${type} header has invalid string value: ${error.message}`);
                  break;
                }
                throw error;
              }
              switch (type) {
                case "TMCL":
                // Musician credits list
                case "TIPL":
                // Involved people list
                case "IPLS":
                  output = FrameParser.functionList(this.splitValue(type, text));
                  break;
                case "TRK":
                case "TRCK":
                case "TPOS":
                  output = text;
                  break;
                case "TCOM":
                case "TEXT":
                case "TOLY":
                case "TOPE":
                case "TPE1":
                case "TSRC":
                  output = this.splitValue(type, text);
                  break;
                case "TCO":
                case "TCON":
                  output = this.splitValue(type, text).map((v) => parseGenre(v)).reduce((acc, val) => acc.concat(val), []);
                  break;
                case "PCS":
                case "PCST":
                  output = this.major >= 4 ? this.splitValue(type, text) : [text];
                  output = Array.isArray(output) && output[0] === "" ? 1 : 0;
                  break;
                default:
                  output = this.major >= 4 ? this.splitValue(type, text) : [text];
              }
              break;
            }
            case "TXXX": {
              const idAndData = FrameParser.readIdentifierAndData(uint8Array, offset + 1, length, encoding);
              const textTag = {
                description: idAndData.id,
                text: this.splitValue(type, decodeString(idAndData.data, encoding).replace(/\x00+$/, ""))
              };
              output = textTag;
              break;
            }
            case "PIC":
            case "APIC":
              if (includeCovers) {
                const pic = {};
                offset += 1;
                switch (this.major) {
                  case 2:
                    pic.format = decodeString(uint8Array.slice(offset, offset + 3), "latin1");
                    offset += 3;
                    break;
                  case 3:
                  case 4:
                    fzero = findZero(uint8Array, offset, length, defaultEnc);
                    pic.format = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
                    offset = fzero + 1;
                    break;
                  default:
                    throw makeUnexpectedMajorVersionError$1(this.major);
                }
                pic.format = FrameParser.fixPictureMimeType(pic.format);
                pic.type = AttachedPictureType[uint8Array[offset]];
                offset += 1;
                fzero = findZero(uint8Array, offset, length, encoding);
                pic.description = decodeString(uint8Array.slice(offset, fzero), encoding);
                offset = fzero + nullTerminatorLength;
                pic.data = uint8Array.slice(offset, length);
                output = pic;
              }
              break;
            case "CNT":
            case "PCNT":
              output = UINT32_BE.get(uint8Array, 0);
              break;
            case "SYLT": {
              const syltHeader = SyncTextHeader.get(uint8Array, 0);
              offset += SyncTextHeader.len;
              const result = {
                descriptor: "",
                language: syltHeader.language,
                contentType: syltHeader.contentType,
                timeStampFormat: syltHeader.timeStampFormat,
                syncText: []
              };
              let readSyllables = false;
              while (offset < length) {
                const nullStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), syltHeader.encoding);
                offset += nullStr.len;
                if (readSyllables) {
                  const timestamp = UINT32_BE.get(uint8Array, offset);
                  offset += UINT32_BE.len;
                  result.syncText.push({
                    text: nullStr.text,
                    timestamp
                  });
                } else {
                  result.descriptor = nullStr.text;
                  readSyllables = true;
                }
              }
              output = result;
              break;
            }
            case "ULT":
            case "USLT":
            case "COM":
            case "COMM": {
              const textHeader = TextHeader.get(uint8Array, offset);
              offset += TextHeader.len;
              const descriptorStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), textHeader.encoding);
              offset += descriptorStr.len;
              const textStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), textHeader.encoding);
              const comment = {
                language: textHeader.language,
                descriptor: descriptorStr.text,
                text: textStr.text
              };
              output = comment;
              break;
            }
            case "UFID": {
              const ufid = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);
              output = { owner_identifier: ufid.id, identifier: ufid.data };
              break;
            }
            case "PRIV": {
              const priv = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);
              output = { owner_identifier: priv.id, data: priv.data };
              break;
            }
            case "POPM": {
              fzero = findZero(uint8Array, offset, length, defaultEnc);
              const email = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
              offset = fzero + 1;
              const dataLen = length - offset;
              output = {
                email,
                rating: UINT8.get(uint8Array, offset),
                counter: dataLen >= 5 ? UINT32_BE.get(uint8Array, offset + 1) : void 0
              };
              break;
            }
            case "GEOB": {
              fzero = findZero(uint8Array, offset + 1, length, encoding);
              const mimeType = decodeString(uint8Array.slice(offset + 1, fzero), defaultEnc);
              offset = fzero + 1;
              fzero = findZero(uint8Array, offset, length, encoding);
              const filename = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
              offset = fzero + 1;
              fzero = findZero(uint8Array, offset, length, encoding);
              const description = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
              offset = fzero + 1;
              const geob = {
                type: mimeType,
                filename,
                description,
                data: uint8Array.slice(offset, length)
              };
              output = geob;
              break;
            }
            // W-Frames:
            case "WCOM":
            case "WCOP":
            case "WOAF":
            case "WOAR":
            case "WOAS":
            case "WORS":
            case "WPAY":
            case "WPUB":
              fzero = findZero(uint8Array, offset + 1, length, encoding);
              output = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
              break;
            case "WXXX": {
              fzero = findZero(uint8Array, offset + 1, length, encoding);
              const description = decodeString(uint8Array.slice(offset + 1, fzero), encoding);
              offset = fzero + (encoding === "utf-16le" ? 2 : 1);
              output = { description, url: decodeString(uint8Array.slice(offset, length), defaultEnc) };
              break;
            }
            case "WFD":
            case "WFED":
              output = decodeString(uint8Array.slice(offset + 1, findZero(uint8Array, offset + 1, length, encoding)), encoding);
              break;
            case "MCDI": {
              output = uint8Array.slice(0, length);
              break;
            }
            default:
              debug(`Warning: unsupported id3v2-tag-type: ${type}`);
              break;
          }
          return output;
        }
        static readNullTerminatedString(uint8Array, encoding) {
          let offset = encoding.bom ? 2 : 0;
          const zeroIndex = findZero(uint8Array, offset, uint8Array.length, encoding.encoding);
          const txt = uint8Array.slice(offset, zeroIndex);
          if (encoding.encoding === "utf-16le") {
            offset = zeroIndex + 2;
          } else {
            offset = zeroIndex + 1;
          }
          return {
            text: decodeString(txt, encoding.encoding),
            len: offset
          };
        }
        static fixPictureMimeType(pictureType) {
          pictureType = pictureType.toLocaleLowerCase();
          switch (pictureType) {
            case "jpg":
              return "image/jpeg";
            case "png":
              return "image/png";
          }
          return pictureType;
        }
        /**
         * Converts TMCL (Musician credits list) or TIPL (Involved people list)
         * @param entries
         */
        static functionList(entries) {
          const res = {};
          for (let i = 0; i + 1 < entries.length; i += 2) {
            const names = entries[i + 1].split(",");
            res[entries[i]] = res[entries[i]] ? res[entries[i]].concat(names) : names;
          }
          return res;
        }
        /**
         * id3v2.4 defines that multiple T* values are separated by 0x00
         * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /
         * @param tag - Tag name
         * @param text - Concatenated tag value
         * @returns Split tag value
         */
        splitValue(tag, text) {
          let values;
          if (this.major < 4) {
            values = text.split(/\x00/g);
            if (values.length > 1) {
              this.warningCollector.addWarning(`ID3v2.${this.major} ${tag} uses non standard null-separator.`);
            } else {
              values = text.split(/\//g);
            }
          } else {
            values = text.split(/\x00/g);
          }
          return FrameParser.trimArray(values);
        }
        static trimArray(values) {
          return values.map((value) => value.replace(/\x00+$/, "").trim());
        }
        static readIdentifierAndData(uint8Array, offset, length, encoding) {
          const fzero = findZero(uint8Array, offset, length, encoding);
          const id = decodeString(uint8Array.slice(offset, fzero), encoding);
          offset = fzero + FrameParser.getNullTerminatorLength(encoding);
          return { id, data: uint8Array.slice(offset, length) };
        }
        static getNullTerminatorLength(enc) {
          return enc === "utf-16le" ? 2 : 1;
        }
      }
      class Id3v2ContentError extends makeUnexpectedFileContentError("id3v2") {
      }
      function makeUnexpectedMajorVersionError$1(majorVer) {
        throw new Id3v2ContentError(`Unexpected majorVer: ${majorVer}`);
      }
      class ID3v2Parser {
        constructor() {
          this.tokenizer = void 0;
          this.id3Header = void 0;
          this.metadata = void 0;
          this.headerType = void 0;
          this.options = void 0;
        }
        static removeUnsyncBytes(buffer) {
          let readI = 0;
          let writeI = 0;
          while (readI < buffer.length - 1) {
            if (readI !== writeI) {
              buffer[writeI] = buffer[readI];
            }
            readI += buffer[readI] === 255 && buffer[readI + 1] === 0 ? 2 : 1;
            writeI++;
          }
          if (readI < buffer.length) {
            buffer[writeI++] = buffer[readI];
          }
          return buffer.slice(0, writeI);
        }
        static getFrameHeaderLength(majorVer) {
          switch (majorVer) {
            case 2:
              return 6;
            case 3:
            case 4:
              return 10;
            default:
              throw makeUnexpectedMajorVersionError(majorVer);
          }
        }
        static readFrameFlags(b) {
          return {
            status: {
              tag_alter_preservation: getBit(b, 0, 6),
              file_alter_preservation: getBit(b, 0, 5),
              read_only: getBit(b, 0, 4)
            },
            format: {
              grouping_identity: getBit(b, 1, 7),
              compression: getBit(b, 1, 3),
              encryption: getBit(b, 1, 2),
              unsynchronisation: getBit(b, 1, 1),
              data_length_indicator: getBit(b, 1, 0)
            }
          };
        }
        static readFrameData(uint8Array, frameHeader, majorVer, includeCovers, warningCollector) {
          const frameParser = new FrameParser(majorVer, warningCollector);
          switch (majorVer) {
            case 2:
              return frameParser.readData(uint8Array, frameHeader.id, includeCovers);
            case 3:
            case 4:
              if (frameHeader.flags?.format.unsynchronisation) {
                uint8Array = ID3v2Parser.removeUnsyncBytes(uint8Array);
              }
              if (frameHeader.flags?.format.data_length_indicator) {
                uint8Array = uint8Array.slice(4, uint8Array.length);
              }
              return frameParser.readData(uint8Array, frameHeader.id, includeCovers);
            default:
              throw makeUnexpectedMajorVersionError(majorVer);
          }
        }
        /**
         * Create a combined tag key, of tag & description
         * @param tag e.g.: COM
         * @param description e.g. iTunPGAP
         * @returns string e.g. COM:iTunPGAP
         */
        static makeDescriptionTagName(tag, description) {
          return tag + (description ? `:${description}` : "");
        }
        async parse(metadata, tokenizer, options) {
          this.tokenizer = tokenizer;
          this.metadata = metadata;
          this.options = options;
          const id3Header = await this.tokenizer.readToken(ID3v2Header);
          if (id3Header.fileIdentifier !== "ID3") {
            throw new Id3v2ContentError("expected ID3-header file-identifier 'ID3' was not found");
          }
          this.id3Header = id3Header;
          this.headerType = `ID3v2.${id3Header.version.major}`;
          return id3Header.flags.isExtendedHeader ? this.parseExtendedHeader() : this.parseId3Data(id3Header.size);
        }
        async parseExtendedHeader() {
          const extendedHeader = await this.tokenizer.readToken(ExtendedHeader);
          const dataRemaining = extendedHeader.size - ExtendedHeader.len;
          return dataRemaining > 0 ? this.parseExtendedHeaderData(dataRemaining, extendedHeader.size) : this.parseId3Data(this.id3Header.size - extendedHeader.size);
        }
        async parseExtendedHeaderData(dataRemaining, extendedHeaderSize) {
          await this.tokenizer.ignore(dataRemaining);
          return this.parseId3Data(this.id3Header.size - extendedHeaderSize);
        }
        async parseId3Data(dataLen) {
          const uint8Array = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));
          for (const tag of this.parseMetadata(uint8Array)) {
            switch (tag.id) {
              case "TXXX":
                if (tag.value) {
                  await this.handleTag(tag, tag.value.text, () => tag.value.description);
                }
                break;
              default:
                await (Array.isArray(tag.value) ? Promise.all(tag.value.map((value) => this.addTag(tag.id, value))) : this.addTag(tag.id, tag.value));
            }
          }
        }
        async handleTag(tag, values, descriptor, resolveValue = (value) => value) {
          await Promise.all(values.map((value) => this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, descriptor(value)), resolveValue(value))));
        }
        async addTag(id, value) {
          await this.metadata.addTag(this.headerType, id, value);
        }
        parseMetadata(data) {
          let offset = 0;
          const tags = [];
          while (true) {
            if (offset === data.length)
              break;
            const frameHeaderLength = ID3v2Parser.getFrameHeaderLength(this.id3Header.version.major);
            if (offset + frameHeaderLength > data.length) {
              this.metadata.addWarning("Illegal ID3v2 tag length");
              break;
            }
            const frameHeaderBytes = data.slice(offset, offset + frameHeaderLength);
            offset += frameHeaderLength;
            const frameHeader = this.readFrameHeader(frameHeaderBytes, this.id3Header.version.major);
            const frameDataBytes = data.slice(offset, offset + frameHeader.length);
            offset += frameHeader.length;
            const values = ID3v2Parser.readFrameData(frameDataBytes, frameHeader, this.id3Header.version.major, !this.options.skipCovers, this.metadata);
            if (values) {
              tags.push({ id: frameHeader.id, value: values });
            }
          }
          return tags;
        }
        readFrameHeader(uint8Array, majorVer) {
          let header;
          switch (majorVer) {
            case 2:
              header = {
                id: textDecode(uint8Array.slice(0, 3), "ascii"),
                length: UINT24_BE.get(uint8Array, 3)
              };
              if (!header.id.match(/[A-Z0-9]{3}/g)) {
                this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);
              }
              break;
            case 3:
            case 4:
              header = {
                id: textDecode(uint8Array.slice(0, 4), "ascii"),
                length: (majorVer === 4 ? UINT32SYNCSAFE : UINT32_BE).get(uint8Array, 4),
                flags: ID3v2Parser.readFrameFlags(uint8Array.slice(8, 10))
              };
              if (!header.id.match(/[A-Z0-9]{4}/g)) {
                this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);
              }
              break;
            default:
              throw makeUnexpectedMajorVersionError(majorVer);
          }
          return header;
        }
      } exports("I", ID3v2Parser);
      function makeUnexpectedMajorVersionError(majorVer) {
        throw new Id3v2ContentError(`Unexpected majorVer: ${majorVer}`);
      }

    })
  };
}));

System.register("./main-cGY5pIDA-DL9qX_J1.js", ['react', 'antd', 'react-dom', '@ant-design/icons'], (function (exports, module) {
  'use strict';
  var forwardRef, useState, useMemo, useEffect, require$$0, useImperativeHandle, useRef, useCallback, useLayoutEffect, Input, DatePicker, Form, Typography, Modal, Button, Table, Spin, Descriptions, Space, Image, Pagination, Select, Tabs, ConfigProvider, Avatar, Tag, Tooltip, message$1, App$1, TreeSelect, Upload, Card, Switch, TimePicker, Checkbox, Radio, require$$0$1, LinkOutlined, GithubOutlined, StarOutlined, ForkOutlined, EyeOutlined, UploadOutlined, DownloadOutlined, CloudDownloadOutlined, FileOutlined, PauseCircleOutlined, PlayCircleOutlined, UserOutlined, SaveOutlined, SelectOutlined, TrophyOutlined, ClockCircleOutlined, CopyOutlined, PictureOutlined, UnorderedListOutlined, ContainerOutlined, BookOutlined, SearchOutlined, InfoCircleOutlined;
  return {
    setters: [module => {
      forwardRef = module.forwardRef;
      useState = module.useState;
      useMemo = module.useMemo;
      useEffect = module.useEffect;
      require$$0 = module.default;
      useImperativeHandle = module.useImperativeHandle;
      useRef = module.useRef;
      useCallback = module.useCallback;
      useLayoutEffect = module.useLayoutEffect;
    }, module => {
      Input = module.Input;
      DatePicker = module.DatePicker;
      Form = module.Form;
      Typography = module.Typography;
      Modal = module.Modal;
      Button = module.Button;
      Table = module.Table;
      Spin = module.Spin;
      Descriptions = module.Descriptions;
      Space = module.Space;
      Image = module.Image;
      Pagination = module.Pagination;
      Select = module.Select;
      Tabs = module.Tabs;
      ConfigProvider = module.ConfigProvider;
      Avatar = module.Avatar;
      Tag = module.Tag;
      Tooltip = module.Tooltip;
      message$1 = module.message;
      App$1 = module.App;
      TreeSelect = module.TreeSelect;
      Upload = module.Upload;
      Card = module.Card;
      Switch = module.Switch;
      TimePicker = module.TimePicker;
      Checkbox = module.Checkbox;
      Radio = module.Radio;
    }, module => {
      require$$0$1 = module.default;
    }, module => {
      LinkOutlined = module.LinkOutlined;
      GithubOutlined = module.GithubOutlined;
      StarOutlined = module.StarOutlined;
      ForkOutlined = module.ForkOutlined;
      EyeOutlined = module.EyeOutlined;
      UploadOutlined = module.UploadOutlined;
      DownloadOutlined = module.DownloadOutlined;
      CloudDownloadOutlined = module.CloudDownloadOutlined;
      FileOutlined = module.FileOutlined;
      PauseCircleOutlined = module.PauseCircleOutlined;
      PlayCircleOutlined = module.PlayCircleOutlined;
      UserOutlined = module.UserOutlined;
      SaveOutlined = module.SaveOutlined;
      SelectOutlined = module.SelectOutlined;
      TrophyOutlined = module.TrophyOutlined;
      ClockCircleOutlined = module.ClockCircleOutlined;
      CopyOutlined = module.CopyOutlined;
      PictureOutlined = module.PictureOutlined;
      UnorderedListOutlined = module.UnorderedListOutlined;
      ContainerOutlined = module.ContainerOutlined;
      BookOutlined = module.BookOutlined;
      SearchOutlined = module.SearchOutlined;
      InfoCircleOutlined = module.InfoCircleOutlined;
    }],
    execute: (function () {

      exports({
        J: tryParseApeHeader,
        K: trimRightNull,
        R: findZero,
        a: isBitSet$1,
        g: getBitAllignedNumber,
        h: hexToUint8Array,
        j: getBit,
        l: decodeString,
        n: fromBuffer,
        s: stripNulls,
        u: uint8ArrayToHex,
        y: textDecode
      });

      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function getDefaultExportFromCjs(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
      }
      function getAugmentedNamespace(n) {
        if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
        var f = n.default;
        if (typeof f == "function") {
          var a = function a2() {
            var isInstance = false;
            try {
              isInstance = this instanceof a2;
            } catch {
            }
            if (isInstance) {
              return Reflect.construct(f, arguments, this.constructor);
            }
            return f.apply(this, arguments);
          };
          a.prototype = f.prototype;
        } else a = {};
        Object.defineProperty(a, "__esModule", { value: true });
        Object.keys(n).forEach(function(k) {
          var d = Object.getOwnPropertyDescriptor(n, k);
          Object.defineProperty(a, k, d.get ? d : {
            enumerable: true,
            get: function() {
              return n[k];
            }
          });
        });
        return a;
      }
      var jsxRuntime = { exports: {} };
      var reactJsxRuntime_production_min = {};
      /**
       * @license React
       * react-jsx-runtime.production.min.js
       *
       * Copyright (c) Facebook, Inc. and its affiliates.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */
      var hasRequiredReactJsxRuntime_production_min;
      function requireReactJsxRuntime_production_min() {
        if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
        hasRequiredReactJsxRuntime_production_min = 1;
        var f = require$$0, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
        function q(c, a, g) {
          var b, d = {}, e = null, h = null;
          void 0 !== g && (e = "" + g);
          void 0 !== a.key && (e = "" + a.key);
          void 0 !== a.ref && (h = a.ref);
          for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
          if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
          return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
        }
        reactJsxRuntime_production_min.Fragment = l;
        reactJsxRuntime_production_min.jsx = q;
        reactJsxRuntime_production_min.jsxs = q;
        return reactJsxRuntime_production_min;
      }
      var hasRequiredJsxRuntime;
      function requireJsxRuntime() {
        if (hasRequiredJsxRuntime) return jsxRuntime.exports;
        hasRequiredJsxRuntime = 1;
        {
          jsxRuntime.exports = requireReactJsxRuntime_production_min();
        }
        return jsxRuntime.exports;
      }
      var jsxRuntimeExports = requireJsxRuntime();
      var zh_CN$6 = {};
      var interopRequireDefault = { exports: {} };
      var hasRequiredInteropRequireDefault;
      function requireInteropRequireDefault() {
        if (hasRequiredInteropRequireDefault) return interopRequireDefault.exports;
        hasRequiredInteropRequireDefault = 1;
        (function(module) {
          function _interopRequireDefault(e) {
            return e && e.__esModule ? e : {
              "default": e
            };
          }
          module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(interopRequireDefault);
        return interopRequireDefault.exports;
      }
      var zh_CN$5 = {};
      var hasRequiredZh_CN$6;
      function requireZh_CN$6() {
        if (hasRequiredZh_CN$6) return zh_CN$5;
        hasRequiredZh_CN$6 = 1;
        Object.defineProperty(zh_CN$5, "__esModule", {
          value: true
        });
        zh_CN$5.default = void 0;
        var locale = {
          // Options
          items_per_page: "条/页",
          jump_to: "跳至",
          jump_to_confirm: "确定",
          page: "页",
          // Pagination
          prev_page: "上一页",
          next_page: "下一页",
          prev_5: "向前 5 页",
          next_5: "向后 5 页",
          prev_3: "向前 3 页",
          next_3: "向后 3 页",
          page_size: "页码"
        };
        zh_CN$5.default = locale;
        return zh_CN$5;
      }
      var zh_CN$4 = {};
      var zh_CN$3 = {};
      var zh_CN$2 = {};
      var objectSpread2 = { exports: {} };
      var defineProperty = { exports: {} };
      var toPropertyKey = { exports: {} };
      var _typeof = { exports: {} };
      var hasRequired_typeof;
      function require_typeof() {
        if (hasRequired_typeof) return _typeof.exports;
        hasRequired_typeof = 1;
        (function(module) {
          function _typeof2(o) {
            "@babel/helpers - typeof";
            return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
              return typeof o2;
            } : function(o2) {
              return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
            }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o);
          }
          module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(_typeof);
        return _typeof.exports;
      }
      var toPrimitive = { exports: {} };
      var hasRequiredToPrimitive;
      function requireToPrimitive() {
        if (hasRequiredToPrimitive) return toPrimitive.exports;
        hasRequiredToPrimitive = 1;
        (function(module) {
          var _typeof2 = require_typeof()["default"];
          function toPrimitive2(t, r) {
            if ("object" != _typeof2(t) || !t) return t;
            var e = t[Symbol.toPrimitive];
            if (void 0 !== e) {
              var i = e.call(t, r || "default");
              if ("object" != _typeof2(i)) return i;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === r ? String : Number)(t);
          }
          module.exports = toPrimitive2, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(toPrimitive);
        return toPrimitive.exports;
      }
      var hasRequiredToPropertyKey;
      function requireToPropertyKey() {
        if (hasRequiredToPropertyKey) return toPropertyKey.exports;
        hasRequiredToPropertyKey = 1;
        (function(module) {
          var _typeof2 = require_typeof()["default"];
          var toPrimitive2 = requireToPrimitive();
          function toPropertyKey2(t) {
            var i = toPrimitive2(t, "string");
            return "symbol" == _typeof2(i) ? i : i + "";
          }
          module.exports = toPropertyKey2, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(toPropertyKey);
        return toPropertyKey.exports;
      }
      var hasRequiredDefineProperty;
      function requireDefineProperty() {
        if (hasRequiredDefineProperty) return defineProperty.exports;
        hasRequiredDefineProperty = 1;
        (function(module) {
          var toPropertyKey2 = requireToPropertyKey();
          function _defineProperty(e, r, t) {
            return (r = toPropertyKey2(r)) in e ? Object.defineProperty(e, r, {
              value: t,
              enumerable: true,
              configurable: true,
              writable: true
            }) : e[r] = t, e;
          }
          module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(defineProperty);
        return defineProperty.exports;
      }
      var hasRequiredObjectSpread2;
      function requireObjectSpread2() {
        if (hasRequiredObjectSpread2) return objectSpread2.exports;
        hasRequiredObjectSpread2 = 1;
        (function(module) {
          var defineProperty2 = requireDefineProperty();
          function ownKeys(e, r) {
            var t = Object.keys(e);
            if (Object.getOwnPropertySymbols) {
              var o = Object.getOwnPropertySymbols(e);
              r && (o = o.filter(function(r2) {
                return Object.getOwnPropertyDescriptor(e, r2).enumerable;
              })), t.push.apply(t, o);
            }
            return t;
          }
          function _objectSpread2(e) {
            for (var r = 1; r < arguments.length; r++) {
              var t = null != arguments[r] ? arguments[r] : {};
              r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
                defineProperty2(e, r2, t[r2]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
                Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
              });
            }
            return e;
          }
          module.exports = _objectSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(objectSpread2);
        return objectSpread2.exports;
      }
      var common$1 = {};
      var hasRequiredCommon$1;
      function requireCommon$1() {
        if (hasRequiredCommon$1) return common$1;
        hasRequiredCommon$1 = 1;
        Object.defineProperty(common$1, "__esModule", {
          value: true
        });
        common$1.commonLocale = void 0;
        common$1.commonLocale = {
          yearFormat: "YYYY",
          dayFormat: "D",
          cellMeridiemFormat: "A",
          monthBeforeYear: true
        };
        return common$1;
      }
      var hasRequiredZh_CN$5;
      function requireZh_CN$5() {
        if (hasRequiredZh_CN$5) return zh_CN$2;
        hasRequiredZh_CN$5 = 1;
        var _interopRequireDefault = requireInteropRequireDefault().default;
        Object.defineProperty(zh_CN$2, "__esModule", {
          value: true
        });
        zh_CN$2.default = void 0;
        var _objectSpread2 = _interopRequireDefault(requireObjectSpread2());
        var _common = requireCommon$1();
        var locale = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, _common.commonLocale), {}, {
          locale: "zh_CN",
          today: "今天",
          now: "此刻",
          backToToday: "返回今天",
          ok: "确定",
          timeSelect: "选择时间",
          dateSelect: "选择日期",
          weekSelect: "选择周",
          clear: "清除",
          week: "周",
          month: "月",
          year: "年",
          previousMonth: "上个月 (翻页上键)",
          nextMonth: "下个月 (翻页下键)",
          monthSelect: "选择月份",
          yearSelect: "选择年份",
          decadeSelect: "选择年代",
          previousYear: "上一年 (Control键加左方向键)",
          nextYear: "下一年 (Control键加右方向键)",
          previousDecade: "上一年代",
          nextDecade: "下一年代",
          previousCentury: "上一世纪",
          nextCentury: "下一世纪",
          yearFormat: "YYYY年",
          cellDateFormat: "D",
          monthBeforeYear: false
        });
        zh_CN$2.default = locale;
        return zh_CN$2;
      }
      var zh_CN$1 = {};
      var hasRequiredZh_CN$4;
      function requireZh_CN$4() {
        if (hasRequiredZh_CN$4) return zh_CN$1;
        hasRequiredZh_CN$4 = 1;
        Object.defineProperty(zh_CN$1, "__esModule", {
          value: true
        });
        zh_CN$1.default = void 0;
        const locale = {
          placeholder: "请选择时间",
          rangePlaceholder: ["开始时间", "结束时间"]
        };
        zh_CN$1.default = locale;
        return zh_CN$1;
      }
      var hasRequiredZh_CN$3;
      function requireZh_CN$3() {
        if (hasRequiredZh_CN$3) return zh_CN$3;
        hasRequiredZh_CN$3 = 1;
        var _interopRequireDefault = requireInteropRequireDefault().default;
        Object.defineProperty(zh_CN$3, "__esModule", {
          value: true
        });
        zh_CN$3.default = void 0;
        var _zh_CN = _interopRequireDefault(requireZh_CN$5());
        var _zh_CN2 = _interopRequireDefault(/* @__PURE__ */ requireZh_CN$4());
        const locale = {
          lang: Object.assign({
            placeholder: "请选择日期",
            yearPlaceholder: "请选择年份",
            quarterPlaceholder: "请选择季度",
            monthPlaceholder: "请选择月份",
            weekPlaceholder: "请选择周",
            rangePlaceholder: ["开始日期", "结束日期"],
            rangeYearPlaceholder: ["开始年份", "结束年份"],
            rangeMonthPlaceholder: ["开始月份", "结束月份"],
            rangeQuarterPlaceholder: ["开始季度", "结束季度"],
            rangeWeekPlaceholder: ["开始周", "结束周"]
          }, _zh_CN.default),
          timePickerLocale: Object.assign({}, _zh_CN2.default)
        };
        locale.lang.ok = "确定";
        zh_CN$3.default = locale;
        return zh_CN$3;
      }
      var hasRequiredZh_CN$2;
      function requireZh_CN$2() {
        if (hasRequiredZh_CN$2) return zh_CN$4;
        hasRequiredZh_CN$2 = 1;
        var _interopRequireDefault = requireInteropRequireDefault().default;
        Object.defineProperty(zh_CN$4, "__esModule", {
          value: true
        });
        zh_CN$4.default = void 0;
        var _zh_CN = _interopRequireDefault(/* @__PURE__ */ requireZh_CN$3());
        zh_CN$4.default = _zh_CN.default;
        return zh_CN$4;
      }
      var hasRequiredZh_CN$1;
      function requireZh_CN$1() {
        if (hasRequiredZh_CN$1) return zh_CN$6;
        hasRequiredZh_CN$1 = 1;
        var _interopRequireDefault = requireInteropRequireDefault().default;
        Object.defineProperty(zh_CN$6, "__esModule", {
          value: true
        });
        zh_CN$6.default = void 0;
        var _zh_CN = _interopRequireDefault(requireZh_CN$6());
        var _zh_CN2 = _interopRequireDefault(/* @__PURE__ */ requireZh_CN$2());
        var _zh_CN3 = _interopRequireDefault(/* @__PURE__ */ requireZh_CN$3());
        var _zh_CN4 = _interopRequireDefault(/* @__PURE__ */ requireZh_CN$4());
        const typeTemplate = "${label}不是一个有效的${type}";
        const localeValues = {
          locale: "zh-cn",
          Pagination: _zh_CN.default,
          DatePicker: _zh_CN3.default,
          TimePicker: _zh_CN4.default,
          Calendar: _zh_CN2.default,
          // locales for all components
          global: {
            placeholder: "请选择",
            close: "关闭"
          },
          Table: {
            filterTitle: "筛选",
            filterConfirm: "确定",
            filterReset: "重置",
            filterEmptyText: "无筛选项",
            filterCheckAll: "全选",
            filterSearchPlaceholder: "在筛选项中搜索",
            emptyText: "暂无数据",
            selectAll: "全选当页",
            selectInvert: "反选当页",
            selectNone: "清空所有",
            selectionAll: "全选所有",
            sortTitle: "排序",
            expand: "展开行",
            collapse: "关闭行",
            triggerDesc: "点击降序",
            triggerAsc: "点击升序",
            cancelSort: "取消排序"
          },
          Modal: {
            okText: "确定",
            cancelText: "取消",
            justOkText: "知道了"
          },
          Tour: {
            Next: "下一步",
            Previous: "上一步",
            Finish: "结束导览"
          },
          Popconfirm: {
            cancelText: "取消",
            okText: "确定"
          },
          Transfer: {
            titles: ["", ""],
            searchPlaceholder: "请输入搜索内容",
            itemUnit: "项",
            itemsUnit: "项",
            remove: "删除",
            selectCurrent: "全选当页",
            removeCurrent: "删除当页",
            selectAll: "全选所有",
            deselectAll: "取消全选",
            removeAll: "删除全部",
            selectInvert: "反选当页"
          },
          Upload: {
            uploading: "文件上传中",
            removeFile: "删除文件",
            uploadError: "上传错误",
            previewFile: "预览文件",
            downloadFile: "下载文件"
          },
          Empty: {
            description: "暂无数据"
          },
          Icon: {
            icon: "图标"
          },
          Text: {
            edit: "编辑",
            copy: "复制",
            copied: "复制成功",
            expand: "展开",
            collapse: "收起"
          },
          Form: {
            optional: "（可选）",
            defaultValidateMessages: {
              default: "字段验证错误${label}",
              required: "请输入${label}",
              enum: "${label}必须是其中一个[${enum}]",
              whitespace: "${label}不能为空字符",
              date: {
                format: "${label}日期格式无效",
                parse: "${label}不能转换为日期",
                invalid: "${label}是一个无效日期"
              },
              types: {
                string: typeTemplate,
                method: typeTemplate,
                array: typeTemplate,
                object: typeTemplate,
                number: typeTemplate,
                date: typeTemplate,
                boolean: typeTemplate,
                integer: typeTemplate,
                float: typeTemplate,
                regexp: typeTemplate,
                email: typeTemplate,
                url: typeTemplate,
                hex: typeTemplate
              },
              string: {
                len: "${label}须为${len}个字符",
                min: "${label}最少${min}个字符",
                max: "${label}最多${max}个字符",
                range: "${label}须在${min}-${max}字符之间"
              },
              number: {
                len: "${label}必须等于${len}",
                min: "${label}最小值为${min}",
                max: "${label}最大值为${max}",
                range: "${label}须在${min}-${max}之间"
              },
              array: {
                len: "须为${len}个${label}",
                min: "最少${min}个${label}",
                max: "最多${max}个${label}",
                range: "${label}数量须在${min}-${max}之间"
              },
              pattern: {
                mismatch: "${label}与模式不匹配${pattern}"
              }
            }
          },
          Image: {
            preview: "预览"
          },
          QRCode: {
            expired: "二维码过期",
            refresh: "点击刷新",
            scanned: "已扫描"
          },
          ColorPicker: {
            presetEmpty: "暂无",
            transparent: "无色",
            singleColor: "单色",
            gradientColor: "渐变色"
          }
        };
        zh_CN$6.default = localeValues;
        return zh_CN$6;
      }
      var zh_CN;
      var hasRequiredZh_CN;
      function requireZh_CN() {
        if (hasRequiredZh_CN) return zh_CN;
        hasRequiredZh_CN = 1;
        zh_CN = /* @__PURE__ */ requireZh_CN$1();
        return zh_CN;
      }
      var zh_CNExports = /* @__PURE__ */ requireZh_CN();
      const zhCN = /* @__PURE__ */ getDefaultExportFromCjs(zh_CNExports);
      var client = {};
      var hasRequiredClient;
      function requireClient() {
        if (hasRequiredClient) return client;
        hasRequiredClient = 1;
        var m = require$$0$1;
        {
          client.createRoot = m.createRoot;
          client.hydrateRoot = m.hydrateRoot;
        }
        return client;
      }
      var clientExports = requireClient();
      const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(clientExports);
      const useCompRef = (_component) => {
        const initObj = {};
        const proxy = new Proxy(initObj, {
          get: (target, prop) => {
            console.log("target", target);
            console.log("prop", prop);
            if (target === initObj) {
              console.warn("是否忘记了传递组件Ref?");
            }
            return null;
          }
        });
        return useRef(proxy);
      };
      const isDev = false;
      const defaultFunctionConfig = {
        /**
         * 是否开启搜索
         */
        enableSearch: isDev,
        /**
         * 是否开启GitHub信息
         */
        enableGithubInfo: true,
        /**
         * 是否开启功能开关Tab
         */
        enableFunctionSwitchTab: true,
        /**
         * 是否开启下载设置Tab
         */
        enableDownloadSetting: true,
        /**
         * 并发上传歌曲数量
         */
        uploadConcurrency: 6,
        /**
         * 是否开启测试Modal
         */
        enableTestModal: isDev,
        /**
         * 演唱会关键词
         */
        liveKeywords: ["演唱会", "Live", "live"]
      };
      const defaultDownloadConfig = {
        /** 下载音质 */
        quality: "flac",
        /** 是否下载歌词 */
        downloadLyric: true,
        /** 是否内嵌歌词封面 */
        embedLyricCover: true,
        /** 是否内嵌歌曲信息 */
        embedSongInfo: true
      };
      var createUpdateEffect = function(hook) {
        return function(effect, deps) {
          var isMounted = useRef(false);
          hook(function() {
            return function() {
              isMounted.current = false;
            };
          }, []);
          hook(function() {
            if (!isMounted.current) {
              isMounted.current = true;
            } else {
              return effect();
            }
          }, deps);
        };
      };
      function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"])) m.call(i);
          } finally {
            if (e) throw e.error;
          }
        }
        return ar;
      }
      typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
        var e = new Error(message2);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
      };
      var isFunction = function(value) {
        return typeof value === "function";
      };
      var isUndef = function(value) {
        return typeof value === "undefined";
      };
      var useMemoizedFn = function(fn) {
        var fnRef = useRef(fn);
        fnRef.current = useMemo(function() {
          return fn;
        }, [fn]);
        var memoizedFn = useRef(void 0);
        if (!memoizedFn.current) {
          memoizedFn.current = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return fnRef.current.apply(this, args);
          };
        }
        return memoizedFn.current;
      };
      const useUpdateEffect = createUpdateEffect(useEffect);
      function depsAreSame(oldDeps, deps) {
        if (oldDeps === deps) {
          return true;
        }
        for (var i = 0; i < oldDeps.length; i++) {
          if (!Object.is(oldDeps[i], deps[i])) {
            return false;
          }
        }
        return true;
      }
      function useLatest(value) {
        var ref = useRef(value);
        ref.current = value;
        return ref;
      }
      var useUnmount = function(fn) {
        var fnRef = useLatest(fn);
        useEffect(function() {
          return function() {
            fnRef.current();
          };
        }, []);
      };
      var isBrowser$1 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
      function getTargetElement(target, defaultElement) {
        if (!isBrowser$1) {
          return void 0;
        }
        if (!target) {
          return defaultElement;
        }
        var targetElement;
        if (isFunction(target)) {
          targetElement = target();
        } else if ("current" in target) {
          targetElement = target.current;
        } else {
          targetElement = target;
        }
        return targetElement;
      }
      var createEffectWithTarget = function(useEffectType) {
        var useEffectWithTarget2 = function(effect, deps, target) {
          var hasInitRef = useRef(false);
          var lastElementRef = useRef([]);
          var lastDepsRef = useRef([]);
          var unLoadRef = useRef(void 0);
          useEffectType(function() {
            var _a2;
            var targets = Array.isArray(target) ? target : [target];
            var els = targets.map(function(item) {
              return getTargetElement(item);
            });
            if (!hasInitRef.current) {
              hasInitRef.current = true;
              lastElementRef.current = els;
              lastDepsRef.current = deps;
              unLoadRef.current = effect();
              return;
            }
            if (els.length !== lastElementRef.current.length || !depsAreSame(lastElementRef.current, els) || !depsAreSame(lastDepsRef.current, deps)) {
              (_a2 = unLoadRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unLoadRef);
              lastElementRef.current = els;
              lastDepsRef.current = deps;
              unLoadRef.current = effect();
            }
          });
          useUnmount(function() {
            var _a2;
            (_a2 = unLoadRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unLoadRef);
            hasInitRef.current = false;
          });
        };
        return useEffectWithTarget2;
      };
      var useEffectWithTarget$1 = createEffectWithTarget(useEffect);
      var dayjs_min$1 = { exports: {} };
      var dayjs_min = dayjs_min$1.exports;
      var hasRequiredDayjs_min;
      function requireDayjs_min() {
        if (hasRequiredDayjs_min) return dayjs_min$1.exports;
        hasRequiredDayjs_min = 1;
        (function(module, exports) {
          !(function(t, e) {
            module.exports = e();
          })(dayjs_min, (function() {
            var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
              var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
              return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
            } }, m = function(t2, e2, n2) {
              var r2 = String(t2);
              return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
            }, v = { s: m, z: function(t2) {
              var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
              return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
            }, m: function t2(e2, n2) {
              if (e2.date() < n2.date()) return -t2(n2, e2);
              var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
              return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
            }, a: function(t2) {
              return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
            }, p: function(t2) {
              return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
            }, u: function(t2) {
              return void 0 === t2;
            } }, g = "en", D = {};
            D[g] = M;
            var p = "$isDayjsObject", S = function(t2) {
              return t2 instanceof _ || !(!t2 || !t2[p]);
            }, w = function t2(e2, n2, r2) {
              var i2;
              if (!e2) return g;
              if ("string" == typeof e2) {
                var s2 = e2.toLowerCase();
                D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
                var u2 = e2.split("-");
                if (!i2 && u2.length > 1) return t2(u2[0]);
              } else {
                var a2 = e2.name;
                D[a2] = e2, i2 = a2;
              }
              return !r2 && i2 && (g = i2), i2 || !r2 && g;
            }, O = function(t2, e2) {
              if (S(t2)) return t2.clone();
              var n2 = "object" == typeof e2 ? e2 : {};
              return n2.date = t2, n2.args = arguments, new _(n2);
            }, b = v;
            b.l = w, b.i = S, b.w = function(t2, e2) {
              return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
            };
            var _ = (function() {
              function M2(t2) {
                this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
              }
              var m2 = M2.prototype;
              return m2.parse = function(t2) {
                this.$d = (function(t3) {
                  var e2 = t3.date, n2 = t3.utc;
                  if (null === e2) return /* @__PURE__ */ new Date(NaN);
                  if (b.u(e2)) return /* @__PURE__ */ new Date();
                  if (e2 instanceof Date) return new Date(e2);
                  if ("string" == typeof e2 && !/Z$/i.test(e2)) {
                    var r2 = e2.match($);
                    if (r2) {
                      var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                      return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
                    }
                  }
                  return new Date(e2);
                })(t2), this.init();
              }, m2.init = function() {
                var t2 = this.$d;
                this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
              }, m2.$utils = function() {
                return b;
              }, m2.isValid = function() {
                return !(this.$d.toString() === l);
              }, m2.isSame = function(t2, e2) {
                var n2 = O(t2);
                return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
              }, m2.isAfter = function(t2, e2) {
                return O(t2) < this.startOf(e2);
              }, m2.isBefore = function(t2, e2) {
                return this.endOf(e2) < O(t2);
              }, m2.$g = function(t2, e2, n2) {
                return b.u(t2) ? this[e2] : this.set(n2, t2);
              }, m2.unix = function() {
                return Math.floor(this.valueOf() / 1e3);
              }, m2.valueOf = function() {
                return this.$d.getTime();
              }, m2.startOf = function(t2, e2) {
                var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
                  var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
                  return r2 ? i2 : i2.endOf(a);
                }, $2 = function(t3, e3) {
                  return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
                }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
                switch (f2) {
                  case h:
                    return r2 ? l2(1, 0) : l2(31, 11);
                  case c:
                    return r2 ? l2(1, M3) : l2(0, M3 + 1);
                  case o:
                    var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
                    return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
                  case a:
                  case d:
                    return $2(v2 + "Hours", 0);
                  case u:
                    return $2(v2 + "Minutes", 1);
                  case s:
                    return $2(v2 + "Seconds", 2);
                  case i:
                    return $2(v2 + "Milliseconds", 3);
                  default:
                    return this.clone();
                }
              }, m2.endOf = function(t2) {
                return this.startOf(t2, false);
              }, m2.$set = function(t2, e2) {
                var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
                if (o2 === c || o2 === h) {
                  var y2 = this.clone().set(d, 1);
                  y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
                } else l2 && this.$d[l2]($2);
                return this.init(), this;
              }, m2.set = function(t2, e2) {
                return this.clone().$set(t2, e2);
              }, m2.get = function(t2) {
                return this[b.p(t2)]();
              }, m2.add = function(r2, f2) {
                var d2, l2 = this;
                r2 = Number(r2);
                var $2 = b.p(f2), y2 = function(t2) {
                  var e2 = O(l2);
                  return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
                };
                if ($2 === c) return this.set(c, this.$M + r2);
                if ($2 === h) return this.set(h, this.$y + r2);
                if ($2 === a) return y2(1);
                if ($2 === o) return y2(7);
                var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
                return b.w(m3, this);
              }, m2.subtract = function(t2, e2) {
                return this.add(-1 * t2, e2);
              }, m2.format = function(t2) {
                var e2 = this, n2 = this.$locale();
                if (!this.isValid()) return n2.invalidDate || l;
                var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
                  return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
                }, d2 = function(t3) {
                  return b.s(s2 % 12 || 12, t3, "0");
                }, $2 = f2 || function(t3, e3, n3) {
                  var r3 = t3 < 12 ? "AM" : "PM";
                  return n3 ? r3.toLowerCase() : r3;
                };
                return r2.replace(y, (function(t3, r3) {
                  return r3 || (function(t4) {
                    switch (t4) {
                      case "YY":
                        return String(e2.$y).slice(-2);
                      case "YYYY":
                        return b.s(e2.$y, 4, "0");
                      case "M":
                        return a2 + 1;
                      case "MM":
                        return b.s(a2 + 1, 2, "0");
                      case "MMM":
                        return h2(n2.monthsShort, a2, c2, 3);
                      case "MMMM":
                        return h2(c2, a2);
                      case "D":
                        return e2.$D;
                      case "DD":
                        return b.s(e2.$D, 2, "0");
                      case "d":
                        return String(e2.$W);
                      case "dd":
                        return h2(n2.weekdaysMin, e2.$W, o2, 2);
                      case "ddd":
                        return h2(n2.weekdaysShort, e2.$W, o2, 3);
                      case "dddd":
                        return o2[e2.$W];
                      case "H":
                        return String(s2);
                      case "HH":
                        return b.s(s2, 2, "0");
                      case "h":
                        return d2(1);
                      case "hh":
                        return d2(2);
                      case "a":
                        return $2(s2, u2, true);
                      case "A":
                        return $2(s2, u2, false);
                      case "m":
                        return String(u2);
                      case "mm":
                        return b.s(u2, 2, "0");
                      case "s":
                        return String(e2.$s);
                      case "ss":
                        return b.s(e2.$s, 2, "0");
                      case "SSS":
                        return b.s(e2.$ms, 3, "0");
                      case "Z":
                        return i2;
                    }
                    return null;
                  })(t3) || i2.replace(":", "");
                }));
              }, m2.utcOffset = function() {
                return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
              }, m2.diff = function(r2, d2, l2) {
                var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
                  return b.m(y2, m3);
                };
                switch (M3) {
                  case h:
                    $2 = D2() / 12;
                    break;
                  case c:
                    $2 = D2();
                    break;
                  case f:
                    $2 = D2() / 3;
                    break;
                  case o:
                    $2 = (g2 - v2) / 6048e5;
                    break;
                  case a:
                    $2 = (g2 - v2) / 864e5;
                    break;
                  case u:
                    $2 = g2 / n;
                    break;
                  case s:
                    $2 = g2 / e;
                    break;
                  case i:
                    $2 = g2 / t;
                    break;
                  default:
                    $2 = g2;
                }
                return l2 ? $2 : b.a($2);
              }, m2.daysInMonth = function() {
                return this.endOf(c).$D;
              }, m2.$locale = function() {
                return D[this.$L];
              }, m2.locale = function(t2, e2) {
                if (!t2) return this.$L;
                var n2 = this.clone(), r2 = w(t2, e2, true);
                return r2 && (n2.$L = r2), n2;
              }, m2.clone = function() {
                return b.w(this.$d, this);
              }, m2.toDate = function() {
                return new Date(this.valueOf());
              }, m2.toJSON = function() {
                return this.isValid() ? this.toISOString() : null;
              }, m2.toISOString = function() {
                return this.$d.toISOString();
              }, m2.toString = function() {
                return this.$d.toUTCString();
              }, M2;
            })(), k = _.prototype;
            return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach((function(t2) {
              k[t2[1]] = function(e2) {
                return this.$g(e2, t2[0], t2[1]);
              };
            })), O.extend = function(t2, e2) {
              return t2.$i || (t2(e2, _, O), t2.$i = true), O;
            }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
              return O(1e3 * t2);
            }, O.en = D[g], O.Ls = D, O.p = {}, O;
          }));
        })(dayjs_min$1);
        return dayjs_min$1.exports;
      }
      var dayjs_minExports = requireDayjs_min();
      const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
      function useEventListener(eventName, handler, options) {
        if (options === void 0) {
          options = {};
        }
        var _a2 = options.enable, enable = _a2 === void 0 ? true : _a2;
        var handlerRef = useLatest(handler);
        useEffectWithTarget$1(function() {
          if (!enable) {
            return;
          }
          var targetElement = getTargetElement(options.target, window);
          if (!(targetElement === null || targetElement === void 0 ? void 0 : targetElement.addEventListener)) {
            return;
          }
          var eventListener = function(event) {
            return handlerRef.current(event);
          };
          var eventNameArray = Array.isArray(eventName) ? eventName : [eventName];
          eventNameArray.forEach(function(event) {
            targetElement.addEventListener(event, eventListener, {
              capture: options.capture,
              once: options.once,
              passive: options.passive
            });
          });
          return function() {
            eventNameArray.forEach(function(event) {
              targetElement.removeEventListener(event, eventListener, {
                capture: options.capture
              });
            });
          };
        }, [eventName, options.capture, options.once, options.passive, enable], options.target);
      }
      var SYNC_STORAGE_EVENT_NAME = "AHOOKS_SYNC_STORAGE_EVENT_NAME";
      function createUseStorageState(getStorage) {
        function useStorageState(key, options) {
          if (options === void 0) {
            options = {};
          }
          var storage;
          var _a2 = options.listenStorageChange, listenStorageChange = _a2 === void 0 ? false : _a2, _b2 = options.onError, onError = _b2 === void 0 ? function(e) {
            console.error(e);
          } : _b2;
          try {
            storage = getStorage();
          } catch (err2) {
            onError(err2);
          }
          var serializer = function(value) {
            if (options.serializer) {
              return options.serializer(value);
            }
            return JSON.stringify(value);
          };
          var deserializer = function(value) {
            if (options.deserializer) {
              return options.deserializer(value);
            }
            return JSON.parse(value);
          };
          function getStoredValue() {
            try {
              var raw = storage === null || storage === void 0 ? void 0 : storage.getItem(key);
              if (raw) {
                return deserializer(raw);
              }
            } catch (e) {
              onError(e);
            }
            if (isFunction(options.defaultValue)) {
              return options.defaultValue();
            }
            return options.defaultValue;
          }
          var _c = __read(useState(getStoredValue), 2), state = _c[0], setState = _c[1];
          useUpdateEffect(function() {
            setState(getStoredValue());
          }, [key]);
          var updateState = function(value) {
            var currentState = isFunction(value) ? value(state) : value;
            if (!listenStorageChange) {
              setState(currentState);
            }
            try {
              var newValue = void 0;
              var oldValue = storage === null || storage === void 0 ? void 0 : storage.getItem(key);
              if (isUndef(currentState)) {
                newValue = null;
                storage === null || storage === void 0 ? void 0 : storage.removeItem(key);
              } else {
                newValue = serializer(currentState);
                storage === null || storage === void 0 ? void 0 : storage.setItem(key, newValue);
              }
              dispatchEvent(
                // send custom event to communicate within same page
                // importantly this should not be a StorageEvent since those cannot
                // be constructed with a non-built-in storage area
                new CustomEvent(SYNC_STORAGE_EVENT_NAME, {
                  detail: {
                    key,
                    newValue,
                    oldValue,
                    storageArea: storage
                  }
                })
              );
            } catch (e) {
              onError(e);
            }
          };
          var syncState = function(event) {
            if (event.key !== key || event.storageArea !== storage) {
              return;
            }
            setState(getStoredValue());
          };
          var syncStateFromCustomEvent = function(event) {
            syncState(event.detail);
          };
          useEventListener("storage", syncState, {
            enable: listenStorageChange
          });
          useEventListener(SYNC_STORAGE_EVENT_NAME, syncStateFromCustomEvent, {
            enable: listenStorageChange
          });
          return [state, useMemoizedFn(updateState)];
        }
        return useStorageState;
      }
      var useLocalStorageState = createUseStorageState(function() {
        return isBrowser$1 ? localStorage : void 0;
      });
      function useRafState(initialState) {
        var ref = useRef(0);
        var _a2 = __read(useState(initialState), 2), state = _a2[0], setState = _a2[1];
        var setRafState = useCallback(function(value) {
          cancelAnimationFrame(ref.current);
          ref.current = requestAnimationFrame(function() {
            setState(value);
          });
        }, []);
        useUnmount(function() {
          cancelAnimationFrame(ref.current);
        });
        return [state, setRafState];
      }
      var MapShim = (function() {
        if (typeof Map !== "undefined") {
          return Map;
        }
        function getIndex(arr, key) {
          var result = -1;
          arr.some(function(entry, index2) {
            if (entry[0] === key) {
              result = index2;
              return true;
            }
            return false;
          });
          return result;
        }
        return (
          /** @class */
          (function() {
            function class_1() {
              this.__entries__ = [];
            }
            Object.defineProperty(class_1.prototype, "size", {
              /**
               * @returns {boolean}
               */
              get: function() {
                return this.__entries__.length;
              },
              enumerable: true,
              configurable: true
            });
            class_1.prototype.get = function(key) {
              var index2 = getIndex(this.__entries__, key);
              var entry = this.__entries__[index2];
              return entry && entry[1];
            };
            class_1.prototype.set = function(key, value) {
              var index2 = getIndex(this.__entries__, key);
              if (~index2) {
                this.__entries__[index2][1] = value;
              } else {
                this.__entries__.push([key, value]);
              }
            };
            class_1.prototype.delete = function(key) {
              var entries = this.__entries__;
              var index2 = getIndex(entries, key);
              if (~index2) {
                entries.splice(index2, 1);
              }
            };
            class_1.prototype.has = function(key) {
              return !!~getIndex(this.__entries__, key);
            };
            class_1.prototype.clear = function() {
              this.__entries__.splice(0);
            };
            class_1.prototype.forEach = function(callback, ctx) {
              if (ctx === void 0) {
                ctx = null;
              }
              for (var _i = 0, _a2 = this.__entries__; _i < _a2.length; _i++) {
                var entry = _a2[_i];
                callback.call(ctx, entry[1], entry[0]);
              }
            };
            return class_1;
          })()
        );
      })();
      var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
      var global$1 = (function() {
        if (typeof global !== "undefined" && global.Math === Math) {
          return global;
        }
        if (typeof self !== "undefined" && self.Math === Math) {
          return self;
        }
        if (typeof window !== "undefined" && window.Math === Math) {
          return window;
        }
        return Function("return this")();
      })();
      var requestAnimationFrame$1 = (function() {
        if (typeof requestAnimationFrame === "function") {
          return requestAnimationFrame.bind(global$1);
        }
        return function(callback) {
          return setTimeout(function() {
            return callback(Date.now());
          }, 1e3 / 60);
        };
      })();
      var trailingTimeout = 2;
      function throttle(callback, delay) {
        var leadingCall = false, trailingCall = false, lastCallTime = 0;
        function resolvePending() {
          if (leadingCall) {
            leadingCall = false;
            callback();
          }
          if (trailingCall) {
            proxy();
          }
        }
        function timeoutCallback() {
          requestAnimationFrame$1(resolvePending);
        }
        function proxy() {
          var timeStamp = Date.now();
          if (leadingCall) {
            if (timeStamp - lastCallTime < trailingTimeout) {
              return;
            }
            trailingCall = true;
          } else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
          }
          lastCallTime = timeStamp;
        }
        return proxy;
      }
      var REFRESH_DELAY = 20;
      var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
      var mutationObserverSupported = typeof MutationObserver !== "undefined";
      var ResizeObserverController = (
        /** @class */
        (function() {
          function ResizeObserverController2() {
            this.connected_ = false;
            this.mutationEventsAdded_ = false;
            this.mutationsObserver_ = null;
            this.observers_ = [];
            this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
            this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
          }
          ResizeObserverController2.prototype.addObserver = function(observer) {
            if (!~this.observers_.indexOf(observer)) {
              this.observers_.push(observer);
            }
            if (!this.connected_) {
              this.connect_();
            }
          };
          ResizeObserverController2.prototype.removeObserver = function(observer) {
            var observers2 = this.observers_;
            var index2 = observers2.indexOf(observer);
            if (~index2) {
              observers2.splice(index2, 1);
            }
            if (!observers2.length && this.connected_) {
              this.disconnect_();
            }
          };
          ResizeObserverController2.prototype.refresh = function() {
            var changesDetected = this.updateObservers_();
            if (changesDetected) {
              this.refresh();
            }
          };
          ResizeObserverController2.prototype.updateObservers_ = function() {
            var activeObservers = this.observers_.filter(function(observer) {
              return observer.gatherActive(), observer.hasActive();
            });
            activeObservers.forEach(function(observer) {
              return observer.broadcastActive();
            });
            return activeObservers.length > 0;
          };
          ResizeObserverController2.prototype.connect_ = function() {
            if (!isBrowser || this.connected_) {
              return;
            }
            document.addEventListener("transitionend", this.onTransitionEnd_);
            window.addEventListener("resize", this.refresh);
            if (mutationObserverSupported) {
              this.mutationsObserver_ = new MutationObserver(this.refresh);
              this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
              });
            } else {
              document.addEventListener("DOMSubtreeModified", this.refresh);
              this.mutationEventsAdded_ = true;
            }
            this.connected_ = true;
          };
          ResizeObserverController2.prototype.disconnect_ = function() {
            if (!isBrowser || !this.connected_) {
              return;
            }
            document.removeEventListener("transitionend", this.onTransitionEnd_);
            window.removeEventListener("resize", this.refresh);
            if (this.mutationsObserver_) {
              this.mutationsObserver_.disconnect();
            }
            if (this.mutationEventsAdded_) {
              document.removeEventListener("DOMSubtreeModified", this.refresh);
            }
            this.mutationsObserver_ = null;
            this.mutationEventsAdded_ = false;
            this.connected_ = false;
          };
          ResizeObserverController2.prototype.onTransitionEnd_ = function(_a2) {
            var _b2 = _a2.propertyName, propertyName = _b2 === void 0 ? "" : _b2;
            var isReflowProperty = transitionKeys.some(function(key) {
              return !!~propertyName.indexOf(key);
            });
            if (isReflowProperty) {
              this.refresh();
            }
          };
          ResizeObserverController2.getInstance = function() {
            if (!this.instance_) {
              this.instance_ = new ResizeObserverController2();
            }
            return this.instance_;
          };
          ResizeObserverController2.instance_ = null;
          return ResizeObserverController2;
        })()
      );
      var defineConfigurable = (function(target, props) {
        for (var _i = 0, _a2 = Object.keys(props); _i < _a2.length; _i++) {
          var key = _a2[_i];
          Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
          });
        }
        return target;
      });
      var getWindowOf = (function(target) {
        var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
        return ownerGlobal || global$1;
      });
      var emptyRect = createRectInit(0, 0, 0, 0);
      function toFloat(value) {
        return parseFloat(value) || 0;
      }
      function getBordersSize(styles2) {
        var positions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          positions[_i - 1] = arguments[_i];
        }
        return positions.reduce(function(size, position) {
          var value = styles2["border-" + position + "-width"];
          return size + toFloat(value);
        }, 0);
      }
      function getPaddings(styles2) {
        var positions = ["top", "right", "bottom", "left"];
        var paddings = {};
        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
          var position = positions_1[_i];
          var value = styles2["padding-" + position];
          paddings[position] = toFloat(value);
        }
        return paddings;
      }
      function getSVGContentRect(target) {
        var bbox = target.getBBox();
        return createRectInit(0, 0, bbox.width, bbox.height);
      }
      function getHTMLElementContentRect(target) {
        var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
        if (!clientWidth && !clientHeight) {
          return emptyRect;
        }
        var styles2 = getWindowOf(target).getComputedStyle(target);
        var paddings = getPaddings(styles2);
        var horizPad = paddings.left + paddings.right;
        var vertPad = paddings.top + paddings.bottom;
        var width = toFloat(styles2.width), height = toFloat(styles2.height);
        if (styles2.boxSizing === "border-box") {
          if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles2, "left", "right") + horizPad;
          }
          if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles2, "top", "bottom") + vertPad;
          }
        }
        if (!isDocumentElement(target)) {
          var vertScrollbar = Math.round(width + horizPad) - clientWidth;
          var horizScrollbar = Math.round(height + vertPad) - clientHeight;
          if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
          }
          if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
          }
        }
        return createRectInit(paddings.left, paddings.top, width, height);
      }
      var isSVGGraphicsElement = (function() {
        if (typeof SVGGraphicsElement !== "undefined") {
          return function(target) {
            return target instanceof getWindowOf(target).SVGGraphicsElement;
          };
        }
        return function(target) {
          return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
        };
      })();
      function isDocumentElement(target) {
        return target === getWindowOf(target).document.documentElement;
      }
      function getContentRect(target) {
        if (!isBrowser) {
          return emptyRect;
        }
        if (isSVGGraphicsElement(target)) {
          return getSVGContentRect(target);
        }
        return getHTMLElementContentRect(target);
      }
      function createReadOnlyRect(_a2) {
        var x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
        var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
        var rect = Object.create(Constr.prototype);
        defineConfigurable(rect, {
          x,
          y,
          width,
          height,
          top: y,
          right: x + width,
          bottom: height + y,
          left: x
        });
        return rect;
      }
      function createRectInit(x, y, width, height) {
        return { x, y, width, height };
      }
      var ResizeObservation = (
        /** @class */
        (function() {
          function ResizeObservation2(target) {
            this.broadcastWidth = 0;
            this.broadcastHeight = 0;
            this.contentRect_ = createRectInit(0, 0, 0, 0);
            this.target = target;
          }
          ResizeObservation2.prototype.isActive = function() {
            var rect = getContentRect(this.target);
            this.contentRect_ = rect;
            return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
          };
          ResizeObservation2.prototype.broadcastRect = function() {
            var rect = this.contentRect_;
            this.broadcastWidth = rect.width;
            this.broadcastHeight = rect.height;
            return rect;
          };
          return ResizeObservation2;
        })()
      );
      var ResizeObserverEntry = (
        /** @class */
        /* @__PURE__ */ (function() {
          function ResizeObserverEntry2(target, rectInit) {
            var contentRect = createReadOnlyRect(rectInit);
            defineConfigurable(this, { target, contentRect });
          }
          return ResizeObserverEntry2;
        })()
      );
      var ResizeObserverSPI = (
        /** @class */
        (function() {
          function ResizeObserverSPI2(callback, controller, callbackCtx) {
            this.activeObservations_ = [];
            this.observations_ = new MapShim();
            if (typeof callback !== "function") {
              throw new TypeError("The callback provided as parameter 1 is not a function.");
            }
            this.callback_ = callback;
            this.controller_ = controller;
            this.callbackCtx_ = callbackCtx;
          }
          ResizeObserverSPI2.prototype.observe = function(target) {
            if (!arguments.length) {
              throw new TypeError("1 argument required, but only 0 present.");
            }
            if (typeof Element === "undefined" || !(Element instanceof Object)) {
              return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            if (observations.has(target)) {
              return;
            }
            observations.set(target, new ResizeObservation(target));
            this.controller_.addObserver(this);
            this.controller_.refresh();
          };
          ResizeObserverSPI2.prototype.unobserve = function(target) {
            if (!arguments.length) {
              throw new TypeError("1 argument required, but only 0 present.");
            }
            if (typeof Element === "undefined" || !(Element instanceof Object)) {
              return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            if (!observations.has(target)) {
              return;
            }
            observations.delete(target);
            if (!observations.size) {
              this.controller_.removeObserver(this);
            }
          };
          ResizeObserverSPI2.prototype.disconnect = function() {
            this.clearActive();
            this.observations_.clear();
            this.controller_.removeObserver(this);
          };
          ResizeObserverSPI2.prototype.gatherActive = function() {
            var _this = this;
            this.clearActive();
            this.observations_.forEach(function(observation) {
              if (observation.isActive()) {
                _this.activeObservations_.push(observation);
              }
            });
          };
          ResizeObserverSPI2.prototype.broadcastActive = function() {
            if (!this.hasActive()) {
              return;
            }
            var ctx = this.callbackCtx_;
            var entries = this.activeObservations_.map(function(observation) {
              return new ResizeObserverEntry(observation.target, observation.broadcastRect());
            });
            this.callback_.call(ctx, entries, ctx);
            this.clearActive();
          };
          ResizeObserverSPI2.prototype.clearActive = function() {
            this.activeObservations_.splice(0);
          };
          ResizeObserverSPI2.prototype.hasActive = function() {
            return this.activeObservations_.length > 0;
          };
          return ResizeObserverSPI2;
        })()
      );
      var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
      var ResizeObserver = (
        /** @class */
        /* @__PURE__ */ (function() {
          function ResizeObserver2(callback) {
            if (!(this instanceof ResizeObserver2)) {
              throw new TypeError("Cannot call a class as a function.");
            }
            if (!arguments.length) {
              throw new TypeError("1 argument required, but only 0 present.");
            }
            var controller = ResizeObserverController.getInstance();
            var observer = new ResizeObserverSPI(callback, controller, this);
            observers.set(this, observer);
          }
          return ResizeObserver2;
        })()
      );
      [
        "observe",
        "unobserve",
        "disconnect"
      ].forEach(function(method) {
        ResizeObserver.prototype[method] = function() {
          var _a2;
          return (_a2 = observers.get(this))[method].apply(_a2, arguments);
        };
      });
      var index = (function() {
        if (typeof global$1.ResizeObserver !== "undefined") {
          return global$1.ResizeObserver;
        }
        return ResizeObserver;
      })();
      var useEffectWithTarget = createEffectWithTarget(useLayoutEffect);
      var useIsomorphicLayoutEffectWithTarget = isBrowser$1 ? useEffectWithTarget : useEffectWithTarget$1;
      function useSize(target) {
        var _a2 = __read(useRafState(function() {
          var el = getTargetElement(target);
          return el ? { width: el.clientWidth, height: el.clientHeight } : void 0;
        }), 2), state = _a2[0], setState = _a2[1];
        useIsomorphicLayoutEffectWithTarget(function() {
          var el = getTargetElement(target);
          if (!el) {
            return;
          }
          var resizeObserver = new index(function(entries) {
            entries.forEach(function(entry) {
              var _a3 = entry.target, clientWidth = _a3.clientWidth, clientHeight = _a3.clientHeight;
              setState({ width: clientWidth, height: clientHeight });
            });
          });
          resizeObserver.observe(el);
          return function() {
            resizeObserver.disconnect();
          };
        }, [], target);
        return state;
      }
      const useConfig = () => {
        const [downloadConfig, setDownloadConfig] = useLocalStorageState(
          "qqmusic_downloadConfig",
          {
            defaultValue: defaultDownloadConfig,
            listenStorageChange: true
          }
        );
        const [functionConfig, setFunctionConfig] = useLocalStorageState(
          "qqmusic_functionConfig",
          {
            defaultValue: defaultFunctionConfig,
            listenStorageChange: true
          }
        );
        useEffect(() => {
          setFunctionConfig({
            ...defaultFunctionConfig,
            ...functionConfig
          });
          setDownloadConfig({
            ...defaultDownloadConfig,
            ...downloadConfig
          });
        }, []);
        return {
          /** 下载配置 */
          downloadConfig: downloadConfig || defaultDownloadConfig,
          /** 设置下载配置 */
          setDownloadConfig,
          /** 功能配置 */
          functionConfig: functionConfig || defaultFunctionConfig,
          /** 设置功能配置 */
          setFunctionConfig
        };
      };
      function useFilter(list, config) {
        const [filteredList, setFilteredList] = useState(list);
        useEffect(() => {
          setFilteredList(list);
        }, [list]);
        const handleFilter = (values) => {
          const filtered = list.filter((item) => {
            return Object.entries(config.fields).every(([field, fieldConfig]) => {
              const filterValue = values[field];
              if (!filterValue?.length) return true;
              const itemValue = fieldConfig.getValue(item);
              if (!itemValue) return false;
              return filterValue.some(
                (keyword) => itemValue.toLowerCase().includes(keyword.toLowerCase())
              );
            });
          });
          setFilteredList(filtered);
        };
        return { filteredList, setFilteredList, handleFilter };
      }
      var _GM_xmlhttpRequest = /* @__PURE__ */ (() => typeof GM_xmlhttpRequest != "undefined" ? GM_xmlhttpRequest : void 0)();
      const yURL = "https://y.qq.com";
      const cURL = "https://c.y.qq.com";
      const uURL = "https://u.y.qq.com";
      const getBaseURL = (url, type = "c") => {
        let baseURL = "";
        switch (type) {
          case "y":
            baseURL = yURL + url;
            break;
          case "u":
            baseURL = uURL + url;
            break;
          case "c":
            baseURL = cURL + url;
            break;
          default:
            baseURL = cURL + url;
            break;
        }
        return baseURL;
      };
      const getDefaultHeaders = (type = "c") => {
        switch (type) {
          case "y":
            return { referer: "https://y.qq.com/", host: "y.qq.com" };
          case "u":
            return {
              referer: "https://y.qq.com/portal/player.html",
              host: "u.y.qq.com",
              "content-type": "application/x-www-form-urlencoded"
            };
          case "c":
            return { referer: "https://c.y.qq.com/", host: "c.y.qq.com" };
          default:
            return { referer: "https://c.y.qq.com/", host: "c.y.qq.com" };
        }
      };
      const qqMusicRequest = async (url, config, type = "c") => {
        const baseURL = getBaseURL(url, type);
        const { headers, method = "GET", responseType = "json", ...rest } = config;
        const cookie = document.cookie;
        return new Promise((resolve, reject) => {
          _GM_xmlhttpRequest({
            method,
            url: baseURL,
            responseType,
            headers: { ...getDefaultHeaders(type), cookie, ...headers },
            cookie,
            onload: (res) => resolve(res.response),
            onerror: reject,
            ...rest
          });
        });
      };
      const getAlbumInfo = async (albummid) => {
        const params = {
          albummid,
          format: "json",
          outCharset: "utf-8"
        };
        const res = await qqMusicRequest(
          `/v8/fcg-bin/fcg_v8_album_info_cp.fcg?${new URLSearchParams(params).toString()}`,
          {}
        );
        if (res.code === 0) {
          return res.data;
        }
        throw new Error("获取专辑信息失败");
      };
      const getAlbumPicUrl = (albummid, options) => {
        const { size = "800x800", maxAge = 2592e3 } = options || {};
        return `https://y.gtimg.cn/music/photo_new/T002R${size}M000${albummid}.jpg?max_age=${maxAge}`;
      };
      var md5$2 = { exports: {} };
      var crypt = { exports: {} };
      var hasRequiredCrypt;
      function requireCrypt() {
        if (hasRequiredCrypt) return crypt.exports;
        hasRequiredCrypt = 1;
        (function() {
          var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt$1 = {
            // Bit-wise rotation left
            rotl: function(n, b) {
              return n << b | n >>> 32 - b;
            },
            // Bit-wise rotation right
            rotr: function(n, b) {
              return n << 32 - b | n >>> b;
            },
            // Swap big-endian to little-endian and vice versa
            endian: function(n) {
              if (n.constructor == Number) {
                return crypt$1.rotl(n, 8) & 16711935 | crypt$1.rotl(n, 24) & 4278255360;
              }
              for (var i = 0; i < n.length; i++)
                n[i] = crypt$1.endian(n[i]);
              return n;
            },
            // Generate an array of any length of random bytes
            randomBytes: function(n) {
              for (var bytes = []; n > 0; n--)
                bytes.push(Math.floor(Math.random() * 256));
              return bytes;
            },
            // Convert a byte array to big-endian 32-bit words
            bytesToWords: function(bytes) {
              for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
                words[b >>> 5] |= bytes[i] << 24 - b % 32;
              return words;
            },
            // Convert big-endian 32-bit words to a byte array
            wordsToBytes: function(words) {
              for (var bytes = [], b = 0; b < words.length * 32; b += 8)
                bytes.push(words[b >>> 5] >>> 24 - b % 32 & 255);
              return bytes;
            },
            // Convert a byte array to a hex string
            bytesToHex: function(bytes) {
              for (var hex = [], i = 0; i < bytes.length; i++) {
                hex.push((bytes[i] >>> 4).toString(16));
                hex.push((bytes[i] & 15).toString(16));
              }
              return hex.join("");
            },
            // Convert a hex string to a byte array
            hexToBytes: function(hex) {
              for (var bytes = [], c = 0; c < hex.length; c += 2)
                bytes.push(parseInt(hex.substr(c, 2), 16));
              return bytes;
            },
            // Convert a byte array to a base-64 string
            bytesToBase64: function(bytes) {
              for (var base64 = [], i = 0; i < bytes.length; i += 3) {
                var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
                for (var j = 0; j < 4; j++)
                  if (i * 8 + j * 6 <= bytes.length * 8)
                    base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63));
                  else
                    base64.push("=");
              }
              return base64.join("");
            },
            // Convert a base-64 string to a byte array
            base64ToBytes: function(base64) {
              base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
              for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
                if (imod4 == 0) continue;
                bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
              }
              return bytes;
            }
          };
          crypt.exports = crypt$1;
        })();
        return crypt.exports;
      }
      var charenc_1;
      var hasRequiredCharenc;
      function requireCharenc() {
        if (hasRequiredCharenc) return charenc_1;
        hasRequiredCharenc = 1;
        var charenc = {
          // UTF-8 encoding
          utf8: {
            // Convert a string to a byte array
            stringToBytes: function(str) {
              return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
            },
            // Convert a byte array to a string
            bytesToString: function(bytes) {
              return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
            }
          },
          // Binary encoding
          bin: {
            // Convert a string to a byte array
            stringToBytes: function(str) {
              for (var bytes = [], i = 0; i < str.length; i++)
                bytes.push(str.charCodeAt(i) & 255);
              return bytes;
            },
            // Convert a byte array to a string
            bytesToString: function(bytes) {
              for (var str = [], i = 0; i < bytes.length; i++)
                str.push(String.fromCharCode(bytes[i]));
              return str.join("");
            }
          }
        };
        charenc_1 = charenc;
        return charenc_1;
      }
      /*!
       * Determine if an object is a Buffer
       *
       * @author   Feross Aboukhadijeh <https://feross.org>
       * @license  MIT
       */
      var isBuffer_1;
      var hasRequiredIsBuffer;
      function requireIsBuffer() {
        if (hasRequiredIsBuffer) return isBuffer_1;
        hasRequiredIsBuffer = 1;
        isBuffer_1 = function(obj) {
          return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
        };
        function isBuffer(obj) {
          return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
        }
        function isSlowBuffer(obj) {
          return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
        }
        return isBuffer_1;
      }
      var hasRequiredMd5$1;
      function requireMd5$1() {
        if (hasRequiredMd5$1) return md5$2.exports;
        hasRequiredMd5$1 = 1;
        (function() {
          var crypt2 = requireCrypt(), utf8 = requireCharenc().utf8, isBuffer = requireIsBuffer(), bin = requireCharenc().bin, md52 = function(message2, options) {
            if (message2.constructor == String)
              if (options && options.encoding === "binary")
                message2 = bin.stringToBytes(message2);
              else
                message2 = utf8.stringToBytes(message2);
            else if (isBuffer(message2))
              message2 = Array.prototype.slice.call(message2, 0);
            else if (!Array.isArray(message2) && message2.constructor !== Uint8Array)
              message2 = message2.toString();
            var m = crypt2.bytesToWords(message2), l = message2.length * 8, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
            for (var i = 0; i < m.length; i++) {
              m[i] = (m[i] << 8 | m[i] >>> 24) & 16711935 | (m[i] << 24 | m[i] >>> 8) & 4278255360;
            }
            m[l >>> 5] |= 128 << l % 32;
            m[(l + 64 >>> 9 << 4) + 14] = l;
            var FF = md52._ff, GG = md52._gg, HH = md52._hh, II = md52._ii;
            for (var i = 0; i < m.length; i += 16) {
              var aa = a, bb = b, cc = c, dd = d;
              a = FF(a, b, c, d, m[i + 0], 7, -680876936);
              d = FF(d, a, b, c, m[i + 1], 12, -389564586);
              c = FF(c, d, a, b, m[i + 2], 17, 606105819);
              b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
              a = FF(a, b, c, d, m[i + 4], 7, -176418897);
              d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
              c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
              b = FF(b, c, d, a, m[i + 7], 22, -45705983);
              a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
              d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
              c = FF(c, d, a, b, m[i + 10], 17, -42063);
              b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
              a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
              d = FF(d, a, b, c, m[i + 13], 12, -40341101);
              c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
              b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
              a = GG(a, b, c, d, m[i + 1], 5, -165796510);
              d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
              c = GG(c, d, a, b, m[i + 11], 14, 643717713);
              b = GG(b, c, d, a, m[i + 0], 20, -373897302);
              a = GG(a, b, c, d, m[i + 5], 5, -701558691);
              d = GG(d, a, b, c, m[i + 10], 9, 38016083);
              c = GG(c, d, a, b, m[i + 15], 14, -660478335);
              b = GG(b, c, d, a, m[i + 4], 20, -405537848);
              a = GG(a, b, c, d, m[i + 9], 5, 568446438);
              d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
              c = GG(c, d, a, b, m[i + 3], 14, -187363961);
              b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
              a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
              d = GG(d, a, b, c, m[i + 2], 9, -51403784);
              c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
              b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
              a = HH(a, b, c, d, m[i + 5], 4, -378558);
              d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
              c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
              b = HH(b, c, d, a, m[i + 14], 23, -35309556);
              a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
              d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
              c = HH(c, d, a, b, m[i + 7], 16, -155497632);
              b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
              a = HH(a, b, c, d, m[i + 13], 4, 681279174);
              d = HH(d, a, b, c, m[i + 0], 11, -358537222);
              c = HH(c, d, a, b, m[i + 3], 16, -722521979);
              b = HH(b, c, d, a, m[i + 6], 23, 76029189);
              a = HH(a, b, c, d, m[i + 9], 4, -640364487);
              d = HH(d, a, b, c, m[i + 12], 11, -421815835);
              c = HH(c, d, a, b, m[i + 15], 16, 530742520);
              b = HH(b, c, d, a, m[i + 2], 23, -995338651);
              a = II(a, b, c, d, m[i + 0], 6, -198630844);
              d = II(d, a, b, c, m[i + 7], 10, 1126891415);
              c = II(c, d, a, b, m[i + 14], 15, -1416354905);
              b = II(b, c, d, a, m[i + 5], 21, -57434055);
              a = II(a, b, c, d, m[i + 12], 6, 1700485571);
              d = II(d, a, b, c, m[i + 3], 10, -1894986606);
              c = II(c, d, a, b, m[i + 10], 15, -1051523);
              b = II(b, c, d, a, m[i + 1], 21, -2054922799);
              a = II(a, b, c, d, m[i + 8], 6, 1873313359);
              d = II(d, a, b, c, m[i + 15], 10, -30611744);
              c = II(c, d, a, b, m[i + 6], 15, -1560198380);
              b = II(b, c, d, a, m[i + 13], 21, 1309151649);
              a = II(a, b, c, d, m[i + 4], 6, -145523070);
              d = II(d, a, b, c, m[i + 11], 10, -1120210379);
              c = II(c, d, a, b, m[i + 2], 15, 718787259);
              b = II(b, c, d, a, m[i + 9], 21, -343485551);
              a = a + aa >>> 0;
              b = b + bb >>> 0;
              c = c + cc >>> 0;
              d = d + dd >>> 0;
            }
            return crypt2.endian([a, b, c, d]);
          };
          md52._ff = function(a, b, c, d, x, s, t) {
            var n = a + (b & c | ~b & d) + (x >>> 0) + t;
            return (n << s | n >>> 32 - s) + b;
          };
          md52._gg = function(a, b, c, d, x, s, t) {
            var n = a + (b & d | c & ~d) + (x >>> 0) + t;
            return (n << s | n >>> 32 - s) + b;
          };
          md52._hh = function(a, b, c, d, x, s, t) {
            var n = a + (b ^ c ^ d) + (x >>> 0) + t;
            return (n << s | n >>> 32 - s) + b;
          };
          md52._ii = function(a, b, c, d, x, s, t) {
            var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
            return (n << s | n >>> 32 - s) + b;
          };
          md52._blocksize = 16;
          md52._digestsize = 16;
          md5$2.exports = function(message2, options) {
            if (message2 === void 0 || message2 === null)
              throw new Error("Illegal argument " + message2);
            var digestbytes = crypt2.wordsToBytes(md52(message2, options));
            return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt2.bytesToHex(digestbytes);
          };
        })();
        return md5$2.exports;
      }
      var md5Exports = requireMd5$1();
      const md5$1 = /* @__PURE__ */ getDefaultExportFromCjs(md5Exports);
      const defaultMessages = "End-Of-Stream";
      class EndOfStreamError extends Error {
        constructor() {
          super(defaultMessages);
          this.name = "EndOfStreamError";
        }
      } exports("E", EndOfStreamError);
      class AbortError extends Error {
        constructor(message2 = "The operation was aborted") {
          super(message2);
          this.name = "AbortError";
        }
      }
      class AbstractStreamReader {
        constructor() {
          this.endOfStream = false;
          this.interrupted = false;
          this.peekQueue = [];
        }
        async peek(uint8Array, mayBeLess = false) {
          const bytesRead = await this.read(uint8Array, mayBeLess);
          this.peekQueue.push(uint8Array.subarray(0, bytesRead));
          return bytesRead;
        }
        async read(buffer, mayBeLess = false) {
          if (buffer.length === 0) {
            return 0;
          }
          let bytesRead = this.readFromPeekBuffer(buffer);
          if (!this.endOfStream) {
            bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);
          }
          if (bytesRead === 0 && !mayBeLess) {
            throw new EndOfStreamError();
          }
          return bytesRead;
        }
        /**
         * Read chunk from stream
         * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
         * @returns Number of bytes read
         */
        readFromPeekBuffer(buffer) {
          let remaining = buffer.length;
          let bytesRead = 0;
          while (this.peekQueue.length > 0 && remaining > 0) {
            const peekData = this.peekQueue.pop();
            if (!peekData)
              throw new Error("peekData should be defined");
            const lenCopy = Math.min(peekData.length, remaining);
            buffer.set(peekData.subarray(0, lenCopy), bytesRead);
            bytesRead += lenCopy;
            remaining -= lenCopy;
            if (lenCopy < peekData.length) {
              this.peekQueue.push(peekData.subarray(lenCopy));
            }
          }
          return bytesRead;
        }
        async readRemainderFromStream(buffer, mayBeLess) {
          let bytesRead = 0;
          while (bytesRead < buffer.length && !this.endOfStream) {
            if (this.interrupted) {
              throw new AbortError();
            }
            const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);
            if (chunkLen === 0)
              break;
            bytesRead += chunkLen;
          }
          if (!mayBeLess && bytesRead < buffer.length) {
            throw new EndOfStreamError();
          }
          return bytesRead;
        }
      }
      class WebStreamReader extends AbstractStreamReader {
        constructor(reader) {
          super();
          this.reader = reader;
        }
        async abort() {
          return this.close();
        }
        async close() {
          this.reader.releaseLock();
        }
      }
      class WebStreamByobReader extends WebStreamReader {
        /**
         * Read from stream
         * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
         * @param mayBeLess - If true, may fill the buffer partially
         * @protected Bytes read
         */
        async readFromStream(buffer, mayBeLess) {
          if (buffer.length === 0)
            return 0;
          const result = await this.reader.read(new Uint8Array(buffer.length), { min: mayBeLess ? void 0 : buffer.length });
          if (result.done) {
            this.endOfStream = result.done;
          }
          if (result.value) {
            buffer.set(result.value);
            return result.value.length;
          }
          return 0;
        }
      }
      class WebStreamDefaultReader extends AbstractStreamReader {
        constructor(reader) {
          super();
          this.reader = reader;
          this.buffer = null;
        }
        /**
         * Copy chunk to target, and store the remainder in this.buffer
         */
        writeChunk(target, chunk) {
          const written = Math.min(chunk.length, target.length);
          target.set(chunk.subarray(0, written));
          if (written < chunk.length) {
            this.buffer = chunk.subarray(written);
          } else {
            this.buffer = null;
          }
          return written;
        }
        /**
         * Read from stream
         * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
         * @param mayBeLess - If true, may fill the buffer partially
         * @protected Bytes read
         */
        async readFromStream(buffer, mayBeLess) {
          if (buffer.length === 0)
            return 0;
          let totalBytesRead = 0;
          if (this.buffer) {
            totalBytesRead += this.writeChunk(buffer, this.buffer);
          }
          while (totalBytesRead < buffer.length && !this.endOfStream) {
            const result = await this.reader.read();
            if (result.done) {
              this.endOfStream = true;
              break;
            }
            if (result.value) {
              totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);
            }
          }
          if (!mayBeLess && totalBytesRead === 0 && this.endOfStream) {
            throw new EndOfStreamError();
          }
          return totalBytesRead;
        }
        abort() {
          this.interrupted = true;
          return this.reader.cancel();
        }
        async close() {
          await this.abort();
          this.reader.releaseLock();
        }
      }
      function makeWebStreamReader(stream) {
        try {
          const reader = stream.getReader({ mode: "byob" });
          if (reader instanceof ReadableStreamDefaultReader) {
            return new WebStreamDefaultReader(reader);
          }
          return new WebStreamByobReader(reader);
        } catch (error) {
          if (error instanceof TypeError) {
            return new WebStreamDefaultReader(stream.getReader());
          }
          throw error;
        }
      }
      class AbstractTokenizer {
        /**
         * Constructor
         * @param options Tokenizer options
         * @protected
         */
        constructor(options) {
          this.numBuffer = new Uint8Array(8);
          this.position = 0;
          this.onClose = options?.onClose;
          if (options?.abortSignal) {
            options.abortSignal.addEventListener("abort", () => {
              this.abort();
            });
          }
        }
        /**
         * Read a token from the tokenizer-stream
         * @param token - The token to read
         * @param position - If provided, the desired position in the tokenizer-stream
         * @returns Promise with token data
         */
        async readToken(token, position = this.position) {
          const uint8Array = new Uint8Array(token.len);
          const len = await this.readBuffer(uint8Array, { position });
          if (len < token.len)
            throw new EndOfStreamError();
          return token.get(uint8Array, 0);
        }
        /**
         * Peek a token from the tokenizer-stream.
         * @param token - Token to peek from the tokenizer-stream.
         * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
         * @returns Promise with token data
         */
        async peekToken(token, position = this.position) {
          const uint8Array = new Uint8Array(token.len);
          const len = await this.peekBuffer(uint8Array, { position });
          if (len < token.len)
            throw new EndOfStreamError();
          return token.get(uint8Array, 0);
        }
        /**
         * Read a numeric token from the stream
         * @param token - Numeric token
         * @returns Promise with number
         */
        async readNumber(token) {
          const len = await this.readBuffer(this.numBuffer, { length: token.len });
          if (len < token.len)
            throw new EndOfStreamError();
          return token.get(this.numBuffer, 0);
        }
        /**
         * Read a numeric token from the stream
         * @param token - Numeric token
         * @returns Promise with number
         */
        async peekNumber(token) {
          const len = await this.peekBuffer(this.numBuffer, { length: token.len });
          if (len < token.len)
            throw new EndOfStreamError();
          return token.get(this.numBuffer, 0);
        }
        /**
         * Ignore number of bytes, advances the pointer in under tokenizer-stream.
         * @param length - Number of bytes to ignore
         * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
         */
        async ignore(length) {
          if (this.fileInfo.size !== void 0) {
            const bytesLeft = this.fileInfo.size - this.position;
            if (length > bytesLeft) {
              this.position += bytesLeft;
              return bytesLeft;
            }
          }
          this.position += length;
          return length;
        }
        async close() {
          await this.abort();
          await this.onClose?.();
        }
        normalizeOptions(uint8Array, options) {
          if (!this.supportsRandomAccess() && options && options.position !== void 0 && options.position < this.position) {
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          }
          return {
            ...{
              mayBeLess: false,
              offset: 0,
              length: uint8Array.length,
              position: this.position
            },
            ...options
          };
        }
        abort() {
          return Promise.resolve();
        }
      }
      const maxBufferSize = 256e3;
      class ReadStreamTokenizer extends AbstractTokenizer {
        /**
         * Constructor
         * @param streamReader stream-reader to read from
         * @param options Tokenizer options
         */
        constructor(streamReader, options) {
          super(options);
          this.streamReader = streamReader;
          this.fileInfo = options?.fileInfo ?? {};
        }
        /**
         * Read buffer from tokenizer
         * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
         * @param options - Read behaviour options
         * @returns Promise with number of bytes read
         */
        async readBuffer(uint8Array, options) {
          const normOptions = this.normalizeOptions(uint8Array, options);
          const skipBytes = normOptions.position - this.position;
          if (skipBytes > 0) {
            await this.ignore(skipBytes);
            return this.readBuffer(uint8Array, options);
          }
          if (skipBytes < 0) {
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          }
          if (normOptions.length === 0) {
            return 0;
          }
          const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
          this.position += bytesRead;
          if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
            throw new EndOfStreamError();
          }
          return bytesRead;
        }
        /**
         * Peek (read ahead) buffer from tokenizer
         * @param uint8Array - Uint8Array (or Buffer) to write data to
         * @param options - Read behaviour options
         * @returns Promise with number of bytes peeked
         */
        async peekBuffer(uint8Array, options) {
          const normOptions = this.normalizeOptions(uint8Array, options);
          let bytesRead = 0;
          if (normOptions.position) {
            const skipBytes = normOptions.position - this.position;
            if (skipBytes > 0) {
              const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
              bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
              uint8Array.set(skipBuffer.subarray(skipBytes));
              return bytesRead - skipBytes;
            }
            if (skipBytes < 0) {
              throw new Error("Cannot peek from a negative offset in a stream");
            }
          }
          if (normOptions.length > 0) {
            try {
              bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
            } catch (err2) {
              if (options?.mayBeLess && err2 instanceof EndOfStreamError) {
                return 0;
              }
              throw err2;
            }
            if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
              throw new EndOfStreamError();
            }
          }
          return bytesRead;
        }
        async ignore(length) {
          const bufSize = Math.min(maxBufferSize, length);
          const buf = new Uint8Array(bufSize);
          let totBytesRead = 0;
          while (totBytesRead < length) {
            const remaining = length - totBytesRead;
            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
            if (bytesRead < 0) {
              return bytesRead;
            }
            totBytesRead += bytesRead;
          }
          return totBytesRead;
        }
        abort() {
          return this.streamReader.abort();
        }
        async close() {
          return this.streamReader.close();
        }
        supportsRandomAccess() {
          return false;
        }
      }
      class BufferTokenizer extends AbstractTokenizer {
        /**
         * Construct BufferTokenizer
         * @param uint8Array - Uint8Array to tokenize
         * @param options Tokenizer options
         */
        constructor(uint8Array, options) {
          super(options);
          this.uint8Array = uint8Array;
          this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };
        }
        /**
         * Read buffer from tokenizer
         * @param uint8Array - Uint8Array to tokenize
         * @param options - Read behaviour options
         * @returns {Promise<number>}
         */
        async readBuffer(uint8Array, options) {
          if (options?.position) {
            this.position = options.position;
          }
          const bytesRead = await this.peekBuffer(uint8Array, options);
          this.position += bytesRead;
          return bytesRead;
        }
        /**
         * Peek (read ahead) buffer from tokenizer
         * @param uint8Array
         * @param options - Read behaviour options
         * @returns {Promise<number>}
         */
        async peekBuffer(uint8Array, options) {
          const normOptions = this.normalizeOptions(uint8Array, options);
          const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
          if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
            throw new EndOfStreamError();
          }
          uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
          return bytes2read;
        }
        close() {
          return super.close();
        }
        supportsRandomAccess() {
          return true;
        }
        setPosition(position) {
          this.position = position;
        }
      }
      class BlobTokenizer extends AbstractTokenizer {
        /**
         * Construct BufferTokenizer
         * @param blob - Uint8Array to tokenize
         * @param options Tokenizer options
         */
        constructor(blob, options) {
          super(options);
          this.blob = blob;
          this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: blob.size, mimeType: blob.type } };
        }
        /**
         * Read buffer from tokenizer
         * @param uint8Array - Uint8Array to tokenize
         * @param options - Read behaviour options
         * @returns {Promise<number>}
         */
        async readBuffer(uint8Array, options) {
          if (options?.position) {
            this.position = options.position;
          }
          const bytesRead = await this.peekBuffer(uint8Array, options);
          this.position += bytesRead;
          return bytesRead;
        }
        /**
         * Peek (read ahead) buffer from tokenizer
         * @param buffer
         * @param options - Read behaviour options
         * @returns {Promise<number>}
         */
        async peekBuffer(buffer, options) {
          const normOptions = this.normalizeOptions(buffer, options);
          const bytes2read = Math.min(this.blob.size - normOptions.position, normOptions.length);
          if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
            throw new EndOfStreamError();
          }
          const arrayBuffer = await this.blob.slice(normOptions.position, normOptions.position + bytes2read).arrayBuffer();
          buffer.set(new Uint8Array(arrayBuffer));
          return bytes2read;
        }
        close() {
          return super.close();
        }
        supportsRandomAccess() {
          return true;
        }
        setPosition(position) {
          this.position = position;
        }
      }
      function fromWebStream(webStream, options) {
        const webStreamReader = makeWebStreamReader(webStream);
        const _options = options ?? {};
        const chainedClose = _options.onClose;
        _options.onClose = async () => {
          await webStreamReader.close();
          if (chainedClose) {
            return chainedClose();
          }
        };
        return new ReadStreamTokenizer(webStreamReader, _options);
      }
      function fromBuffer(uint8Array, options) {
        return new BufferTokenizer(uint8Array, options);
      }
      function fromBlob(blob, options) {
        return new BlobTokenizer(blob, options);
      }
      var ieee754 = {};
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      var hasRequiredIeee754;
      function requireIeee754() {
        if (hasRequiredIeee754) return ieee754;
        hasRequiredIeee754 = 1;
        ieee754.read = function(buffer, offset, isLE, mLen, nBytes) {
          var e, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];
          i += d;
          e = s & (1 << -nBits) - 1;
          s >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          m = e & (1 << -nBits) - 1;
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        ieee754.write = function(buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
          }
          e = e << mLen | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
          }
          buffer[offset + i - d] |= s * 128;
        };
        return ieee754;
      }
      var ieee754Exports = requireIeee754();
      const WINDOWS_1252_EXTRA$1 = {
        128: "€",
        130: "‚",
        131: "ƒ",
        132: "„",
        133: "…",
        134: "†",
        135: "‡",
        136: "ˆ",
        137: "‰",
        138: "Š",
        139: "‹",
        140: "Œ",
        142: "Ž",
        145: "‘",
        146: "’",
        147: "“",
        148: "”",
        149: "•",
        150: "–",
        151: "—",
        152: "˜",
        153: "™",
        154: "š",
        155: "›",
        156: "œ",
        158: "ž",
        159: "Ÿ"
      };
      for (const [code, char] of Object.entries(WINDOWS_1252_EXTRA$1)) {
      }
      function textDecode$1(bytes, encoding = "utf-8") {
        switch (encoding.toLowerCase()) {
          case "utf-8":
          case "utf8":
            if (typeof globalThis.TextDecoder !== "undefined") {
              return new globalThis.TextDecoder("utf-8").decode(bytes);
            }
            return decodeUTF8$1(bytes);
          case "utf-16le":
            return decodeUTF16LE$1(bytes);
          case "ascii":
            return decodeASCII$1(bytes);
          case "latin1":
          case "iso-8859-1":
            return decodeLatin1$1(bytes);
          case "windows-1252":
            return decodeWindows1252$1(bytes);
          default:
            throw new RangeError(`Encoding '${encoding}' not supported`);
        }
      }
      function decodeUTF8$1(bytes) {
        let out = "";
        let i = 0;
        while (i < bytes.length) {
          const b1 = bytes[i++];
          if (b1 < 128) {
            out += String.fromCharCode(b1);
          } else if (b1 < 224) {
            const b2 = bytes[i++] & 63;
            out += String.fromCharCode((b1 & 31) << 6 | b2);
          } else if (b1 < 240) {
            const b2 = bytes[i++] & 63;
            const b3 = bytes[i++] & 63;
            out += String.fromCharCode((b1 & 15) << 12 | b2 << 6 | b3);
          } else {
            const b2 = bytes[i++] & 63;
            const b3 = bytes[i++] & 63;
            const b4 = bytes[i++] & 63;
            let cp = (b1 & 7) << 18 | b2 << 12 | b3 << 6 | b4;
            cp -= 65536;
            out += String.fromCharCode(55296 + (cp >> 10 & 1023), 56320 + (cp & 1023));
          }
        }
        return out;
      }
      function decodeUTF16LE$1(bytes) {
        let out = "";
        for (let i = 0; i < bytes.length; i += 2) {
          out += String.fromCharCode(bytes[i] | bytes[i + 1] << 8);
        }
        return out;
      }
      function decodeASCII$1(bytes) {
        return String.fromCharCode(...bytes.map((b) => b & 127));
      }
      function decodeLatin1$1(bytes) {
        return String.fromCharCode(...bytes);
      }
      function decodeWindows1252$1(bytes) {
        let out = "";
        for (const b of bytes) {
          if (b >= 128 && b <= 159 && WINDOWS_1252_EXTRA$1[b]) {
            out += WINDOWS_1252_EXTRA$1[b];
          } else {
            out += String.fromCharCode(b);
          }
        }
        return out;
      }
      function dv(array) {
        return new DataView(array.buffer, array.byteOffset);
      }
      const UINT8 = exports("d", {
        len: 1,
        get(array, offset) {
          return dv(array).getUint8(offset);
        },
        put(array, offset, value) {
          dv(array).setUint8(offset, value);
          return offset + 1;
        }
      });
      const UINT16_LE = exports("k", {
        len: 2,
        get(array, offset) {
          return dv(array).getUint16(offset, true);
        },
        put(array, offset, value) {
          dv(array).setUint16(offset, value, true);
          return offset + 2;
        }
      });
      const UINT16_BE = exports("c", {
        len: 2,
        get(array, offset) {
          return dv(array).getUint16(offset);
        },
        put(array, offset, value) {
          dv(array).setUint16(offset, value);
          return offset + 2;
        }
      });
      const UINT24_LE = exports("N", {
        len: 3,
        get(array, offset) {
          const dataView = dv(array);
          return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
        },
        put(array, offset, value) {
          const dataView = dv(array);
          dataView.setUint8(offset, value & 255);
          dataView.setUint16(offset + 1, value >> 8, true);
          return offset + 3;
        }
      });
      const UINT24_BE = exports("H", {
        len: 3,
        get(array, offset) {
          const dataView = dv(array);
          return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
        },
        put(array, offset, value) {
          const dataView = dv(array);
          dataView.setUint16(offset, value >> 8);
          dataView.setUint8(offset + 2, value & 255);
          return offset + 3;
        }
      });
      const UINT32_LE = exports("e", {
        len: 4,
        get(array, offset) {
          return dv(array).getUint32(offset, true);
        },
        put(array, offset, value) {
          dv(array).setUint32(offset, value, true);
          return offset + 4;
        }
      });
      const UINT32_BE = exports("b", {
        len: 4,
        get(array, offset) {
          return dv(array).getUint32(offset);
        },
        put(array, offset, value) {
          dv(array).setUint32(offset, value);
          return offset + 4;
        }
      });
      const INT8 = exports("D", {
        len: 1,
        get(array, offset) {
          return dv(array).getInt8(offset);
        },
        put(array, offset, value) {
          dv(array).setInt8(offset, value);
          return offset + 1;
        }
      });
      const INT16_BE = exports("I", {
        len: 2,
        get(array, offset) {
          return dv(array).getInt16(offset);
        },
        put(array, offset, value) {
          dv(array).setInt16(offset, value);
          return offset + 2;
        }
      });
      const INT16_LE = {
        len: 2,
        get(array, offset) {
          return dv(array).getInt16(offset, true);
        },
        put(array, offset, value) {
          dv(array).setInt16(offset, value, true);
          return offset + 2;
        }
      };
      const INT24_LE = {
        len: 3,
        get(array, offset) {
          const unsigned = UINT24_LE.get(array, offset);
          return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
        },
        put(array, offset, value) {
          const dataView = dv(array);
          dataView.setUint8(offset, value & 255);
          dataView.setUint16(offset + 1, value >> 8, true);
          return offset + 3;
        }
      };
      const INT24_BE = exports("C", {
        len: 3,
        get(array, offset) {
          const unsigned = UINT24_BE.get(array, offset);
          return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
        },
        put(array, offset, value) {
          const dataView = dv(array);
          dataView.setUint16(offset, value >> 8);
          dataView.setUint8(offset + 2, value & 255);
          return offset + 3;
        }
      });
      const INT32_BE = exports("z", {
        len: 4,
        get(array, offset) {
          return dv(array).getInt32(offset);
        },
        put(array, offset, value) {
          dv(array).setInt32(offset, value);
          return offset + 4;
        }
      });
      const INT32_LE = exports("q", {
        len: 4,
        get(array, offset) {
          return dv(array).getInt32(offset, true);
        },
        put(array, offset, value) {
          dv(array).setInt32(offset, value, true);
          return offset + 4;
        }
      });
      const UINT64_LE = exports("f", {
        len: 8,
        get(array, offset) {
          return dv(array).getBigUint64(offset, true);
        },
        put(array, offset, value) {
          dv(array).setBigUint64(offset, value, true);
          return offset + 8;
        }
      });
      const INT64_LE = exports("p", {
        len: 8,
        get(array, offset) {
          return dv(array).getBigInt64(offset, true);
        },
        put(array, offset, value) {
          dv(array).setBigInt64(offset, value, true);
          return offset + 8;
        }
      });
      const UINT64_BE = exports("w", {
        len: 8,
        get(array, offset) {
          return dv(array).getBigUint64(offset);
        },
        put(array, offset, value) {
          dv(array).setBigUint64(offset, value);
          return offset + 8;
        }
      });
      const INT64_BE = exports("o", {
        len: 8,
        get(array, offset) {
          return dv(array).getBigInt64(offset);
        },
        put(array, offset, value) {
          dv(array).setBigInt64(offset, value);
          return offset + 8;
        }
      });
      const Float16_BE = {
        len: 2,
        get(dataView, offset) {
          return ieee754Exports.read(dataView, offset, false, 10, this.len);
        },
        put(dataView, offset, value) {
          ieee754Exports.write(dataView, value, offset, false, 10, this.len);
          return offset + this.len;
        }
      };
      const Float16_LE = {
        len: 2,
        get(array, offset) {
          return ieee754Exports.read(array, offset, true, 10, this.len);
        },
        put(array, offset, value) {
          ieee754Exports.write(array, value, offset, true, 10, this.len);
          return offset + this.len;
        }
      };
      const Float32_BE = exports("v", {
        len: 4,
        get(array, offset) {
          return dv(array).getFloat32(offset);
        },
        put(array, offset, value) {
          dv(array).setFloat32(offset, value);
          return offset + 4;
        }
      });
      const Float32_LE = {
        len: 4,
        get(array, offset) {
          return dv(array).getFloat32(offset, true);
        },
        put(array, offset, value) {
          dv(array).setFloat32(offset, value, true);
          return offset + 4;
        }
      };
      const Float64_BE = exports("t", {
        len: 8,
        get(array, offset) {
          return dv(array).getFloat64(offset);
        },
        put(array, offset, value) {
          dv(array).setFloat64(offset, value);
          return offset + 8;
        }
      });
      const Float64_LE = {
        len: 8,
        get(array, offset) {
          return dv(array).getFloat64(offset, true);
        },
        put(array, offset, value) {
          dv(array).setFloat64(offset, value, true);
          return offset + 8;
        }
      };
      const Float80_BE = {
        len: 10,
        get(array, offset) {
          return ieee754Exports.read(array, offset, false, 63, this.len);
        },
        put(array, offset, value) {
          ieee754Exports.write(array, value, offset, false, 63, this.len);
          return offset + this.len;
        }
      };
      const Float80_LE = {
        len: 10,
        get(array, offset) {
          return ieee754Exports.read(array, offset, true, 63, this.len);
        },
        put(array, offset, value) {
          ieee754Exports.write(array, value, offset, true, 63, this.len);
          return offset + this.len;
        }
      };
      class IgnoreType {
        /**
         * @param len number of bytes to ignore
         */
        constructor(len) {
          this.len = len;
        }
        // ToDo: don't read, but skip data
        get(_array, _off) {
        }
      }
      class Uint8ArrayType {
        constructor(len) {
          this.len = len;
        }
        get(array, offset) {
          return array.subarray(offset, offset + this.len);
        }
      } exports("U", Uint8ArrayType);
      class StringType {
        constructor(len, encoding) {
          this.len = len;
          this.encoding = encoding;
        }
        get(data, offset = 0) {
          const bytes = data.subarray(offset, offset + this.len);
          return textDecode$1(bytes, this.encoding);
        }
      } exports("S", StringType);
      class AnsiStringType extends StringType {
        constructor(len) {
          super(len, "windows-1252");
        }
      }
      const Token = exports("x", /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        AnsiStringType,
        Float16_BE,
        Float16_LE,
        Float32_BE,
        Float32_LE,
        Float64_BE,
        Float64_LE,
        Float80_BE,
        Float80_LE,
        INT16_BE,
        INT16_LE,
        INT24_BE,
        INT24_LE,
        INT32_BE,
        INT32_LE,
        INT64_BE,
        INT64_LE,
        INT8,
        IgnoreType,
        StringType,
        UINT16_BE,
        UINT16_LE,
        UINT24_BE,
        UINT24_LE,
        UINT32_BE,
        UINT32_LE,
        UINT64_BE,
        UINT64_LE,
        UINT8,
        Uint8ArrayType
      }, Symbol.toStringTag, { value: "Module" })));
      var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
      var fleb = new u8([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0,
        /* unused */
        0,
        0,
        /* impossible */
        0
      ]);
      var fdeb = new u8([
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13,
        /* unused */
        0,
        0
      ]);
      var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      var freb = function(eb, start) {
        var b = new u16(31);
        for (var i = 0; i < 31; ++i) {
          b[i] = start += 1 << eb[i - 1];
        }
        var r = new i32(b[30]);
        for (var i = 1; i < 30; ++i) {
          for (var j = b[i]; j < b[i + 1]; ++j) {
            r[j] = j - b[i] << 5 | i;
          }
        }
        return { b, r };
      };
      var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
      fl[28] = 258, revfl[258] = 28;
      var _b = freb(fdeb, 0), fd = _b.b;
      var rev = new u16(32768);
      for (var i = 0; i < 32768; ++i) {
        var x = (i & 43690) >> 1 | (i & 21845) << 1;
        x = (x & 52428) >> 2 | (x & 13107) << 2;
        x = (x & 61680) >> 4 | (x & 3855) << 4;
        rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
      }
      var hMap = (function(cd, mb, r) {
        var s = cd.length;
        var i = 0;
        var l = new u16(mb);
        for (; i < s; ++i) {
          if (cd[i])
            ++l[cd[i] - 1];
        }
        var le = new u16(mb);
        for (i = 1; i < mb; ++i) {
          le[i] = le[i - 1] + l[i - 1] << 1;
        }
        var co;
        {
          co = new u16(1 << mb);
          var rvb = 15 - mb;
          for (i = 0; i < s; ++i) {
            if (cd[i]) {
              var sv = i << 4 | cd[i];
              var r_1 = mb - cd[i];
              var v = le[cd[i] - 1]++ << r_1;
              for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
                co[rev[v] >> rvb] = sv;
              }
            }
          }
        }
        return co;
      });
      var flt = new u8(288);
      for (var i = 0; i < 144; ++i)
        flt[i] = 8;
      for (var i = 144; i < 256; ++i)
        flt[i] = 9;
      for (var i = 256; i < 280; ++i)
        flt[i] = 7;
      for (var i = 280; i < 288; ++i)
        flt[i] = 8;
      var fdt = new u8(32);
      for (var i = 0; i < 32; ++i)
        fdt[i] = 5;
      var flrm = /* @__PURE__ */ hMap(flt, 9);
      var fdrm = /* @__PURE__ */ hMap(fdt, 5);
      var max = function(a) {
        var m = a[0];
        for (var i = 1; i < a.length; ++i) {
          if (a[i] > m)
            m = a[i];
        }
        return m;
      };
      var bits = function(d, p, m) {
        var o = p / 8 | 0;
        return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
      };
      var bits16 = function(d, p) {
        var o = p / 8 | 0;
        return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
      };
      var shft = function(p) {
        return (p + 7) / 8 | 0;
      };
      var slc = function(v, s, e) {
        if (e == null || e > v.length)
          e = v.length;
        return new u8(v.subarray(s, e));
      };
      var ec = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data"
        // determined by unknown compression method
      ];
      var err = function(ind, msg, nt) {
        var e = new Error(msg || ec[ind]);
        e.code = ind;
        if (Error.captureStackTrace)
          Error.captureStackTrace(e, err);
        if (!nt)
          throw e;
        return e;
      };
      var inflt = function(dat, st, buf, dict) {
        var sl = dat.length, dl = 0;
        if (!sl || st.f && !st.l)
          return buf || new u8(0);
        var noBuf = !buf;
        var resize = noBuf || st.i != 2;
        var noSt = st.i;
        if (noBuf)
          buf = new u8(sl * 3);
        var cbuf = function(l2) {
          var bl = buf.length;
          if (l2 > bl) {
            var nbuf = new u8(Math.max(bl * 2, l2));
            nbuf.set(buf);
            buf = nbuf;
          }
        };
        var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
        var tbts = sl * 8;
        do {
          if (!lm) {
            final = bits(dat, pos, 1);
            var type = bits(dat, pos + 1, 3);
            pos += 3;
            if (!type) {
              var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
              if (t > sl) {
                if (noSt)
                  err(0);
                break;
              }
              if (resize)
                cbuf(bt + l);
              buf.set(dat.subarray(s, t), bt);
              st.b = bt += l, st.p = pos = t * 8, st.f = final;
              continue;
            } else if (type == 1)
              lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
            else if (type == 2) {
              var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
              var tl = hLit + bits(dat, pos + 5, 31) + 1;
              pos += 14;
              var ldt = new u8(tl);
              var clt = new u8(19);
              for (var i = 0; i < hcLen; ++i) {
                clt[clim[i]] = bits(dat, pos + i * 3, 7);
              }
              pos += hcLen * 3;
              var clb = max(clt), clbmsk = (1 << clb) - 1;
              var clm = hMap(clt, clb);
              for (var i = 0; i < tl; ) {
                var r = clm[bits(dat, pos, clbmsk)];
                pos += r & 15;
                var s = r >> 4;
                if (s < 16) {
                  ldt[i++] = s;
                } else {
                  var c = 0, n = 0;
                  if (s == 16)
                    n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                  else if (s == 17)
                    n = 3 + bits(dat, pos, 7), pos += 3;
                  else if (s == 18)
                    n = 11 + bits(dat, pos, 127), pos += 7;
                  while (n--)
                    ldt[i++] = c;
                }
              }
              var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
              lbt = max(lt);
              dbt = max(dt);
              lm = hMap(lt, lbt);
              dm = hMap(dt, dbt);
            } else
              err(1);
            if (pos > tbts) {
              if (noSt)
                err(0);
              break;
            }
          }
          if (resize)
            cbuf(bt + 131072);
          var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
          var lpos = pos;
          for (; ; lpos = pos) {
            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
            pos += c & 15;
            if (pos > tbts) {
              if (noSt)
                err(0);
              break;
            }
            if (!c)
              err(2);
            if (sym < 256)
              buf[bt++] = sym;
            else if (sym == 256) {
              lpos = pos, lm = null;
              break;
            } else {
              var add = sym - 254;
              if (sym > 264) {
                var i = sym - 257, b = fleb[i];
                add = bits(dat, pos, (1 << b) - 1) + fl[i];
                pos += b;
              }
              var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
              if (!d)
                err(3);
              pos += d & 15;
              var dt = fd[dsym];
              if (dsym > 3) {
                var b = fdeb[dsym];
                dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
              }
              if (pos > tbts) {
                if (noSt)
                  err(0);
                break;
              }
              if (resize)
                cbuf(bt + 131072);
              var end = bt + add;
              if (bt < dt) {
                var shift = dl - dt, dend = Math.min(dt, end);
                if (shift + bt < 0)
                  err(3);
                for (; bt < dend; ++bt)
                  buf[bt] = dict[shift + bt];
              }
              for (; bt < end; ++bt)
                buf[bt] = buf[bt - dt];
            }
          }
          st.l = lm, st.p = lpos, st.b = bt, st.f = final;
          if (lm)
            final = 1, st.m = lbt, st.d = dm, st.n = dbt;
        } while (!final);
        return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
      };
      var et = /* @__PURE__ */ new u8(0);
      var gzs = function(d) {
        if (d[0] != 31 || d[1] != 139 || d[2] != 8)
          err(6, "invalid gzip data");
        var flg = d[3];
        var st = 10;
        if (flg & 4)
          st += (d[10] | d[11] << 8) + 2;
        for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
          ;
        return st + (flg & 2);
      };
      var gzl = function(d) {
        var l = d.length;
        return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
      };
      var zls = function(d, dict) {
        if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
          err(6, "invalid zlib data");
        if ((d[1] >> 5 & 1) == 1)
          err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
        return (d[1] >> 3 & 4) + 2;
      };
      function inflateSync(data, opts) {
        return inflt(data, { i: 2 }, opts, opts);
      }
      function gunzipSync(data, opts) {
        var st = gzs(data);
        if (st + 8 > data.length)
          err(6, "invalid gzip data");
        return inflt(data.subarray(st, -8), { i: 2 }, new u8(gzl(data)), opts);
      }
      function unzlibSync(data, opts) {
        return inflt(data.subarray(zls(data), -4), { i: 2 }, opts, opts);
      }
      function decompressSync(data, opts) {
        return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
      }
      var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
      var tds = 0;
      try {
        td.decode(et, { stream: true });
        tds = 1;
      } catch (e) {
      }
      var browser = { exports: {} };
      var ms;
      var hasRequiredMs;
      function requireMs() {
        if (hasRequiredMs) return ms;
        hasRequiredMs = 1;
        var s = 1e3;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;
        ms = function(val, options) {
          options = options || {};
          var type = typeof val;
          if (type === "string" && val.length > 0) {
            return parse(val);
          } else if (type === "number" && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error(
            "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
          );
        };
        function parse(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
            str
          );
          if (!match) {
            return;
          }
          var n = parseFloat(match[1]);
          var type = (match[2] || "ms").toLowerCase();
          switch (type) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n * y;
            case "weeks":
            case "week":
            case "w":
              return n * w;
            case "days":
            case "day":
            case "d":
              return n * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n;
            default:
              return void 0;
          }
        }
        function fmtShort(ms2) {
          var msAbs = Math.abs(ms2);
          if (msAbs >= d) {
            return Math.round(ms2 / d) + "d";
          }
          if (msAbs >= h) {
            return Math.round(ms2 / h) + "h";
          }
          if (msAbs >= m) {
            return Math.round(ms2 / m) + "m";
          }
          if (msAbs >= s) {
            return Math.round(ms2 / s) + "s";
          }
          return ms2 + "ms";
        }
        function fmtLong(ms2) {
          var msAbs = Math.abs(ms2);
          if (msAbs >= d) {
            return plural(ms2, msAbs, d, "day");
          }
          if (msAbs >= h) {
            return plural(ms2, msAbs, h, "hour");
          }
          if (msAbs >= m) {
            return plural(ms2, msAbs, m, "minute");
          }
          if (msAbs >= s) {
            return plural(ms2, msAbs, s, "second");
          }
          return ms2 + " ms";
        }
        function plural(ms2, msAbs, n, name2) {
          var isPlural = msAbs >= n * 1.5;
          return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
        }
        return ms;
      }
      var common;
      var hasRequiredCommon;
      function requireCommon() {
        if (hasRequiredCommon) return common;
        hasRequiredCommon = 1;
        function setup(env) {
          createDebug.debug = createDebug;
          createDebug.default = createDebug;
          createDebug.coerce = coerce;
          createDebug.disable = disable;
          createDebug.enable = enable;
          createDebug.enabled = enabled;
          createDebug.humanize = requireMs();
          createDebug.destroy = destroy;
          Object.keys(env).forEach((key) => {
            createDebug[key] = env[key];
          });
          createDebug.names = [];
          createDebug.skips = [];
          createDebug.formatters = {};
          function selectColor(namespace) {
            let hash = 0;
            for (let i = 0; i < namespace.length; i++) {
              hash = (hash << 5) - hash + namespace.charCodeAt(i);
              hash |= 0;
            }
            return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
          }
          createDebug.selectColor = selectColor;
          function createDebug(namespace) {
            let prevTime;
            let enableOverride = null;
            let namespacesCache;
            let enabledCache;
            function debug2(...args) {
              if (!debug2.enabled) {
                return;
              }
              const self2 = debug2;
              const curr = Number(/* @__PURE__ */ new Date());
              const ms2 = curr - (prevTime || curr);
              self2.diff = ms2;
              self2.prev = prevTime;
              self2.curr = curr;
              prevTime = curr;
              args[0] = createDebug.coerce(args[0]);
              if (typeof args[0] !== "string") {
                args.unshift("%O");
              }
              let index2 = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
                if (match === "%%") {
                  return "%";
                }
                index2++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === "function") {
                  const val = args[index2];
                  match = formatter.call(self2, val);
                  args.splice(index2, 1);
                  index2--;
                }
                return match;
              });
              createDebug.formatArgs.call(self2, args);
              const logFn = self2.log || createDebug.log;
              logFn.apply(self2, args);
            }
            debug2.namespace = namespace;
            debug2.useColors = createDebug.useColors();
            debug2.color = createDebug.selectColor(namespace);
            debug2.extend = extend;
            debug2.destroy = createDebug.destroy;
            Object.defineProperty(debug2, "enabled", {
              enumerable: true,
              configurable: false,
              get: () => {
                if (enableOverride !== null) {
                  return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                  namespacesCache = createDebug.namespaces;
                  enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
              },
              set: (v) => {
                enableOverride = v;
              }
            });
            if (typeof createDebug.init === "function") {
              createDebug.init(debug2);
            }
            return debug2;
          }
          function extend(namespace, delimiter) {
            const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
            newDebug.log = this.log;
            return newDebug;
          }
          function enable(namespaces) {
            createDebug.save(namespaces);
            createDebug.namespaces = namespaces;
            createDebug.names = [];
            createDebug.skips = [];
            const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
            for (const ns of split) {
              if (ns[0] === "-") {
                createDebug.skips.push(ns.slice(1));
              } else {
                createDebug.names.push(ns);
              }
            }
          }
          function matchesTemplate(search, template) {
            let searchIndex = 0;
            let templateIndex = 0;
            let starIndex = -1;
            let matchIndex = 0;
            while (searchIndex < search.length) {
              if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
                if (template[templateIndex] === "*") {
                  starIndex = templateIndex;
                  matchIndex = searchIndex;
                  templateIndex++;
                } else {
                  searchIndex++;
                  templateIndex++;
                }
              } else if (starIndex !== -1) {
                templateIndex = starIndex + 1;
                matchIndex++;
                searchIndex = matchIndex;
              } else {
                return false;
              }
            }
            while (templateIndex < template.length && template[templateIndex] === "*") {
              templateIndex++;
            }
            return templateIndex === template.length;
          }
          function disable() {
            const namespaces = [
              ...createDebug.names,
              ...createDebug.skips.map((namespace) => "-" + namespace)
            ].join(",");
            createDebug.enable("");
            return namespaces;
          }
          function enabled(name2) {
            for (const skip of createDebug.skips) {
              if (matchesTemplate(name2, skip)) {
                return false;
              }
            }
            for (const ns of createDebug.names) {
              if (matchesTemplate(name2, ns)) {
                return true;
              }
            }
            return false;
          }
          function coerce(val) {
            if (val instanceof Error) {
              return val.stack || val.message;
            }
            return val;
          }
          function destroy() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
          createDebug.enable(createDebug.load());
          return createDebug;
        }
        common = setup;
        return common;
      }
      var hasRequiredBrowser;
      function requireBrowser() {
        if (hasRequiredBrowser) return browser.exports;
        hasRequiredBrowser = 1;
        (function(module, exports) {
          var define_process_env_default = {};
          exports.formatArgs = formatArgs;
          exports.save = save;
          exports.load = load;
          exports.useColors = useColors;
          exports.storage = localstorage();
          exports.destroy = /* @__PURE__ */ (() => {
            let warned = false;
            return () => {
              if (!warned) {
                warned = true;
                console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
              }
            };
          })();
          exports.colors = [
            "#0000CC",
            "#0000FF",
            "#0033CC",
            "#0033FF",
            "#0066CC",
            "#0066FF",
            "#0099CC",
            "#0099FF",
            "#00CC00",
            "#00CC33",
            "#00CC66",
            "#00CC99",
            "#00CCCC",
            "#00CCFF",
            "#3300CC",
            "#3300FF",
            "#3333CC",
            "#3333FF",
            "#3366CC",
            "#3366FF",
            "#3399CC",
            "#3399FF",
            "#33CC00",
            "#33CC33",
            "#33CC66",
            "#33CC99",
            "#33CCCC",
            "#33CCFF",
            "#6600CC",
            "#6600FF",
            "#6633CC",
            "#6633FF",
            "#66CC00",
            "#66CC33",
            "#9900CC",
            "#9900FF",
            "#9933CC",
            "#9933FF",
            "#99CC00",
            "#99CC33",
            "#CC0000",
            "#CC0033",
            "#CC0066",
            "#CC0099",
            "#CC00CC",
            "#CC00FF",
            "#CC3300",
            "#CC3333",
            "#CC3366",
            "#CC3399",
            "#CC33CC",
            "#CC33FF",
            "#CC6600",
            "#CC6633",
            "#CC9900",
            "#CC9933",
            "#CCCC00",
            "#CCCC33",
            "#FF0000",
            "#FF0033",
            "#FF0066",
            "#FF0099",
            "#FF00CC",
            "#FF00FF",
            "#FF3300",
            "#FF3333",
            "#FF3366",
            "#FF3399",
            "#FF33CC",
            "#FF33FF",
            "#FF6600",
            "#FF6633",
            "#FF9900",
            "#FF9933",
            "#FFCC00",
            "#FFCC33"
          ];
          function useColors() {
            if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
              return true;
            }
            if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
              return false;
            }
            let m;
            return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
            typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
            // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
            typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
            typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
          }
          function formatArgs(args) {
            args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
            if (!this.useColors) {
              return;
            }
            const c = "color: " + this.color;
            args.splice(1, 0, c, "color: inherit");
            let index2 = 0;
            let lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, (match) => {
              if (match === "%%") {
                return;
              }
              index2++;
              if (match === "%c") {
                lastC = index2;
              }
            });
            args.splice(lastC, 0, c);
          }
          exports.log = console.debug || console.log || (() => {
          });
          function save(namespaces) {
            try {
              if (namespaces) {
                exports.storage.setItem("debug", namespaces);
              } else {
                exports.storage.removeItem("debug");
              }
            } catch (error) {
            }
          }
          function load() {
            let r;
            try {
              r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
            } catch (error) {
            }
            if (!r && typeof process !== "undefined" && "env" in process) {
              r = define_process_env_default.DEBUG;
            }
            return r;
          }
          function localstorage() {
            try {
              return localStorage;
            } catch (error) {
            }
          }
          module.exports = requireCommon()(exports);
          const { formatters } = module.exports;
          formatters.j = function(v) {
            try {
              return JSON.stringify(v);
            } catch (error) {
              return "[UnexpectedJSONParseError]: " + error.message;
            }
          };
        })(browser, browser.exports);
        return browser.exports;
      }
      var browserExports = requireBrowser();
      const initDebug = exports("i", /* @__PURE__ */ getDefaultExportFromCjs(browserExports));
      const Signature = {
        LocalFileHeader: 67324752,
        DataDescriptor: 134695760,
        CentralFileHeader: 33639248,
        EndOfCentralDirectory: 101010256
      };
      const DataDescriptor = {
        get(array) {
          UINT16_LE.get(array, 6);
          return {
            signature: UINT32_LE.get(array, 0),
            compressedSize: UINT32_LE.get(array, 8),
            uncompressedSize: UINT32_LE.get(array, 12)
          };
        },
        len: 16
      };
      const LocalFileHeaderToken = {
        get(array) {
          const flags = UINT16_LE.get(array, 6);
          return {
            signature: UINT32_LE.get(array, 0),
            minVersion: UINT16_LE.get(array, 4),
            dataDescriptor: !!(flags & 8),
            compressedMethod: UINT16_LE.get(array, 8),
            compressedSize: UINT32_LE.get(array, 18),
            uncompressedSize: UINT32_LE.get(array, 22),
            filenameLength: UINT16_LE.get(array, 26),
            extraFieldLength: UINT16_LE.get(array, 28),
            filename: null
          };
        },
        len: 30
      };
      const EndOfCentralDirectoryRecordToken = {
        get(array) {
          return {
            signature: UINT32_LE.get(array, 0),
            nrOfThisDisk: UINT16_LE.get(array, 4),
            nrOfThisDiskWithTheStart: UINT16_LE.get(array, 6),
            nrOfEntriesOnThisDisk: UINT16_LE.get(array, 8),
            nrOfEntriesOfSize: UINT16_LE.get(array, 10),
            sizeOfCd: UINT32_LE.get(array, 12),
            offsetOfStartOfCd: UINT32_LE.get(array, 16),
            zipFileCommentLength: UINT16_LE.get(array, 20)
          };
        },
        len: 22
      };
      const FileHeader = {
        get(array) {
          const flags = UINT16_LE.get(array, 8);
          return {
            signature: UINT32_LE.get(array, 0),
            minVersion: UINT16_LE.get(array, 6),
            dataDescriptor: !!(flags & 8),
            compressedMethod: UINT16_LE.get(array, 10),
            compressedSize: UINT32_LE.get(array, 20),
            uncompressedSize: UINT32_LE.get(array, 24),
            filenameLength: UINT16_LE.get(array, 28),
            extraFieldLength: UINT16_LE.get(array, 30),
            fileCommentLength: UINT16_LE.get(array, 32),
            relativeOffsetOfLocalHeader: UINT32_LE.get(array, 42),
            filename: null
          };
        },
        len: 46
      };
      function signatureToArray(signature) {
        const signatureBytes = new Uint8Array(UINT32_LE.len);
        UINT32_LE.put(signatureBytes, 0, signature);
        return signatureBytes;
      }
      const debug$4 = initDebug("tokenizer:inflate");
      const syncBufferSize = 256 * 1024;
      const ddSignatureArray = signatureToArray(Signature.DataDescriptor);
      const eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);
      class ZipHandler {
        constructor(tokenizer) {
          this.tokenizer = tokenizer;
          this.syncBuffer = new Uint8Array(syncBufferSize);
        }
        async isZip() {
          return await this.peekSignature() === Signature.LocalFileHeader;
        }
        peekSignature() {
          return this.tokenizer.peekToken(UINT32_LE);
        }
        async findEndOfCentralDirectoryLocator() {
          const randomReadTokenizer = this.tokenizer;
          const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
          const buffer = this.syncBuffer.subarray(0, chunkLength);
          await this.tokenizer.readBuffer(buffer, { position: randomReadTokenizer.fileInfo.size - chunkLength });
          for (let i = buffer.length - 4; i >= 0; i--) {
            if (buffer[i] === eocdSignatureBytes[0] && buffer[i + 1] === eocdSignatureBytes[1] && buffer[i + 2] === eocdSignatureBytes[2] && buffer[i + 3] === eocdSignatureBytes[3]) {
              return randomReadTokenizer.fileInfo.size - chunkLength + i;
            }
          }
          return -1;
        }
        async readCentralDirectory() {
          if (!this.tokenizer.supportsRandomAccess()) {
            debug$4("Cannot reading central-directory without random-read support");
            return;
          }
          debug$4("Reading central-directory...");
          const pos = this.tokenizer.position;
          const offset = await this.findEndOfCentralDirectoryLocator();
          if (offset > 0) {
            debug$4("Central-directory 32-bit signature found");
            const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
            const files = [];
            this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
            for (let n = 0; n < eocdHeader.nrOfEntriesOfSize; ++n) {
              const entry = await this.tokenizer.readToken(FileHeader);
              if (entry.signature !== Signature.CentralFileHeader) {
                throw new Error("Expected Central-File-Header signature");
              }
              entry.filename = await this.tokenizer.readToken(new StringType(entry.filenameLength, "utf-8"));
              await this.tokenizer.ignore(entry.extraFieldLength);
              await this.tokenizer.ignore(entry.fileCommentLength);
              files.push(entry);
              debug$4(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);
            }
            this.tokenizer.setPosition(pos);
            return files;
          }
          this.tokenizer.setPosition(pos);
        }
        async unzip(fileCb) {
          const entries = await this.readCentralDirectory();
          if (entries) {
            return this.iterateOverCentralDirectory(entries, fileCb);
          }
          let stop = false;
          do {
            const zipHeader = await this.readLocalFileHeader();
            if (!zipHeader)
              break;
            const next = fileCb(zipHeader);
            stop = !!next.stop;
            let fileData = void 0;
            await this.tokenizer.ignore(zipHeader.extraFieldLength);
            if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
              const chunks = [];
              let len = syncBufferSize;
              debug$4("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
              let nextHeaderIndex = -1;
              while (nextHeaderIndex < 0 && len === syncBufferSize) {
                len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
                nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
                const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
                if (next.handler) {
                  const data = new Uint8Array(size);
                  await this.tokenizer.readBuffer(data);
                  chunks.push(data);
                } else {
                  await this.tokenizer.ignore(size);
                }
              }
              debug$4(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
              if (next.handler) {
                await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
              }
            } else {
              if (next.handler) {
                debug$4(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
                fileData = new Uint8Array(zipHeader.compressedSize);
                await this.tokenizer.readBuffer(fileData);
                await this.inflate(zipHeader, fileData, next.handler);
              } else {
                debug$4(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
                await this.tokenizer.ignore(zipHeader.compressedSize);
              }
            }
            debug$4(`Reading data-descriptor at pos=${this.tokenizer.position}`);
            if (zipHeader.dataDescriptor) {
              const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
              if (dataDescriptor.signature !== 134695760) {
                throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
              }
            }
          } while (!stop);
        }
        async iterateOverCentralDirectory(entries, fileCb) {
          for (const fileHeader of entries) {
            const next = fileCb(fileHeader);
            if (next.handler) {
              this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
              const zipHeader = await this.readLocalFileHeader();
              if (zipHeader) {
                await this.tokenizer.ignore(zipHeader.extraFieldLength);
                const fileData = new Uint8Array(fileHeader.compressedSize);
                await this.tokenizer.readBuffer(fileData);
                await this.inflate(zipHeader, fileData, next.handler);
              }
            }
            if (next.stop)
              break;
          }
        }
        inflate(zipHeader, fileData, cb) {
          if (zipHeader.compressedMethod === 0) {
            return cb(fileData);
          }
          debug$4(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
          const uncompressedData = decompressSync(fileData);
          return cb(uncompressedData);
        }
        async readLocalFileHeader() {
          const signature = await this.tokenizer.peekToken(UINT32_LE);
          if (signature === Signature.LocalFileHeader) {
            const header = await this.tokenizer.readToken(LocalFileHeaderToken);
            header.filename = await this.tokenizer.readToken(new StringType(header.filenameLength, "utf-8"));
            return header;
          }
          if (signature === Signature.CentralFileHeader) {
            return false;
          }
          if (signature === 3759263696) {
            throw new Error("Encrypted ZIP");
          }
          throw new Error("Unexpected signature");
        }
      }
      function indexOf(buffer, portion) {
        const bufferLength = buffer.length;
        const portionLength = portion.length;
        if (portionLength > bufferLength)
          return -1;
        for (let i = 0; i <= bufferLength - portionLength; i++) {
          let found = true;
          for (let j = 0; j < portionLength; j++) {
            if (buffer[i + j] !== portion[j]) {
              found = false;
              break;
            }
          }
          if (found) {
            return i;
          }
        }
        return -1;
      }
      function mergeArrays(chunks) {
        const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
        const mergedArray = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
          mergedArray.set(chunk, offset);
          offset += chunk.length;
        }
        return mergedArray;
      }
      const objectToString = Object.prototype.toString;
      const uint8ArrayStringified = "[object Uint8Array]";
      function isType(value, typeConstructor, typeStringified) {
        if (!value) {
          return false;
        }
        if (value.constructor === typeConstructor) {
          return true;
        }
        return objectToString.call(value) === typeStringified;
      }
      function isUint8Array(value) {
        return isType(value, Uint8Array, uint8ArrayStringified);
      }
      function assertUint8Array(value) {
        if (!isUint8Array(value)) {
          throw new TypeError(`Expected \`Uint8Array\`, got \`${typeof value}\``);
        }
      }
      ({
        utf8: new globalThis.TextDecoder("utf8")
      });
      function assertString(value) {
        if (typeof value !== "string") {
          throw new TypeError(`Expected \`string\`, got \`${typeof value}\``);
        }
      }
      new globalThis.TextEncoder();
      const byteToHexLookupTable = Array.from({ length: 256 }, (_, index2) => index2.toString(16).padStart(2, "0"));
      function uint8ArrayToHex(array) {
        assertUint8Array(array);
        let hexString = "";
        for (let index2 = 0; index2 < array.length; index2++) {
          hexString += byteToHexLookupTable[array[index2]];
        }
        return hexString;
      }
      const hexToDecimalLookupTable = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        b: 11,
        c: 12,
        d: 13,
        e: 14,
        f: 15,
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15
      };
      function hexToUint8Array(hexString) {
        assertString(hexString);
        if (hexString.length % 2 !== 0) {
          throw new Error("Invalid Hex string length.");
        }
        const resultLength = hexString.length / 2;
        const bytes = new Uint8Array(resultLength);
        for (let index2 = 0; index2 < resultLength; index2++) {
          const highNibble = hexToDecimalLookupTable[hexString[index2 * 2]];
          const lowNibble = hexToDecimalLookupTable[hexString[index2 * 2 + 1]];
          if (highNibble === void 0 || lowNibble === void 0) {
            throw new Error(`Invalid Hex character encountered at position ${index2 * 2}`);
          }
          bytes[index2] = highNibble << 4 | lowNibble;
        }
        return bytes;
      }
      function getUintBE(view) {
        const { byteLength } = view;
        if (byteLength === 6) {
          return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
        }
        if (byteLength === 5) {
          return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
        }
        if (byteLength === 4) {
          return view.getUint32(0);
        }
        if (byteLength === 3) {
          return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
        }
        if (byteLength === 2) {
          return view.getUint16(0);
        }
        if (byteLength === 1) {
          return view.getUint8(0);
        }
      }
      function stringToBytes$1(string) {
        return [...string].map((character) => character.charCodeAt(0));
      }
      function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
        const readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
        if (Number.isNaN(readSum)) {
          return false;
        }
        let sum = 8 * 32;
        for (let index2 = offset; index2 < offset + 148; index2++) {
          sum += arrayBuffer[index2];
        }
        for (let index2 = offset + 156; index2 < offset + 512; index2++) {
          sum += arrayBuffer[index2];
        }
        return readSum === sum;
      }
      const uint32SyncSafeToken = {
        get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
        len: 4
      };
      const extensions = [
        "jpg",
        "png",
        "apng",
        "gif",
        "webp",
        "flif",
        "xcf",
        "cr2",
        "cr3",
        "orf",
        "arw",
        "dng",
        "nef",
        "rw2",
        "raf",
        "tif",
        "bmp",
        "icns",
        "jxr",
        "psd",
        "indd",
        "zip",
        "tar",
        "rar",
        "gz",
        "bz2",
        "7z",
        "dmg",
        "mp4",
        "mid",
        "mkv",
        "webm",
        "mov",
        "avi",
        "mpg",
        "mp2",
        "mp3",
        "m4a",
        "oga",
        "ogg",
        "ogv",
        "opus",
        "flac",
        "wav",
        "spx",
        "amr",
        "pdf",
        "epub",
        "elf",
        "macho",
        "exe",
        "swf",
        "rtf",
        "wasm",
        "woff",
        "woff2",
        "eot",
        "ttf",
        "otf",
        "ttc",
        "ico",
        "flv",
        "ps",
        "xz",
        "sqlite",
        "nes",
        "crx",
        "xpi",
        "cab",
        "deb",
        "ar",
        "rpm",
        "Z",
        "lz",
        "cfb",
        "mxf",
        "mts",
        "blend",
        "bpg",
        "docx",
        "pptx",
        "xlsx",
        "3gp",
        "3g2",
        "j2c",
        "jp2",
        "jpm",
        "jpx",
        "mj2",
        "aif",
        "qcp",
        "odt",
        "ods",
        "odp",
        "xml",
        "mobi",
        "heic",
        "cur",
        "ktx",
        "ape",
        "wv",
        "dcm",
        "ics",
        "glb",
        "pcap",
        "dsf",
        "lnk",
        "alias",
        "voc",
        "ac3",
        "m4v",
        "m4p",
        "m4b",
        "f4v",
        "f4p",
        "f4b",
        "f4a",
        "mie",
        "asf",
        "ogm",
        "ogx",
        "mpc",
        "arrow",
        "shp",
        "aac",
        "mp1",
        "it",
        "s3m",
        "xm",
        "skp",
        "avif",
        "eps",
        "lzh",
        "pgp",
        "asar",
        "stl",
        "chm",
        "3mf",
        "zst",
        "jxl",
        "vcf",
        "jls",
        "pst",
        "dwg",
        "parquet",
        "class",
        "arj",
        "cpio",
        "ace",
        "avro",
        "icc",
        "fbx",
        "vsdx",
        "vtt",
        "apk",
        "drc",
        "lz4",
        "potx",
        "xltx",
        "dotx",
        "xltm",
        "ott",
        "ots",
        "otp",
        "odg",
        "otg",
        "xlsm",
        "docm",
        "dotm",
        "potm",
        "pptm",
        "jar",
        "rm",
        "ppsm",
        "ppsx"
      ];
      const mimeTypes = [
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/webp",
        "image/flif",
        "image/x-xcf",
        "image/x-canon-cr2",
        "image/x-canon-cr3",
        "image/tiff",
        "image/bmp",
        "image/vnd.ms-photo",
        "image/vnd.adobe.photoshop",
        "application/x-indesign",
        "application/epub+zip",
        "application/x-xpinstall",
        "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
        "application/vnd.oasis.opendocument.text",
        "application/vnd.oasis.opendocument.spreadsheet",
        "application/vnd.oasis.opendocument.presentation",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
        "application/zip",
        "application/x-tar",
        "application/x-rar-compressed",
        "application/gzip",
        "application/x-bzip2",
        "application/x-7z-compressed",
        "application/x-apple-diskimage",
        "application/vnd.apache.arrow.file",
        "video/mp4",
        "audio/midi",
        "video/matroska",
        "video/webm",
        "video/quicktime",
        "video/vnd.avi",
        "audio/wav",
        "audio/qcelp",
        "audio/x-ms-asf",
        "video/x-ms-asf",
        "application/vnd.ms-asf",
        "video/mpeg",
        "video/3gpp",
        "audio/mpeg",
        "audio/mp4",
        // RFC 4337
        "video/ogg",
        "audio/ogg",
        "audio/ogg; codecs=opus",
        "application/ogg",
        "audio/flac",
        "audio/ape",
        "audio/wavpack",
        "audio/amr",
        "application/pdf",
        "application/x-elf",
        "application/x-mach-binary",
        "application/x-msdownload",
        "application/x-shockwave-flash",
        "application/rtf",
        "application/wasm",
        "font/woff",
        "font/woff2",
        "application/vnd.ms-fontobject",
        "font/ttf",
        "font/otf",
        "font/collection",
        "image/x-icon",
        "video/x-flv",
        "application/postscript",
        "application/eps",
        "application/x-xz",
        "application/x-sqlite3",
        "application/x-nintendo-nes-rom",
        "application/x-google-chrome-extension",
        "application/vnd.ms-cab-compressed",
        "application/x-deb",
        "application/x-unix-archive",
        "application/x-rpm",
        "application/x-compress",
        "application/x-lzip",
        "application/x-cfb",
        "application/x-mie",
        "application/mxf",
        "video/mp2t",
        "application/x-blender",
        "image/bpg",
        "image/j2c",
        "image/jp2",
        "image/jpx",
        "image/jpm",
        "image/mj2",
        "audio/aiff",
        "application/xml",
        "application/x-mobipocket-ebook",
        "image/heif",
        "image/heif-sequence",
        "image/heic",
        "image/heic-sequence",
        "image/icns",
        "image/ktx",
        "application/dicom",
        "audio/x-musepack",
        "text/calendar",
        "text/vcard",
        "text/vtt",
        "model/gltf-binary",
        "application/vnd.tcpdump.pcap",
        "audio/x-dsf",
        // Non-standard
        "application/x.ms.shortcut",
        // Invented by us
        "application/x.apple.alias",
        // Invented by us
        "audio/x-voc",
        "audio/vnd.dolby.dd-raw",
        "audio/x-m4a",
        "image/apng",
        "image/x-olympus-orf",
        "image/x-sony-arw",
        "image/x-adobe-dng",
        "image/x-nikon-nef",
        "image/x-panasonic-rw2",
        "image/x-fujifilm-raf",
        "video/x-m4v",
        "video/3gpp2",
        "application/x-esri-shape",
        "audio/aac",
        "audio/x-it",
        "audio/x-s3m",
        "audio/x-xm",
        "video/MP1S",
        "video/MP2P",
        "application/vnd.sketchup.skp",
        "image/avif",
        "application/x-lzh-compressed",
        "application/pgp-encrypted",
        "application/x-asar",
        "model/stl",
        "application/vnd.ms-htmlhelp",
        "model/3mf",
        "image/jxl",
        "application/zstd",
        "image/jls",
        "application/vnd.ms-outlook",
        "image/vnd.dwg",
        "application/vnd.apache.parquet",
        "application/java-vm",
        "application/x-arj",
        "application/x-cpio",
        "application/x-ace-compressed",
        "application/avro",
        "application/vnd.iccprofile",
        "application/x.autodesk.fbx",
        // Invented by us
        "application/vnd.visio",
        "application/vnd.android.package-archive",
        "application/vnd.google.draco",
        // Invented by us
        "application/x-lz4",
        // Invented by us
        "application/vnd.openxmlformats-officedocument.presentationml.template",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
        "application/vnd.ms-excel.template.macroenabled.12",
        "application/vnd.oasis.opendocument.text-template",
        "application/vnd.oasis.opendocument.spreadsheet-template",
        "application/vnd.oasis.opendocument.presentation-template",
        "application/vnd.oasis.opendocument.graphics",
        "application/vnd.oasis.opendocument.graphics-template",
        "application/vnd.ms-excel.sheet.macroenabled.12",
        "application/vnd.ms-word.document.macroenabled.12",
        "application/vnd.ms-word.template.macroenabled.12",
        "application/vnd.ms-powerpoint.template.macroenabled.12",
        "application/vnd.ms-powerpoint.presentation.macroenabled.12",
        "application/java-archive",
        "application/vnd.rn-realmedia"
      ];
      const reasonableDetectionSizeInBytes = 4100;
      async function fileTypeFromBuffer(input, options) {
        return new FileTypeParser(options).fromBuffer(input);
      }
      function getFileTypeFromMimeType(mimeType) {
        mimeType = mimeType.toLowerCase();
        switch (mimeType) {
          case "application/epub+zip":
            return {
              ext: "epub",
              mime: mimeType
            };
          case "application/vnd.oasis.opendocument.text":
            return {
              ext: "odt",
              mime: mimeType
            };
          case "application/vnd.oasis.opendocument.text-template":
            return {
              ext: "ott",
              mime: mimeType
            };
          case "application/vnd.oasis.opendocument.spreadsheet":
            return {
              ext: "ods",
              mime: mimeType
            };
          case "application/vnd.oasis.opendocument.spreadsheet-template":
            return {
              ext: "ots",
              mime: mimeType
            };
          case "application/vnd.oasis.opendocument.presentation":
            return {
              ext: "odp",
              mime: mimeType
            };
          case "application/vnd.oasis.opendocument.presentation-template":
            return {
              ext: "otp",
              mime: mimeType
            };
          case "application/vnd.oasis.opendocument.graphics":
            return {
              ext: "odg",
              mime: mimeType
            };
          case "application/vnd.oasis.opendocument.graphics-template":
            return {
              ext: "otg",
              mime: mimeType
            };
          case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
            return {
              ext: "ppsx",
              mime: mimeType
            };
          case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
            return {
              ext: "xlsx",
              mime: mimeType
            };
          case "application/vnd.ms-excel.sheet.macroenabled":
            return {
              ext: "xlsm",
              mime: "application/vnd.ms-excel.sheet.macroenabled.12"
            };
          case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
            return {
              ext: "xltx",
              mime: mimeType
            };
          case "application/vnd.ms-excel.template.macroenabled":
            return {
              ext: "xltm",
              mime: "application/vnd.ms-excel.template.macroenabled.12"
            };
          case "application/vnd.ms-powerpoint.slideshow.macroenabled":
            return {
              ext: "ppsm",
              mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
            };
          case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
            return {
              ext: "docx",
              mime: mimeType
            };
          case "application/vnd.ms-word.document.macroenabled":
            return {
              ext: "docm",
              mime: "application/vnd.ms-word.document.macroenabled.12"
            };
          case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
            return {
              ext: "dotx",
              mime: mimeType
            };
          case "application/vnd.ms-word.template.macroenabledtemplate":
            return {
              ext: "dotm",
              mime: "application/vnd.ms-word.template.macroenabled.12"
            };
          case "application/vnd.openxmlformats-officedocument.presentationml.template":
            return {
              ext: "potx",
              mime: mimeType
            };
          case "application/vnd.ms-powerpoint.template.macroenabled":
            return {
              ext: "potm",
              mime: "application/vnd.ms-powerpoint.template.macroenabled.12"
            };
          case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
            return {
              ext: "pptx",
              mime: mimeType
            };
          case "application/vnd.ms-powerpoint.presentation.macroenabled":
            return {
              ext: "pptm",
              mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12"
            };
          case "application/vnd.ms-visio.drawing":
            return {
              ext: "vsdx",
              mime: "application/vnd.visio"
            };
          case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
            return {
              ext: "3mf",
              mime: "model/3mf"
            };
        }
      }
      function _check(buffer, headers, options) {
        options = {
          offset: 0,
          ...options
        };
        for (const [index2, header] of headers.entries()) {
          if (options.mask) {
            if (header !== (options.mask[index2] & buffer[index2 + options.offset])) {
              return false;
            }
          } else if (header !== buffer[index2 + options.offset]) {
            return false;
          }
        }
        return true;
      }
      class FileTypeParser {
        constructor(options) {
          this.options = {
            mpegOffsetTolerance: 0,
            ...options
          };
          this.detectors = [
            ...options?.customDetectors ?? [],
            { id: "core", detect: this.detectConfident },
            { id: "core.imprecise", detect: this.detectImprecise }
          ];
          this.tokenizerOptions = {
            abortSignal: options?.signal
          };
        }
        async fromTokenizer(tokenizer) {
          const initialPosition = tokenizer.position;
          for (const detector of this.detectors) {
            const fileType = await detector.detect(tokenizer);
            if (fileType) {
              return fileType;
            }
            if (initialPosition !== tokenizer.position) {
              return void 0;
            }
          }
        }
        async fromBuffer(input) {
          if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
            throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
          }
          const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
          if (!(buffer?.length > 1)) {
            return;
          }
          return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
        }
        async fromBlob(blob) {
          return this.fromStream(blob.stream());
        }
        async fromStream(stream) {
          const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
          try {
            return await this.fromTokenizer(tokenizer);
          } finally {
            await tokenizer.close();
          }
        }
        async toDetectionStream(stream, options) {
          const { sampleSize = reasonableDetectionSizeInBytes } = options;
          let detectedFileType;
          let firstChunk;
          const reader = stream.getReader({ mode: "byob" });
          try {
            const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
            firstChunk = chunk;
            if (!done && chunk) {
              try {
                detectedFileType = await this.fromBuffer(chunk.subarray(0, sampleSize));
              } catch (error) {
                if (!(error instanceof EndOfStreamError)) {
                  throw error;
                }
                detectedFileType = void 0;
              }
            }
            firstChunk = chunk;
          } finally {
            reader.releaseLock();
          }
          const transformStream = new TransformStream({
            async start(controller) {
              controller.enqueue(firstChunk);
            },
            transform(chunk, controller) {
              controller.enqueue(chunk);
            }
          });
          const newStream = stream.pipeThrough(transformStream);
          newStream.fileType = detectedFileType;
          return newStream;
        }
        check(header, options) {
          return _check(this.buffer, header, options);
        }
        checkString(header, options) {
          return this.check(stringToBytes$1(header), options);
        }
        // Detections with a high degree of certainty in identifying the correct file type
        detectConfident = async (tokenizer) => {
          this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
          if (tokenizer.fileInfo.size === void 0) {
            tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
          }
          this.tokenizer = tokenizer;
          await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
          if (this.check([66, 77])) {
            return {
              ext: "bmp",
              mime: "image/bmp"
            };
          }
          if (this.check([11, 119])) {
            return {
              ext: "ac3",
              mime: "audio/vnd.dolby.dd-raw"
            };
          }
          if (this.check([120, 1])) {
            return {
              ext: "dmg",
              mime: "application/x-apple-diskimage"
            };
          }
          if (this.check([77, 90])) {
            return {
              ext: "exe",
              mime: "application/x-msdownload"
            };
          }
          if (this.check([37, 33])) {
            await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
            if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
              return {
                ext: "eps",
                mime: "application/eps"
              };
            }
            return {
              ext: "ps",
              mime: "application/postscript"
            };
          }
          if (this.check([31, 160]) || this.check([31, 157])) {
            return {
              ext: "Z",
              mime: "application/x-compress"
            };
          }
          if (this.check([199, 113])) {
            return {
              ext: "cpio",
              mime: "application/x-cpio"
            };
          }
          if (this.check([96, 234])) {
            return {
              ext: "arj",
              mime: "application/x-arj"
            };
          }
          if (this.check([239, 187, 191])) {
            this.tokenizer.ignore(3);
            return this.detectConfident(tokenizer);
          }
          if (this.check([71, 73, 70])) {
            return {
              ext: "gif",
              mime: "image/gif"
            };
          }
          if (this.check([73, 73, 188])) {
            return {
              ext: "jxr",
              mime: "image/vnd.ms-photo"
            };
          }
          if (this.check([31, 139, 8])) {
            return {
              ext: "gz",
              mime: "application/gzip"
            };
          }
          if (this.check([66, 90, 104])) {
            return {
              ext: "bz2",
              mime: "application/x-bzip2"
            };
          }
          if (this.checkString("ID3")) {
            await tokenizer.ignore(6);
            const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
            if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
              return {
                ext: "mp3",
                mime: "audio/mpeg"
              };
            }
            await tokenizer.ignore(id3HeaderLength);
            return this.fromTokenizer(tokenizer);
          }
          if (this.checkString("MP+")) {
            return {
              ext: "mpc",
              mime: "audio/x-musepack"
            };
          }
          if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
            return {
              ext: "swf",
              mime: "application/x-shockwave-flash"
            };
          }
          if (this.check([255, 216, 255])) {
            if (this.check([247], { offset: 3 })) {
              return {
                ext: "jls",
                mime: "image/jls"
              };
            }
            return {
              ext: "jpg",
              mime: "image/jpeg"
            };
          }
          if (this.check([79, 98, 106, 1])) {
            return {
              ext: "avro",
              mime: "application/avro"
            };
          }
          if (this.checkString("FLIF")) {
            return {
              ext: "flif",
              mime: "image/flif"
            };
          }
          if (this.checkString("8BPS")) {
            return {
              ext: "psd",
              mime: "image/vnd.adobe.photoshop"
            };
          }
          if (this.checkString("MPCK")) {
            return {
              ext: "mpc",
              mime: "audio/x-musepack"
            };
          }
          if (this.checkString("FORM")) {
            return {
              ext: "aif",
              mime: "audio/aiff"
            };
          }
          if (this.checkString("icns", { offset: 0 })) {
            return {
              ext: "icns",
              mime: "image/icns"
            };
          }
          if (this.check([80, 75, 3, 4])) {
            let fileType;
            await new ZipHandler(tokenizer).unzip((zipHeader) => {
              switch (zipHeader.filename) {
                case "META-INF/mozilla.rsa":
                  fileType = {
                    ext: "xpi",
                    mime: "application/x-xpinstall"
                  };
                  return {
                    stop: true
                  };
                case "META-INF/MANIFEST.MF":
                  fileType = {
                    ext: "jar",
                    mime: "application/java-archive"
                  };
                  return {
                    stop: true
                  };
                case "mimetype":
                  return {
                    async handler(fileData) {
                      const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
                      fileType = getFileTypeFromMimeType(mimeType);
                    },
                    stop: true
                  };
                case "[Content_Types].xml":
                  return {
                    async handler(fileData) {
                      let xmlContent = new TextDecoder("utf-8").decode(fileData);
                      const endPos = xmlContent.indexOf('.main+xml"');
                      if (endPos === -1) {
                        const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                        if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                          fileType = getFileTypeFromMimeType(mimeType);
                        }
                      } else {
                        xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                        const firstPos = xmlContent.lastIndexOf('"');
                        const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                        fileType = getFileTypeFromMimeType(mimeType);
                      }
                    },
                    stop: true
                  };
                default:
                  if (/classes\d*\.dex/.test(zipHeader.filename)) {
                    fileType = {
                      ext: "apk",
                      mime: "application/vnd.android.package-archive"
                    };
                    return { stop: true };
                  }
                  return {};
              }
            });
            return fileType ?? {
              ext: "zip",
              mime: "application/zip"
            };
          }
          if (this.checkString("OggS")) {
            await tokenizer.ignore(28);
            const type = new Uint8Array(8);
            await tokenizer.readBuffer(type);
            if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
              return {
                ext: "opus",
                mime: "audio/ogg; codecs=opus"
              };
            }
            if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
              return {
                ext: "ogv",
                mime: "video/ogg"
              };
            }
            if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
              return {
                ext: "ogm",
                mime: "video/ogg"
              };
            }
            if (_check(type, [127, 70, 76, 65, 67])) {
              return {
                ext: "oga",
                mime: "audio/ogg"
              };
            }
            if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
              return {
                ext: "spx",
                mime: "audio/ogg"
              };
            }
            if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
              return {
                ext: "ogg",
                mime: "audio/ogg"
              };
            }
            return {
              ext: "ogx",
              mime: "application/ogg"
            };
          }
          if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
            return {
              ext: "zip",
              mime: "application/zip"
            };
          }
          if (this.checkString("MThd")) {
            return {
              ext: "mid",
              mime: "audio/midi"
            };
          }
          if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
            return {
              ext: "woff",
              mime: "font/woff"
            };
          }
          if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
            return {
              ext: "woff2",
              mime: "font/woff2"
            };
          }
          if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
            return {
              ext: "pcap",
              mime: "application/vnd.tcpdump.pcap"
            };
          }
          if (this.checkString("DSD ")) {
            return {
              ext: "dsf",
              mime: "audio/x-dsf"
              // Non-standard
            };
          }
          if (this.checkString("LZIP")) {
            return {
              ext: "lz",
              mime: "application/x-lzip"
            };
          }
          if (this.checkString("fLaC")) {
            return {
              ext: "flac",
              mime: "audio/flac"
            };
          }
          if (this.check([66, 80, 71, 251])) {
            return {
              ext: "bpg",
              mime: "image/bpg"
            };
          }
          if (this.checkString("wvpk")) {
            return {
              ext: "wv",
              mime: "audio/wavpack"
            };
          }
          if (this.checkString("%PDF")) {
            return {
              ext: "pdf",
              mime: "application/pdf"
            };
          }
          if (this.check([0, 97, 115, 109])) {
            return {
              ext: "wasm",
              mime: "application/wasm"
            };
          }
          if (this.check([73, 73])) {
            const fileType = await this.readTiffHeader(false);
            if (fileType) {
              return fileType;
            }
          }
          if (this.check([77, 77])) {
            const fileType = await this.readTiffHeader(true);
            if (fileType) {
              return fileType;
            }
          }
          if (this.checkString("MAC ")) {
            return {
              ext: "ape",
              mime: "audio/ape"
            };
          }
          if (this.check([26, 69, 223, 163])) {
            async function readField() {
              const msb = await tokenizer.peekNumber(UINT8);
              let mask = 128;
              let ic = 0;
              while ((msb & mask) === 0 && mask !== 0) {
                ++ic;
                mask >>= 1;
              }
              const id = new Uint8Array(ic + 1);
              await tokenizer.readBuffer(id);
              return id;
            }
            async function readElement() {
              const idField = await readField();
              const lengthField = await readField();
              lengthField[0] ^= 128 >> lengthField.length - 1;
              const nrLength = Math.min(6, lengthField.length);
              const idView = new DataView(idField.buffer);
              const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
              return {
                id: getUintBE(idView),
                len: getUintBE(lengthView)
              };
            }
            async function readChildren(children) {
              while (children > 0) {
                const element = await readElement();
                if (element.id === 17026) {
                  const rawValue = await tokenizer.readToken(new StringType(element.len));
                  return rawValue.replaceAll(/\00.*$/g, "");
                }
                await tokenizer.ignore(element.len);
                --children;
              }
            }
            const re = await readElement();
            const documentType = await readChildren(re.len);
            switch (documentType) {
              case "webm":
                return {
                  ext: "webm",
                  mime: "video/webm"
                };
              case "matroska":
                return {
                  ext: "mkv",
                  mime: "video/matroska"
                };
              default:
                return;
            }
          }
          if (this.checkString("SQLi")) {
            return {
              ext: "sqlite",
              mime: "application/x-sqlite3"
            };
          }
          if (this.check([78, 69, 83, 26])) {
            return {
              ext: "nes",
              mime: "application/x-nintendo-nes-rom"
            };
          }
          if (this.checkString("Cr24")) {
            return {
              ext: "crx",
              mime: "application/x-google-chrome-extension"
            };
          }
          if (this.checkString("MSCF") || this.checkString("ISc(")) {
            return {
              ext: "cab",
              mime: "application/vnd.ms-cab-compressed"
            };
          }
          if (this.check([237, 171, 238, 219])) {
            return {
              ext: "rpm",
              mime: "application/x-rpm"
            };
          }
          if (this.check([197, 208, 211, 198])) {
            return {
              ext: "eps",
              mime: "application/eps"
            };
          }
          if (this.check([40, 181, 47, 253])) {
            return {
              ext: "zst",
              mime: "application/zstd"
            };
          }
          if (this.check([127, 69, 76, 70])) {
            return {
              ext: "elf",
              mime: "application/x-elf"
            };
          }
          if (this.check([33, 66, 68, 78])) {
            return {
              ext: "pst",
              mime: "application/vnd.ms-outlook"
            };
          }
          if (this.checkString("PAR1") || this.checkString("PARE")) {
            return {
              ext: "parquet",
              mime: "application/vnd.apache.parquet"
            };
          }
          if (this.checkString("ttcf")) {
            return {
              ext: "ttc",
              mime: "font/collection"
            };
          }
          if (this.check([207, 250, 237, 254])) {
            return {
              ext: "macho",
              mime: "application/x-mach-binary"
            };
          }
          if (this.check([4, 34, 77, 24])) {
            return {
              ext: "lz4",
              mime: "application/x-lz4"
              // Invented by us
            };
          }
          if (this.check([79, 84, 84, 79, 0])) {
            return {
              ext: "otf",
              mime: "font/otf"
            };
          }
          if (this.checkString("#!AMR")) {
            return {
              ext: "amr",
              mime: "audio/amr"
            };
          }
          if (this.checkString("{\\rtf")) {
            return {
              ext: "rtf",
              mime: "application/rtf"
            };
          }
          if (this.check([70, 76, 86, 1])) {
            return {
              ext: "flv",
              mime: "video/x-flv"
            };
          }
          if (this.checkString("IMPM")) {
            return {
              ext: "it",
              mime: "audio/x-it"
            };
          }
          if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
            return {
              ext: "lzh",
              mime: "application/x-lzh-compressed"
            };
          }
          if (this.check([0, 0, 1, 186])) {
            if (this.check([33], { offset: 4, mask: [241] })) {
              return {
                ext: "mpg",
                // May also be .ps, .mpeg
                mime: "video/MP1S"
              };
            }
            if (this.check([68], { offset: 4, mask: [196] })) {
              return {
                ext: "mpg",
                // May also be .mpg, .m2p, .vob or .sub
                mime: "video/MP2P"
              };
            }
          }
          if (this.checkString("ITSF")) {
            return {
              ext: "chm",
              mime: "application/vnd.ms-htmlhelp"
            };
          }
          if (this.check([202, 254, 186, 190])) {
            return {
              ext: "class",
              mime: "application/java-vm"
            };
          }
          if (this.checkString(".RMF")) {
            return {
              ext: "rm",
              mime: "application/vnd.rn-realmedia"
            };
          }
          if (this.checkString("DRACO")) {
            return {
              ext: "drc",
              mime: "application/vnd.google.draco"
              // Invented by us
            };
          }
          if (this.check([253, 55, 122, 88, 90, 0])) {
            return {
              ext: "xz",
              mime: "application/x-xz"
            };
          }
          if (this.checkString("<?xml ")) {
            return {
              ext: "xml",
              mime: "application/xml"
            };
          }
          if (this.check([55, 122, 188, 175, 39, 28])) {
            return {
              ext: "7z",
              mime: "application/x-7z-compressed"
            };
          }
          if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
            return {
              ext: "rar",
              mime: "application/x-rar-compressed"
            };
          }
          if (this.checkString("solid ")) {
            return {
              ext: "stl",
              mime: "model/stl"
            };
          }
          if (this.checkString("AC")) {
            const version = new StringType(4, "latin1").get(this.buffer, 2);
            if (version.match("^d*") && version >= 1e3 && version <= 1050) {
              return {
                ext: "dwg",
                mime: "image/vnd.dwg"
              };
            }
          }
          if (this.checkString("070707")) {
            return {
              ext: "cpio",
              mime: "application/x-cpio"
            };
          }
          if (this.checkString("BLENDER")) {
            return {
              ext: "blend",
              mime: "application/x-blender"
            };
          }
          if (this.checkString("!<arch>")) {
            await tokenizer.ignore(8);
            const string = await tokenizer.readToken(new StringType(13, "ascii"));
            if (string === "debian-binary") {
              return {
                ext: "deb",
                mime: "application/x-deb"
              };
            }
            return {
              ext: "ar",
              mime: "application/x-unix-archive"
            };
          }
          if (this.checkString("WEBVTT") && // One of LF, CR, tab, space, or end of file must follow "WEBVTT" per the spec (see `fixture/fixture-vtt-*.vtt` for examples). Note that `\0` is technically the null character (there is no such thing as an EOF character). However, checking for `\0` gives us the same result as checking for the end of the stream.
          ["\n", "\r", "	", " ", "\0"].some((char7) => this.checkString(char7, { offset: 6 }))) {
            return {
              ext: "vtt",
              mime: "text/vtt"
            };
          }
          if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
            await tokenizer.ignore(8);
            async function readChunkHeader() {
              return {
                length: await tokenizer.readToken(INT32_BE),
                type: await tokenizer.readToken(new StringType(4, "latin1"))
              };
            }
            do {
              const chunk = await readChunkHeader();
              if (chunk.length < 0) {
                return;
              }
              switch (chunk.type) {
                case "IDAT":
                  return {
                    ext: "png",
                    mime: "image/png"
                  };
                case "acTL":
                  return {
                    ext: "apng",
                    mime: "image/apng"
                  };
                default:
                  await tokenizer.ignore(chunk.length + 4);
              }
            } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
            return {
              ext: "png",
              mime: "image/png"
            };
          }
          if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
            return {
              ext: "arrow",
              mime: "application/vnd.apache.arrow.file"
            };
          }
          if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
            return {
              ext: "glb",
              mime: "model/gltf-binary"
            };
          }
          if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
            return {
              ext: "mov",
              mime: "video/quicktime"
            };
          }
          if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
            return {
              ext: "orf",
              mime: "image/x-olympus-orf"
            };
          }
          if (this.checkString("gimp xcf ")) {
            return {
              ext: "xcf",
              mime: "image/x-xcf"
            };
          }
          if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
            const brandMajor = new StringType(4, "latin1").get(this.buffer, 8).replace("\0", " ").trim();
            switch (brandMajor) {
              case "avif":
              case "avis":
                return { ext: "avif", mime: "image/avif" };
              case "mif1":
                return { ext: "heic", mime: "image/heif" };
              case "msf1":
                return { ext: "heic", mime: "image/heif-sequence" };
              case "heic":
              case "heix":
                return { ext: "heic", mime: "image/heic" };
              case "hevc":
              case "hevx":
                return { ext: "heic", mime: "image/heic-sequence" };
              case "qt":
                return { ext: "mov", mime: "video/quicktime" };
              case "M4V":
              case "M4VH":
              case "M4VP":
                return { ext: "m4v", mime: "video/x-m4v" };
              case "M4P":
                return { ext: "m4p", mime: "video/mp4" };
              case "M4B":
                return { ext: "m4b", mime: "audio/mp4" };
              case "M4A":
                return { ext: "m4a", mime: "audio/x-m4a" };
              case "F4V":
                return { ext: "f4v", mime: "video/mp4" };
              case "F4P":
                return { ext: "f4p", mime: "video/mp4" };
              case "F4A":
                return { ext: "f4a", mime: "audio/mp4" };
              case "F4B":
                return { ext: "f4b", mime: "audio/mp4" };
              case "crx":
                return { ext: "cr3", mime: "image/x-canon-cr3" };
              default:
                if (brandMajor.startsWith("3g")) {
                  if (brandMajor.startsWith("3g2")) {
                    return { ext: "3g2", mime: "video/3gpp2" };
                  }
                  return { ext: "3gp", mime: "video/3gpp" };
                }
                return { ext: "mp4", mime: "video/mp4" };
            }
          }
          if (this.check([82, 73, 70, 70])) {
            if (this.checkString("WEBP", { offset: 8 })) {
              return {
                ext: "webp",
                mime: "image/webp"
              };
            }
            if (this.check([65, 86, 73], { offset: 8 })) {
              return {
                ext: "avi",
                mime: "video/vnd.avi"
              };
            }
            if (this.check([87, 65, 86, 69], { offset: 8 })) {
              return {
                ext: "wav",
                mime: "audio/wav"
              };
            }
            if (this.check([81, 76, 67, 77], { offset: 8 })) {
              return {
                ext: "qcp",
                mime: "audio/qcelp"
              };
            }
          }
          if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
            return {
              ext: "rw2",
              mime: "image/x-panasonic-rw2"
            };
          }
          if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
            async function readHeader() {
              const guid = new Uint8Array(16);
              await tokenizer.readBuffer(guid);
              return {
                id: guid,
                size: Number(await tokenizer.readToken(UINT64_LE))
              };
            }
            await tokenizer.ignore(30);
            while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
              const header = await readHeader();
              let payload = header.size - 24;
              if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
                const typeId = new Uint8Array(16);
                payload -= await tokenizer.readBuffer(typeId);
                if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
                  return {
                    ext: "asf",
                    mime: "audio/x-ms-asf"
                  };
                }
                if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
                  return {
                    ext: "asf",
                    mime: "video/x-ms-asf"
                  };
                }
                break;
              }
              await tokenizer.ignore(payload);
            }
            return {
              ext: "asf",
              mime: "application/vnd.ms-asf"
            };
          }
          if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
            return {
              ext: "ktx",
              mime: "image/ktx"
            };
          }
          if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
            return {
              ext: "mie",
              mime: "application/x-mie"
            };
          }
          if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
            return {
              ext: "shp",
              mime: "application/x-esri-shape"
            };
          }
          if (this.check([255, 79, 255, 81])) {
            return {
              ext: "j2c",
              mime: "image/j2c"
            };
          }
          if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
            await tokenizer.ignore(20);
            const type = await tokenizer.readToken(new StringType(4, "ascii"));
            switch (type) {
              case "jp2 ":
                return {
                  ext: "jp2",
                  mime: "image/jp2"
                };
              case "jpx ":
                return {
                  ext: "jpx",
                  mime: "image/jpx"
                };
              case "jpm ":
                return {
                  ext: "jpm",
                  mime: "image/jpm"
                };
              case "mjp2":
                return {
                  ext: "mj2",
                  mime: "image/mj2"
                };
              default:
                return;
            }
          }
          if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
            return {
              ext: "jxl",
              mime: "image/jxl"
            };
          }
          if (this.check([254, 255])) {
            if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
              return {
                ext: "xml",
                mime: "application/xml"
              };
            }
            return void 0;
          }
          if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
            return {
              ext: "cfb",
              mime: "application/x-cfb"
            };
          }
          await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
          if (this.check([97, 99, 115, 112], { offset: 36 })) {
            return {
              ext: "icc",
              mime: "application/vnd.iccprofile"
            };
          }
          if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
            return {
              ext: "ace",
              mime: "application/x-ace-compressed"
            };
          }
          if (this.checkString("BEGIN:")) {
            if (this.checkString("VCARD", { offset: 6 })) {
              return {
                ext: "vcf",
                mime: "text/vcard"
              };
            }
            if (this.checkString("VCALENDAR", { offset: 6 })) {
              return {
                ext: "ics",
                mime: "text/calendar"
              };
            }
          }
          if (this.checkString("FUJIFILMCCD-RAW")) {
            return {
              ext: "raf",
              mime: "image/x-fujifilm-raf"
            };
          }
          if (this.checkString("Extended Module:")) {
            return {
              ext: "xm",
              mime: "audio/x-xm"
            };
          }
          if (this.checkString("Creative Voice File")) {
            return {
              ext: "voc",
              mime: "audio/x-voc"
            };
          }
          if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
            const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
            if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
              try {
                const header = new TextDecoder().decode(this.buffer.subarray(16, jsonSize + 16));
                const json = JSON.parse(header);
                if (json.files) {
                  return {
                    ext: "asar",
                    mime: "application/x-asar"
                  };
                }
              } catch {
              }
            }
          }
          if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
            return {
              ext: "mxf",
              mime: "application/mxf"
            };
          }
          if (this.checkString("SCRM", { offset: 44 })) {
            return {
              ext: "s3m",
              mime: "audio/x-s3m"
            };
          }
          if (this.check([71]) && this.check([71], { offset: 188 })) {
            return {
              ext: "mts",
              mime: "video/mp2t"
            };
          }
          if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
            return {
              ext: "mts",
              mime: "video/mp2t"
            };
          }
          if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
            return {
              ext: "mobi",
              mime: "application/x-mobipocket-ebook"
            };
          }
          if (this.check([68, 73, 67, 77], { offset: 128 })) {
            return {
              ext: "dcm",
              mime: "application/dicom"
            };
          }
          if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
            return {
              ext: "lnk",
              mime: "application/x.ms.shortcut"
              // Invented by us
            };
          }
          if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
            return {
              ext: "alias",
              mime: "application/x.apple.alias"
              // Invented by us
            };
          }
          if (this.checkString("Kaydara FBX Binary  \0")) {
            return {
              ext: "fbx",
              mime: "application/x.autodesk.fbx"
              // Invented by us
            };
          }
          if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
            return {
              ext: "eot",
              mime: "application/vnd.ms-fontobject"
            };
          }
          if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
            return {
              ext: "indd",
              mime: "application/x-indesign"
            };
          }
          await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
          if (this.checkString("ustar", { offset: 257 }) && (this.checkString("\0", { offset: 262 }) || this.checkString(" ", { offset: 262 })) || this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && tarHeaderChecksumMatches(this.buffer)) {
            return {
              ext: "tar",
              mime: "application/x-tar"
            };
          }
          if (this.check([255, 254])) {
            if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
              return {
                ext: "xml",
                mime: "application/xml"
              };
            }
            if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
              return {
                ext: "skp",
                mime: "application/vnd.sketchup.skp"
              };
            }
            return void 0;
          }
          if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
            return {
              ext: "pgp",
              mime: "application/pgp-encrypted"
            };
          }
        };
        // Detections with limited supporting data, resulting in a higher likelihood of false positives
        detectImprecise = async (tokenizer) => {
          this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
          await tokenizer.peekBuffer(this.buffer, { length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true });
          if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
            return {
              ext: "mpg",
              mime: "video/mpeg"
            };
          }
          if (this.check([0, 1, 0, 0, 0])) {
            return {
              ext: "ttf",
              mime: "font/ttf"
            };
          }
          if (this.check([0, 0, 1, 0])) {
            return {
              ext: "ico",
              mime: "image/x-icon"
            };
          }
          if (this.check([0, 0, 2, 0])) {
            return {
              ext: "cur",
              mime: "image/x-icon"
            };
          }
          await tokenizer.peekBuffer(this.buffer, { length: Math.min(2 + this.options.mpegOffsetTolerance, tokenizer.fileInfo.size), mayBeLess: true });
          if (this.buffer.length >= 2 + this.options.mpegOffsetTolerance) {
            for (let depth = 0; depth <= this.options.mpegOffsetTolerance; ++depth) {
              const type = this.scanMpeg(depth);
              if (type) {
                return type;
              }
            }
          }
        };
        async readTiffTag(bigEndian) {
          const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
          this.tokenizer.ignore(10);
          switch (tagId) {
            case 50341:
              return {
                ext: "arw",
                mime: "image/x-sony-arw"
              };
            case 50706:
              return {
                ext: "dng",
                mime: "image/x-adobe-dng"
              };
          }
        }
        async readTiffIFD(bigEndian) {
          const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
          for (let n = 0; n < numberOfTags; ++n) {
            const fileType = await this.readTiffTag(bigEndian);
            if (fileType) {
              return fileType;
            }
          }
        }
        async readTiffHeader(bigEndian) {
          const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
          const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
          if (version === 42) {
            if (ifdOffset >= 6) {
              if (this.checkString("CR", { offset: 8 })) {
                return {
                  ext: "cr2",
                  mime: "image/x-canon-cr2"
                };
              }
              if (ifdOffset >= 8) {
                const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
                const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
                if (someId1 === 28 && someId2 === 254 || someId1 === 31 && someId2 === 11) {
                  return {
                    ext: "nef",
                    mime: "image/x-nikon-nef"
                  };
                }
              }
            }
            await this.tokenizer.ignore(ifdOffset);
            const fileType = await this.readTiffIFD(bigEndian);
            return fileType ?? {
              ext: "tif",
              mime: "image/tiff"
            };
          }
          if (version === 43) {
            return {
              ext: "tif",
              mime: "image/tiff"
            };
          }
        }
        /**
        	Scan check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE).
        
        	@param offset - Offset to scan for sync-preamble.
        	@returns {{ext: string, mime: string}}
        	*/
        scanMpeg(offset) {
          if (this.check([255, 224], { offset, mask: [255, 224] })) {
            if (this.check([16], { offset: offset + 1, mask: [22] })) {
              if (this.check([8], { offset: offset + 1, mask: [8] })) {
                return {
                  ext: "aac",
                  mime: "audio/aac"
                };
              }
              return {
                ext: "aac",
                mime: "audio/aac"
              };
            }
            if (this.check([2], { offset: offset + 1, mask: [6] })) {
              return {
                ext: "mp3",
                mime: "audio/mpeg"
              };
            }
            if (this.check([4], { offset: offset + 1, mask: [6] })) {
              return {
                ext: "mp2",
                mime: "audio/mpeg"
              };
            }
            if (this.check([6], { offset: offset + 1, mask: [6] })) {
              return {
                ext: "mp1",
                mime: "audio/mpeg"
              };
            }
          }
        }
      }
      new Set(extensions);
      new Set(mimeTypes);
      var contentType = {};
      /*!
       * content-type
       * Copyright(c) 2015 Douglas Christopher Wilson
       * MIT Licensed
       */
      var hasRequiredContentType;
      function requireContentType() {
        if (hasRequiredContentType) return contentType;
        hasRequiredContentType = 1;
        var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
        var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
        var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
        var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
        var QUOTE_REGEXP = /([\\"])/g;
        var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
        contentType.format = format;
        contentType.parse = parse;
        function format(obj) {
          if (!obj || typeof obj !== "object") {
            throw new TypeError("argument obj is required");
          }
          var parameters = obj.parameters;
          var type = obj.type;
          if (!type || !TYPE_REGEXP.test(type)) {
            throw new TypeError("invalid type");
          }
          var string = type;
          if (parameters && typeof parameters === "object") {
            var param;
            var params = Object.keys(parameters).sort();
            for (var i = 0; i < params.length; i++) {
              param = params[i];
              if (!TOKEN_REGEXP.test(param)) {
                throw new TypeError("invalid parameter name");
              }
              string += "; " + param + "=" + qstring(parameters[param]);
            }
          }
          return string;
        }
        function parse(string) {
          if (!string) {
            throw new TypeError("argument string is required");
          }
          var header = typeof string === "object" ? getcontenttype(string) : string;
          if (typeof header !== "string") {
            throw new TypeError("argument string is required to be a string");
          }
          var index2 = header.indexOf(";");
          var type = index2 !== -1 ? header.slice(0, index2).trim() : header.trim();
          if (!TYPE_REGEXP.test(type)) {
            throw new TypeError("invalid media type");
          }
          var obj = new ContentType2(type.toLowerCase());
          if (index2 !== -1) {
            var key;
            var match;
            var value;
            PARAM_REGEXP.lastIndex = index2;
            while (match = PARAM_REGEXP.exec(header)) {
              if (match.index !== index2) {
                throw new TypeError("invalid parameter format");
              }
              index2 += match[0].length;
              key = match[1].toLowerCase();
              value = match[2];
              if (value.charCodeAt(0) === 34) {
                value = value.slice(1, -1);
                if (value.indexOf("\\") !== -1) {
                  value = value.replace(QESC_REGEXP, "$1");
                }
              }
              obj.parameters[key] = value;
            }
            if (index2 !== header.length) {
              throw new TypeError("invalid parameter format");
            }
          }
          return obj;
        }
        function getcontenttype(obj) {
          var header;
          if (typeof obj.getHeader === "function") {
            header = obj.getHeader("content-type");
          } else if (typeof obj.headers === "object") {
            header = obj.headers && obj.headers["content-type"];
          }
          if (typeof header !== "string") {
            throw new TypeError("content-type header is missing from object");
          }
          return header;
        }
        function qstring(val) {
          var str = String(val);
          if (TOKEN_REGEXP.test(str)) {
            return str;
          }
          if (str.length > 0 && !TEXT_REGEXP.test(str)) {
            throw new TypeError("invalid parameter value");
          }
          return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
        }
        function ContentType2(type) {
          this.parameters = /* @__PURE__ */ Object.create(null);
          this.type = type;
        }
        return contentType;
      }
      var contentTypeExports = requireContentType();
      const ContentType = /* @__PURE__ */ getDefaultExportFromCjs(contentTypeExports);
      var mediaTyper = {};
      /*!
       * media-typer
       * Copyright(c) 2014-2017 Douglas Christopher Wilson
       * MIT Licensed
       */
      var hasRequiredMediaTyper;
      function requireMediaTyper() {
        if (hasRequiredMediaTyper) return mediaTyper;
        hasRequiredMediaTyper = 1;
        var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
        var TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
        var TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
        mediaTyper.format = format;
        mediaTyper.parse = parse;
        mediaTyper.test = test;
        function format(obj) {
          if (!obj || typeof obj !== "object") {
            throw new TypeError("argument obj is required");
          }
          var subtype = obj.subtype;
          var suffix = obj.suffix;
          var type = obj.type;
          if (!type || !TYPE_NAME_REGEXP.test(type)) {
            throw new TypeError("invalid type");
          }
          if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype)) {
            throw new TypeError("invalid subtype");
          }
          var string = type + "/" + subtype;
          if (suffix) {
            if (!TYPE_NAME_REGEXP.test(suffix)) {
              throw new TypeError("invalid suffix");
            }
            string += "+" + suffix;
          }
          return string;
        }
        function test(string) {
          if (!string) {
            throw new TypeError("argument string is required");
          }
          if (typeof string !== "string") {
            throw new TypeError("argument string is required to be a string");
          }
          return TYPE_REGEXP.test(string.toLowerCase());
        }
        function parse(string) {
          if (!string) {
            throw new TypeError("argument string is required");
          }
          if (typeof string !== "string") {
            throw new TypeError("argument string is required to be a string");
          }
          var match = TYPE_REGEXP.exec(string.toLowerCase());
          if (!match) {
            throw new TypeError("invalid media type");
          }
          var type = match[1];
          var subtype = match[2];
          var suffix;
          var index2 = subtype.lastIndexOf("+");
          if (index2 !== -1) {
            suffix = subtype.substr(index2 + 1);
            subtype = subtype.substr(0, index2);
          }
          return new MediaType(type, subtype, suffix);
        }
        function MediaType(type, subtype, suffix) {
          this.type = type;
          this.subtype = subtype;
          this.suffix = suffix;
        }
        return mediaTyper;
      }
      var mediaTyperExports = requireMediaTyper();
      const TargetType = exports("r", {
        10: "shot",
        20: "scene",
        30: "track",
        40: "part",
        50: "album",
        60: "edition",
        70: "collection"
      });
      const TrackType = exports("T", {
        video: 1,
        audio: 2,
        complex: 3,
        logo: 4,
        subtitle: 17,
        button: 18,
        control: 32
      });
      const TrackTypeValueToKeyMap = {
        [TrackType.video]: "video",
        [TrackType.audio]: "audio",
        [TrackType.complex]: "complex",
        [TrackType.logo]: "logo",
        [TrackType.subtitle]: "subtitle",
        [TrackType.button]: "button",
        [TrackType.control]: "control"
      };
      const makeParseError = (name2) => {
        return class ParseError extends Error {
          constructor(message2) {
            super(message2);
            this.name = name2;
          }
        };
      };
      class CouldNotDetermineFileTypeError extends makeParseError("CouldNotDetermineFileTypeError") {
      }
      class UnsupportedFileTypeError extends makeParseError("UnsupportedFileTypeError") {
      }
      class UnexpectedFileContentError extends makeParseError("UnexpectedFileContentError") {
        constructor(fileType, message2) {
          super(message2);
          this.fileType = fileType;
        }
        // Override toString to include file type information.
        toString() {
          return `${this.name} (FileType: ${this.fileType}): ${this.message}`;
        }
      }
      class FieldDecodingError extends makeParseError("FieldDecodingError") {
      }
      class InternalParserError extends makeParseError("InternalParserError") {
      }
      const makeUnexpectedFileContentError = exports("m", (fileType) => {
        return class extends UnexpectedFileContentError {
          constructor(message2) {
            super(fileType, message2);
          }
        };
      });
      function getBit(buf, off, bit) {
        return (buf[off] & 1 << bit) !== 0;
      }
      function findZero(uint8Array, start, end, encoding) {
        let i = start;
        if (encoding === "utf-16le") {
          while (uint8Array[i] !== 0 || uint8Array[i + 1] !== 0) {
            if (i >= end)
              return end;
            i += 2;
          }
          return i;
        }
        while (uint8Array[i] !== 0) {
          if (i >= end)
            return end;
          i++;
        }
        return i;
      }
      function trimRightNull(x) {
        const pos0 = x.indexOf("\0");
        return pos0 === -1 ? x : x.substr(0, pos0);
      }
      function swapBytes(uint8Array) {
        const l = uint8Array.length;
        if ((l & 1) !== 0)
          throw new FieldDecodingError("Buffer length must be even");
        for (let i = 0; i < l; i += 2) {
          const a = uint8Array[i];
          uint8Array[i] = uint8Array[i + 1];
          uint8Array[i + 1] = a;
        }
        return uint8Array;
      }
      function decodeString(uint8Array, encoding) {
        if (uint8Array[0] === 255 && uint8Array[1] === 254) {
          return decodeString(uint8Array.subarray(2), encoding);
        }
        if (encoding === "utf-16le" && uint8Array[0] === 254 && uint8Array[1] === 255) {
          if ((uint8Array.length & 1) !== 0)
            throw new FieldDecodingError("Expected even number of octets for 16-bit unicode string");
          return decodeString(swapBytes(uint8Array), encoding);
        }
        return new StringType(uint8Array.length, encoding).get(uint8Array, 0);
      }
      function stripNulls(str) {
        str = str.replace(/^\x00+/g, "");
        str = str.replace(/\x00+$/g, "");
        return str;
      }
      function getBitAllignedNumber(source, byteOffset, bitOffset, len) {
        const byteOff = byteOffset + ~~(bitOffset / 8);
        const bitOff = bitOffset % 8;
        let value = source[byteOff];
        value &= 255 >> bitOff;
        const bitsRead = 8 - bitOff;
        const bitsLeft = len - bitsRead;
        if (bitsLeft < 0) {
          value >>= 8 - bitOff - len;
        } else if (bitsLeft > 0) {
          value <<= bitsLeft;
          value |= getBitAllignedNumber(source, byteOffset, bitOffset + bitsRead, bitsLeft);
        }
        return value;
      }
      function isBitSet$1(source, byteOffset, bitOffset) {
        return getBitAllignedNumber(source, byteOffset, bitOffset, 1) === 1;
      }
      function a2hex(str) {
        const arr = [];
        for (let i = 0, l = str.length; i < l; i++) {
          const hex = Number(str.charCodeAt(i)).toString(16);
          arr.push(hex.length === 1 ? `0${hex}` : hex);
        }
        return arr.join(" ");
      }
      function ratioToDb(ratio) {
        return 10 * Math.log10(ratio);
      }
      function dbToRatio(dB) {
        return 10 ** (dB / 10);
      }
      function toRatio(value) {
        const ps = value.split(" ").map((p) => p.trim().toLowerCase());
        if (ps.length >= 1) {
          const v = Number.parseFloat(ps[0]);
          return ps.length === 2 && ps[1] === "db" ? {
            dB: v,
            ratio: dbToRatio(v)
          } : {
            dB: ratioToDb(v),
            ratio: v
          };
        }
      }
      const AttachedPictureType = exports("A", {
        0: "Other",
        1: "32x32 pixels 'file icon' (PNG only)",
        2: "Other file icon",
        3: "Cover (front)",
        4: "Cover (back)",
        5: "Leaflet page",
        6: "Media (e.g. label side of CD)",
        7: "Lead artist/lead performer/soloist",
        8: "Artist/performer",
        9: "Conductor",
        10: "Band/Orchestra",
        11: "Composer",
        12: "Lyricist/text writer",
        13: "Recording Location",
        14: "During recording",
        15: "During performance",
        16: "Movie/video screen capture",
        17: "A bright coloured fish",
        18: "Illustration",
        19: "Band/artist logotype",
        20: "Publisher/Studio logotype"
      });
      const LyricsContentType = {
        lyrics: 1
      };
      const TimestampFormat = {
        milliseconds: 2
      };
      const UINT32SYNCSAFE = exports("P", {
        get: (buf, off) => {
          return buf[off + 3] & 127 | buf[off + 2] << 7 | buf[off + 1] << 14 | buf[off] << 21;
        },
        len: 4
      });
      const ID3v2Header = exports("L", {
        len: 10,
        get: (buf, off) => {
          return {
            // ID3v2/file identifier   "ID3"
            fileIdentifier: new StringType(3, "ascii").get(buf, off),
            // ID3v2 versionIndex
            version: {
              major: INT8.get(buf, off + 3),
              revision: INT8.get(buf, off + 4)
            },
            // ID3v2 flags
            flags: {
              // Unsynchronisation
              unsynchronisation: getBit(buf, off + 5, 7),
              // Extended header
              isExtendedHeader: getBit(buf, off + 5, 6),
              // Experimental indicator
              expIndicator: getBit(buf, off + 5, 5),
              footer: getBit(buf, off + 5, 4)
            },
            size: UINT32SYNCSAFE.get(buf, off + 6)
          };
        }
      });
      const ExtendedHeader = exports("O", {
        len: 10,
        get: (buf, off) => {
          return {
            // Extended header size
            size: UINT32_BE.get(buf, off),
            // Extended Flags
            extendedFlags: UINT16_BE.get(buf, off + 4),
            // Size of padding
            sizeOfPadding: UINT32_BE.get(buf, off + 6),
            // CRC data present
            crcDataPresent: getBit(buf, off + 4, 31)
          };
        }
      });
      const TextEncodingToken = exports("Q", {
        len: 1,
        get: (uint8Array, off) => {
          switch (uint8Array[off]) {
            case 0:
              return { encoding: "latin1" };
            // binary
            case 1:
              return { encoding: "utf-16le", bom: true };
            case 2:
              return { encoding: "utf-16le", bom: false };
            case 3:
              return { encoding: "utf8", bom: false };
            default:
              return { encoding: "utf8", bom: false };
          }
        }
      });
      const TextHeader = exports("V", {
        len: 4,
        get: (uint8Array, off) => {
          return {
            encoding: TextEncodingToken.get(uint8Array, off),
            language: new StringType(3, "latin1").get(uint8Array, off + 1)
          };
        }
      });
      const SyncTextHeader = exports("W", {
        len: 6,
        get: (uint8Array, off) => {
          const text = TextHeader.get(uint8Array, off);
          return {
            encoding: text.encoding,
            language: text.language,
            timeStampFormat: UINT8.get(uint8Array, off + 4),
            contentType: UINT8.get(uint8Array, off + 5)
          };
        }
      });
      const defaultTagInfo = {
        multiple: false
      };
      const commonTags = {
        year: defaultTagInfo,
        track: defaultTagInfo,
        disk: defaultTagInfo,
        title: defaultTagInfo,
        artist: defaultTagInfo,
        artists: { multiple: true, unique: true },
        albumartist: defaultTagInfo,
        album: defaultTagInfo,
        date: defaultTagInfo,
        originaldate: defaultTagInfo,
        originalyear: defaultTagInfo,
        releasedate: defaultTagInfo,
        comment: { multiple: true, unique: false },
        genre: { multiple: true, unique: true },
        picture: { multiple: true, unique: true },
        composer: { multiple: true, unique: true },
        lyrics: { multiple: true, unique: false },
        albumsort: { multiple: false, unique: true },
        titlesort: { multiple: false, unique: true },
        work: { multiple: false, unique: true },
        artistsort: { multiple: false, unique: true },
        albumartistsort: { multiple: false, unique: true },
        composersort: { multiple: false, unique: true },
        lyricist: { multiple: true, unique: true },
        writer: { multiple: true, unique: true },
        conductor: { multiple: true, unique: true },
        remixer: { multiple: true, unique: true },
        arranger: { multiple: true, unique: true },
        engineer: { multiple: true, unique: true },
        producer: { multiple: true, unique: true },
        technician: { multiple: true, unique: true },
        djmixer: { multiple: true, unique: true },
        mixer: { multiple: true, unique: true },
        label: { multiple: true, unique: true },
        grouping: defaultTagInfo,
        subtitle: { multiple: true },
        discsubtitle: defaultTagInfo,
        totaltracks: defaultTagInfo,
        totaldiscs: defaultTagInfo,
        compilation: defaultTagInfo,
        rating: { multiple: true },
        bpm: defaultTagInfo,
        mood: defaultTagInfo,
        media: defaultTagInfo,
        catalognumber: { multiple: true, unique: true },
        tvShow: defaultTagInfo,
        tvShowSort: defaultTagInfo,
        tvSeason: defaultTagInfo,
        tvEpisode: defaultTagInfo,
        tvEpisodeId: defaultTagInfo,
        tvNetwork: defaultTagInfo,
        podcast: defaultTagInfo,
        podcasturl: defaultTagInfo,
        releasestatus: defaultTagInfo,
        releasetype: { multiple: true },
        releasecountry: defaultTagInfo,
        script: defaultTagInfo,
        language: defaultTagInfo,
        copyright: defaultTagInfo,
        license: defaultTagInfo,
        encodedby: defaultTagInfo,
        encodersettings: defaultTagInfo,
        gapless: defaultTagInfo,
        barcode: defaultTagInfo,
        isrc: { multiple: true },
        asin: defaultTagInfo,
        musicbrainz_recordingid: defaultTagInfo,
        musicbrainz_trackid: defaultTagInfo,
        musicbrainz_albumid: defaultTagInfo,
        musicbrainz_artistid: { multiple: true },
        musicbrainz_albumartistid: { multiple: true },
        musicbrainz_releasegroupid: defaultTagInfo,
        musicbrainz_workid: defaultTagInfo,
        musicbrainz_trmid: defaultTagInfo,
        musicbrainz_discid: defaultTagInfo,
        acoustid_id: defaultTagInfo,
        acoustid_fingerprint: defaultTagInfo,
        musicip_puid: defaultTagInfo,
        musicip_fingerprint: defaultTagInfo,
        website: defaultTagInfo,
        "performer:instrument": { multiple: true, unique: true },
        averageLevel: defaultTagInfo,
        peakLevel: defaultTagInfo,
        notes: { multiple: true, unique: false },
        key: defaultTagInfo,
        originalalbum: defaultTagInfo,
        originalartist: defaultTagInfo,
        discogs_artist_id: { multiple: true, unique: true },
        discogs_release_id: defaultTagInfo,
        discogs_label_id: defaultTagInfo,
        discogs_master_release_id: defaultTagInfo,
        discogs_votes: defaultTagInfo,
        discogs_rating: defaultTagInfo,
        replaygain_track_peak: defaultTagInfo,
        replaygain_track_gain: defaultTagInfo,
        replaygain_album_peak: defaultTagInfo,
        replaygain_album_gain: defaultTagInfo,
        replaygain_track_minmax: defaultTagInfo,
        replaygain_album_minmax: defaultTagInfo,
        replaygain_undo: defaultTagInfo,
        description: { multiple: true },
        longDescription: defaultTagInfo,
        category: { multiple: true },
        hdVideo: defaultTagInfo,
        keywords: { multiple: true },
        movement: defaultTagInfo,
        movementIndex: defaultTagInfo,
        movementTotal: defaultTagInfo,
        podcastId: defaultTagInfo,
        showMovement: defaultTagInfo,
        stik: defaultTagInfo
      };
      function isSingleton(alias) {
        return commonTags[alias] && !commonTags[alias].multiple;
      }
      function isUnique(alias) {
        return !commonTags[alias].multiple || commonTags[alias].unique || false;
      }
      class CommonTagMapper {
        static toIntOrNull(str) {
          const cleaned = Number.parseInt(str, 10);
          return Number.isNaN(cleaned) ? null : cleaned;
        }
        // TODO: a string of 1of1 would fail to be converted
        // converts 1/10 to no : 1, of : 10
        // or 1 to no : 1, of : 0
        static normalizeTrack(origVal) {
          const split = origVal.toString().split("/");
          return {
            no: Number.parseInt(split[0], 10) || null,
            of: Number.parseInt(split[1], 10) || null
          };
        }
        constructor(tagTypes, tagMap2) {
          this.tagTypes = tagTypes;
          this.tagMap = tagMap2;
        }
        /**
         * Process and set common tags
         * write common tags to
         * @param tag Native tag
         * @param warnings Register warnings
         * @return common name
         */
        mapGenericTag(tag, warnings) {
          tag = { id: tag.id, value: tag.value };
          this.postMap(tag, warnings);
          const id = this.getCommonName(tag.id);
          return id ? { id, value: tag.value } : null;
        }
        /**
         * Convert native tag key to common tag key
         * @param tag Native header tag
         * @return common tag name (alias)
         */
        getCommonName(tag) {
          return this.tagMap[tag];
        }
        /**
         * Handle post mapping exceptions / correction
         * @param tag Tag e.g. {"©alb", "Buena Vista Social Club")
         * @param warnings Used to register warnings
         */
        postMap(_tag, _warnings) {
          return;
        }
      }
      CommonTagMapper.maxRatingScore = 1;
      const id3v1TagMap = {
        title: "title",
        artist: "artist",
        album: "album",
        year: "year",
        comment: "comment",
        track: "track",
        genre: "genre"
      };
      class ID3v1TagMapper extends CommonTagMapper {
        constructor() {
          super(["ID3v1"], id3v1TagMap);
        }
      }
      class CaseInsensitiveTagMap extends CommonTagMapper {
        constructor(tagTypes, tagMap2) {
          const upperCaseMap = {};
          for (const tag of Object.keys(tagMap2)) {
            upperCaseMap[tag.toUpperCase()] = tagMap2[tag];
          }
          super(tagTypes, upperCaseMap);
        }
        /**
         * @tag  Native header tag
         * @return common tag name (alias)
         */
        getCommonName(tag) {
          return this.tagMap[tag.toUpperCase()];
        }
      }
      const id3v24TagMap = {
        // id3v2.3
        TIT2: "title",
        TPE1: "artist",
        "TXXX:Artists": "artists",
        TPE2: "albumartist",
        TALB: "album",
        TDRV: "date",
        // [ 'date', 'year' ] ToDo: improve 'year' mapping
        /**
         * Original release year
         */
        TORY: "originalyear",
        TPOS: "disk",
        TCON: "genre",
        APIC: "picture",
        TCOM: "composer",
        USLT: "lyrics",
        TSOA: "albumsort",
        TSOT: "titlesort",
        TOAL: "originalalbum",
        TSOP: "artistsort",
        TSO2: "albumartistsort",
        TSOC: "composersort",
        TEXT: "lyricist",
        "TXXX:Writer": "writer",
        TPE3: "conductor",
        // 'IPLS:instrument': 'performer:instrument', // ToDo
        TPE4: "remixer",
        "IPLS:arranger": "arranger",
        "IPLS:engineer": "engineer",
        "IPLS:producer": "producer",
        "IPLS:DJ-mix": "djmixer",
        "IPLS:mix": "mixer",
        TPUB: "label",
        TIT1: "grouping",
        TIT3: "subtitle",
        TRCK: "track",
        TCMP: "compilation",
        POPM: "rating",
        TBPM: "bpm",
        TMED: "media",
        "TXXX:CATALOGNUMBER": "catalognumber",
        "TXXX:MusicBrainz Album Status": "releasestatus",
        "TXXX:MusicBrainz Album Type": "releasetype",
        /**
         * Release country as documented: https://picard.musicbrainz.org/docs/mappings/#cite_note-0
         */
        "TXXX:MusicBrainz Album Release Country": "releasecountry",
        /**
         * Release country as implemented // ToDo: report
         */
        "TXXX:RELEASECOUNTRY": "releasecountry",
        "TXXX:SCRIPT": "script",
        TLAN: "language",
        TCOP: "copyright",
        WCOP: "license",
        TENC: "encodedby",
        TSSE: "encodersettings",
        "TXXX:BARCODE": "barcode",
        "TXXX:ISRC": "isrc",
        TSRC: "isrc",
        "TXXX:ASIN": "asin",
        "TXXX:originalyear": "originalyear",
        "UFID:http://musicbrainz.org": "musicbrainz_recordingid",
        "TXXX:MusicBrainz Release Track Id": "musicbrainz_trackid",
        "TXXX:MusicBrainz Album Id": "musicbrainz_albumid",
        "TXXX:MusicBrainz Artist Id": "musicbrainz_artistid",
        "TXXX:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
        "TXXX:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
        "TXXX:MusicBrainz Work Id": "musicbrainz_workid",
        "TXXX:MusicBrainz TRM Id": "musicbrainz_trmid",
        "TXXX:MusicBrainz Disc Id": "musicbrainz_discid",
        "TXXX:ACOUSTID_ID": "acoustid_id",
        "TXXX:Acoustid Id": "acoustid_id",
        "TXXX:Acoustid Fingerprint": "acoustid_fingerprint",
        "TXXX:MusicIP PUID": "musicip_puid",
        "TXXX:MusicMagic Fingerprint": "musicip_fingerprint",
        WOAR: "website",
        // id3v2.4
        // ToDo: In same sequence as defined at http://id3.org/id3v2.4.0-frames
        TDRC: "date",
        // date YYYY-MM-DD
        TYER: "year",
        TDOR: "originaldate",
        // 'TMCL:instrument': 'performer:instrument',
        "TIPL:arranger": "arranger",
        "TIPL:engineer": "engineer",
        "TIPL:producer": "producer",
        "TIPL:DJ-mix": "djmixer",
        "TIPL:mix": "mixer",
        TMOO: "mood",
        // additional mappings:
        SYLT: "lyrics",
        TSST: "discsubtitle",
        TKEY: "key",
        COMM: "comment",
        TOPE: "originalartist",
        // Windows Media Player
        "PRIV:AverageLevel": "averageLevel",
        "PRIV:PeakLevel": "peakLevel",
        // Discogs
        "TXXX:DISCOGS_ARTIST_ID": "discogs_artist_id",
        "TXXX:DISCOGS_ARTISTS": "artists",
        "TXXX:DISCOGS_ARTIST_NAME": "artists",
        "TXXX:DISCOGS_ALBUM_ARTISTS": "albumartist",
        "TXXX:DISCOGS_CATALOG": "catalognumber",
        "TXXX:DISCOGS_COUNTRY": "releasecountry",
        "TXXX:DISCOGS_DATE": "originaldate",
        "TXXX:DISCOGS_LABEL": "label",
        "TXXX:DISCOGS_LABEL_ID": "discogs_label_id",
        "TXXX:DISCOGS_MASTER_RELEASE_ID": "discogs_master_release_id",
        "TXXX:DISCOGS_RATING": "discogs_rating",
        "TXXX:DISCOGS_RELEASED": "date",
        "TXXX:DISCOGS_RELEASE_ID": "discogs_release_id",
        "TXXX:DISCOGS_VOTES": "discogs_votes",
        "TXXX:CATALOGID": "catalognumber",
        "TXXX:STYLE": "genre",
        "TXXX:REPLAYGAIN_TRACK_PEAK": "replaygain_track_peak",
        "TXXX:REPLAYGAIN_TRACK_GAIN": "replaygain_track_gain",
        "TXXX:REPLAYGAIN_ALBUM_PEAK": "replaygain_album_peak",
        "TXXX:REPLAYGAIN_ALBUM_GAIN": "replaygain_album_gain",
        "TXXX:MP3GAIN_MINMAX": "replaygain_track_minmax",
        "TXXX:MP3GAIN_ALBUM_MINMAX": "replaygain_album_minmax",
        "TXXX:MP3GAIN_UNDO": "replaygain_undo",
        MVNM: "movement",
        MVIN: "movementIndex",
        PCST: "podcast",
        TCAT: "category",
        TDES: "description",
        TDRL: "releasedate",
        TGID: "podcastId",
        TKWD: "keywords",
        WFED: "podcasturl",
        GRP1: "grouping"
      };
      class ID3v24TagMapper extends CaseInsensitiveTagMap {
        static toRating(popm) {
          return {
            source: popm.email,
            rating: popm.rating > 0 ? (popm.rating - 1) / 254 * CommonTagMapper.maxRatingScore : void 0
          };
        }
        constructor() {
          super(["ID3v2.3", "ID3v2.4"], id3v24TagMap);
        }
        /**
         * Handle post mapping exceptions / correction
         * @param tag to post map
         * @param warnings Wil be used to register (collect) warnings
         */
        postMap(tag, warnings) {
          switch (tag.id) {
            case "UFID":
              {
                const idTag = tag.value;
                if (idTag.owner_identifier === "http://musicbrainz.org") {
                  tag.id += `:${idTag.owner_identifier}`;
                  tag.value = decodeString(idTag.identifier, "latin1");
                }
              }
              break;
            case "PRIV":
              {
                const customTag = tag.value;
                switch (customTag.owner_identifier) {
                  // decode Windows Media Player
                  case "AverageLevel":
                  case "PeakValue":
                    tag.id += `:${customTag.owner_identifier}`;
                    tag.value = customTag.data.length === 4 ? UINT32_LE.get(customTag.data, 0) : null;
                    if (tag.value === null) {
                      warnings.addWarning("Failed to parse PRIV:PeakValue");
                    }
                    break;
                  default:
                    warnings.addWarning(`Unknown PRIV owner-identifier: ${customTag.data}`);
                }
              }
              break;
            case "POPM":
              tag.value = ID3v24TagMapper.toRating(tag.value);
              break;
          }
        }
      }
      const asfTagMap = {
        Title: "title",
        Author: "artist",
        "WM/AlbumArtist": "albumartist",
        "WM/AlbumTitle": "album",
        "WM/Year": "date",
        // changed to 'year' to 'date' based on Picard mappings; ToDo: check me
        "WM/OriginalReleaseTime": "originaldate",
        "WM/OriginalReleaseYear": "originalyear",
        Description: "comment",
        "WM/TrackNumber": "track",
        "WM/PartOfSet": "disk",
        "WM/Genre": "genre",
        "WM/Composer": "composer",
        "WM/Lyrics": "lyrics",
        "WM/AlbumSortOrder": "albumsort",
        "WM/TitleSortOrder": "titlesort",
        "WM/ArtistSortOrder": "artistsort",
        "WM/AlbumArtistSortOrder": "albumartistsort",
        "WM/ComposerSortOrder": "composersort",
        "WM/Writer": "lyricist",
        "WM/Conductor": "conductor",
        "WM/ModifiedBy": "remixer",
        "WM/Engineer": "engineer",
        "WM/Producer": "producer",
        "WM/DJMixer": "djmixer",
        "WM/Mixer": "mixer",
        "WM/Publisher": "label",
        "WM/ContentGroupDescription": "grouping",
        "WM/SubTitle": "subtitle",
        "WM/SetSubTitle": "discsubtitle",
        // 'WM/PartOfSet': 'totaldiscs',
        "WM/IsCompilation": "compilation",
        "WM/SharedUserRating": "rating",
        "WM/BeatsPerMinute": "bpm",
        "WM/Mood": "mood",
        "WM/Media": "media",
        "WM/CatalogNo": "catalognumber",
        "MusicBrainz/Album Status": "releasestatus",
        "MusicBrainz/Album Type": "releasetype",
        "MusicBrainz/Album Release Country": "releasecountry",
        "WM/Script": "script",
        "WM/Language": "language",
        Copyright: "copyright",
        LICENSE: "license",
        "WM/EncodedBy": "encodedby",
        "WM/EncodingSettings": "encodersettings",
        "WM/Barcode": "barcode",
        "WM/ISRC": "isrc",
        "MusicBrainz/Track Id": "musicbrainz_recordingid",
        "MusicBrainz/Release Track Id": "musicbrainz_trackid",
        "MusicBrainz/Album Id": "musicbrainz_albumid",
        "MusicBrainz/Artist Id": "musicbrainz_artistid",
        "MusicBrainz/Album Artist Id": "musicbrainz_albumartistid",
        "MusicBrainz/Release Group Id": "musicbrainz_releasegroupid",
        "MusicBrainz/Work Id": "musicbrainz_workid",
        "MusicBrainz/TRM Id": "musicbrainz_trmid",
        "MusicBrainz/Disc Id": "musicbrainz_discid",
        "Acoustid/Id": "acoustid_id",
        "Acoustid/Fingerprint": "acoustid_fingerprint",
        "MusicIP/PUID": "musicip_puid",
        "WM/ARTISTS": "artists",
        "WM/InitialKey": "key",
        ASIN: "asin",
        "WM/Work": "work",
        "WM/AuthorURL": "website",
        "WM/Picture": "picture"
      };
      class AsfTagMapper extends CommonTagMapper {
        static toRating(rating) {
          return {
            rating: Number.parseFloat(rating + 1) / 5
          };
        }
        constructor() {
          super(["asf"], asfTagMap);
        }
        postMap(tag) {
          switch (tag.id) {
            case "WM/SharedUserRating": {
              const keys = tag.id.split(":");
              tag.value = AsfTagMapper.toRating(tag.value);
              tag.id = keys[0];
              break;
            }
          }
        }
      }
      const id3v22TagMap = {
        TT2: "title",
        TP1: "artist",
        TP2: "albumartist",
        TAL: "album",
        TYE: "year",
        COM: "comment",
        TRK: "track",
        TPA: "disk",
        TCO: "genre",
        PIC: "picture",
        TCM: "composer",
        TOR: "originaldate",
        TOT: "originalalbum",
        TXT: "lyricist",
        TP3: "conductor",
        TPB: "label",
        TT1: "grouping",
        TT3: "subtitle",
        TLA: "language",
        TCR: "copyright",
        WCP: "license",
        TEN: "encodedby",
        TSS: "encodersettings",
        WAR: "website",
        PCS: "podcast",
        TCP: "compilation",
        TDR: "date",
        TS2: "albumartistsort",
        TSA: "albumsort",
        TSC: "composersort",
        TSP: "artistsort",
        TST: "titlesort",
        WFD: "podcasturl",
        TBP: "bpm"
      };
      class ID3v22TagMapper extends CaseInsensitiveTagMap {
        constructor() {
          super(["ID3v2.2"], id3v22TagMap);
        }
      }
      const apev2TagMap = {
        Title: "title",
        Artist: "artist",
        Artists: "artists",
        "Album Artist": "albumartist",
        Album: "album",
        Year: "date",
        Originalyear: "originalyear",
        Originaldate: "originaldate",
        Releasedate: "releasedate",
        Comment: "comment",
        Track: "track",
        Disc: "disk",
        DISCNUMBER: "disk",
        // ToDo: backwards compatibility', valid tag?
        Genre: "genre",
        "Cover Art (Front)": "picture",
        "Cover Art (Back)": "picture",
        Composer: "composer",
        Lyrics: "lyrics",
        ALBUMSORT: "albumsort",
        TITLESORT: "titlesort",
        WORK: "work",
        ARTISTSORT: "artistsort",
        ALBUMARTISTSORT: "albumartistsort",
        COMPOSERSORT: "composersort",
        Lyricist: "lyricist",
        Writer: "writer",
        Conductor: "conductor",
        // 'Performer=artist (instrument)': 'performer:instrument',
        MixArtist: "remixer",
        Arranger: "arranger",
        Engineer: "engineer",
        Producer: "producer",
        DJMixer: "djmixer",
        Mixer: "mixer",
        Label: "label",
        Grouping: "grouping",
        Subtitle: "subtitle",
        DiscSubtitle: "discsubtitle",
        Compilation: "compilation",
        BPM: "bpm",
        Mood: "mood",
        Media: "media",
        CatalogNumber: "catalognumber",
        MUSICBRAINZ_ALBUMSTATUS: "releasestatus",
        MUSICBRAINZ_ALBUMTYPE: "releasetype",
        RELEASECOUNTRY: "releasecountry",
        Script: "script",
        Language: "language",
        Copyright: "copyright",
        LICENSE: "license",
        EncodedBy: "encodedby",
        EncoderSettings: "encodersettings",
        Barcode: "barcode",
        ISRC: "isrc",
        ASIN: "asin",
        musicbrainz_trackid: "musicbrainz_recordingid",
        musicbrainz_releasetrackid: "musicbrainz_trackid",
        MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
        MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
        MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
        MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
        MUSICBRAINZ_WORKID: "musicbrainz_workid",
        MUSICBRAINZ_TRMID: "musicbrainz_trmid",
        MUSICBRAINZ_DISCID: "musicbrainz_discid",
        Acoustid_Id: "acoustid_id",
        ACOUSTID_FINGERPRINT: "acoustid_fingerprint",
        MUSICIP_PUID: "musicip_puid",
        Weblink: "website",
        REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
        REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
        MP3GAIN_MINMAX: "replaygain_track_minmax",
        MP3GAIN_UNDO: "replaygain_undo"
      };
      class APEv2TagMapper extends CaseInsensitiveTagMap {
        constructor() {
          super(["APEv2"], apev2TagMap);
        }
      }
      const mp4TagMap = {
        "©nam": "title",
        "©ART": "artist",
        aART: "albumartist",
        /**
         * ToDo: Album artist seems to be stored here while Picard documentation says: aART
         */
        "----:com.apple.iTunes:Band": "albumartist",
        "©alb": "album",
        "©day": "date",
        "©cmt": "comment",
        "©com": "comment",
        trkn: "track",
        disk: "disk",
        "©gen": "genre",
        covr: "picture",
        "©wrt": "composer",
        "©lyr": "lyrics",
        soal: "albumsort",
        sonm: "titlesort",
        soar: "artistsort",
        soaa: "albumartistsort",
        soco: "composersort",
        "----:com.apple.iTunes:LYRICIST": "lyricist",
        "----:com.apple.iTunes:CONDUCTOR": "conductor",
        "----:com.apple.iTunes:REMIXER": "remixer",
        "----:com.apple.iTunes:ENGINEER": "engineer",
        "----:com.apple.iTunes:PRODUCER": "producer",
        "----:com.apple.iTunes:DJMIXER": "djmixer",
        "----:com.apple.iTunes:MIXER": "mixer",
        "----:com.apple.iTunes:LABEL": "label",
        "©grp": "grouping",
        "----:com.apple.iTunes:SUBTITLE": "subtitle",
        "----:com.apple.iTunes:DISCSUBTITLE": "discsubtitle",
        cpil: "compilation",
        tmpo: "bpm",
        "----:com.apple.iTunes:MOOD": "mood",
        "----:com.apple.iTunes:MEDIA": "media",
        "----:com.apple.iTunes:CATALOGNUMBER": "catalognumber",
        tvsh: "tvShow",
        tvsn: "tvSeason",
        tves: "tvEpisode",
        sosn: "tvShowSort",
        tven: "tvEpisodeId",
        tvnn: "tvNetwork",
        pcst: "podcast",
        purl: "podcasturl",
        "----:com.apple.iTunes:MusicBrainz Album Status": "releasestatus",
        "----:com.apple.iTunes:MusicBrainz Album Type": "releasetype",
        "----:com.apple.iTunes:MusicBrainz Album Release Country": "releasecountry",
        "----:com.apple.iTunes:SCRIPT": "script",
        "----:com.apple.iTunes:LANGUAGE": "language",
        cprt: "copyright",
        "©cpy": "copyright",
        "----:com.apple.iTunes:LICENSE": "license",
        "©too": "encodedby",
        pgap: "gapless",
        "----:com.apple.iTunes:BARCODE": "barcode",
        "----:com.apple.iTunes:ISRC": "isrc",
        "----:com.apple.iTunes:ASIN": "asin",
        "----:com.apple.iTunes:NOTES": "comment",
        "----:com.apple.iTunes:MusicBrainz Track Id": "musicbrainz_recordingid",
        "----:com.apple.iTunes:MusicBrainz Release Track Id": "musicbrainz_trackid",
        "----:com.apple.iTunes:MusicBrainz Album Id": "musicbrainz_albumid",
        "----:com.apple.iTunes:MusicBrainz Artist Id": "musicbrainz_artistid",
        "----:com.apple.iTunes:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
        "----:com.apple.iTunes:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
        "----:com.apple.iTunes:MusicBrainz Work Id": "musicbrainz_workid",
        "----:com.apple.iTunes:MusicBrainz TRM Id": "musicbrainz_trmid",
        "----:com.apple.iTunes:MusicBrainz Disc Id": "musicbrainz_discid",
        "----:com.apple.iTunes:Acoustid Id": "acoustid_id",
        "----:com.apple.iTunes:Acoustid Fingerprint": "acoustid_fingerprint",
        "----:com.apple.iTunes:MusicIP PUID": "musicip_puid",
        "----:com.apple.iTunes:fingerprint": "musicip_fingerprint",
        "----:com.apple.iTunes:replaygain_track_gain": "replaygain_track_gain",
        "----:com.apple.iTunes:replaygain_track_peak": "replaygain_track_peak",
        "----:com.apple.iTunes:replaygain_album_gain": "replaygain_album_gain",
        "----:com.apple.iTunes:replaygain_album_peak": "replaygain_album_peak",
        "----:com.apple.iTunes:replaygain_track_minmax": "replaygain_track_minmax",
        "----:com.apple.iTunes:replaygain_album_minmax": "replaygain_album_minmax",
        "----:com.apple.iTunes:replaygain_undo": "replaygain_undo",
        // Additional mappings:
        gnre: "genre",
        // ToDo: check mapping
        "----:com.apple.iTunes:ALBUMARTISTSORT": "albumartistsort",
        "----:com.apple.iTunes:ARTISTS": "artists",
        "----:com.apple.iTunes:ORIGINALDATE": "originaldate",
        "----:com.apple.iTunes:ORIGINALYEAR": "originalyear",
        "----:com.apple.iTunes:RELEASEDATE": "releasedate",
        // '----:com.apple.iTunes:PERFORMER': 'performer'
        desc: "description",
        ldes: "longDescription",
        "©mvn": "movement",
        "©mvi": "movementIndex",
        "©mvc": "movementTotal",
        "©wrk": "work",
        catg: "category",
        egid: "podcastId",
        hdvd: "hdVideo",
        keyw: "keywords",
        shwm: "showMovement",
        stik: "stik",
        rate: "rating"
      };
      const tagType = "iTunes";
      class MP4TagMapper extends CaseInsensitiveTagMap {
        constructor() {
          super([tagType], mp4TagMap);
        }
        postMap(tag, _warnings) {
          switch (tag.id) {
            case "rate":
              tag.value = {
                source: void 0,
                rating: Number.parseFloat(tag.value) / 100
              };
              break;
          }
        }
      }
      const vorbisTagMap = {
        TITLE: "title",
        ARTIST: "artist",
        ARTISTS: "artists",
        ALBUMARTIST: "albumartist",
        "ALBUM ARTIST": "albumartist",
        ALBUM: "album",
        DATE: "date",
        ORIGINALDATE: "originaldate",
        ORIGINALYEAR: "originalyear",
        RELEASEDATE: "releasedate",
        COMMENT: "comment",
        TRACKNUMBER: "track",
        DISCNUMBER: "disk",
        GENRE: "genre",
        METADATA_BLOCK_PICTURE: "picture",
        COMPOSER: "composer",
        LYRICS: "lyrics",
        ALBUMSORT: "albumsort",
        TITLESORT: "titlesort",
        WORK: "work",
        ARTISTSORT: "artistsort",
        ALBUMARTISTSORT: "albumartistsort",
        COMPOSERSORT: "composersort",
        LYRICIST: "lyricist",
        WRITER: "writer",
        CONDUCTOR: "conductor",
        // 'PERFORMER=artist (instrument)': 'performer:instrument', // ToDo
        REMIXER: "remixer",
        ARRANGER: "arranger",
        ENGINEER: "engineer",
        PRODUCER: "producer",
        DJMIXER: "djmixer",
        MIXER: "mixer",
        LABEL: "label",
        GROUPING: "grouping",
        SUBTITLE: "subtitle",
        DISCSUBTITLE: "discsubtitle",
        TRACKTOTAL: "totaltracks",
        DISCTOTAL: "totaldiscs",
        COMPILATION: "compilation",
        RATING: "rating",
        BPM: "bpm",
        KEY: "key",
        MOOD: "mood",
        MEDIA: "media",
        CATALOGNUMBER: "catalognumber",
        RELEASESTATUS: "releasestatus",
        RELEASETYPE: "releasetype",
        RELEASECOUNTRY: "releasecountry",
        SCRIPT: "script",
        LANGUAGE: "language",
        COPYRIGHT: "copyright",
        LICENSE: "license",
        ENCODEDBY: "encodedby",
        ENCODERSETTINGS: "encodersettings",
        BARCODE: "barcode",
        ISRC: "isrc",
        ASIN: "asin",
        MUSICBRAINZ_TRACKID: "musicbrainz_recordingid",
        MUSICBRAINZ_RELEASETRACKID: "musicbrainz_trackid",
        MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
        MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
        MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
        MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
        MUSICBRAINZ_WORKID: "musicbrainz_workid",
        MUSICBRAINZ_TRMID: "musicbrainz_trmid",
        MUSICBRAINZ_DISCID: "musicbrainz_discid",
        ACOUSTID_ID: "acoustid_id",
        ACOUSTID_ID_FINGERPRINT: "acoustid_fingerprint",
        MUSICIP_PUID: "musicip_puid",
        // 'FINGERPRINT=MusicMagic Fingerprint {fingerprint}': 'musicip_fingerprint', // ToDo
        WEBSITE: "website",
        NOTES: "notes",
        TOTALTRACKS: "totaltracks",
        TOTALDISCS: "totaldiscs",
        // Discogs
        DISCOGS_ARTIST_ID: "discogs_artist_id",
        DISCOGS_ARTISTS: "artists",
        DISCOGS_ARTIST_NAME: "artists",
        DISCOGS_ALBUM_ARTISTS: "albumartist",
        DISCOGS_CATALOG: "catalognumber",
        DISCOGS_COUNTRY: "releasecountry",
        DISCOGS_DATE: "originaldate",
        DISCOGS_LABEL: "label",
        DISCOGS_LABEL_ID: "discogs_label_id",
        DISCOGS_MASTER_RELEASE_ID: "discogs_master_release_id",
        DISCOGS_RATING: "discogs_rating",
        DISCOGS_RELEASED: "date",
        DISCOGS_RELEASE_ID: "discogs_release_id",
        DISCOGS_VOTES: "discogs_votes",
        CATALOGID: "catalognumber",
        STYLE: "genre",
        //
        REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
        REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
        REPLAYGAIN_ALBUM_GAIN: "replaygain_album_gain",
        REPLAYGAIN_ALBUM_PEAK: "replaygain_album_peak",
        // To Sure if these (REPLAYGAIN_MINMAX, REPLAYGAIN_ALBUM_MINMAX & REPLAYGAIN_UNDO) are used for Vorbis:
        REPLAYGAIN_MINMAX: "replaygain_track_minmax",
        REPLAYGAIN_ALBUM_MINMAX: "replaygain_album_minmax",
        REPLAYGAIN_UNDO: "replaygain_undo"
      };
      class VorbisTagMapper extends CommonTagMapper {
        static toRating(email, rating, maxScore) {
          return {
            source: email ? email.toLowerCase() : void 0,
            rating: Number.parseFloat(rating) / maxScore * CommonTagMapper.maxRatingScore
          };
        }
        constructor() {
          super(["vorbis"], vorbisTagMap);
        }
        postMap(tag) {
          if (tag.id === "RATING") {
            tag.value = VorbisTagMapper.toRating(void 0, tag.value, 100);
          } else if (tag.id.indexOf("RATING:") === 0) {
            const keys = tag.id.split(":");
            tag.value = VorbisTagMapper.toRating(keys[1], tag.value, 1);
            tag.id = keys[0];
          }
        }
      }
      const riffInfoTagMap = {
        IART: "artist",
        // Artist
        ICRD: "date",
        // DateCreated
        INAM: "title",
        // Title
        TITL: "title",
        IPRD: "album",
        // Product
        ITRK: "track",
        IPRT: "track",
        // Additional tag for track index
        COMM: "comment",
        // Comments
        ICMT: "comment",
        // Country
        ICNT: "releasecountry",
        GNRE: "genre",
        // Genre
        IWRI: "writer",
        // WrittenBy
        RATE: "rating",
        YEAR: "year",
        ISFT: "encodedby",
        // Software
        CODE: "encodedby",
        // EncodedBy
        TURL: "website",
        // URL,
        IGNR: "genre",
        // Genre
        IENG: "engineer",
        // Engineer
        ITCH: "technician",
        // Technician
        IMED: "media",
        // Original Media
        IRPD: "album"
        // Product, where the file was intended for
      };
      class RiffInfoTagMapper extends CommonTagMapper {
        constructor() {
          super(["exif"], riffInfoTagMap);
        }
      }
      const ebmlTagMap = {
        "segment:title": "title",
        "album:ARTIST": "albumartist",
        "album:ARTISTSORT": "albumartistsort",
        "album:TITLE": "album",
        "album:DATE_RECORDED": "originaldate",
        "album:DATE_RELEASED": "releasedate",
        "album:PART_NUMBER": "disk",
        "album:TOTAL_PARTS": "totaltracks",
        "track:ARTIST": "artist",
        "track:ARTISTSORT": "artistsort",
        "track:TITLE": "title",
        "track:PART_NUMBER": "track",
        "track:MUSICBRAINZ_TRACKID": "musicbrainz_recordingid",
        "track:MUSICBRAINZ_ALBUMID": "musicbrainz_albumid",
        "track:MUSICBRAINZ_ARTISTID": "musicbrainz_artistid",
        "track:PUBLISHER": "label",
        "track:GENRE": "genre",
        "track:ENCODER": "encodedby",
        "track:ENCODER_OPTIONS": "encodersettings",
        "edition:TOTAL_PARTS": "totaldiscs",
        picture: "picture"
      };
      class MatroskaTagMapper extends CaseInsensitiveTagMap {
        constructor() {
          super(["matroska"], ebmlTagMap);
        }
      }
      const tagMap = {
        NAME: "title",
        AUTH: "artist",
        "(c) ": "copyright",
        ANNO: "comment"
      };
      class AiffTagMapper extends CommonTagMapper {
        constructor() {
          super(["AIFF"], tagMap);
        }
      }
      class CombinedTagMapper {
        constructor() {
          this.tagMappers = {};
          [
            new ID3v1TagMapper(),
            new ID3v22TagMapper(),
            new ID3v24TagMapper(),
            new MP4TagMapper(),
            new MP4TagMapper(),
            new VorbisTagMapper(),
            new APEv2TagMapper(),
            new AsfTagMapper(),
            new RiffInfoTagMapper(),
            new MatroskaTagMapper(),
            new AiffTagMapper()
          ].forEach((mapper) => {
            this.registerTagMapper(mapper);
          });
        }
        /**
         * Convert native to generic (common) tags
         * @param tagType Originating tag format
         * @param tag     Native tag to map to a generic tag id
         * @param warnings
         * @return Generic tag result (output of this function)
         */
        mapTag(tagType2, tag, warnings) {
          const tagMapper = this.tagMappers[tagType2];
          if (tagMapper) {
            return this.tagMappers[tagType2].mapGenericTag(tag, warnings);
          }
          throw new InternalParserError(`No generic tag mapper defined for tag-format: ${tagType2}`);
        }
        registerTagMapper(genericTagMapper) {
          for (const tagType2 of genericTagMapper.tagTypes) {
            this.tagMappers[tagType2] = genericTagMapper;
          }
        }
      }
      function parseLrc(lrcString) {
        const lines = lrcString.split("\n");
        const syncText = [];
        const timestampRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
        for (const line of lines) {
          const match = line.match(timestampRegex);
          if (match) {
            const minutes = Number.parseInt(match[1], 10);
            const seconds = Number.parseInt(match[2], 10);
            const millisecondsStr = match[3];
            let milliseconds;
            if (millisecondsStr.length === 3) {
              milliseconds = Number.parseInt(millisecondsStr, 10);
            } else {
              milliseconds = Number.parseInt(millisecondsStr, 10) * 10;
            }
            const timestamp = (minutes * 60 + seconds) * 1e3 + milliseconds;
            const text = line.replace(timestampRegex, "").trim();
            syncText.push({ timestamp, text });
          }
        }
        return {
          contentType: LyricsContentType.lyrics,
          timeStampFormat: TimestampFormat.milliseconds,
          syncText
        };
      }
      const debug$3 = initDebug("music-metadata:collector");
      const TagPriority = ["matroska", "APEv2", "vorbis", "ID3v2.4", "ID3v2.3", "ID3v2.2", "exif", "asf", "iTunes", "AIFF", "ID3v1"];
      class MetadataCollector {
        constructor(opts) {
          this.format = {
            tagTypes: [],
            trackInfo: []
          };
          this.native = {};
          this.common = {
            track: { no: null, of: null },
            disk: { no: null, of: null },
            movementIndex: { no: null, of: null }
          };
          this.quality = {
            warnings: []
          };
          this.commonOrigin = {};
          this.originPriority = {};
          this.tagMapper = new CombinedTagMapper();
          this.opts = opts;
          let priority = 1;
          for (const tagType2 of TagPriority) {
            this.originPriority[tagType2] = priority++;
          }
          this.originPriority.artificial = 500;
          this.originPriority.id3v1 = 600;
        }
        /**
         * @returns {boolean} true if one or more tags have been found
         */
        hasAny() {
          return Object.keys(this.native).length > 0;
        }
        addStreamInfo(streamInfo) {
          debug$3(`streamInfo: type=${streamInfo.type ? TrackTypeValueToKeyMap[streamInfo.type] : "?"}, codec=${streamInfo.codecName}`);
          this.format.trackInfo.push(streamInfo);
        }
        setFormat(key, value) {
          debug$3(`format: ${key} = ${value}`);
          this.format[key] = value;
          if (this.opts?.observer) {
            this.opts.observer({ metadata: this, tag: { type: "format", id: key, value } });
          }
        }
        setAudioOnly() {
          this.setFormat("hasAudio", true);
          this.setFormat("hasVideo", false);
        }
        async addTag(tagType2, tagId, value) {
          debug$3(`tag ${tagType2}.${tagId} = ${value}`);
          if (!this.native[tagType2]) {
            this.format.tagTypes.push(tagType2);
            this.native[tagType2] = [];
          }
          this.native[tagType2].push({ id: tagId, value });
          await this.toCommon(tagType2, tagId, value);
        }
        addWarning(warning) {
          this.quality.warnings.push({ message: warning });
        }
        async postMap(tagType2, tag) {
          switch (tag.id) {
            case "artist":
              if (this.commonOrigin.artist === this.originPriority[tagType2]) {
                return this.postMap("artificial", { id: "artists", value: tag.value });
              }
              if (!this.common.artists) {
                this.setGenericTag("artificial", { id: "artists", value: tag.value });
              }
              break;
            case "artists":
              if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {
                if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {
                  const artists = (this.common.artists || []).concat([tag.value]);
                  const value = joinArtists(artists);
                  const artistTag = { id: "artist", value };
                  this.setGenericTag("artificial", artistTag);
                }
              }
              break;
            case "picture":
              return this.postFixPicture(tag.value).then((picture) => {
                if (picture !== null) {
                  tag.value = picture;
                  this.setGenericTag(tagType2, tag);
                }
              });
            case "totaltracks":
              this.common.track.of = CommonTagMapper.toIntOrNull(tag.value);
              return;
            case "totaldiscs":
              this.common.disk.of = CommonTagMapper.toIntOrNull(tag.value);
              return;
            case "movementTotal":
              this.common.movementIndex.of = CommonTagMapper.toIntOrNull(tag.value);
              return;
            case "track":
            case "disk":
            case "movementIndex": {
              const of = this.common[tag.id].of;
              this.common[tag.id] = CommonTagMapper.normalizeTrack(tag.value);
              this.common[tag.id].of = of != null ? of : this.common[tag.id].of;
              return;
            }
            case "bpm":
            case "year":
            case "originalyear":
              tag.value = Number.parseInt(tag.value, 10);
              break;
            case "date": {
              const year = Number.parseInt(tag.value.substr(0, 4), 10);
              if (!Number.isNaN(year)) {
                this.common.year = year;
              }
              break;
            }
            case "discogs_label_id":
            case "discogs_release_id":
            case "discogs_master_release_id":
            case "discogs_artist_id":
            case "discogs_votes":
              tag.value = typeof tag.value === "string" ? Number.parseInt(tag.value, 10) : tag.value;
              break;
            case "replaygain_track_gain":
            case "replaygain_track_peak":
            case "replaygain_album_gain":
            case "replaygain_album_peak":
              tag.value = toRatio(tag.value);
              break;
            case "replaygain_track_minmax":
              tag.value = tag.value.split(",").map((v) => Number.parseInt(v, 10));
              break;
            case "replaygain_undo": {
              const minMix = tag.value.split(",").map((v) => Number.parseInt(v, 10));
              tag.value = {
                leftChannel: minMix[0],
                rightChannel: minMix[1]
              };
              break;
            }
            case "gapless":
            // iTunes gap-less flag
            case "compilation":
            case "podcast":
            case "showMovement":
              tag.value = tag.value === "1" || tag.value === 1;
              break;
            case "isrc": {
              const commonTag = this.common[tag.id];
              if (commonTag && commonTag.indexOf(tag.value) !== -1)
                return;
              break;
            }
            case "comment":
              if (typeof tag.value === "string") {
                tag.value = { text: tag.value };
              }
              if (tag.value.descriptor === "iTunPGAP") {
                this.setGenericTag(tagType2, { id: "gapless", value: tag.value.text === "1" });
              }
              break;
            case "lyrics":
              if (typeof tag.value === "string") {
                tag.value = parseLrc(tag.value);
              }
              break;
          }
          if (tag.value !== null) {
            this.setGenericTag(tagType2, tag);
          }
        }
        /**
         * Convert native tags to common tags
         * @returns {IAudioMetadata} Native + common tags
         */
        toCommonMetadata() {
          return {
            format: this.format,
            native: this.native,
            quality: this.quality,
            common: this.common
          };
        }
        /**
         * Fix some common issues with picture object
         * @param picture Picture
         */
        async postFixPicture(picture) {
          if (picture.data && picture.data.length > 0) {
            if (!picture.format) {
              const fileType = await fileTypeFromBuffer(Uint8Array.from(picture.data));
              if (fileType) {
                picture.format = fileType.mime;
              } else {
                return null;
              }
            }
            picture.format = picture.format.toLocaleLowerCase();
            switch (picture.format) {
              case "image/jpg":
                picture.format = "image/jpeg";
            }
            return picture;
          }
          this.addWarning("Empty picture tag found");
          return null;
        }
        /**
         * Convert native tag to common tags
         */
        async toCommon(tagType2, tagId, value) {
          const tag = { id: tagId, value };
          const genericTag = this.tagMapper.mapTag(tagType2, tag, this);
          if (genericTag) {
            await this.postMap(tagType2, genericTag);
          }
        }
        /**
         * Set generic tag
         */
        setGenericTag(tagType2, tag) {
          debug$3(`common.${tag.id} = ${tag.value}`);
          const prio0 = this.commonOrigin[tag.id] || 1e3;
          const prio1 = this.originPriority[tagType2];
          if (isSingleton(tag.id)) {
            if (prio1 <= prio0) {
              this.common[tag.id] = tag.value;
              this.commonOrigin[tag.id] = prio1;
            } else {
              return debug$3(`Ignore native tag (singleton): ${tagType2}.${tag.id} = ${tag.value}`);
            }
          } else {
            if (prio1 === prio0) {
              if (!isUnique(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {
                this.common[tag.id].push(tag.value);
              } else {
                debug$3(`Ignore duplicate value: ${tagType2}.${tag.id} = ${tag.value}`);
              }
            } else if (prio1 < prio0) {
              this.common[tag.id] = [tag.value];
              this.commonOrigin[tag.id] = prio1;
            } else {
              return debug$3(`Ignore native tag (list): ${tagType2}.${tag.id} = ${tag.value}`);
            }
          }
          if (this.opts?.observer) {
            this.opts.observer({ metadata: this, tag: { type: "common", id: tag.id, value: tag.value } });
          }
        }
      }
      function joinArtists(artists) {
        if (artists.length > 2) {
          return `${artists.slice(0, artists.length - 1).join(", ")} & ${artists[artists.length - 1]}`;
        }
        return artists.join(" & ");
      }
      const scriptRel = /* @__PURE__ */ (function detectScriptRel() {
        const relList = typeof document !== "undefined" && document.createElement("link").relList;
        return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
      })();
      const assetsURL = function(dep) {
        return "/" + dep;
      };
      const seen = {};
      const __vitePreload = function preload(baseModule, deps, importerUrl) {
        let promise = Promise.resolve();
        if (deps && deps.length > 0) {
          let allSettled = function(promises$2) {
            return Promise.all(promises$2.map((p) => Promise.resolve(p).then((value$1) => ({
              status: "fulfilled",
              value: value$1
            }), (reason) => ({
              status: "rejected",
              reason
            }))));
          };
          document.getElementsByTagName("link");
          const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
          const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
          promise = allSettled(deps.map((dep) => {
            dep = assetsURL(dep);
            if (dep in seen) return;
            seen[dep] = true;
            const isCss = dep.endsWith(".css");
            const cssSelector = isCss ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
            const link = document.createElement("link");
            link.rel = isCss ? "stylesheet" : scriptRel;
            if (!isCss) link.as = "script";
            link.crossOrigin = "";
            link.href = dep;
            if (cspNonce) link.setAttribute("nonce", cspNonce);
            document.head.appendChild(link);
            if (isCss) return new Promise((res, rej) => {
              link.addEventListener("load", res);
              link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
            });
          }));
        }
        function handlePreloadError(err$2) {
          const e$1 = new Event("vite:preloadError", { cancelable: true });
          e$1.payload = err$2;
          window.dispatchEvent(e$1);
          if (!e$1.defaultPrevented) throw err$2;
        }
        return promise.then((res) => {
          for (const item of res || []) {
            if (item.status !== "rejected") continue;
            handlePreloadError(item.reason);
          }
          return baseModule().catch(handlePreloadError);
        });
      };
      const mpegParserLoader = {
        parserType: "mpeg",
        extensions: [".mp2", ".mp3", ".m2a", ".aac", "aacp"],
        mimeTypes: ["audio/mpeg", "audio/mp3", "audio/aacs", "audio/aacp"],
        async load() {
          return (await __vitePreload(async () => {
            const { MpegParser } = await module.import('./MpegParser-DyX8Q9zG-DQ-hFEy_.js');
            return { MpegParser };
          }, void 0 )).MpegParser;
        }
      };
      const apeParserLoader = {
        parserType: "apev2",
        extensions: [".ape"],
        mimeTypes: ["audio/ape", "audio/monkeys-audio"],
        async load() {
          return (await __vitePreload(async () => {
            const { APEv2Parser: APEv2Parser2 } = await Promise.resolve().then(() => APEv2Parser$1);
            return { APEv2Parser: APEv2Parser2 };
          }, void 0 )).APEv2Parser;
        }
      };
      const asfParserLoader = {
        parserType: "asf",
        extensions: [".asf"],
        mimeTypes: ["audio/ms-wma", "video/ms-wmv", "audio/ms-asf", "video/ms-asf", "application/vnd.ms-asf"],
        async load() {
          return (await __vitePreload(async () => {
            const { AsfParser } = await module.import('./AsfParser-kBS_Jzzd--TJ98UiQ.js');
            return { AsfParser };
          }, void 0 )).AsfParser;
        }
      };
      const dsdiffParserLoader = {
        parserType: "dsdiff",
        extensions: [".dff"],
        mimeTypes: ["audio/dsf", "audio/dsd"],
        async load() {
          return (await __vitePreload(async () => {
            const { DsdiffParser } = await module.import('./DsdiffParser-Cj-IrqyX-XWY5qgSL.js');
            return { DsdiffParser };
          }, void 0 )).DsdiffParser;
        }
      };
      const aiffParserLoader = {
        parserType: "aiff",
        extensions: [".aif", "aiff", "aifc"],
        mimeTypes: ["audio/aiff", "audio/aif", "audio/aifc", "application/aiff"],
        async load() {
          return (await __vitePreload(async () => {
            const { AIFFParser } = await module.import('./AiffParser-D5_3j2lV-CIoGOP9Z.js');
            return { AIFFParser };
          }, void 0 )).AIFFParser;
        }
      };
      const dsfParserLoader = {
        parserType: "dsf",
        extensions: [".dsf"],
        mimeTypes: ["audio/dsf"],
        async load() {
          return (await __vitePreload(async () => {
            const { DsfParser } = await module.import('./DsfParser-CXpMW3TW-C2hKRmVY.js');
            return { DsfParser };
          }, void 0 )).DsfParser;
        }
      };
      const flacParserLoader = {
        parserType: "flac",
        extensions: [".flac"],
        mimeTypes: ["audio/flac"],
        async load() {
          return (await __vitePreload(async () => {
            const { FlacParser } = await module.import('./FlacParser-CAsVRrMV-DZB68qaX.js').then((n) => n.d);
            return { FlacParser };
          }, void 0 )).FlacParser;
        }
      };
      const matroskaParserLoader = {
        parserType: "matroska",
        extensions: [".mka", ".mkv", ".mk3d", ".mks", "webm"],
        mimeTypes: ["audio/matroska", "video/matroska", "audio/webm", "video/webm"],
        async load() {
          return (await __vitePreload(async () => {
            const { MatroskaParser } = await module.import('./MatroskaParser-CS7zPSHf-BBAz_su7.js');
            return { MatroskaParser };
          }, void 0 )).MatroskaParser;
        }
      };
      const mp4ParserLoader = {
        parserType: "mp4",
        extensions: [".mp4", ".m4a", ".m4b", ".m4pa", "m4v", "m4r", "3gp"],
        mimeTypes: ["audio/mp4", "audio/m4a", "video/m4v", "video/mp4"],
        async load() {
          return (await __vitePreload(async () => {
            const { MP4Parser } = await module.import('./MP4Parser-D4esQf31-DVt6cbno.js');
            return { MP4Parser };
          }, void 0 )).MP4Parser;
        }
      };
      const musepackParserLoader = {
        parserType: "musepack",
        extensions: [".mpc"],
        mimeTypes: ["audio/musepack"],
        async load() {
          return (await __vitePreload(async () => {
            const { MusepackParser } = await module.import('./MusepackParser-DjtwqjaL-D_aeNfDv.js');
            return { MusepackParser };
          }, void 0 )).MusepackParser;
        }
      };
      const oggParserLoader = {
        parserType: "ogg",
        extensions: [".ogg", ".ogv", ".oga", ".ogm", ".ogx", ".opus", ".spx"],
        mimeTypes: ["audio/ogg", "audio/opus", "audio/speex", "video/ogg"],
        // RFC 7845, RFC 6716, RFC 5574
        async load() {
          return (await __vitePreload(async () => {
            const { OggParser } = await module.import('./OggParser-ClkMM5gt-DEny-a2U.js');
            return { OggParser };
          }, void 0 )).OggParser;
        }
      };
      const wavpackParserLoader = {
        parserType: "wavpack",
        extensions: [".wv", ".wvp"],
        mimeTypes: ["audio/wavpack"],
        async load() {
          return (await __vitePreload(async () => {
            const { WavPackParser } = await module.import('./WavPackParser-BLGhkLPg-CrOWnE7a.js');
            return { WavPackParser };
          }, void 0 )).WavPackParser;
        }
      };
      const riffParserLoader = {
        parserType: "riff",
        extensions: [".wav", "wave", ".bwf"],
        mimeTypes: ["audio/vnd.wave", "audio/wav", "audio/wave"],
        async load() {
          return (await __vitePreload(async () => {
            const { WaveParser } = await module.import('./WaveParser-C8tUW5CK--zKdjNgH.js');
            return { WaveParser };
          }, void 0 )).WaveParser;
        }
      };
      const debug$2 = initDebug("music-metadata:parser:factory");
      function parseHttpContentType(contentType2) {
        const type = ContentType.parse(contentType2);
        const mime = mediaTyperExports.parse(type.type);
        return {
          type: mime.type,
          subtype: mime.subtype,
          suffix: mime.suffix,
          parameters: type.parameters
        };
      }
      class ParserFactory {
        constructor() {
          this.parsers = [];
          [
            flacParserLoader,
            mpegParserLoader,
            apeParserLoader,
            mp4ParserLoader,
            matroskaParserLoader,
            riffParserLoader,
            oggParserLoader,
            asfParserLoader,
            aiffParserLoader,
            wavpackParserLoader,
            musepackParserLoader,
            dsfParserLoader,
            dsdiffParserLoader
          ].forEach((parser) => {
            this.registerParser(parser);
          });
        }
        registerParser(parser) {
          this.parsers.push(parser);
        }
        async parse(tokenizer, parserLoader, opts) {
          if (tokenizer.supportsRandomAccess()) {
            debug$2("tokenizer supports random-access, scanning for appending headers");
            await scanAppendingHeaders(tokenizer, opts);
          } else {
            debug$2("tokenizer does not support random-access, cannot scan for appending headers");
          }
          if (!parserLoader) {
            const buf = new Uint8Array(4100);
            if (tokenizer.fileInfo.mimeType) {
              parserLoader = this.findLoaderForContentType(tokenizer.fileInfo.mimeType);
            }
            if (!parserLoader && tokenizer.fileInfo.path) {
              parserLoader = this.findLoaderForExtension(tokenizer.fileInfo.path);
            }
            if (!parserLoader) {
              debug$2("Guess parser on content...");
              await tokenizer.peekBuffer(buf, { mayBeLess: true });
              const guessedType = await fileTypeFromBuffer(buf, { mpegOffsetTolerance: 10 });
              if (!guessedType || !guessedType.mime) {
                throw new CouldNotDetermineFileTypeError("Failed to determine audio format");
              }
              debug$2(`Guessed file type is mime=${guessedType.mime}, extension=${guessedType.ext}`);
              parserLoader = this.findLoaderForContentType(guessedType.mime);
              if (!parserLoader) {
                throw new UnsupportedFileTypeError(`Guessed MIME-type not supported: ${guessedType.mime}`);
              }
            }
          }
          debug$2(`Loading ${parserLoader.parserType} parser...`);
          const metadata = new MetadataCollector(opts);
          const ParserImpl = await parserLoader.load();
          const parser = new ParserImpl(metadata, tokenizer, opts ?? {});
          debug$2(`Parser ${parserLoader.parserType} loaded`);
          await parser.parse();
          if (metadata.format.trackInfo) {
            if (metadata.format.hasAudio === void 0) {
              metadata.setFormat("hasAudio", !!metadata.format.trackInfo.find((track) => track.type === TrackType.audio));
            }
            if (metadata.format.hasVideo === void 0) {
              metadata.setFormat("hasVideo", !!metadata.format.trackInfo.find((track) => track.type === TrackType.video));
            }
          }
          return metadata.toCommonMetadata();
        }
        /**
         * @param filePath - Path, filename or extension to audio file
         * @return Parser submodule name
         */
        findLoaderForExtension(filePath) {
          if (!filePath)
            return;
          const extension = getExtension(filePath).toLocaleLowerCase() || filePath;
          return this.parsers.find((parser) => parser.extensions.indexOf(extension) !== -1);
        }
        findLoaderForContentType(httpContentType) {
          let mime;
          if (!httpContentType)
            return;
          try {
            mime = parseHttpContentType(httpContentType);
          } catch (_err) {
            debug$2(`Invalid HTTP Content-Type header value: ${httpContentType}`);
            return;
          }
          const subType = mime.subtype.indexOf("x-") === 0 ? mime.subtype.substring(2) : mime.subtype;
          return this.parsers.find((parser) => parser.mimeTypes.find((loader) => loader.indexOf(`${mime.type}/${subType}`) !== -1));
        }
        getSupportedMimeTypes() {
          const mimeTypeSet = /* @__PURE__ */ new Set();
          this.parsers.forEach((loader) => {
            loader.mimeTypes.forEach((mimeType) => {
              mimeTypeSet.add(mimeType);
              mimeTypeSet.add(mimeType.replace("/", "/x-"));
            });
          });
          return Array.from(mimeTypeSet);
        }
      }
      function getExtension(fname) {
        const i = fname.lastIndexOf(".");
        return i === -1 ? "" : fname.slice(i);
      }
      class BasicParser {
        /**
         * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
         * @param {INativeMetadataCollector} metadata Output
         * @param {ITokenizer} tokenizer Input
         * @param {IOptions} options Parsing options
         */
        constructor(metadata, tokenizer, options) {
          this.metadata = metadata;
          this.tokenizer = tokenizer;
          this.options = options;
        }
      } exports("B", BasicParser);
      const WINDOWS_1252_EXTRA = {
        128: "€",
        130: "‚",
        131: "ƒ",
        132: "„",
        133: "…",
        134: "†",
        135: "‡",
        136: "ˆ",
        137: "‰",
        138: "Š",
        139: "‹",
        140: "Œ",
        142: "Ž",
        145: "‘",
        146: "’",
        147: "“",
        148: "”",
        149: "•",
        150: "–",
        151: "—",
        152: "˜",
        153: "™",
        154: "š",
        155: "›",
        156: "œ",
        158: "ž",
        159: "Ÿ"
      };
      const WINDOWS_1252_REVERSE = {};
      for (const [code, char] of Object.entries(WINDOWS_1252_EXTRA)) {
        WINDOWS_1252_REVERSE[char] = Number.parseInt(code);
      }
      function textDecode(bytes, encoding = "utf-8") {
        switch (encoding.toLowerCase()) {
          case "utf-8":
          case "utf8":
            if (typeof globalThis.TextDecoder !== "undefined") {
              return new globalThis.TextDecoder("utf-8").decode(bytes);
            }
            return decodeUTF8(bytes);
          case "utf-16le":
            return decodeUTF16LE(bytes);
          case "ascii":
            return decodeASCII(bytes);
          case "latin1":
          case "iso-8859-1":
            return decodeLatin1(bytes);
          case "windows-1252":
            return decodeWindows1252(bytes);
          default:
            throw new RangeError(`Encoding '${encoding}' not supported`);
        }
      }
      function textEncode(input = "", encoding = "utf-8") {
        switch (encoding.toLowerCase()) {
          case "utf-8":
          case "utf8":
            if (typeof globalThis.TextEncoder !== "undefined") {
              return new globalThis.TextEncoder().encode(input);
            }
            return encodeUTF8(input);
          case "utf-16le":
            return encodeUTF16LE(input);
          case "ascii":
            return encodeASCII(input);
          case "latin1":
          case "iso-8859-1":
            return encodeLatin1(input);
          case "windows-1252":
            return encodeWindows1252(input);
          default:
            throw new RangeError(`Encoding '${encoding}' not supported`);
        }
      }
      function decodeUTF8(bytes) {
        let out = "";
        let i = 0;
        while (i < bytes.length) {
          const b1 = bytes[i++];
          if (b1 < 128) {
            out += String.fromCharCode(b1);
          } else if (b1 < 224) {
            const b2 = bytes[i++] & 63;
            out += String.fromCharCode((b1 & 31) << 6 | b2);
          } else if (b1 < 240) {
            const b2 = bytes[i++] & 63;
            const b3 = bytes[i++] & 63;
            out += String.fromCharCode((b1 & 15) << 12 | b2 << 6 | b3);
          } else {
            const b2 = bytes[i++] & 63;
            const b3 = bytes[i++] & 63;
            const b4 = bytes[i++] & 63;
            let cp = (b1 & 7) << 18 | b2 << 12 | b3 << 6 | b4;
            cp -= 65536;
            out += String.fromCharCode(55296 + (cp >> 10 & 1023), 56320 + (cp & 1023));
          }
        }
        return out;
      }
      function decodeUTF16LE(bytes) {
        let out = "";
        for (let i = 0; i < bytes.length; i += 2) {
          out += String.fromCharCode(bytes[i] | bytes[i + 1] << 8);
        }
        return out;
      }
      function decodeASCII(bytes) {
        return String.fromCharCode(...bytes.map((b) => b & 127));
      }
      function decodeLatin1(bytes) {
        return String.fromCharCode(...bytes);
      }
      function decodeWindows1252(bytes) {
        let out = "";
        for (const b of bytes) {
          if (b >= 128 && b <= 159 && WINDOWS_1252_EXTRA[b]) {
            out += WINDOWS_1252_EXTRA[b];
          } else {
            out += String.fromCharCode(b);
          }
        }
        return out;
      }
      function encodeUTF8(str) {
        const out = [];
        for (let i = 0; i < str.length; i++) {
          const cp = str.charCodeAt(i);
          if (cp < 128) {
            out.push(cp);
          } else if (cp < 2048) {
            out.push(192 | cp >> 6, 128 | cp & 63);
          } else if (cp < 65536) {
            out.push(224 | cp >> 12, 128 | cp >> 6 & 63, 128 | cp & 63);
          } else {
            out.push(240 | cp >> 18, 128 | cp >> 12 & 63, 128 | cp >> 6 & 63, 128 | cp & 63);
          }
        }
        return new Uint8Array(out);
      }
      function encodeUTF16LE(str) {
        const out = new Uint8Array(str.length * 2);
        for (let i = 0; i < str.length; i++) {
          const code = str.charCodeAt(i);
          out[i * 2] = code & 255;
          out[i * 2 + 1] = code >> 8;
        }
        return out;
      }
      function encodeASCII(str) {
        return new Uint8Array([...str].map((ch) => ch.charCodeAt(0) & 127));
      }
      function encodeLatin1(str) {
        return new Uint8Array([...str].map((ch) => ch.charCodeAt(0) & 255));
      }
      function encodeWindows1252(str) {
        return new Uint8Array([...str].map((ch) => {
          const code = ch.charCodeAt(0);
          if (code <= 255)
            return code;
          if (WINDOWS_1252_REVERSE[ch] !== void 0)
            return WINDOWS_1252_REVERSE[ch];
          return 63;
        }));
      }
      const validFourCC = /^[\x21-\x7e©][\x20-\x7e\x00()]{3}/;
      const FourCcToken = exports("F", {
        len: 4,
        get: (buf, off) => {
          const id = textDecode(buf.slice(off, off + FourCcToken.len), "latin1");
          if (!id.match(validFourCC)) {
            throw new FieldDecodingError(`FourCC contains invalid characters: ${a2hex(id)} "${id}"`);
          }
          return id;
        },
        put: (buffer, offset, id) => {
          const str = textEncode(id, "latin1");
          if (str.length !== 4)
            throw new InternalParserError("Invalid length");
          buffer.set(str, offset);
          return offset + 4;
        }
      });
      const DataType = {
        text_utf8: 0,
        binary: 1,
        external_info: 2,
        reserved: 3
      };
      const DescriptorParser = {
        len: 52,
        get: (buf, off) => {
          return {
            // should equal 'MAC '
            ID: FourCcToken.get(buf, off),
            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
            version: UINT32_LE.get(buf, off + 4) / 1e3,
            // the number of descriptor bytes (allows later expansion of this header)
            descriptorBytes: UINT32_LE.get(buf, off + 8),
            // the number of header APE_HEADER bytes
            headerBytes: UINT32_LE.get(buf, off + 12),
            // the number of header APE_HEADER bytes
            seekTableBytes: UINT32_LE.get(buf, off + 16),
            // the number of header data bytes (from original file)
            headerDataBytes: UINT32_LE.get(buf, off + 20),
            // the number of bytes of APE frame data
            apeFrameDataBytes: UINT32_LE.get(buf, off + 24),
            // the high order number of APE frame data bytes
            apeFrameDataBytesHigh: UINT32_LE.get(buf, off + 28),
            // the terminating data of the file (not including tag data)
            terminatingDataBytes: UINT32_LE.get(buf, off + 32),
            // the MD5 hash of the file (see notes for usage... it's a little tricky)
            fileMD5: new Uint8ArrayType(16).get(buf, off + 36)
          };
        }
      };
      const Header = {
        len: 24,
        get: (buf, off) => {
          return {
            // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)
            compressionLevel: UINT16_LE.get(buf, off),
            // any format flags (for future use)
            formatFlags: UINT16_LE.get(buf, off + 2),
            // the number of audio blocks in one frame
            blocksPerFrame: UINT32_LE.get(buf, off + 4),
            // the number of audio blocks in the final frame
            finalFrameBlocks: UINT32_LE.get(buf, off + 8),
            // the total number of frames
            totalFrames: UINT32_LE.get(buf, off + 12),
            // the bits per sample (typically 16)
            bitsPerSample: UINT16_LE.get(buf, off + 16),
            // the number of channels (1 or 2)
            channel: UINT16_LE.get(buf, off + 18),
            // the sample rate (typically 44100)
            sampleRate: UINT32_LE.get(buf, off + 20)
          };
        }
      };
      const TagFooter = {
        len: 32,
        get: (buf, off) => {
          return {
            // should equal 'APETAGEX'
            ID: new StringType(8, "ascii").get(buf, off),
            // equals CURRENT_APE_TAG_VERSION
            version: UINT32_LE.get(buf, off + 8),
            // the complete size of the tag, including this footer (excludes header)
            size: UINT32_LE.get(buf, off + 12),
            // the number of fields in the tag
            fields: UINT32_LE.get(buf, off + 16),
            // reserved for later use (must be zero),
            flags: parseTagFlags(UINT32_LE.get(buf, off + 20))
          };
        }
      };
      const TagItemHeader = {
        len: 8,
        get: (buf, off) => {
          return {
            // Length of assigned value in bytes
            size: UINT32_LE.get(buf, off),
            // reserved for later use (must be zero),
            flags: parseTagFlags(UINT32_LE.get(buf, off + 4))
          };
        }
      };
      function parseTagFlags(flags) {
        return {
          containsHeader: isBitSet(flags, 31),
          containsFooter: isBitSet(flags, 30),
          isHeader: isBitSet(flags, 29),
          readOnly: isBitSet(flags, 0),
          dataType: (flags & 6) >> 1
        };
      }
      function isBitSet(num, bit) {
        return (num & 1 << bit) !== 0;
      }
      const debug$1 = initDebug("music-metadata:parser:APEv2");
      const tagFormat = "APEv2";
      const preamble = "APETAGEX";
      class ApeContentError extends makeUnexpectedFileContentError("APEv2") {
      }
      function tryParseApeHeader(metadata, tokenizer, options) {
        const apeParser = new APEv2Parser(metadata, tokenizer, options);
        return apeParser.tryParseApeHeader();
      }
      class APEv2Parser extends BasicParser {
        constructor() {
          super(...arguments);
          this.ape = {};
        }
        /**
         * Calculate the media file duration
         * @param ah ApeHeader
         * @return {number} duration in seconds
         */
        static calculateDuration(ah) {
          let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;
          duration += ah.finalFrameBlocks;
          return duration / ah.sampleRate;
        }
        /**
         * Calculates the APEv1 / APEv2 first field offset
         * @param tokenizer
         * @param offset
         */
        static async findApeFooterOffset(tokenizer, offset) {
          const apeBuf = new Uint8Array(TagFooter.len);
          const position = tokenizer.position;
          if (offset <= TagFooter.len) {
            debug$1(`Offset is too small to read APE footer: offset=${offset}`);
            return void 0;
          }
          if (offset > TagFooter.len) {
            await tokenizer.readBuffer(apeBuf, { position: offset - TagFooter.len });
            tokenizer.setPosition(position);
            const tagFooter = TagFooter.get(apeBuf, 0);
            if (tagFooter.ID === "APETAGEX") {
              if (tagFooter.flags.isHeader) {
                debug$1(`APE Header found at offset=${offset - TagFooter.len}`);
              } else {
                debug$1(`APE Footer found at offset=${offset - TagFooter.len}`);
                offset -= tagFooter.size;
              }
              return { footer: tagFooter, offset };
            }
          }
        }
        static parseTagFooter(metadata, buffer, options) {
          const footer2 = TagFooter.get(buffer, buffer.length - TagFooter.len);
          if (footer2.ID !== preamble)
            throw new ApeContentError("Unexpected APEv2 Footer ID preamble value");
          fromBuffer(buffer);
          const apeParser = new APEv2Parser(metadata, fromBuffer(buffer), options);
          return apeParser.parseTags(footer2);
        }
        /**
         * Parse APEv1 / APEv2 header if header signature found
         */
        async tryParseApeHeader() {
          if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < TagFooter.len) {
            debug$1("No APEv2 header found, end-of-file reached");
            return;
          }
          const footer2 = await this.tokenizer.peekToken(TagFooter);
          if (footer2.ID === preamble) {
            await this.tokenizer.ignore(TagFooter.len);
            return this.parseTags(footer2);
          }
          debug$1(`APEv2 header not found at offset=${this.tokenizer.position}`);
          if (this.tokenizer.fileInfo.size) {
            const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position;
            const buffer = new Uint8Array(remaining);
            await this.tokenizer.readBuffer(buffer);
            return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);
          }
        }
        async parse() {
          const descriptor = await this.tokenizer.readToken(DescriptorParser);
          if (descriptor.ID !== "MAC ")
            throw new ApeContentError("Unexpected descriptor ID");
          this.ape.descriptor = descriptor;
          const lenExp = descriptor.descriptorBytes - DescriptorParser.len;
          const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());
          this.metadata.setAudioOnly();
          await this.tokenizer.ignore(header.forwardBytes);
          return this.tryParseApeHeader();
        }
        async parseTags(footer2) {
          const keyBuffer = new Uint8Array(256);
          let bytesRemaining = footer2.size - TagFooter.len;
          debug$1(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);
          for (let i = 0; i < footer2.fields; i++) {
            if (bytesRemaining < TagItemHeader.len) {
              this.metadata.addWarning(`APEv2 Tag-header: ${footer2.fields - i} items remaining, but no more tag data to read.`);
              break;
            }
            const tagItemHeader = await this.tokenizer.readToken(TagItemHeader);
            bytesRemaining -= TagItemHeader.len + tagItemHeader.size;
            await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });
            let zero = findZero(keyBuffer, 0, keyBuffer.length);
            const key = await this.tokenizer.readToken(new StringType(zero, "ascii"));
            await this.tokenizer.ignore(1);
            bytesRemaining -= key.length + 1;
            switch (tagItemHeader.flags.dataType) {
              case DataType.text_utf8: {
                const value = await this.tokenizer.readToken(new StringType(tagItemHeader.size, "utf8"));
                const values = value.split(/\x00/g);
                await Promise.all(values.map((val) => this.metadata.addTag(tagFormat, key, val)));
                break;
              }
              case DataType.binary:
                if (this.options.skipCovers) {
                  await this.tokenizer.ignore(tagItemHeader.size);
                } else {
                  const picData = new Uint8Array(tagItemHeader.size);
                  await this.tokenizer.readBuffer(picData);
                  zero = findZero(picData, 0, picData.length);
                  const description = textDecode(picData.slice(0, zero), "utf-8");
                  const data = picData.slice(zero + 1);
                  await this.metadata.addTag(tagFormat, key, {
                    description,
                    data
                  });
                }
                break;
              case DataType.external_info:
                debug$1(`Ignore external info ${key}`);
                await this.tokenizer.ignore(tagItemHeader.size);
                break;
              case DataType.reserved:
                debug$1(`Ignore external info ${key}`);
                this.metadata.addWarning(`APEv2 header declares a reserved datatype for "${key}"`);
                await this.tokenizer.ignore(tagItemHeader.size);
                break;
            }
          }
        }
        async parseDescriptorExpansion(lenExp) {
          await this.tokenizer.ignore(lenExp);
          return this.parseHeader();
        }
        async parseHeader() {
          const header = await this.tokenizer.readToken(Header);
          this.metadata.setFormat("lossless", true);
          this.metadata.setFormat("container", "Monkey's Audio");
          this.metadata.setFormat("bitsPerSample", header.bitsPerSample);
          this.metadata.setFormat("sampleRate", header.sampleRate);
          this.metadata.setFormat("numberOfChannels", header.channel);
          this.metadata.setFormat("duration", APEv2Parser.calculateDuration(header));
          if (!this.ape.descriptor) {
            throw new ApeContentError("Missing APE descriptor");
          }
          return {
            forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes + this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes
          };
        }
      }
      const APEv2Parser$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        APEv2Parser,
        ApeContentError,
        tryParseApeHeader
      }, Symbol.toStringTag, { value: "Module" }));
      const debug = initDebug("music-metadata:parser:ID3v1");
      const Genres = exports("G", [
        "Blues",
        "Classic Rock",
        "Country",
        "Dance",
        "Disco",
        "Funk",
        "Grunge",
        "Hip-Hop",
        "Jazz",
        "Metal",
        "New Age",
        "Oldies",
        "Other",
        "Pop",
        "R&B",
        "Rap",
        "Reggae",
        "Rock",
        "Techno",
        "Industrial",
        "Alternative",
        "Ska",
        "Death Metal",
        "Pranks",
        "Soundtrack",
        "Euro-Techno",
        "Ambient",
        "Trip-Hop",
        "Vocal",
        "Jazz+Funk",
        "Fusion",
        "Trance",
        "Classical",
        "Instrumental",
        "Acid",
        "House",
        "Game",
        "Sound Clip",
        "Gospel",
        "Noise",
        "Alt. Rock",
        "Bass",
        "Soul",
        "Punk",
        "Space",
        "Meditative",
        "Instrumental Pop",
        "Instrumental Rock",
        "Ethnic",
        "Gothic",
        "Darkwave",
        "Techno-Industrial",
        "Electronic",
        "Pop-Folk",
        "Eurodance",
        "Dream",
        "Southern Rock",
        "Comedy",
        "Cult",
        "Gangsta Rap",
        "Top 40",
        "Christian Rap",
        "Pop/Funk",
        "Jungle",
        "Native American",
        "Cabaret",
        "New Wave",
        "Psychedelic",
        "Rave",
        "Showtunes",
        "Trailer",
        "Lo-Fi",
        "Tribal",
        "Acid Punk",
        "Acid Jazz",
        "Polka",
        "Retro",
        "Musical",
        "Rock & Roll",
        "Hard Rock",
        "Folk",
        "Folk/Rock",
        "National Folk",
        "Swing",
        "Fast-Fusion",
        "Bebob",
        "Latin",
        "Revival",
        "Celtic",
        "Bluegrass",
        "Avantgarde",
        "Gothic Rock",
        "Progressive Rock",
        "Psychedelic Rock",
        "Symphonic Rock",
        "Slow Rock",
        "Big Band",
        "Chorus",
        "Easy Listening",
        "Acoustic",
        "Humour",
        "Speech",
        "Chanson",
        "Opera",
        "Chamber Music",
        "Sonata",
        "Symphony",
        "Booty Bass",
        "Primus",
        "Porn Groove",
        "Satire",
        "Slow Jam",
        "Club",
        "Tango",
        "Samba",
        "Folklore",
        "Ballad",
        "Power Ballad",
        "Rhythmic Soul",
        "Freestyle",
        "Duet",
        "Punk Rock",
        "Drum Solo",
        "A Cappella",
        "Euro-House",
        "Dance Hall",
        "Goa",
        "Drum & Bass",
        "Club-House",
        "Hardcore",
        "Terror",
        "Indie",
        "BritPop",
        "Negerpunk",
        "Polsk Punk",
        "Beat",
        "Christian Gangsta Rap",
        "Heavy Metal",
        "Black Metal",
        "Crossover",
        "Contemporary Christian",
        "Christian Rock",
        "Merengue",
        "Salsa",
        "Thrash Metal",
        "Anime",
        "JPop",
        "Synthpop",
        "Abstract",
        "Art Rock",
        "Baroque",
        "Bhangra",
        "Big Beat",
        "Breakbeat",
        "Chillout",
        "Downtempo",
        "Dub",
        "EBM",
        "Eclectic",
        "Electro",
        "Electroclash",
        "Emo",
        "Experimental",
        "Garage",
        "Global",
        "IDM",
        "Illbient",
        "Industro-Goth",
        "Jam Band",
        "Krautrock",
        "Leftfield",
        "Lounge",
        "Math Rock",
        "New Romantic",
        "Nu-Breakz",
        "Post-Punk",
        "Post-Rock",
        "Psytrance",
        "Shoegaze",
        "Space Rock",
        "Trop Rock",
        "World Music",
        "Neoclassical",
        "Audiobook",
        "Audio Theatre",
        "Neue Deutsche Welle",
        "Podcast",
        "Indie Rock",
        "G-Funk",
        "Dubstep",
        "Garage Rock",
        "Psybient"
      ]);
      const Iid3v1Token = {
        len: 128,
        /**
         * @param buf Buffer possibly holding the 128 bytes ID3v1.1 metadata header
         * @param off Offset in buffer in bytes
         * @returns ID3v1.1 header if first 3 bytes equals 'TAG', otherwise null is returned
         */
        get: (buf, off) => {
          const header = new Id3v1StringType(3).get(buf, off);
          return header === "TAG" ? {
            header,
            title: new Id3v1StringType(30).get(buf, off + 3),
            artist: new Id3v1StringType(30).get(buf, off + 33),
            album: new Id3v1StringType(30).get(buf, off + 63),
            year: new Id3v1StringType(4).get(buf, off + 93),
            comment: new Id3v1StringType(28).get(buf, off + 97),
            // ID3v1.1 separator for track
            zeroByte: UINT8.get(buf, off + 127),
            // track: ID3v1.1 field added by Michael Mutschler
            track: UINT8.get(buf, off + 126),
            genre: UINT8.get(buf, off + 127)
          } : null;
        }
      };
      class Id3v1StringType {
        constructor(len) {
          this.len = len;
          this.stringType = new StringType(len, "latin1");
        }
        get(buf, off) {
          let value = this.stringType.get(buf, off);
          value = trimRightNull(value);
          value = value.trim();
          return value.length > 0 ? value : void 0;
        }
      }
      class ID3v1Parser extends BasicParser {
        constructor(metadata, tokenizer, options) {
          super(metadata, tokenizer, options);
          this.apeHeader = options.apeHeader;
        }
        static getGenre(genreIndex) {
          if (genreIndex < Genres.length) {
            return Genres[genreIndex];
          }
          return void 0;
        }
        async parse() {
          if (!this.tokenizer.fileInfo.size) {
            debug("Skip checking for ID3v1 because the file-size is unknown");
            return;
          }
          if (this.apeHeader) {
            this.tokenizer.ignore(this.apeHeader.offset - this.tokenizer.position);
            const apeParser = new APEv2Parser(this.metadata, this.tokenizer, this.options);
            await apeParser.parseTags(this.apeHeader.footer);
          }
          const offset = this.tokenizer.fileInfo.size - Iid3v1Token.len;
          if (this.tokenizer.position > offset) {
            debug("Already consumed the last 128 bytes");
            return;
          }
          const header = await this.tokenizer.readToken(Iid3v1Token, offset);
          if (header) {
            debug("ID3v1 header found at: pos=%s", this.tokenizer.fileInfo.size - Iid3v1Token.len);
            const props = ["title", "artist", "album", "comment", "track", "year"];
            for (const id of props) {
              if (header[id] && header[id] !== "")
                await this.addTag(id, header[id]);
            }
            const genre = ID3v1Parser.getGenre(header.genre);
            if (genre)
              await this.addTag("genre", genre);
          } else {
            debug("ID3v1 header not found at: pos=%s", this.tokenizer.fileInfo.size - Iid3v1Token.len);
          }
        }
        async addTag(id, value) {
          await this.metadata.addTag("ID3v1", id, value);
        }
      } exports("M", ID3v1Parser);
      async function hasID3v1Header(tokenizer) {
        if (tokenizer.fileInfo.size >= 128) {
          const tag = new Uint8Array(3);
          const position = tokenizer.position;
          await tokenizer.readBuffer(tag, { position: tokenizer.fileInfo.size - 128 });
          tokenizer.setPosition(position);
          return textDecode(tag, "latin1") === "TAG";
        }
        return false;
      }
      const endTag2 = "LYRICS200";
      async function getLyricsHeaderLength(tokenizer) {
        const fileSize = tokenizer.fileInfo.size;
        if (fileSize >= 143) {
          const buf = new Uint8Array(15);
          const position = tokenizer.position;
          await tokenizer.readBuffer(buf, { position: fileSize - 143 });
          tokenizer.setPosition(position);
          const txt = textDecode(buf, "latin1");
          const tag = txt.slice(6);
          if (tag === endTag2) {
            return Number.parseInt(txt.slice(0, 6), 10) + 15;
          }
        }
        return 0;
      }
      async function parseBlob(blob, options = {}) {
        const tokenizer = fromBlob(blob);
        try {
          return await parseFromTokenizer(tokenizer, options);
        } finally {
          await tokenizer.close();
        }
      }
      function parseFromTokenizer(tokenizer, options) {
        const parserFactory = new ParserFactory();
        return parserFactory.parse(tokenizer, void 0, options);
      }
      async function scanAppendingHeaders(tokenizer, options = {}) {
        let apeOffset = tokenizer.fileInfo.size;
        if (await hasID3v1Header(tokenizer)) {
          apeOffset -= 128;
          const lyricsLen = await getLyricsHeaderLength(tokenizer);
          apeOffset -= lyricsLen;
        }
        options.apeHeader = await APEv2Parser.findApeFooterOffset(tokenizer, apeOffset);
      }
      const uniqueArrayByKey = (arr, key) => {
        if (!Array.isArray(arr)) return [];
        if (!key) return arr;
        const seen2 = /* @__PURE__ */ new Map();
        return arr.filter((item) => {
          if (!item || typeof item !== "object") return false;
          const val = item[key];
          if (seen2.has(val)) return false;
          seen2.set(val, true);
          return true;
        });
      };
      const promiseLimit = (promiseArray, limit = 6) => {
        if (!Array.isArray(promiseArray)) {
          throw new Error("第一个参数必须是数组");
        }
        if (!Number.isInteger(limit) || limit < 1) {
          throw new Error("并发限制必须是正整数");
        }
        if (promiseArray.length === 0) {
          return Promise.resolve([]);
        }
        return new Promise((resolve, reject) => {
          const results = new Array(promiseArray.length);
          let completed = 0;
          let currentIndex = 0;
          const runTask = async () => {
            const index2 = currentIndex++;
            if (index2 >= promiseArray.length) {
              return;
            }
            try {
              const promise = promiseArray[index2];
              if (typeof promise !== "function") {
                throw new Error(`数组中索引为 ${index2} 的元素不是函数`);
              }
              results[index2] = await promise();
            } catch (error) {
              results[index2] = error;
            }
            completed++;
            if (currentIndex < promiseArray.length) {
              runTask();
            } else if (completed === promiseArray.length) {
              resolve(results);
            }
          };
          const tasksToStart = Math.min(limit, promiseArray.length);
          for (let i = 0; i < tasksToStart; i++) {
            try {
              runTask();
            } catch (error) {
              reject(error);
            }
          }
        });
      };
      const getCookie = (key) => {
        const cookie = document.cookie;
        const cookieMap = {};
        cookie.split("; ").forEach((row) => {
          const [key2, value] = row.split("=");
          cookieMap[key2] = value;
        });
        return cookieMap[key];
      };
      const getFile_qualityList = (file) => {
        const qualityList = [];
        if (file.size_flac) qualityList.push("flac");
        if (file.size_ape) qualityList.push("ape");
        if (file.size_320mp3) qualityList.push(320);
        if (file.size_192aac) qualityList.push("m4a");
        if (file.size_128mp3) qualityList.push(128);
        return qualityList;
      };
      const getFileQualityList = (file) => {
        const qualityList = [];
        if (file.size128) qualityList.push(128);
        if (file.size320) qualityList.push(320);
        if (file.sizeflac) qualityList.push("flac");
        return qualityList;
      };
      async function getFileMD5(file) {
        const arrayBuffer = await file.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);
        return md5$1(uint8Array);
      }
      async function getAudioMetadata(file) {
        try {
          const metadata = await parseBlob(file);
          console.log("metadata.common", metadata, metadata.common);
          const { album, artist, artists, title } = metadata.common || {};
          const { bitrate = 0 } = metadata.format || {};
          return {
            title: title || "",
            artist: artist || artists?.[0] || "",
            artists: artists || (artist ? [artist] : []),
            album: album || "",
            duration: metadata.format?.duration || 0,
            sampleRate: metadata.format?.sampleRate || 0,
            format: metadata.format?.container || "",
            bitrate: Math.floor(bitrate / 1e3) || 0
          };
        } catch (error) {
          console.error("Failed to parse audio metadata:", error);
          return {
            title: "",
            artist: "",
            artists: [],
            album: "",
            duration: 0,
            bitrate: 0,
            sampleRate: 0,
            format: ""
          };
        }
      }
      const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
      let nanoid = (size = 21) => {
        let id = "";
        let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
        while (size--) {
          id += urlAlphabet[bytes[size] & 63];
        }
        return id;
      };
      let message;
      const ModalUtils = () => {
        const staticFunction = App$1.useApp();
        message = staticFunction.message;
        staticFunction.modal;
        staticFunction.notification;
        return null;
      };
      const msgSuccess = (content) => {
        return message.success(content);
      };
      const msgWarning = (content) => {
        return message.warning(content);
      };
      const msgError = (content) => {
        return message.error(content);
      };
      const msgLoading = (loadingContent, completeCallBack) => {
        const key = nanoid();
        message.loading({
          key,
          content: loadingContent
        }).then(() => {
        });
        return () => message.destroy(key);
      };
      var forge$1;
      var hasRequiredForge;
      function requireForge() {
        if (hasRequiredForge) return forge$1;
        hasRequiredForge = 1;
        forge$1 = {
          // default options
          options: {
            usePureJavaScript: false
          }
        };
        return forge$1;
      }
      var util = { exports: {} };
      var baseN;
      var hasRequiredBaseN;
      function requireBaseN() {
        if (hasRequiredBaseN) return baseN;
        hasRequiredBaseN = 1;
        var api = {};
        baseN = api;
        var _reverseAlphabets = {};
        api.encode = function(input, alphabet, maxline) {
          if (typeof alphabet !== "string") {
            throw new TypeError('"alphabet" must be a string.');
          }
          if (maxline !== void 0 && typeof maxline !== "number") {
            throw new TypeError('"maxline" must be a number.');
          }
          var output = "";
          if (!(input instanceof Uint8Array)) {
            output = _encodeWithByteBuffer(input, alphabet);
          } else {
            var i = 0;
            var base = alphabet.length;
            var first = alphabet.charAt(0);
            var digits = [0];
            for (i = 0; i < input.length; ++i) {
              for (var j = 0, carry = input[i]; j < digits.length; ++j) {
                carry += digits[j] << 8;
                digits[j] = carry % base;
                carry = carry / base | 0;
              }
              while (carry > 0) {
                digits.push(carry % base);
                carry = carry / base | 0;
              }
            }
            for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
              output += first;
            }
            for (i = digits.length - 1; i >= 0; --i) {
              output += alphabet[digits[i]];
            }
          }
          if (maxline) {
            var regex = new RegExp(".{1," + maxline + "}", "g");
            output = output.match(regex).join("\r\n");
          }
          return output;
        };
        api.decode = function(input, alphabet) {
          if (typeof input !== "string") {
            throw new TypeError('"input" must be a string.');
          }
          if (typeof alphabet !== "string") {
            throw new TypeError('"alphabet" must be a string.');
          }
          var table = _reverseAlphabets[alphabet];
          if (!table) {
            table = _reverseAlphabets[alphabet] = [];
            for (var i = 0; i < alphabet.length; ++i) {
              table[alphabet.charCodeAt(i)] = i;
            }
          }
          input = input.replace(/\s/g, "");
          var base = alphabet.length;
          var first = alphabet.charAt(0);
          var bytes = [0];
          for (var i = 0; i < input.length; i++) {
            var value = table[input.charCodeAt(i)];
            if (value === void 0) {
              return;
            }
            for (var j = 0, carry = value; j < bytes.length; ++j) {
              carry += bytes[j] * base;
              bytes[j] = carry & 255;
              carry >>= 8;
            }
            while (carry > 0) {
              bytes.push(carry & 255);
              carry >>= 8;
            }
          }
          for (var k = 0; input[k] === first && k < input.length - 1; ++k) {
            bytes.push(0);
          }
          if (typeof Buffer !== "undefined") {
            return Buffer.from(bytes.reverse());
          }
          return new Uint8Array(bytes.reverse());
        };
        function _encodeWithByteBuffer(input, alphabet) {
          var i = 0;
          var base = alphabet.length;
          var first = alphabet.charAt(0);
          var digits = [0];
          for (i = 0; i < input.length(); ++i) {
            for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
              carry += digits[j] << 8;
              digits[j] = carry % base;
              carry = carry / base | 0;
            }
            while (carry > 0) {
              digits.push(carry % base);
              carry = carry / base | 0;
            }
          }
          var output = "";
          for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
            output += first;
          }
          for (i = digits.length - 1; i >= 0; --i) {
            output += alphabet[digits[i]];
          }
          return output;
        }
        return baseN;
      }
      var hasRequiredUtil;
      function requireUtil() {
        if (hasRequiredUtil) return util.exports;
        hasRequiredUtil = 1;
        var forge2 = requireForge();
        var baseN2 = requireBaseN();
        var util$1 = util.exports = forge2.util = forge2.util || {};
        (function() {
          if (typeof process !== "undefined" && process.nextTick && !process.browser) {
            util$1.nextTick = process.nextTick;
            if (typeof setImmediate === "function") {
              util$1.setImmediate = setImmediate;
            } else {
              util$1.setImmediate = util$1.nextTick;
            }
            return;
          }
          if (typeof setImmediate === "function") {
            util$1.setImmediate = function() {
              return setImmediate.apply(void 0, arguments);
            };
            util$1.nextTick = function(callback) {
              return setImmediate(callback);
            };
            return;
          }
          util$1.setImmediate = function(callback) {
            setTimeout(callback, 0);
          };
          if (typeof window !== "undefined" && typeof window.postMessage === "function") {
            let handler = function(event) {
              if (event.source === window && event.data === msg) {
                event.stopPropagation();
                var copy2 = callbacks.slice();
                callbacks.length = 0;
                copy2.forEach(function(callback) {
                  callback();
                });
              }
            };
            var msg = "forge.setImmediate";
            var callbacks = [];
            util$1.setImmediate = function(callback) {
              callbacks.push(callback);
              if (callbacks.length === 1) {
                window.postMessage(msg, "*");
              }
            };
            window.addEventListener("message", handler, true);
          }
          if (typeof MutationObserver !== "undefined") {
            var now = Date.now();
            var attr = true;
            var div = document.createElement("div");
            var callbacks = [];
            new MutationObserver(function() {
              var copy2 = callbacks.slice();
              callbacks.length = 0;
              copy2.forEach(function(callback) {
                callback();
              });
            }).observe(div, { attributes: true });
            var oldSetImmediate = util$1.setImmediate;
            util$1.setImmediate = function(callback) {
              if (Date.now() - now > 15) {
                now = Date.now();
                oldSetImmediate(callback);
              } else {
                callbacks.push(callback);
                if (callbacks.length === 1) {
                  div.setAttribute("a", attr = !attr);
                }
              }
            };
          }
          util$1.nextTick = util$1.setImmediate;
        })();
        util$1.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
        util$1.globalScope = (function() {
          if (util$1.isNodejs) {
            return commonjsGlobal;
          }
          return typeof self === "undefined" ? window : self;
        })();
        util$1.isArray = Array.isArray || function(x) {
          return Object.prototype.toString.call(x) === "[object Array]";
        };
        util$1.isArrayBuffer = function(x) {
          return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
        };
        util$1.isArrayBufferView = function(x) {
          return x && util$1.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
        };
        function _checkBitsParam(n) {
          if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
            throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
          }
        }
        util$1.ByteBuffer = ByteStringBuffer;
        function ByteStringBuffer(b) {
          this.data = "";
          this.read = 0;
          if (typeof b === "string") {
            this.data = b;
          } else if (util$1.isArrayBuffer(b) || util$1.isArrayBufferView(b)) {
            if (typeof Buffer !== "undefined" && b instanceof Buffer) {
              this.data = b.toString("binary");
            } else {
              var arr = new Uint8Array(b);
              try {
                this.data = String.fromCharCode.apply(null, arr);
              } catch (e) {
                for (var i = 0; i < arr.length; ++i) {
                  this.putByte(arr[i]);
                }
              }
            }
          } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
            this.data = b.data;
            this.read = b.read;
          }
          this._constructedStringLength = 0;
        }
        util$1.ByteStringBuffer = ByteStringBuffer;
        var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
        util$1.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
          this._constructedStringLength += x;
          if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
            this.data.substr(0, 1);
            this._constructedStringLength = 0;
          }
        };
        util$1.ByteStringBuffer.prototype.length = function() {
          return this.data.length - this.read;
        };
        util$1.ByteStringBuffer.prototype.isEmpty = function() {
          return this.length() <= 0;
        };
        util$1.ByteStringBuffer.prototype.putByte = function(b) {
          return this.putBytes(String.fromCharCode(b));
        };
        util$1.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
          b = String.fromCharCode(b);
          var d = this.data;
          while (n > 0) {
            if (n & 1) {
              d += b;
            }
            n >>>= 1;
            if (n > 0) {
              b += b;
            }
          }
          this.data = d;
          this._optimizeConstructedString(n);
          return this;
        };
        util$1.ByteStringBuffer.prototype.putBytes = function(bytes) {
          this.data += bytes;
          this._optimizeConstructedString(bytes.length);
          return this;
        };
        util$1.ByteStringBuffer.prototype.putString = function(str) {
          return this.putBytes(util$1.encodeUtf8(str));
        };
        util$1.ByteStringBuffer.prototype.putInt16 = function(i) {
          return this.putBytes(
            String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
          );
        };
        util$1.ByteStringBuffer.prototype.putInt24 = function(i) {
          return this.putBytes(
            String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
          );
        };
        util$1.ByteStringBuffer.prototype.putInt32 = function(i) {
          return this.putBytes(
            String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
          );
        };
        util$1.ByteStringBuffer.prototype.putInt16Le = function(i) {
          return this.putBytes(
            String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255)
          );
        };
        util$1.ByteStringBuffer.prototype.putInt24Le = function(i) {
          return this.putBytes(
            String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255)
          );
        };
        util$1.ByteStringBuffer.prototype.putInt32Le = function(i) {
          return this.putBytes(
            String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255)
          );
        };
        util$1.ByteStringBuffer.prototype.putInt = function(i, n) {
          _checkBitsParam(n);
          var bytes = "";
          do {
            n -= 8;
            bytes += String.fromCharCode(i >> n & 255);
          } while (n > 0);
          return this.putBytes(bytes);
        };
        util$1.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
          if (i < 0) {
            i += 2 << n - 1;
          }
          return this.putInt(i, n);
        };
        util$1.ByteStringBuffer.prototype.putBuffer = function(buffer) {
          return this.putBytes(buffer.getBytes());
        };
        util$1.ByteStringBuffer.prototype.getByte = function() {
          return this.data.charCodeAt(this.read++);
        };
        util$1.ByteStringBuffer.prototype.getInt16 = function() {
          var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
          this.read += 2;
          return rval;
        };
        util$1.ByteStringBuffer.prototype.getInt24 = function() {
          var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
          this.read += 3;
          return rval;
        };
        util$1.ByteStringBuffer.prototype.getInt32 = function() {
          var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
          this.read += 4;
          return rval;
        };
        util$1.ByteStringBuffer.prototype.getInt16Le = function() {
          var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
          this.read += 2;
          return rval;
        };
        util$1.ByteStringBuffer.prototype.getInt24Le = function() {
          var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
          this.read += 3;
          return rval;
        };
        util$1.ByteStringBuffer.prototype.getInt32Le = function() {
          var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
          this.read += 4;
          return rval;
        };
        util$1.ByteStringBuffer.prototype.getInt = function(n) {
          _checkBitsParam(n);
          var rval = 0;
          do {
            rval = (rval << 8) + this.data.charCodeAt(this.read++);
            n -= 8;
          } while (n > 0);
          return rval;
        };
        util$1.ByteStringBuffer.prototype.getSignedInt = function(n) {
          var x = this.getInt(n);
          var max2 = 2 << n - 2;
          if (x >= max2) {
            x -= max2 << 1;
          }
          return x;
        };
        util$1.ByteStringBuffer.prototype.getBytes = function(count) {
          var rval;
          if (count) {
            count = Math.min(this.length(), count);
            rval = this.data.slice(this.read, this.read + count);
            this.read += count;
          } else if (count === 0) {
            rval = "";
          } else {
            rval = this.read === 0 ? this.data : this.data.slice(this.read);
            this.clear();
          }
          return rval;
        };
        util$1.ByteStringBuffer.prototype.bytes = function(count) {
          return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
        };
        util$1.ByteStringBuffer.prototype.at = function(i) {
          return this.data.charCodeAt(this.read + i);
        };
        util$1.ByteStringBuffer.prototype.setAt = function(i, b) {
          this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
          return this;
        };
        util$1.ByteStringBuffer.prototype.last = function() {
          return this.data.charCodeAt(this.data.length - 1);
        };
        util$1.ByteStringBuffer.prototype.copy = function() {
          var c = util$1.createBuffer(this.data);
          c.read = this.read;
          return c;
        };
        util$1.ByteStringBuffer.prototype.compact = function() {
          if (this.read > 0) {
            this.data = this.data.slice(this.read);
            this.read = 0;
          }
          return this;
        };
        util$1.ByteStringBuffer.prototype.clear = function() {
          this.data = "";
          this.read = 0;
          return this;
        };
        util$1.ByteStringBuffer.prototype.truncate = function(count) {
          var len = Math.max(0, this.length() - count);
          this.data = this.data.substr(this.read, len);
          this.read = 0;
          return this;
        };
        util$1.ByteStringBuffer.prototype.toHex = function() {
          var rval = "";
          for (var i = this.read; i < this.data.length; ++i) {
            var b = this.data.charCodeAt(i);
            if (b < 16) {
              rval += "0";
            }
            rval += b.toString(16);
          }
          return rval;
        };
        util$1.ByteStringBuffer.prototype.toString = function() {
          return util$1.decodeUtf8(this.bytes());
        };
        function DataBuffer(b, options) {
          options = options || {};
          this.read = options.readOffset || 0;
          this.growSize = options.growSize || 1024;
          var isArrayBuffer = util$1.isArrayBuffer(b);
          var isArrayBufferView = util$1.isArrayBufferView(b);
          if (isArrayBuffer || isArrayBufferView) {
            if (isArrayBuffer) {
              this.data = new DataView(b);
            } else {
              this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
            }
            this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
            return;
          }
          this.data = new DataView(new ArrayBuffer(0));
          this.write = 0;
          if (b !== null && b !== void 0) {
            this.putBytes(b);
          }
          if ("writeOffset" in options) {
            this.write = options.writeOffset;
          }
        }
        util$1.DataBuffer = DataBuffer;
        util$1.DataBuffer.prototype.length = function() {
          return this.write - this.read;
        };
        util$1.DataBuffer.prototype.isEmpty = function() {
          return this.length() <= 0;
        };
        util$1.DataBuffer.prototype.accommodate = function(amount, growSize) {
          if (this.length() >= amount) {
            return this;
          }
          growSize = Math.max(growSize || this.growSize, amount);
          var src = new Uint8Array(
            this.data.buffer,
            this.data.byteOffset,
            this.data.byteLength
          );
          var dst = new Uint8Array(this.length() + growSize);
          dst.set(src);
          this.data = new DataView(dst.buffer);
          return this;
        };
        util$1.DataBuffer.prototype.putByte = function(b) {
          this.accommodate(1);
          this.data.setUint8(this.write++, b);
          return this;
        };
        util$1.DataBuffer.prototype.fillWithByte = function(b, n) {
          this.accommodate(n);
          for (var i = 0; i < n; ++i) {
            this.data.setUint8(b);
          }
          return this;
        };
        util$1.DataBuffer.prototype.putBytes = function(bytes, encoding) {
          if (util$1.isArrayBufferView(bytes)) {
            var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
            var len = src.byteLength - src.byteOffset;
            this.accommodate(len);
            var dst = new Uint8Array(this.data.buffer, this.write);
            dst.set(src);
            this.write += len;
            return this;
          }
          if (util$1.isArrayBuffer(bytes)) {
            var src = new Uint8Array(bytes);
            this.accommodate(src.byteLength);
            var dst = new Uint8Array(this.data.buffer);
            dst.set(src, this.write);
            this.write += src.byteLength;
            return this;
          }
          if (bytes instanceof util$1.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util$1.isArrayBufferView(bytes.data)) {
            var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
            this.accommodate(src.byteLength);
            var dst = new Uint8Array(bytes.data.byteLength, this.write);
            dst.set(src);
            this.write += src.byteLength;
            return this;
          }
          if (bytes instanceof util$1.ByteStringBuffer) {
            bytes = bytes.data;
            encoding = "binary";
          }
          encoding = encoding || "binary";
          if (typeof bytes === "string") {
            var view;
            if (encoding === "hex") {
              this.accommodate(Math.ceil(bytes.length / 2));
              view = new Uint8Array(this.data.buffer, this.write);
              this.write += util$1.binary.hex.decode(bytes, view, this.write);
              return this;
            }
            if (encoding === "base64") {
              this.accommodate(Math.ceil(bytes.length / 4) * 3);
              view = new Uint8Array(this.data.buffer, this.write);
              this.write += util$1.binary.base64.decode(bytes, view, this.write);
              return this;
            }
            if (encoding === "utf8") {
              bytes = util$1.encodeUtf8(bytes);
              encoding = "binary";
            }
            if (encoding === "binary" || encoding === "raw") {
              this.accommodate(bytes.length);
              view = new Uint8Array(this.data.buffer, this.write);
              this.write += util$1.binary.raw.decode(view);
              return this;
            }
            if (encoding === "utf16") {
              this.accommodate(bytes.length * 2);
              view = new Uint16Array(this.data.buffer, this.write);
              this.write += util$1.text.utf16.encode(view);
              return this;
            }
            throw new Error("Invalid encoding: " + encoding);
          }
          throw Error("Invalid parameter: " + bytes);
        };
        util$1.DataBuffer.prototype.putBuffer = function(buffer) {
          this.putBytes(buffer);
          buffer.clear();
          return this;
        };
        util$1.DataBuffer.prototype.putString = function(str) {
          return this.putBytes(str, "utf16");
        };
        util$1.DataBuffer.prototype.putInt16 = function(i) {
          this.accommodate(2);
          this.data.setInt16(this.write, i);
          this.write += 2;
          return this;
        };
        util$1.DataBuffer.prototype.putInt24 = function(i) {
          this.accommodate(3);
          this.data.setInt16(this.write, i >> 8 & 65535);
          this.data.setInt8(this.write, i >> 16 & 255);
          this.write += 3;
          return this;
        };
        util$1.DataBuffer.prototype.putInt32 = function(i) {
          this.accommodate(4);
          this.data.setInt32(this.write, i);
          this.write += 4;
          return this;
        };
        util$1.DataBuffer.prototype.putInt16Le = function(i) {
          this.accommodate(2);
          this.data.setInt16(this.write, i, true);
          this.write += 2;
          return this;
        };
        util$1.DataBuffer.prototype.putInt24Le = function(i) {
          this.accommodate(3);
          this.data.setInt8(this.write, i >> 16 & 255);
          this.data.setInt16(this.write, i >> 8 & 65535, true);
          this.write += 3;
          return this;
        };
        util$1.DataBuffer.prototype.putInt32Le = function(i) {
          this.accommodate(4);
          this.data.setInt32(this.write, i, true);
          this.write += 4;
          return this;
        };
        util$1.DataBuffer.prototype.putInt = function(i, n) {
          _checkBitsParam(n);
          this.accommodate(n / 8);
          do {
            n -= 8;
            this.data.setInt8(this.write++, i >> n & 255);
          } while (n > 0);
          return this;
        };
        util$1.DataBuffer.prototype.putSignedInt = function(i, n) {
          _checkBitsParam(n);
          this.accommodate(n / 8);
          if (i < 0) {
            i += 2 << n - 1;
          }
          return this.putInt(i, n);
        };
        util$1.DataBuffer.prototype.getByte = function() {
          return this.data.getInt8(this.read++);
        };
        util$1.DataBuffer.prototype.getInt16 = function() {
          var rval = this.data.getInt16(this.read);
          this.read += 2;
          return rval;
        };
        util$1.DataBuffer.prototype.getInt24 = function() {
          var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
          this.read += 3;
          return rval;
        };
        util$1.DataBuffer.prototype.getInt32 = function() {
          var rval = this.data.getInt32(this.read);
          this.read += 4;
          return rval;
        };
        util$1.DataBuffer.prototype.getInt16Le = function() {
          var rval = this.data.getInt16(this.read, true);
          this.read += 2;
          return rval;
        };
        util$1.DataBuffer.prototype.getInt24Le = function() {
          var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
          this.read += 3;
          return rval;
        };
        util$1.DataBuffer.prototype.getInt32Le = function() {
          var rval = this.data.getInt32(this.read, true);
          this.read += 4;
          return rval;
        };
        util$1.DataBuffer.prototype.getInt = function(n) {
          _checkBitsParam(n);
          var rval = 0;
          do {
            rval = (rval << 8) + this.data.getInt8(this.read++);
            n -= 8;
          } while (n > 0);
          return rval;
        };
        util$1.DataBuffer.prototype.getSignedInt = function(n) {
          var x = this.getInt(n);
          var max2 = 2 << n - 2;
          if (x >= max2) {
            x -= max2 << 1;
          }
          return x;
        };
        util$1.DataBuffer.prototype.getBytes = function(count) {
          var rval;
          if (count) {
            count = Math.min(this.length(), count);
            rval = this.data.slice(this.read, this.read + count);
            this.read += count;
          } else if (count === 0) {
            rval = "";
          } else {
            rval = this.read === 0 ? this.data : this.data.slice(this.read);
            this.clear();
          }
          return rval;
        };
        util$1.DataBuffer.prototype.bytes = function(count) {
          return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
        };
        util$1.DataBuffer.prototype.at = function(i) {
          return this.data.getUint8(this.read + i);
        };
        util$1.DataBuffer.prototype.setAt = function(i, b) {
          this.data.setUint8(i, b);
          return this;
        };
        util$1.DataBuffer.prototype.last = function() {
          return this.data.getUint8(this.write - 1);
        };
        util$1.DataBuffer.prototype.copy = function() {
          return new util$1.DataBuffer(this);
        };
        util$1.DataBuffer.prototype.compact = function() {
          if (this.read > 0) {
            var src = new Uint8Array(this.data.buffer, this.read);
            var dst = new Uint8Array(src.byteLength);
            dst.set(src);
            this.data = new DataView(dst);
            this.write -= this.read;
            this.read = 0;
          }
          return this;
        };
        util$1.DataBuffer.prototype.clear = function() {
          this.data = new DataView(new ArrayBuffer(0));
          this.read = this.write = 0;
          return this;
        };
        util$1.DataBuffer.prototype.truncate = function(count) {
          this.write = Math.max(0, this.length() - count);
          this.read = Math.min(this.read, this.write);
          return this;
        };
        util$1.DataBuffer.prototype.toHex = function() {
          var rval = "";
          for (var i = this.read; i < this.data.byteLength; ++i) {
            var b = this.data.getUint8(i);
            if (b < 16) {
              rval += "0";
            }
            rval += b.toString(16);
          }
          return rval;
        };
        util$1.DataBuffer.prototype.toString = function(encoding) {
          var view = new Uint8Array(this.data, this.read, this.length());
          encoding = encoding || "utf8";
          if (encoding === "binary" || encoding === "raw") {
            return util$1.binary.raw.encode(view);
          }
          if (encoding === "hex") {
            return util$1.binary.hex.encode(view);
          }
          if (encoding === "base64") {
            return util$1.binary.base64.encode(view);
          }
          if (encoding === "utf8") {
            return util$1.text.utf8.decode(view);
          }
          if (encoding === "utf16") {
            return util$1.text.utf16.decode(view);
          }
          throw new Error("Invalid encoding: " + encoding);
        };
        util$1.createBuffer = function(input, encoding) {
          encoding = encoding || "raw";
          if (input !== void 0 && encoding === "utf8") {
            input = util$1.encodeUtf8(input);
          }
          return new util$1.ByteBuffer(input);
        };
        util$1.fillString = function(c, n) {
          var s = "";
          while (n > 0) {
            if (n & 1) {
              s += c;
            }
            n >>>= 1;
            if (n > 0) {
              c += c;
            }
          }
          return s;
        };
        util$1.xorBytes = function(s1, s2, n) {
          var s3 = "";
          var b = "";
          var t = "";
          var i = 0;
          var c = 0;
          for (; n > 0; --n, ++i) {
            b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
            if (c >= 10) {
              s3 += t;
              t = "";
              c = 0;
            }
            t += String.fromCharCode(b);
            ++c;
          }
          s3 += t;
          return s3;
        };
        util$1.hexToBytes = function(hex) {
          var rval = "";
          var i = 0;
          if (hex.length & true) {
            i = 1;
            rval += String.fromCharCode(parseInt(hex[0], 16));
          }
          for (; i < hex.length; i += 2) {
            rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
          }
          return rval;
        };
        util$1.bytesToHex = function(bytes) {
          return util$1.createBuffer(bytes).toHex();
        };
        util$1.int32ToBytes = function(i) {
          return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
        };
        var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var _base64Idx = [
          /*43 -43 = 0*/
          /*'+',  1,  2,  3,'/' */
          62,
          -1,
          -1,
          -1,
          63,
          /*'0','1','2','3','4','5','6','7','8','9' */
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          /*15, 16, 17,'=', 19, 20, 21 */
          -1,
          -1,
          -1,
          64,
          -1,
          -1,
          -1,
          /*65 - 43 = 22*/
          /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          /*91 - 43 = 48 */
          /*48, 49, 50, 51, 52, 53 */
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          /*97 - 43 = 54*/
          /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51
        ];
        var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
        util$1.encode64 = function(input, maxline) {
          var line = "";
          var output = "";
          var chr1, chr2, chr3;
          var i = 0;
          while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            line += _base64.charAt(chr1 >> 2);
            line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
            if (isNaN(chr2)) {
              line += "==";
            } else {
              line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
              line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
            }
            if (maxline && line.length > maxline) {
              output += line.substr(0, maxline) + "\r\n";
              line = line.substr(maxline);
            }
          }
          output += line;
          return output;
        };
        util$1.decode64 = function(input) {
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
          var output = "";
          var enc1, enc2, enc3, enc4;
          var i = 0;
          while (i < input.length) {
            enc1 = _base64Idx[input.charCodeAt(i++) - 43];
            enc2 = _base64Idx[input.charCodeAt(i++) - 43];
            enc3 = _base64Idx[input.charCodeAt(i++) - 43];
            enc4 = _base64Idx[input.charCodeAt(i++) - 43];
            output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
            if (enc3 !== 64) {
              output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
              if (enc4 !== 64) {
                output += String.fromCharCode((enc3 & 3) << 6 | enc4);
              }
            }
          }
          return output;
        };
        util$1.encodeUtf8 = function(str) {
          return unescape(encodeURIComponent(str));
        };
        util$1.decodeUtf8 = function(str) {
          return decodeURIComponent(escape(str));
        };
        util$1.binary = {
          raw: {},
          hex: {},
          base64: {},
          base58: {},
          baseN: {
            encode: baseN2.encode,
            decode: baseN2.decode
          }
        };
        util$1.binary.raw.encode = function(bytes) {
          return String.fromCharCode.apply(null, bytes);
        };
        util$1.binary.raw.decode = function(str, output, offset) {
          var out = output;
          if (!out) {
            out = new Uint8Array(str.length);
          }
          offset = offset || 0;
          var j = offset;
          for (var i = 0; i < str.length; ++i) {
            out[j++] = str.charCodeAt(i);
          }
          return output ? j - offset : out;
        };
        util$1.binary.hex.encode = util$1.bytesToHex;
        util$1.binary.hex.decode = function(hex, output, offset) {
          var out = output;
          if (!out) {
            out = new Uint8Array(Math.ceil(hex.length / 2));
          }
          offset = offset || 0;
          var i = 0, j = offset;
          if (hex.length & 1) {
            i = 1;
            out[j++] = parseInt(hex[0], 16);
          }
          for (; i < hex.length; i += 2) {
            out[j++] = parseInt(hex.substr(i, 2), 16);
          }
          return output ? j - offset : out;
        };
        util$1.binary.base64.encode = function(input, maxline) {
          var line = "";
          var output = "";
          var chr1, chr2, chr3;
          var i = 0;
          while (i < input.byteLength) {
            chr1 = input[i++];
            chr2 = input[i++];
            chr3 = input[i++];
            line += _base64.charAt(chr1 >> 2);
            line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
            if (isNaN(chr2)) {
              line += "==";
            } else {
              line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
              line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
            }
            if (maxline && line.length > maxline) {
              output += line.substr(0, maxline) + "\r\n";
              line = line.substr(maxline);
            }
          }
          output += line;
          return output;
        };
        util$1.binary.base64.decode = function(input, output, offset) {
          var out = output;
          if (!out) {
            out = new Uint8Array(Math.ceil(input.length / 4) * 3);
          }
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
          offset = offset || 0;
          var enc1, enc2, enc3, enc4;
          var i = 0, j = offset;
          while (i < input.length) {
            enc1 = _base64Idx[input.charCodeAt(i++) - 43];
            enc2 = _base64Idx[input.charCodeAt(i++) - 43];
            enc3 = _base64Idx[input.charCodeAt(i++) - 43];
            enc4 = _base64Idx[input.charCodeAt(i++) - 43];
            out[j++] = enc1 << 2 | enc2 >> 4;
            if (enc3 !== 64) {
              out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
              if (enc4 !== 64) {
                out[j++] = (enc3 & 3) << 6 | enc4;
              }
            }
          }
          return output ? j - offset : out.subarray(0, j);
        };
        util$1.binary.base58.encode = function(input, maxline) {
          return util$1.binary.baseN.encode(input, _base58, maxline);
        };
        util$1.binary.base58.decode = function(input, maxline) {
          return util$1.binary.baseN.decode(input, _base58, maxline);
        };
        util$1.text = {
          utf8: {},
          utf16: {}
        };
        util$1.text.utf8.encode = function(str, output, offset) {
          str = util$1.encodeUtf8(str);
          var out = output;
          if (!out) {
            out = new Uint8Array(str.length);
          }
          offset = offset || 0;
          var j = offset;
          for (var i = 0; i < str.length; ++i) {
            out[j++] = str.charCodeAt(i);
          }
          return output ? j - offset : out;
        };
        util$1.text.utf8.decode = function(bytes) {
          return util$1.decodeUtf8(String.fromCharCode.apply(null, bytes));
        };
        util$1.text.utf16.encode = function(str, output, offset) {
          var out = output;
          if (!out) {
            out = new Uint8Array(str.length * 2);
          }
          var view = new Uint16Array(out.buffer);
          offset = offset || 0;
          var j = offset;
          var k = offset;
          for (var i = 0; i < str.length; ++i) {
            view[k++] = str.charCodeAt(i);
            j += 2;
          }
          return output ? j - offset : out;
        };
        util$1.text.utf16.decode = function(bytes) {
          return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
        };
        util$1.deflate = function(api, bytes, raw) {
          bytes = util$1.decode64(api.deflate(util$1.encode64(bytes)).rval);
          if (raw) {
            var start = 2;
            var flg = bytes.charCodeAt(1);
            if (flg & 32) {
              start = 6;
            }
            bytes = bytes.substring(start, bytes.length - 4);
          }
          return bytes;
        };
        util$1.inflate = function(api, bytes, raw) {
          var rval = api.inflate(util$1.encode64(bytes)).rval;
          return rval === null ? null : util$1.decode64(rval);
        };
        var _setStorageObject = function(api, id, obj) {
          if (!api) {
            throw new Error("WebStorage not available.");
          }
          var rval;
          if (obj === null) {
            rval = api.removeItem(id);
          } else {
            obj = util$1.encode64(JSON.stringify(obj));
            rval = api.setItem(id, obj);
          }
          if (typeof rval !== "undefined" && rval.rval !== true) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
        };
        var _getStorageObject = function(api, id) {
          if (!api) {
            throw new Error("WebStorage not available.");
          }
          var rval = api.getItem(id);
          if (api.init) {
            if (rval.rval === null) {
              if (rval.error) {
                var error = new Error(rval.error.message);
                error.id = rval.error.id;
                error.name = rval.error.name;
                throw error;
              }
              rval = null;
            } else {
              rval = rval.rval;
            }
          }
          if (rval !== null) {
            rval = JSON.parse(util$1.decode64(rval));
          }
          return rval;
        };
        var _setItem = function(api, id, key, data) {
          var obj = _getStorageObject(api, id);
          if (obj === null) {
            obj = {};
          }
          obj[key] = data;
          _setStorageObject(api, id, obj);
        };
        var _getItem = function(api, id, key) {
          var rval = _getStorageObject(api, id);
          if (rval !== null) {
            rval = key in rval ? rval[key] : null;
          }
          return rval;
        };
        var _removeItem = function(api, id, key) {
          var obj = _getStorageObject(api, id);
          if (obj !== null && key in obj) {
            delete obj[key];
            var empty = true;
            for (var prop in obj) {
              empty = false;
              break;
            }
            if (empty) {
              obj = null;
            }
            _setStorageObject(api, id, obj);
          }
        };
        var _clearItems = function(api, id) {
          _setStorageObject(api, id, null);
        };
        var _callStorageFunction = function(func, args, location) {
          var rval = null;
          if (typeof location === "undefined") {
            location = ["web", "flash"];
          }
          var type;
          var done = false;
          var exception = null;
          for (var idx in location) {
            type = location[idx];
            try {
              if (type === "flash" || type === "both") {
                if (args[0] === null) {
                  throw new Error("Flash local storage not available.");
                }
                rval = func.apply(this, args);
                done = type === "flash";
              }
              if (type === "web" || type === "both") {
                args[0] = localStorage;
                rval = func.apply(this, args);
                done = true;
              }
            } catch (ex) {
              exception = ex;
            }
            if (done) {
              break;
            }
          }
          if (!done) {
            throw exception;
          }
          return rval;
        };
        util$1.setItem = function(api, id, key, data, location) {
          _callStorageFunction(_setItem, arguments, location);
        };
        util$1.getItem = function(api, id, key, location) {
          return _callStorageFunction(_getItem, arguments, location);
        };
        util$1.removeItem = function(api, id, key, location) {
          _callStorageFunction(_removeItem, arguments, location);
        };
        util$1.clearItems = function(api, id, location) {
          _callStorageFunction(_clearItems, arguments, location);
        };
        util$1.isEmpty = function(obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
          return true;
        };
        util$1.format = function(format) {
          var re = /%./g;
          var match;
          var part;
          var argi = 0;
          var parts = [];
          var last = 0;
          while (match = re.exec(format)) {
            part = format.substring(last, re.lastIndex - 2);
            if (part.length > 0) {
              parts.push(part);
            }
            last = re.lastIndex;
            var code = match[0][1];
            switch (code) {
              case "s":
              case "o":
                if (argi < arguments.length) {
                  parts.push(arguments[argi++ + 1]);
                } else {
                  parts.push("<?>");
                }
                break;
              // FIXME: do proper formatting for numbers, etc
              //case 'f':
              //case 'd':
              case "%":
                parts.push("%");
                break;
              default:
                parts.push("<%" + code + "?>");
            }
          }
          parts.push(format.substring(last));
          return parts.join("");
        };
        util$1.formatNumber = function(number, decimals, dec_point, thousands_sep) {
          var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
          var d = dec_point === void 0 ? "," : dec_point;
          var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
          var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
          var j = i.length > 3 ? i.length % 3 : 0;
          return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
        };
        util$1.formatSize = function(size) {
          if (size >= 1073741824) {
            size = util$1.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
          } else if (size >= 1048576) {
            size = util$1.formatNumber(size / 1048576, 2, ".", "") + " MiB";
          } else if (size >= 1024) {
            size = util$1.formatNumber(size / 1024, 0) + " KiB";
          } else {
            size = util$1.formatNumber(size, 0) + " bytes";
          }
          return size;
        };
        util$1.bytesFromIP = function(ip) {
          if (ip.indexOf(".") !== -1) {
            return util$1.bytesFromIPv4(ip);
          }
          if (ip.indexOf(":") !== -1) {
            return util$1.bytesFromIPv6(ip);
          }
          return null;
        };
        util$1.bytesFromIPv4 = function(ip) {
          ip = ip.split(".");
          if (ip.length !== 4) {
            return null;
          }
          var b = util$1.createBuffer();
          for (var i = 0; i < ip.length; ++i) {
            var num = parseInt(ip[i], 10);
            if (isNaN(num)) {
              return null;
            }
            b.putByte(num);
          }
          return b.getBytes();
        };
        util$1.bytesFromIPv6 = function(ip) {
          var blanks = 0;
          ip = ip.split(":").filter(function(e) {
            if (e.length === 0) ++blanks;
            return true;
          });
          var zeros = (8 - ip.length + blanks) * 2;
          var b = util$1.createBuffer();
          for (var i = 0; i < 8; ++i) {
            if (!ip[i] || ip[i].length === 0) {
              b.fillWithByte(0, zeros);
              zeros = 0;
              continue;
            }
            var bytes = util$1.hexToBytes(ip[i]);
            if (bytes.length < 2) {
              b.putByte(0);
            }
            b.putBytes(bytes);
          }
          return b.getBytes();
        };
        util$1.bytesToIP = function(bytes) {
          if (bytes.length === 4) {
            return util$1.bytesToIPv4(bytes);
          }
          if (bytes.length === 16) {
            return util$1.bytesToIPv6(bytes);
          }
          return null;
        };
        util$1.bytesToIPv4 = function(bytes) {
          if (bytes.length !== 4) {
            return null;
          }
          var ip = [];
          for (var i = 0; i < bytes.length; ++i) {
            ip.push(bytes.charCodeAt(i));
          }
          return ip.join(".");
        };
        util$1.bytesToIPv6 = function(bytes) {
          if (bytes.length !== 16) {
            return null;
          }
          var ip = [];
          var zeroGroups = [];
          var zeroMaxGroup = 0;
          for (var i = 0; i < bytes.length; i += 2) {
            var hex = util$1.bytesToHex(bytes[i] + bytes[i + 1]);
            while (hex[0] === "0" && hex !== "0") {
              hex = hex.substr(1);
            }
            if (hex === "0") {
              var last = zeroGroups[zeroGroups.length - 1];
              var idx = ip.length;
              if (!last || idx !== last.end + 1) {
                zeroGroups.push({ start: idx, end: idx });
              } else {
                last.end = idx;
                if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
                  zeroMaxGroup = zeroGroups.length - 1;
                }
              }
            }
            ip.push(hex);
          }
          if (zeroGroups.length > 0) {
            var group = zeroGroups[zeroMaxGroup];
            if (group.end - group.start > 0) {
              ip.splice(group.start, group.end - group.start + 1, "");
              if (group.start === 0) {
                ip.unshift("");
              }
              if (group.end === 7) {
                ip.push("");
              }
            }
          }
          return ip.join(":");
        };
        util$1.estimateCores = function(options, callback) {
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          options = options || {};
          if ("cores" in util$1 && !options.update) {
            return callback(null, util$1.cores);
          }
          if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
            util$1.cores = navigator.hardwareConcurrency;
            return callback(null, util$1.cores);
          }
          if (typeof Worker === "undefined") {
            util$1.cores = 1;
            return callback(null, util$1.cores);
          }
          if (typeof Blob === "undefined") {
            util$1.cores = 2;
            return callback(null, util$1.cores);
          }
          var blobUrl = URL.createObjectURL(new Blob([
            "(",
            (function() {
              self.addEventListener("message", function(e) {
                var st = Date.now();
                var et2 = st + 4;
                self.postMessage({ st, et: et2 });
              });
            }).toString(),
            ")()"
          ], { type: "application/javascript" }));
          sample([], 5, 16);
          function sample(max2, samples, numWorkers) {
            if (samples === 0) {
              var avg = Math.floor(max2.reduce(function(avg2, x) {
                return avg2 + x;
              }, 0) / max2.length);
              util$1.cores = Math.max(1, avg);
              URL.revokeObjectURL(blobUrl);
              return callback(null, util$1.cores);
            }
            map(numWorkers, function(err2, results) {
              max2.push(reduce(numWorkers, results));
              sample(max2, samples - 1, numWorkers);
            });
          }
          function map(numWorkers, callback2) {
            var workers = [];
            var results = [];
            for (var i = 0; i < numWorkers; ++i) {
              var worker = new Worker(blobUrl);
              worker.addEventListener("message", function(e) {
                results.push(e.data);
                if (results.length === numWorkers) {
                  for (var i2 = 0; i2 < numWorkers; ++i2) {
                    workers[i2].terminate();
                  }
                  callback2(null, results);
                }
              });
              workers.push(worker);
            }
            for (var i = 0; i < numWorkers; ++i) {
              workers[i].postMessage(i);
            }
          }
          function reduce(numWorkers, results) {
            var overlaps = [];
            for (var n = 0; n < numWorkers; ++n) {
              var r1 = results[n];
              var overlap = overlaps[n] = [];
              for (var i = 0; i < numWorkers; ++i) {
                if (n === i) {
                  continue;
                }
                var r2 = results[i];
                if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
                  overlap.push(i);
                }
              }
            }
            return overlaps.reduce(function(max2, overlap2) {
              return Math.max(max2, overlap2.length);
            }, 0);
          }
        };
        return util.exports;
      }
      var cipher;
      var hasRequiredCipher;
      function requireCipher() {
        if (hasRequiredCipher) return cipher;
        hasRequiredCipher = 1;
        var forge2 = requireForge();
        requireUtil();
        cipher = forge2.cipher = forge2.cipher || {};
        forge2.cipher.algorithms = forge2.cipher.algorithms || {};
        forge2.cipher.createCipher = function(algorithm, key) {
          var api = algorithm;
          if (typeof api === "string") {
            api = forge2.cipher.getAlgorithm(api);
            if (api) {
              api = api();
            }
          }
          if (!api) {
            throw new Error("Unsupported algorithm: " + algorithm);
          }
          return new forge2.cipher.BlockCipher({
            algorithm: api,
            key,
            decrypt: false
          });
        };
        forge2.cipher.createDecipher = function(algorithm, key) {
          var api = algorithm;
          if (typeof api === "string") {
            api = forge2.cipher.getAlgorithm(api);
            if (api) {
              api = api();
            }
          }
          if (!api) {
            throw new Error("Unsupported algorithm: " + algorithm);
          }
          return new forge2.cipher.BlockCipher({
            algorithm: api,
            key,
            decrypt: true
          });
        };
        forge2.cipher.registerAlgorithm = function(name2, algorithm) {
          name2 = name2.toUpperCase();
          forge2.cipher.algorithms[name2] = algorithm;
        };
        forge2.cipher.getAlgorithm = function(name2) {
          name2 = name2.toUpperCase();
          if (name2 in forge2.cipher.algorithms) {
            return forge2.cipher.algorithms[name2];
          }
          return null;
        };
        var BlockCipher = forge2.cipher.BlockCipher = function(options) {
          this.algorithm = options.algorithm;
          this.mode = this.algorithm.mode;
          this.blockSize = this.mode.blockSize;
          this._finish = false;
          this._input = null;
          this.output = null;
          this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
          this._decrypt = options.decrypt;
          this.algorithm.initialize(options);
        };
        BlockCipher.prototype.start = function(options) {
          options = options || {};
          var opts = {};
          for (var key in options) {
            opts[key] = options[key];
          }
          opts.decrypt = this._decrypt;
          this._finish = false;
          this._input = forge2.util.createBuffer();
          this.output = options.output || forge2.util.createBuffer();
          this.mode.start(opts);
        };
        BlockCipher.prototype.update = function(input) {
          if (input) {
            this._input.putBuffer(input);
          }
          while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
          }
          this._input.compact();
        };
        BlockCipher.prototype.finish = function(pad) {
          if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
            this.mode.pad = function(input) {
              return pad(this.blockSize, input, false);
            };
            this.mode.unpad = function(output) {
              return pad(this.blockSize, output, true);
            };
          }
          var options = {};
          options.decrypt = this._decrypt;
          options.overflow = this._input.length() % this.blockSize;
          if (!this._decrypt && this.mode.pad) {
            if (!this.mode.pad(this._input, options)) {
              return false;
            }
          }
          this._finish = true;
          this.update();
          if (this._decrypt && this.mode.unpad) {
            if (!this.mode.unpad(this.output, options)) {
              return false;
            }
          }
          if (this.mode.afterFinish) {
            if (!this.mode.afterFinish(this.output, options)) {
              return false;
            }
          }
          return true;
        };
        return cipher;
      }
      var cipherModes = { exports: {} };
      var hasRequiredCipherModes;
      function requireCipherModes() {
        if (hasRequiredCipherModes) return cipherModes.exports;
        hasRequiredCipherModes = 1;
        var forge2 = requireForge();
        requireUtil();
        forge2.cipher = forge2.cipher || {};
        var modes = cipherModes.exports = forge2.cipher.modes = forge2.cipher.modes || {};
        modes.ecb = function(options) {
          options = options || {};
          this.name = "ECB";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = new Array(this._ints);
          this._outBlock = new Array(this._ints);
        };
        modes.ecb.prototype.start = function(options) {
        };
        modes.ecb.prototype.encrypt = function(input, output, finish) {
          if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
            return true;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = input.getInt32();
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          for (var i = 0; i < this._ints; ++i) {
            output.putInt32(this._outBlock[i]);
          }
        };
        modes.ecb.prototype.decrypt = function(input, output, finish) {
          if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
            return true;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = input.getInt32();
          }
          this.cipher.decrypt(this._inBlock, this._outBlock);
          for (var i = 0; i < this._ints; ++i) {
            output.putInt32(this._outBlock[i]);
          }
        };
        modes.ecb.prototype.pad = function(input, options) {
          var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
          input.fillWithByte(padding, padding);
          return true;
        };
        modes.ecb.prototype.unpad = function(output, options) {
          if (options.overflow > 0) {
            return false;
          }
          var len = output.length();
          var count = output.at(len - 1);
          if (count > this.blockSize << 2) {
            return false;
          }
          output.truncate(count);
          return true;
        };
        modes.cbc = function(options) {
          options = options || {};
          this.name = "CBC";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = new Array(this._ints);
          this._outBlock = new Array(this._ints);
        };
        modes.cbc.prototype.start = function(options) {
          if (options.iv === null) {
            if (!this._prev) {
              throw new Error("Invalid IV parameter.");
            }
            this._iv = this._prev.slice(0);
          } else if (!("iv" in options)) {
            throw new Error("Invalid IV parameter.");
          } else {
            this._iv = transformIV(options.iv, this.blockSize);
            this._prev = this._iv.slice(0);
          }
        };
        modes.cbc.prototype.encrypt = function(input, output, finish) {
          if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
            return true;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = this._prev[i] ^ input.getInt32();
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          for (var i = 0; i < this._ints; ++i) {
            output.putInt32(this._outBlock[i]);
          }
          this._prev = this._outBlock;
        };
        modes.cbc.prototype.decrypt = function(input, output, finish) {
          if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
            return true;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = input.getInt32();
          }
          this.cipher.decrypt(this._inBlock, this._outBlock);
          for (var i = 0; i < this._ints; ++i) {
            output.putInt32(this._prev[i] ^ this._outBlock[i]);
          }
          this._prev = this._inBlock.slice(0);
        };
        modes.cbc.prototype.pad = function(input, options) {
          var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
          input.fillWithByte(padding, padding);
          return true;
        };
        modes.cbc.prototype.unpad = function(output, options) {
          if (options.overflow > 0) {
            return false;
          }
          var len = output.length();
          var count = output.at(len - 1);
          if (count > this.blockSize << 2) {
            return false;
          }
          output.truncate(count);
          return true;
        };
        modes.cfb = function(options) {
          options = options || {};
          this.name = "CFB";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = null;
          this._outBlock = new Array(this._ints);
          this._partialBlock = new Array(this._ints);
          this._partialOutput = forge2.util.createBuffer();
          this._partialBytes = 0;
        };
        modes.cfb.prototype.start = function(options) {
          if (!("iv" in options)) {
            throw new Error("Invalid IV parameter.");
          }
          this._iv = transformIV(options.iv, this.blockSize);
          this._inBlock = this._iv.slice(0);
          this._partialBytes = 0;
        };
        modes.cfb.prototype.encrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (inputLength === 0) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          if (this._partialBytes === 0 && inputLength >= this.blockSize) {
            for (var i = 0; i < this._ints; ++i) {
              this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
              output.putInt32(this._inBlock[i]);
            }
            return;
          }
          var partialBytes = (this.blockSize - inputLength) % this.blockSize;
          if (partialBytes > 0) {
            partialBytes = this.blockSize - partialBytes;
          }
          this._partialOutput.clear();
          for (var i = 0; i < this._ints; ++i) {
            this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
            this._partialOutput.putInt32(this._partialBlock[i]);
          }
          if (partialBytes > 0) {
            input.read -= this.blockSize;
          } else {
            for (var i = 0; i < this._ints; ++i) {
              this._inBlock[i] = this._partialBlock[i];
            }
          }
          if (this._partialBytes > 0) {
            this._partialOutput.getBytes(this._partialBytes);
          }
          if (partialBytes > 0 && !finish) {
            output.putBytes(this._partialOutput.getBytes(
              partialBytes - this._partialBytes
            ));
            this._partialBytes = partialBytes;
            return true;
          }
          output.putBytes(this._partialOutput.getBytes(
            inputLength - this._partialBytes
          ));
          this._partialBytes = 0;
        };
        modes.cfb.prototype.decrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (inputLength === 0) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          if (this._partialBytes === 0 && inputLength >= this.blockSize) {
            for (var i = 0; i < this._ints; ++i) {
              this._inBlock[i] = input.getInt32();
              output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
            }
            return;
          }
          var partialBytes = (this.blockSize - inputLength) % this.blockSize;
          if (partialBytes > 0) {
            partialBytes = this.blockSize - partialBytes;
          }
          this._partialOutput.clear();
          for (var i = 0; i < this._ints; ++i) {
            this._partialBlock[i] = input.getInt32();
            this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
          }
          if (partialBytes > 0) {
            input.read -= this.blockSize;
          } else {
            for (var i = 0; i < this._ints; ++i) {
              this._inBlock[i] = this._partialBlock[i];
            }
          }
          if (this._partialBytes > 0) {
            this._partialOutput.getBytes(this._partialBytes);
          }
          if (partialBytes > 0 && !finish) {
            output.putBytes(this._partialOutput.getBytes(
              partialBytes - this._partialBytes
            ));
            this._partialBytes = partialBytes;
            return true;
          }
          output.putBytes(this._partialOutput.getBytes(
            inputLength - this._partialBytes
          ));
          this._partialBytes = 0;
        };
        modes.ofb = function(options) {
          options = options || {};
          this.name = "OFB";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = null;
          this._outBlock = new Array(this._ints);
          this._partialOutput = forge2.util.createBuffer();
          this._partialBytes = 0;
        };
        modes.ofb.prototype.start = function(options) {
          if (!("iv" in options)) {
            throw new Error("Invalid IV parameter.");
          }
          this._iv = transformIV(options.iv, this.blockSize);
          this._inBlock = this._iv.slice(0);
          this._partialBytes = 0;
        };
        modes.ofb.prototype.encrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (input.length() === 0) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          if (this._partialBytes === 0 && inputLength >= this.blockSize) {
            for (var i = 0; i < this._ints; ++i) {
              output.putInt32(input.getInt32() ^ this._outBlock[i]);
              this._inBlock[i] = this._outBlock[i];
            }
            return;
          }
          var partialBytes = (this.blockSize - inputLength) % this.blockSize;
          if (partialBytes > 0) {
            partialBytes = this.blockSize - partialBytes;
          }
          this._partialOutput.clear();
          for (var i = 0; i < this._ints; ++i) {
            this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
          }
          if (partialBytes > 0) {
            input.read -= this.blockSize;
          } else {
            for (var i = 0; i < this._ints; ++i) {
              this._inBlock[i] = this._outBlock[i];
            }
          }
          if (this._partialBytes > 0) {
            this._partialOutput.getBytes(this._partialBytes);
          }
          if (partialBytes > 0 && !finish) {
            output.putBytes(this._partialOutput.getBytes(
              partialBytes - this._partialBytes
            ));
            this._partialBytes = partialBytes;
            return true;
          }
          output.putBytes(this._partialOutput.getBytes(
            inputLength - this._partialBytes
          ));
          this._partialBytes = 0;
        };
        modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
        modes.ctr = function(options) {
          options = options || {};
          this.name = "CTR";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = null;
          this._outBlock = new Array(this._ints);
          this._partialOutput = forge2.util.createBuffer();
          this._partialBytes = 0;
        };
        modes.ctr.prototype.start = function(options) {
          if (!("iv" in options)) {
            throw new Error("Invalid IV parameter.");
          }
          this._iv = transformIV(options.iv, this.blockSize);
          this._inBlock = this._iv.slice(0);
          this._partialBytes = 0;
        };
        modes.ctr.prototype.encrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (inputLength === 0) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          if (this._partialBytes === 0 && inputLength >= this.blockSize) {
            for (var i = 0; i < this._ints; ++i) {
              output.putInt32(input.getInt32() ^ this._outBlock[i]);
            }
          } else {
            var partialBytes = (this.blockSize - inputLength) % this.blockSize;
            if (partialBytes > 0) {
              partialBytes = this.blockSize - partialBytes;
            }
            this._partialOutput.clear();
            for (var i = 0; i < this._ints; ++i) {
              this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
            }
            if (partialBytes > 0) {
              input.read -= this.blockSize;
            }
            if (this._partialBytes > 0) {
              this._partialOutput.getBytes(this._partialBytes);
            }
            if (partialBytes > 0 && !finish) {
              output.putBytes(this._partialOutput.getBytes(
                partialBytes - this._partialBytes
              ));
              this._partialBytes = partialBytes;
              return true;
            }
            output.putBytes(this._partialOutput.getBytes(
              inputLength - this._partialBytes
            ));
            this._partialBytes = 0;
          }
          inc32(this._inBlock);
        };
        modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
        modes.gcm = function(options) {
          options = options || {};
          this.name = "GCM";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = new Array(this._ints);
          this._outBlock = new Array(this._ints);
          this._partialOutput = forge2.util.createBuffer();
          this._partialBytes = 0;
          this._R = 3774873600;
        };
        modes.gcm.prototype.start = function(options) {
          if (!("iv" in options)) {
            throw new Error("Invalid IV parameter.");
          }
          var iv = forge2.util.createBuffer(options.iv);
          this._cipherLength = 0;
          var additionalData;
          if ("additionalData" in options) {
            additionalData = forge2.util.createBuffer(options.additionalData);
          } else {
            additionalData = forge2.util.createBuffer();
          }
          if ("tagLength" in options) {
            this._tagLength = options.tagLength;
          } else {
            this._tagLength = 128;
          }
          this._tag = null;
          if (options.decrypt) {
            this._tag = forge2.util.createBuffer(options.tag).getBytes();
            if (this._tag.length !== this._tagLength / 8) {
              throw new Error("Authentication tag does not match tag length.");
            }
          }
          this._hashBlock = new Array(this._ints);
          this.tag = null;
          this._hashSubkey = new Array(this._ints);
          this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
          this.componentBits = 4;
          this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
          var ivLength = iv.length();
          if (ivLength === 12) {
            this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
          } else {
            this._j0 = [0, 0, 0, 0];
            while (iv.length() > 0) {
              this._j0 = this.ghash(
                this._hashSubkey,
                this._j0,
                [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]
              );
            }
            this._j0 = this.ghash(
              this._hashSubkey,
              this._j0,
              [0, 0].concat(from64To32(ivLength * 8))
            );
          }
          this._inBlock = this._j0.slice(0);
          inc32(this._inBlock);
          this._partialBytes = 0;
          additionalData = forge2.util.createBuffer(additionalData);
          this._aDataLength = from64To32(additionalData.length() * 8);
          var overflow = additionalData.length() % this.blockSize;
          if (overflow) {
            additionalData.fillWithByte(0, this.blockSize - overflow);
          }
          this._s = [0, 0, 0, 0];
          while (additionalData.length() > 0) {
            this._s = this.ghash(this._hashSubkey, this._s, [
              additionalData.getInt32(),
              additionalData.getInt32(),
              additionalData.getInt32(),
              additionalData.getInt32()
            ]);
          }
        };
        modes.gcm.prototype.encrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (inputLength === 0) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          if (this._partialBytes === 0 && inputLength >= this.blockSize) {
            for (var i = 0; i < this._ints; ++i) {
              output.putInt32(this._outBlock[i] ^= input.getInt32());
            }
            this._cipherLength += this.blockSize;
          } else {
            var partialBytes = (this.blockSize - inputLength) % this.blockSize;
            if (partialBytes > 0) {
              partialBytes = this.blockSize - partialBytes;
            }
            this._partialOutput.clear();
            for (var i = 0; i < this._ints; ++i) {
              this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
            }
            if (partialBytes <= 0 || finish) {
              if (finish) {
                var overflow = inputLength % this.blockSize;
                this._cipherLength += overflow;
                this._partialOutput.truncate(this.blockSize - overflow);
              } else {
                this._cipherLength += this.blockSize;
              }
              for (var i = 0; i < this._ints; ++i) {
                this._outBlock[i] = this._partialOutput.getInt32();
              }
              this._partialOutput.read -= this.blockSize;
            }
            if (this._partialBytes > 0) {
              this._partialOutput.getBytes(this._partialBytes);
            }
            if (partialBytes > 0 && !finish) {
              input.read -= this.blockSize;
              output.putBytes(this._partialOutput.getBytes(
                partialBytes - this._partialBytes
              ));
              this._partialBytes = partialBytes;
              return true;
            }
            output.putBytes(this._partialOutput.getBytes(
              inputLength - this._partialBytes
            ));
            this._partialBytes = 0;
          }
          this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
          inc32(this._inBlock);
        };
        modes.gcm.prototype.decrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          inc32(this._inBlock);
          this._hashBlock[0] = input.getInt32();
          this._hashBlock[1] = input.getInt32();
          this._hashBlock[2] = input.getInt32();
          this._hashBlock[3] = input.getInt32();
          this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
          for (var i = 0; i < this._ints; ++i) {
            output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
          }
          if (inputLength < this.blockSize) {
            this._cipherLength += inputLength % this.blockSize;
          } else {
            this._cipherLength += this.blockSize;
          }
        };
        modes.gcm.prototype.afterFinish = function(output, options) {
          var rval = true;
          if (options.decrypt && options.overflow) {
            output.truncate(this.blockSize - options.overflow);
          }
          this.tag = forge2.util.createBuffer();
          var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
          this._s = this.ghash(this._hashSubkey, this._s, lengths);
          var tag = [];
          this.cipher.encrypt(this._j0, tag);
          for (var i = 0; i < this._ints; ++i) {
            this.tag.putInt32(this._s[i] ^ tag[i]);
          }
          this.tag.truncate(this.tag.length() % (this._tagLength / 8));
          if (options.decrypt && this.tag.bytes() !== this._tag) {
            rval = false;
          }
          return rval;
        };
        modes.gcm.prototype.multiply = function(x, y) {
          var z_i = [0, 0, 0, 0];
          var v_i = y.slice(0);
          for (var i = 0; i < 128; ++i) {
            var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
            if (x_i) {
              z_i[0] ^= v_i[0];
              z_i[1] ^= v_i[1];
              z_i[2] ^= v_i[2];
              z_i[3] ^= v_i[3];
            }
            this.pow(v_i, v_i);
          }
          return z_i;
        };
        modes.gcm.prototype.pow = function(x, out) {
          var lsb = x[3] & 1;
          for (var i = 3; i > 0; --i) {
            out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
          }
          out[0] = x[0] >>> 1;
          if (lsb) {
            out[0] ^= this._R;
          }
        };
        modes.gcm.prototype.tableMultiply = function(x) {
          var z = [0, 0, 0, 0];
          for (var i = 0; i < 32; ++i) {
            var idx = i / 8 | 0;
            var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;
            var ah = this._m[i][x_i];
            z[0] ^= ah[0];
            z[1] ^= ah[1];
            z[2] ^= ah[2];
            z[3] ^= ah[3];
          }
          return z;
        };
        modes.gcm.prototype.ghash = function(h, y, x) {
          y[0] ^= x[0];
          y[1] ^= x[1];
          y[2] ^= x[2];
          y[3] ^= x[3];
          return this.tableMultiply(y);
        };
        modes.gcm.prototype.generateHashTable = function(h, bits2) {
          var multiplier = 8 / bits2;
          var perInt = 4 * multiplier;
          var size = 16 * multiplier;
          var m = new Array(size);
          for (var i = 0; i < size; ++i) {
            var tmp = [0, 0, 0, 0];
            var idx = i / perInt | 0;
            var shft2 = (perInt - 1 - i % perInt) * bits2;
            tmp[idx] = 1 << bits2 - 1 << shft2;
            m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits2);
          }
          return m;
        };
        modes.gcm.prototype.generateSubHashTable = function(mid, bits2) {
          var size = 1 << bits2;
          var half = size >>> 1;
          var m = new Array(size);
          m[half] = mid.slice(0);
          var i = half >>> 1;
          while (i > 0) {
            this.pow(m[2 * i], m[i] = []);
            i >>= 1;
          }
          i = 2;
          while (i < half) {
            for (var j = 1; j < i; ++j) {
              var m_i = m[i];
              var m_j = m[j];
              m[i + j] = [
                m_i[0] ^ m_j[0],
                m_i[1] ^ m_j[1],
                m_i[2] ^ m_j[2],
                m_i[3] ^ m_j[3]
              ];
            }
            i *= 2;
          }
          m[0] = [0, 0, 0, 0];
          for (i = half + 1; i < size; ++i) {
            var c = m[i ^ half];
            m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
          }
          return m;
        };
        function transformIV(iv, blockSize) {
          if (typeof iv === "string") {
            iv = forge2.util.createBuffer(iv);
          }
          if (forge2.util.isArray(iv) && iv.length > 4) {
            var tmp = iv;
            iv = forge2.util.createBuffer();
            for (var i = 0; i < tmp.length; ++i) {
              iv.putByte(tmp[i]);
            }
          }
          if (iv.length() < blockSize) {
            throw new Error(
              "Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes."
            );
          }
          if (!forge2.util.isArray(iv)) {
            var ints = [];
            var blocks = blockSize / 4;
            for (var i = 0; i < blocks; ++i) {
              ints.push(iv.getInt32());
            }
            iv = ints;
          }
          return iv;
        }
        function inc32(block) {
          block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
        }
        function from64To32(num) {
          return [num / 4294967296 | 0, num & 4294967295];
        }
        return cipherModes.exports;
      }
      var aes;
      var hasRequiredAes;
      function requireAes() {
        if (hasRequiredAes) return aes;
        hasRequiredAes = 1;
        var forge2 = requireForge();
        requireCipher();
        requireCipherModes();
        requireUtil();
        aes = forge2.aes = forge2.aes || {};
        forge2.aes.startEncrypting = function(key, iv, output, mode) {
          var cipher2 = _createCipher({
            key,
            output,
            decrypt: false,
            mode
          });
          cipher2.start(iv);
          return cipher2;
        };
        forge2.aes.createEncryptionCipher = function(key, mode) {
          return _createCipher({
            key,
            output: null,
            decrypt: false,
            mode
          });
        };
        forge2.aes.startDecrypting = function(key, iv, output, mode) {
          var cipher2 = _createCipher({
            key,
            output,
            decrypt: true,
            mode
          });
          cipher2.start(iv);
          return cipher2;
        };
        forge2.aes.createDecryptionCipher = function(key, mode) {
          return _createCipher({
            key,
            output: null,
            decrypt: true,
            mode
          });
        };
        forge2.aes.Algorithm = function(name2, mode) {
          if (!init) {
            initialize();
          }
          var self2 = this;
          self2.name = name2;
          self2.mode = new mode({
            blockSize: 16,
            cipher: {
              encrypt: function(inBlock, outBlock) {
                return _updateBlock(self2._w, inBlock, outBlock, false);
              },
              decrypt: function(inBlock, outBlock) {
                return _updateBlock(self2._w, inBlock, outBlock, true);
              }
            }
          });
          self2._init = false;
        };
        forge2.aes.Algorithm.prototype.initialize = function(options) {
          if (this._init) {
            return;
          }
          var key = options.key;
          var tmp;
          if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
            key = forge2.util.createBuffer(key);
          } else if (forge2.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
            tmp = key;
            key = forge2.util.createBuffer();
            for (var i = 0; i < tmp.length; ++i) {
              key.putByte(tmp[i]);
            }
          }
          if (!forge2.util.isArray(key)) {
            tmp = key;
            key = [];
            var len = tmp.length();
            if (len === 16 || len === 24 || len === 32) {
              len = len >>> 2;
              for (var i = 0; i < len; ++i) {
                key.push(tmp.getInt32());
              }
            }
          }
          if (!forge2.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
            throw new Error("Invalid key parameter.");
          }
          var mode = this.mode.name;
          var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
          this._w = _expandKey(key, options.decrypt && !encryptOp);
          this._init = true;
        };
        forge2.aes._expandKey = function(key, decrypt) {
          if (!init) {
            initialize();
          }
          return _expandKey(key, decrypt);
        };
        forge2.aes._updateBlock = _updateBlock;
        registerAlgorithm("AES-ECB", forge2.cipher.modes.ecb);
        registerAlgorithm("AES-CBC", forge2.cipher.modes.cbc);
        registerAlgorithm("AES-CFB", forge2.cipher.modes.cfb);
        registerAlgorithm("AES-OFB", forge2.cipher.modes.ofb);
        registerAlgorithm("AES-CTR", forge2.cipher.modes.ctr);
        registerAlgorithm("AES-GCM", forge2.cipher.modes.gcm);
        function registerAlgorithm(name2, mode) {
          var factory = function() {
            return new forge2.aes.Algorithm(name2, mode);
          };
          forge2.cipher.registerAlgorithm(name2, factory);
        }
        var init = false;
        var Nb = 4;
        var sbox;
        var isbox;
        var rcon;
        var mix;
        var imix;
        function initialize() {
          init = true;
          rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
          var xtime = new Array(256);
          for (var i = 0; i < 128; ++i) {
            xtime[i] = i << 1;
            xtime[i + 128] = i + 128 << 1 ^ 283;
          }
          sbox = new Array(256);
          isbox = new Array(256);
          mix = new Array(4);
          imix = new Array(4);
          for (var i = 0; i < 4; ++i) {
            mix[i] = new Array(256);
            imix[i] = new Array(256);
          }
          var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
          for (var i = 0; i < 256; ++i) {
            sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
            sx = sx >> 8 ^ sx & 255 ^ 99;
            sbox[e] = sx;
            isbox[sx] = e;
            sx2 = xtime[sx];
            e2 = xtime[e];
            e4 = xtime[e2];
            e8 = xtime[e4];
            me = sx2 << 24 ^ // 2
            sx << 16 ^ // 1
            sx << 8 ^ // 1
            (sx ^ sx2);
            ime = (e2 ^ e4 ^ e8) << 24 ^ // E (14)
            (e ^ e8) << 16 ^ // 9
            (e ^ e4 ^ e8) << 8 ^ // D (13)
            (e ^ e2 ^ e8);
            for (var n = 0; n < 4; ++n) {
              mix[n][e] = me;
              imix[n][sx] = ime;
              me = me << 24 | me >>> 8;
              ime = ime << 24 | ime >>> 8;
            }
            if (e === 0) {
              e = ei = 1;
            } else {
              e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
              ei ^= xtime[xtime[ei]];
            }
          }
        }
        function _expandKey(key, decrypt) {
          var w = key.slice(0);
          var temp, iNk = 1;
          var Nk = w.length;
          var Nr1 = Nk + 6 + 1;
          var end = Nb * Nr1;
          for (var i = Nk; i < end; ++i) {
            temp = w[i - 1];
            if (i % Nk === 0) {
              temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
              iNk++;
            } else if (Nk > 6 && i % Nk === 4) {
              temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
            }
            w[i] = w[i - Nk] ^ temp;
          }
          if (decrypt) {
            var tmp;
            var m0 = imix[0];
            var m1 = imix[1];
            var m2 = imix[2];
            var m3 = imix[3];
            var wnew = w.slice(0);
            end = w.length;
            for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
              if (i === 0 || i === end - Nb) {
                wnew[i] = w[wi];
                wnew[i + 1] = w[wi + 3];
                wnew[i + 2] = w[wi + 2];
                wnew[i + 3] = w[wi + 1];
              } else {
                for (var n = 0; n < Nb; ++n) {
                  tmp = w[wi + n];
                  wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
                }
              }
            }
            w = wnew;
          }
          return w;
        }
        function _updateBlock(w, input, output, decrypt) {
          var Nr = w.length / 4 - 1;
          var m0, m1, m2, m3, sub;
          if (decrypt) {
            m0 = imix[0];
            m1 = imix[1];
            m2 = imix[2];
            m3 = imix[3];
            sub = isbox;
          } else {
            m0 = mix[0];
            m1 = mix[1];
            m2 = mix[2];
            m3 = mix[3];
            sub = sbox;
          }
          var a, b, c, d, a2, b2, c2;
          a = input[0] ^ w[0];
          b = input[decrypt ? 3 : 1] ^ w[1];
          c = input[2] ^ w[2];
          d = input[decrypt ? 1 : 3] ^ w[3];
          var i = 3;
          for (var round = 1; round < Nr; ++round) {
            a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
            b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
            c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
            d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
            a = a2;
            b = b2;
            c = c2;
          }
          output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];
          output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];
          output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];
          output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];
        }
        function _createCipher(options) {
          options = options || {};
          var mode = (options.mode || "CBC").toUpperCase();
          var algorithm = "AES-" + mode;
          var cipher2;
          if (options.decrypt) {
            cipher2 = forge2.cipher.createDecipher(algorithm, options.key);
          } else {
            cipher2 = forge2.cipher.createCipher(algorithm, options.key);
          }
          var start = cipher2.start;
          cipher2.start = function(iv, options2) {
            var output = null;
            if (options2 instanceof forge2.util.ByteBuffer) {
              output = options2;
              options2 = {};
            }
            options2 = options2 || {};
            options2.output = output;
            options2.iv = iv;
            start.call(cipher2, options2);
          };
          return cipher2;
        }
        return aes;
      }
      var aesCipherSuites = { exports: {} };
      var asn1 = { exports: {} };
      var oids = { exports: {} };
      var hasRequiredOids;
      function requireOids() {
        if (hasRequiredOids) return oids.exports;
        hasRequiredOids = 1;
        var forge2 = requireForge();
        forge2.pki = forge2.pki || {};
        var oids$1 = oids.exports = forge2.pki.oids = forge2.oids = forge2.oids || {};
        function _IN(id, name2) {
          oids$1[id] = name2;
          oids$1[name2] = id;
        }
        function _I_(id, name2) {
          oids$1[id] = name2;
        }
        _IN("1.2.840.113549.1.1.1", "rsaEncryption");
        _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
        _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
        _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
        _IN("1.2.840.113549.1.1.8", "mgf1");
        _IN("1.2.840.113549.1.1.9", "pSpecified");
        _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
        _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
        _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
        _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
        _IN("1.3.101.112", "EdDSA25519");
        _IN("1.2.840.10040.4.3", "dsa-with-sha1");
        _IN("1.3.14.3.2.7", "desCBC");
        _IN("1.3.14.3.2.26", "sha1");
        _IN("1.3.14.3.2.29", "sha1WithRSASignature");
        _IN("2.16.840.1.101.3.4.2.1", "sha256");
        _IN("2.16.840.1.101.3.4.2.2", "sha384");
        _IN("2.16.840.1.101.3.4.2.3", "sha512");
        _IN("2.16.840.1.101.3.4.2.4", "sha224");
        _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
        _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
        _IN("1.2.840.113549.2.2", "md2");
        _IN("1.2.840.113549.2.5", "md5");
        _IN("1.2.840.113549.1.7.1", "data");
        _IN("1.2.840.113549.1.7.2", "signedData");
        _IN("1.2.840.113549.1.7.3", "envelopedData");
        _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
        _IN("1.2.840.113549.1.7.5", "digestedData");
        _IN("1.2.840.113549.1.7.6", "encryptedData");
        _IN("1.2.840.113549.1.9.1", "emailAddress");
        _IN("1.2.840.113549.1.9.2", "unstructuredName");
        _IN("1.2.840.113549.1.9.3", "contentType");
        _IN("1.2.840.113549.1.9.4", "messageDigest");
        _IN("1.2.840.113549.1.9.5", "signingTime");
        _IN("1.2.840.113549.1.9.6", "counterSignature");
        _IN("1.2.840.113549.1.9.7", "challengePassword");
        _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
        _IN("1.2.840.113549.1.9.14", "extensionRequest");
        _IN("1.2.840.113549.1.9.20", "friendlyName");
        _IN("1.2.840.113549.1.9.21", "localKeyId");
        _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
        _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
        _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
        _IN("1.2.840.113549.1.12.10.1.3", "certBag");
        _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
        _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
        _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
        _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
        _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
        _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
        _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
        _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
        _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
        _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
        _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
        _IN("1.2.840.113549.2.7", "hmacWithSHA1");
        _IN("1.2.840.113549.2.8", "hmacWithSHA224");
        _IN("1.2.840.113549.2.9", "hmacWithSHA256");
        _IN("1.2.840.113549.2.10", "hmacWithSHA384");
        _IN("1.2.840.113549.2.11", "hmacWithSHA512");
        _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
        _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
        _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
        _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
        _IN("2.5.4.3", "commonName");
        _IN("2.5.4.4", "surname");
        _IN("2.5.4.5", "serialNumber");
        _IN("2.5.4.6", "countryName");
        _IN("2.5.4.7", "localityName");
        _IN("2.5.4.8", "stateOrProvinceName");
        _IN("2.5.4.9", "streetAddress");
        _IN("2.5.4.10", "organizationName");
        _IN("2.5.4.11", "organizationalUnitName");
        _IN("2.5.4.12", "title");
        _IN("2.5.4.13", "description");
        _IN("2.5.4.15", "businessCategory");
        _IN("2.5.4.17", "postalCode");
        _IN("2.5.4.42", "givenName");
        _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
        _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
        _IN("2.16.840.1.113730.1.1", "nsCertType");
        _IN("2.16.840.1.113730.1.13", "nsComment");
        _I_("2.5.29.1", "authorityKeyIdentifier");
        _I_("2.5.29.2", "keyAttributes");
        _I_("2.5.29.3", "certificatePolicies");
        _I_("2.5.29.4", "keyUsageRestriction");
        _I_("2.5.29.5", "policyMapping");
        _I_("2.5.29.6", "subtreesConstraint");
        _I_("2.5.29.7", "subjectAltName");
        _I_("2.5.29.8", "issuerAltName");
        _I_("2.5.29.9", "subjectDirectoryAttributes");
        _I_("2.5.29.10", "basicConstraints");
        _I_("2.5.29.11", "nameConstraints");
        _I_("2.5.29.12", "policyConstraints");
        _I_("2.5.29.13", "basicConstraints");
        _IN("2.5.29.14", "subjectKeyIdentifier");
        _IN("2.5.29.15", "keyUsage");
        _I_("2.5.29.16", "privateKeyUsagePeriod");
        _IN("2.5.29.17", "subjectAltName");
        _IN("2.5.29.18", "issuerAltName");
        _IN("2.5.29.19", "basicConstraints");
        _I_("2.5.29.20", "cRLNumber");
        _I_("2.5.29.21", "cRLReason");
        _I_("2.5.29.22", "expirationDate");
        _I_("2.5.29.23", "instructionCode");
        _I_("2.5.29.24", "invalidityDate");
        _I_("2.5.29.25", "cRLDistributionPoints");
        _I_("2.5.29.26", "issuingDistributionPoint");
        _I_("2.5.29.27", "deltaCRLIndicator");
        _I_("2.5.29.28", "issuingDistributionPoint");
        _I_("2.5.29.29", "certificateIssuer");
        _I_("2.5.29.30", "nameConstraints");
        _IN("2.5.29.31", "cRLDistributionPoints");
        _IN("2.5.29.32", "certificatePolicies");
        _I_("2.5.29.33", "policyMappings");
        _I_("2.5.29.34", "policyConstraints");
        _IN("2.5.29.35", "authorityKeyIdentifier");
        _I_("2.5.29.36", "policyConstraints");
        _IN("2.5.29.37", "extKeyUsage");
        _I_("2.5.29.46", "freshestCRL");
        _I_("2.5.29.54", "inhibitAnyPolicy");
        _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
        _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
        _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
        _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
        _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
        _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
        _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
        return oids.exports;
      }
      var hasRequiredAsn1;
      function requireAsn1() {
        if (hasRequiredAsn1) return asn1.exports;
        hasRequiredAsn1 = 1;
        var forge2 = requireForge();
        requireUtil();
        requireOids();
        var asn1$1 = asn1.exports = forge2.asn1 = forge2.asn1 || {};
        asn1$1.Class = {
          UNIVERSAL: 0,
          APPLICATION: 64,
          CONTEXT_SPECIFIC: 128,
          PRIVATE: 192
        };
        asn1$1.Type = {
          NONE: 0,
          BOOLEAN: 1,
          INTEGER: 2,
          BITSTRING: 3,
          OCTETSTRING: 4,
          NULL: 5,
          OID: 6,
          ODESC: 7,
          EXTERNAL: 8,
          REAL: 9,
          ENUMERATED: 10,
          EMBEDDED: 11,
          UTF8: 12,
          ROID: 13,
          SEQUENCE: 16,
          SET: 17,
          PRINTABLESTRING: 19,
          IA5STRING: 22,
          UTCTIME: 23,
          GENERALIZEDTIME: 24,
          BMPSTRING: 30
        };
        asn1$1.maxDepth = 256;
        asn1$1.create = function(tagClass, type, constructed, value, options) {
          if (forge2.util.isArray(value)) {
            var tmp = [];
            for (var i = 0; i < value.length; ++i) {
              if (value[i] !== void 0) {
                tmp.push(value[i]);
              }
            }
            value = tmp;
          }
          var obj = {
            tagClass,
            type,
            constructed,
            composed: constructed || forge2.util.isArray(value),
            value
          };
          if (options && "bitStringContents" in options) {
            obj.bitStringContents = options.bitStringContents;
            obj.original = asn1$1.copy(obj);
          }
          return obj;
        };
        asn1$1.copy = function(obj, options) {
          var copy2;
          if (forge2.util.isArray(obj)) {
            copy2 = [];
            for (var i = 0; i < obj.length; ++i) {
              copy2.push(asn1$1.copy(obj[i], options));
            }
            return copy2;
          }
          if (typeof obj === "string") {
            return obj;
          }
          copy2 = {
            tagClass: obj.tagClass,
            type: obj.type,
            constructed: obj.constructed,
            composed: obj.composed,
            value: asn1$1.copy(obj.value, options)
          };
          if (options && !options.excludeBitStringContents) {
            copy2.bitStringContents = obj.bitStringContents;
          }
          return copy2;
        };
        asn1$1.equals = function(obj1, obj2, options) {
          if (forge2.util.isArray(obj1)) {
            if (!forge2.util.isArray(obj2)) {
              return false;
            }
            if (obj1.length !== obj2.length) {
              return false;
            }
            for (var i = 0; i < obj1.length; ++i) {
              if (!asn1$1.equals(obj1[i], obj2[i])) {
                return false;
              }
            }
            return true;
          }
          if (typeof obj1 !== typeof obj2) {
            return false;
          }
          if (typeof obj1 === "string") {
            return obj1 === obj2;
          }
          var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1$1.equals(obj1.value, obj2.value);
          if (options && options.includeBitStringContents) {
            equal = equal && obj1.bitStringContents === obj2.bitStringContents;
          }
          return equal;
        };
        asn1$1.getBerValueLength = function(b) {
          var b2 = b.getByte();
          if (b2 === 128) {
            return void 0;
          }
          var length;
          var longForm = b2 & 128;
          if (!longForm) {
            length = b2;
          } else {
            length = b.getInt((b2 & 127) << 3);
          }
          return length;
        };
        function _checkBufferLength(bytes, remaining, n) {
          if (n > remaining) {
            var error = new Error("Too few bytes to parse DER.");
            error.available = bytes.length();
            error.remaining = remaining;
            error.requested = n;
            throw error;
          }
        }
        var _getValueLength = function(bytes, remaining) {
          var b2 = bytes.getByte();
          remaining--;
          if (b2 === 128) {
            return void 0;
          }
          var length;
          var longForm = b2 & 128;
          if (!longForm) {
            length = b2;
          } else {
            var longFormBytes = b2 & 127;
            _checkBufferLength(bytes, remaining, longFormBytes);
            length = bytes.getInt(longFormBytes << 3);
          }
          if (length < 0) {
            throw new Error("Negative length: " + length);
          }
          return length;
        };
        asn1$1.fromDer = function(bytes, options) {
          if (options === void 0) {
            options = {
              strict: true,
              parseAllBytes: true,
              decodeBitStrings: true
            };
          }
          if (typeof options === "boolean") {
            options = {
              strict: options,
              parseAllBytes: true,
              decodeBitStrings: true
            };
          }
          if (!("strict" in options)) {
            options.strict = true;
          }
          if (!("parseAllBytes" in options)) {
            options.parseAllBytes = true;
          }
          if (!("decodeBitStrings" in options)) {
            options.decodeBitStrings = true;
          }
          if (!("maxDepth" in options)) {
            options.maxDepth = asn1$1.maxDepth;
          }
          if (typeof bytes === "string") {
            bytes = forge2.util.createBuffer(bytes);
          }
          var byteCount = bytes.length();
          var value = _fromDer(bytes, bytes.length(), 0, options);
          if (options.parseAllBytes && bytes.length() !== 0) {
            var error = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
            error.byteCount = byteCount;
            error.remaining = bytes.length();
            throw error;
          }
          return value;
        };
        function _fromDer(bytes, remaining, depth, options) {
          if (depth >= options.maxDepth) {
            throw new Error("ASN.1 parsing error: Max depth exceeded.");
          }
          var start;
          _checkBufferLength(bytes, remaining, 2);
          var b1 = bytes.getByte();
          remaining--;
          var tagClass = b1 & 192;
          var type = b1 & 31;
          start = bytes.length();
          var length = _getValueLength(bytes, remaining);
          remaining -= start - bytes.length();
          if (length !== void 0 && length > remaining) {
            if (options.strict) {
              var error = new Error("Too few bytes to read ASN.1 value.");
              error.available = bytes.length();
              error.remaining = remaining;
              error.requested = length;
              throw error;
            }
            length = remaining;
          }
          var value;
          var bitStringContents;
          var constructed = (b1 & 32) === 32;
          if (constructed) {
            value = [];
            if (length === void 0) {
              for (; ; ) {
                _checkBufferLength(bytes, remaining, 2);
                if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
                  bytes.getBytes(2);
                  remaining -= 2;
                  break;
                }
                start = bytes.length();
                value.push(_fromDer(bytes, remaining, depth + 1, options));
                remaining -= start - bytes.length();
              }
            } else {
              while (length > 0) {
                start = bytes.length();
                value.push(_fromDer(bytes, length, depth + 1, options));
                remaining -= start - bytes.length();
                length -= start - bytes.length();
              }
            }
          }
          if (value === void 0 && tagClass === asn1$1.Class.UNIVERSAL && type === asn1$1.Type.BITSTRING) {
            bitStringContents = bytes.bytes(length);
          }
          if (value === void 0 && options.decodeBitStrings && tagClass === asn1$1.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
          // .. other parts of forge expect to decode OCTET STRINGs manually
          type === asn1$1.Type.BITSTRING && length > 1) {
            var savedRead = bytes.read;
            var savedRemaining = remaining;
            var unused = 0;
            if (type === asn1$1.Type.BITSTRING) {
              _checkBufferLength(bytes, remaining, 1);
              unused = bytes.getByte();
              remaining--;
            }
            if (unused === 0) {
              try {
                start = bytes.length();
                var subOptions = {
                  // enforce strict mode to avoid parsing ASN.1 from plain data
                  strict: true,
                  decodeBitStrings: true
                };
                var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
                var used = start - bytes.length();
                remaining -= used;
                if (type == asn1$1.Type.BITSTRING) {
                  used++;
                }
                var tc = composed.tagClass;
                if (used === length && (tc === asn1$1.Class.UNIVERSAL || tc === asn1$1.Class.CONTEXT_SPECIFIC)) {
                  value = [composed];
                }
              } catch (ex) {
              }
            }
            if (value === void 0) {
              bytes.read = savedRead;
              remaining = savedRemaining;
            }
          }
          if (value === void 0) {
            if (length === void 0) {
              if (options.strict) {
                throw new Error("Non-constructed ASN.1 object of indefinite length.");
              }
              length = remaining;
            }
            if (type === asn1$1.Type.BMPSTRING) {
              value = "";
              for (; length > 0; length -= 2) {
                _checkBufferLength(bytes, remaining, 2);
                value += String.fromCharCode(bytes.getInt16());
                remaining -= 2;
              }
            } else {
              value = bytes.getBytes(length);
              remaining -= length;
            }
          }
          var asn1Options = bitStringContents === void 0 ? null : {
            bitStringContents
          };
          return asn1$1.create(tagClass, type, constructed, value, asn1Options);
        }
        asn1$1.toDer = function(obj) {
          var bytes = forge2.util.createBuffer();
          var b1 = obj.tagClass | obj.type;
          var value = forge2.util.createBuffer();
          var useBitStringContents = false;
          if ("bitStringContents" in obj) {
            useBitStringContents = true;
            if (obj.original) {
              useBitStringContents = asn1$1.equals(obj, obj.original);
            }
          }
          if (useBitStringContents) {
            value.putBytes(obj.bitStringContents);
          } else if (obj.composed) {
            if (obj.constructed) {
              b1 |= 32;
            } else {
              value.putByte(0);
            }
            for (var i = 0; i < obj.value.length; ++i) {
              if (obj.value[i] !== void 0) {
                value.putBuffer(asn1$1.toDer(obj.value[i]));
              }
            }
          } else {
            if (obj.type === asn1$1.Type.BMPSTRING) {
              for (var i = 0; i < obj.value.length; ++i) {
                value.putInt16(obj.value.charCodeAt(i));
              }
            } else {
              if (obj.type === asn1$1.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer
              (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
              obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
                value.putBytes(obj.value.substr(1));
              } else {
                value.putBytes(obj.value);
              }
            }
          }
          bytes.putByte(b1);
          if (value.length() <= 127) {
            bytes.putByte(value.length() & 127);
          } else {
            var len = value.length();
            var lenBytes = "";
            do {
              lenBytes += String.fromCharCode(len & 255);
              len = len >>> 8;
            } while (len > 0);
            bytes.putByte(lenBytes.length | 128);
            for (var i = lenBytes.length - 1; i >= 0; --i) {
              bytes.putByte(lenBytes.charCodeAt(i));
            }
          }
          bytes.putBuffer(value);
          return bytes;
        };
        asn1$1.oidToDer = function(oid) {
          var values = oid.split(".");
          var bytes = forge2.util.createBuffer();
          bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
          var last, valueBytes, value, b;
          for (var i = 2; i < values.length; ++i) {
            last = true;
            valueBytes = [];
            value = parseInt(values[i], 10);
            if (value > 4294967295) {
              throw new Error("OID value too large; max is 32-bits.");
            }
            do {
              b = value & 127;
              value = value >>> 7;
              if (!last) {
                b |= 128;
              }
              valueBytes.push(b);
              last = false;
            } while (value > 0);
            for (var n = valueBytes.length - 1; n >= 0; --n) {
              bytes.putByte(valueBytes[n]);
            }
          }
          return bytes;
        };
        asn1$1.derToOid = function(bytes) {
          var oid;
          if (typeof bytes === "string") {
            bytes = forge2.util.createBuffer(bytes);
          }
          var b = bytes.getByte();
          oid = Math.floor(b / 40) + "." + b % 40;
          var value = 0;
          while (bytes.length() > 0) {
            if (value > 70368744177663) {
              throw new Error("OID value too large; max is 53-bits.");
            }
            b = bytes.getByte();
            value = value * 128;
            if (b & 128) {
              value += b & 127;
            } else {
              oid += "." + (value + b);
              value = 0;
            }
          }
          return oid;
        };
        asn1$1.utcTimeToDate = function(utc) {
          var date = /* @__PURE__ */ new Date();
          var year = parseInt(utc.substr(0, 2), 10);
          year = year >= 50 ? 1900 + year : 2e3 + year;
          var MM = parseInt(utc.substr(2, 2), 10) - 1;
          var DD = parseInt(utc.substr(4, 2), 10);
          var hh = parseInt(utc.substr(6, 2), 10);
          var mm = parseInt(utc.substr(8, 2), 10);
          var ss = 0;
          if (utc.length > 11) {
            var c = utc.charAt(10);
            var end = 10;
            if (c !== "+" && c !== "-") {
              ss = parseInt(utc.substr(10, 2), 10);
              end += 2;
            }
          }
          date.setUTCFullYear(year, MM, DD);
          date.setUTCHours(hh, mm, ss, 0);
          if (end) {
            c = utc.charAt(end);
            if (c === "+" || c === "-") {
              var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
              var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
              var offset = hhoffset * 60 + mmoffset;
              offset *= 6e4;
              if (c === "+") {
                date.setTime(+date - offset);
              } else {
                date.setTime(+date + offset);
              }
            }
          }
          return date;
        };
        asn1$1.generalizedTimeToDate = function(gentime) {
          var date = /* @__PURE__ */ new Date();
          var YYYY = parseInt(gentime.substr(0, 4), 10);
          var MM = parseInt(gentime.substr(4, 2), 10) - 1;
          var DD = parseInt(gentime.substr(6, 2), 10);
          var hh = parseInt(gentime.substr(8, 2), 10);
          var mm = parseInt(gentime.substr(10, 2), 10);
          var ss = parseInt(gentime.substr(12, 2), 10);
          var fff = 0;
          var offset = 0;
          var isUTC = false;
          if (gentime.charAt(gentime.length - 1) === "Z") {
            isUTC = true;
          }
          var end = gentime.length - 5, c = gentime.charAt(end);
          if (c === "+" || c === "-") {
            var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
            var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
            offset = hhoffset * 60 + mmoffset;
            offset *= 6e4;
            if (c === "+") {
              offset *= -1;
            }
            isUTC = true;
          }
          if (gentime.charAt(14) === ".") {
            fff = parseFloat(gentime.substr(14), 10) * 1e3;
          }
          if (isUTC) {
            date.setUTCFullYear(YYYY, MM, DD);
            date.setUTCHours(hh, mm, ss, fff);
            date.setTime(+date + offset);
          } else {
            date.setFullYear(YYYY, MM, DD);
            date.setHours(hh, mm, ss, fff);
          }
          return date;
        };
        asn1$1.dateToUtcTime = function(date) {
          if (typeof date === "string") {
            return date;
          }
          var rval = "";
          var format = [];
          format.push(("" + date.getUTCFullYear()).substr(2));
          format.push("" + (date.getUTCMonth() + 1));
          format.push("" + date.getUTCDate());
          format.push("" + date.getUTCHours());
          format.push("" + date.getUTCMinutes());
          format.push("" + date.getUTCSeconds());
          for (var i = 0; i < format.length; ++i) {
            if (format[i].length < 2) {
              rval += "0";
            }
            rval += format[i];
          }
          rval += "Z";
          return rval;
        };
        asn1$1.dateToGeneralizedTime = function(date) {
          if (typeof date === "string") {
            return date;
          }
          var rval = "";
          var format = [];
          format.push("" + date.getUTCFullYear());
          format.push("" + (date.getUTCMonth() + 1));
          format.push("" + date.getUTCDate());
          format.push("" + date.getUTCHours());
          format.push("" + date.getUTCMinutes());
          format.push("" + date.getUTCSeconds());
          for (var i = 0; i < format.length; ++i) {
            if (format[i].length < 2) {
              rval += "0";
            }
            rval += format[i];
          }
          rval += "Z";
          return rval;
        };
        asn1$1.integerToDer = function(x) {
          var rval = forge2.util.createBuffer();
          if (x >= -128 && x < 128) {
            return rval.putSignedInt(x, 8);
          }
          if (x >= -32768 && x < 32768) {
            return rval.putSignedInt(x, 16);
          }
          if (x >= -8388608 && x < 8388608) {
            return rval.putSignedInt(x, 24);
          }
          if (x >= -2147483648 && x < 2147483648) {
            return rval.putSignedInt(x, 32);
          }
          var error = new Error("Integer too large; max is 32-bits.");
          error.integer = x;
          throw error;
        };
        asn1$1.derToInteger = function(bytes) {
          if (typeof bytes === "string") {
            bytes = forge2.util.createBuffer(bytes);
          }
          var n = bytes.length() * 8;
          if (n > 32) {
            throw new Error("Integer too large; max is 32-bits.");
          }
          return bytes.getSignedInt(n);
        };
        asn1$1.validate = function(obj, v, capture, errors) {
          var rval = false;
          if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
            if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
              rval = true;
              if (v.value && forge2.util.isArray(v.value)) {
                var j = 0;
                for (var i = 0; rval && i < v.value.length; ++i) {
                  var schemaItem = v.value[i];
                  rval = !!schemaItem.optional;
                  var objChild = obj.value[j];
                  if (!objChild) {
                    if (!schemaItem.optional) {
                      rval = false;
                      if (errors) {
                        errors.push("[" + v.name + '] Missing required element. Expected tag class "' + schemaItem.tagClass + '", type "' + schemaItem.type + '"');
                      }
                    }
                    continue;
                  }
                  var schemaHasTag = typeof schemaItem.tagClass !== "undefined" && typeof schemaItem.type !== "undefined";
                  if (schemaHasTag && (objChild.tagClass !== schemaItem.tagClass || objChild.type !== schemaItem.type)) {
                    if (schemaItem.optional) {
                      rval = true;
                      continue;
                    } else {
                      rval = false;
                      if (errors) {
                        errors.push("[" + v.name + "] Tag mismatch. Expected (" + schemaItem.tagClass + "," + schemaItem.type + "), got (" + objChild.tagClass + "," + objChild.type + ")");
                      }
                      break;
                    }
                  }
                  var childRval = asn1$1.validate(objChild, schemaItem, capture, errors);
                  if (childRval) {
                    ++j;
                    rval = true;
                  } else if (schemaItem.optional) {
                    rval = true;
                  } else {
                    rval = false;
                    break;
                  }
                }
              }
              if (rval && capture) {
                if (v.capture) {
                  capture[v.capture] = obj.value;
                }
                if (v.captureAsn1) {
                  capture[v.captureAsn1] = obj;
                }
                if (v.captureBitStringContents && "bitStringContents" in obj) {
                  capture[v.captureBitStringContents] = obj.bitStringContents;
                }
                if (v.captureBitStringValue && "bitStringContents" in obj) {
                  if (obj.bitStringContents.length < 2) {
                    capture[v.captureBitStringValue] = "";
                  } else {
                    var unused = obj.bitStringContents.charCodeAt(0);
                    if (unused !== 0) {
                      throw new Error(
                        "captureBitStringValue only supported for zero unused bits"
                      );
                    }
                    capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
                  }
                }
              }
            } else if (errors) {
              errors.push(
                "[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"'
              );
            }
          } else if (errors) {
            if (obj.tagClass !== v.tagClass) {
              errors.push(
                "[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"'
              );
            }
            if (obj.type !== v.type) {
              errors.push(
                "[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"'
              );
            }
          }
          return rval;
        };
        var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
        asn1$1.prettyPrint = function(obj, level, indentation) {
          var rval = "";
          level = level || 0;
          indentation = indentation || 2;
          if (level > 0) {
            rval += "\n";
          }
          var indent = "";
          for (var i = 0; i < level * indentation; ++i) {
            indent += " ";
          }
          rval += indent + "Tag: ";
          switch (obj.tagClass) {
            case asn1$1.Class.UNIVERSAL:
              rval += "Universal:";
              break;
            case asn1$1.Class.APPLICATION:
              rval += "Application:";
              break;
            case asn1$1.Class.CONTEXT_SPECIFIC:
              rval += "Context-Specific:";
              break;
            case asn1$1.Class.PRIVATE:
              rval += "Private:";
              break;
          }
          if (obj.tagClass === asn1$1.Class.UNIVERSAL) {
            rval += obj.type;
            switch (obj.type) {
              case asn1$1.Type.NONE:
                rval += " (None)";
                break;
              case asn1$1.Type.BOOLEAN:
                rval += " (Boolean)";
                break;
              case asn1$1.Type.INTEGER:
                rval += " (Integer)";
                break;
              case asn1$1.Type.BITSTRING:
                rval += " (Bit string)";
                break;
              case asn1$1.Type.OCTETSTRING:
                rval += " (Octet string)";
                break;
              case asn1$1.Type.NULL:
                rval += " (Null)";
                break;
              case asn1$1.Type.OID:
                rval += " (Object Identifier)";
                break;
              case asn1$1.Type.ODESC:
                rval += " (Object Descriptor)";
                break;
              case asn1$1.Type.EXTERNAL:
                rval += " (External or Instance of)";
                break;
              case asn1$1.Type.REAL:
                rval += " (Real)";
                break;
              case asn1$1.Type.ENUMERATED:
                rval += " (Enumerated)";
                break;
              case asn1$1.Type.EMBEDDED:
                rval += " (Embedded PDV)";
                break;
              case asn1$1.Type.UTF8:
                rval += " (UTF8)";
                break;
              case asn1$1.Type.ROID:
                rval += " (Relative Object Identifier)";
                break;
              case asn1$1.Type.SEQUENCE:
                rval += " (Sequence)";
                break;
              case asn1$1.Type.SET:
                rval += " (Set)";
                break;
              case asn1$1.Type.PRINTABLESTRING:
                rval += " (Printable String)";
                break;
              case asn1$1.Type.IA5String:
                rval += " (IA5String (ASCII))";
                break;
              case asn1$1.Type.UTCTIME:
                rval += " (UTC time)";
                break;
              case asn1$1.Type.GENERALIZEDTIME:
                rval += " (Generalized time)";
                break;
              case asn1$1.Type.BMPSTRING:
                rval += " (BMP String)";
                break;
            }
          } else {
            rval += obj.type;
          }
          rval += "\n";
          rval += indent + "Constructed: " + obj.constructed + "\n";
          if (obj.composed) {
            var subvalues = 0;
            var sub = "";
            for (var i = 0; i < obj.value.length; ++i) {
              if (obj.value[i] !== void 0) {
                subvalues += 1;
                sub += asn1$1.prettyPrint(obj.value[i], level + 1, indentation);
                if (i + 1 < obj.value.length) {
                  sub += ",";
                }
              }
            }
            rval += indent + "Sub values: " + subvalues + sub;
          } else {
            rval += indent + "Value: ";
            if (obj.type === asn1$1.Type.OID) {
              var oid = asn1$1.derToOid(obj.value);
              rval += oid;
              if (forge2.pki && forge2.pki.oids) {
                if (oid in forge2.pki.oids) {
                  rval += " (" + forge2.pki.oids[oid] + ") ";
                }
              }
            }
            if (obj.type === asn1$1.Type.INTEGER) {
              try {
                rval += asn1$1.derToInteger(obj.value);
              } catch (ex) {
                rval += "0x" + forge2.util.bytesToHex(obj.value);
              }
            } else if (obj.type === asn1$1.Type.BITSTRING) {
              if (obj.value.length > 1) {
                rval += "0x" + forge2.util.bytesToHex(obj.value.slice(1));
              } else {
                rval += "(none)";
              }
              if (obj.value.length > 0) {
                var unused = obj.value.charCodeAt(0);
                if (unused == 1) {
                  rval += " (1 unused bit shown)";
                } else if (unused > 1) {
                  rval += " (" + unused + " unused bits shown)";
                }
              }
            } else if (obj.type === asn1$1.Type.OCTETSTRING) {
              if (!_nonLatinRegex.test(obj.value)) {
                rval += "(" + obj.value + ") ";
              }
              rval += "0x" + forge2.util.bytesToHex(obj.value);
            } else if (obj.type === asn1$1.Type.UTF8) {
              try {
                rval += forge2.util.decodeUtf8(obj.value);
              } catch (e) {
                if (e.message === "URI malformed") {
                  rval += "0x" + forge2.util.bytesToHex(obj.value) + " (malformed UTF8)";
                } else {
                  throw e;
                }
              }
            } else if (obj.type === asn1$1.Type.PRINTABLESTRING || obj.type === asn1$1.Type.IA5String) {
              rval += obj.value;
            } else if (_nonLatinRegex.test(obj.value)) {
              rval += "0x" + forge2.util.bytesToHex(obj.value);
            } else if (obj.value.length === 0) {
              rval += "[null]";
            } else {
              rval += obj.value;
            }
          }
          return rval;
        };
        return asn1.exports;
      }
      var hmac = { exports: {} };
      var md;
      var hasRequiredMd;
      function requireMd() {
        if (hasRequiredMd) return md;
        hasRequiredMd = 1;
        var forge2 = requireForge();
        md = forge2.md = forge2.md || {};
        forge2.md.algorithms = forge2.md.algorithms || {};
        return md;
      }
      var hasRequiredHmac;
      function requireHmac() {
        if (hasRequiredHmac) return hmac.exports;
        hasRequiredHmac = 1;
        var forge2 = requireForge();
        requireMd();
        requireUtil();
        var hmac$1 = hmac.exports = forge2.hmac = forge2.hmac || {};
        hmac$1.create = function() {
          var _key = null;
          var _md = null;
          var _ipadding = null;
          var _opadding = null;
          var ctx = {};
          ctx.start = function(md2, key) {
            if (md2 !== null) {
              if (typeof md2 === "string") {
                md2 = md2.toLowerCase();
                if (md2 in forge2.md.algorithms) {
                  _md = forge2.md.algorithms[md2].create();
                } else {
                  throw new Error('Unknown hash algorithm "' + md2 + '"');
                }
              } else {
                _md = md2;
              }
            }
            if (key === null) {
              key = _key;
            } else {
              if (typeof key === "string") {
                key = forge2.util.createBuffer(key);
              } else if (forge2.util.isArray(key)) {
                var tmp = key;
                key = forge2.util.createBuffer();
                for (var i = 0; i < tmp.length; ++i) {
                  key.putByte(tmp[i]);
                }
              }
              var keylen = key.length();
              if (keylen > _md.blockLength) {
                _md.start();
                _md.update(key.bytes());
                key = _md.digest();
              }
              _ipadding = forge2.util.createBuffer();
              _opadding = forge2.util.createBuffer();
              keylen = key.length();
              for (var i = 0; i < keylen; ++i) {
                var tmp = key.at(i);
                _ipadding.putByte(54 ^ tmp);
                _opadding.putByte(92 ^ tmp);
              }
              if (keylen < _md.blockLength) {
                var tmp = _md.blockLength - keylen;
                for (var i = 0; i < tmp; ++i) {
                  _ipadding.putByte(54);
                  _opadding.putByte(92);
                }
              }
              _key = key;
              _ipadding = _ipadding.bytes();
              _opadding = _opadding.bytes();
            }
            _md.start();
            _md.update(_ipadding);
          };
          ctx.update = function(bytes) {
            _md.update(bytes);
          };
          ctx.getMac = function() {
            var inner = _md.digest().bytes();
            _md.start();
            _md.update(_opadding);
            _md.update(inner);
            return _md.digest();
          };
          ctx.digest = ctx.getMac;
          return ctx;
        };
        return hmac.exports;
      }
      var md5 = { exports: {} };
      var hasRequiredMd5;
      function requireMd5() {
        if (hasRequiredMd5) return md5.exports;
        hasRequiredMd5 = 1;
        var forge2 = requireForge();
        requireMd();
        requireUtil();
        var md5$12 = md5.exports = forge2.md5 = forge2.md5 || {};
        forge2.md.md5 = forge2.md.algorithms.md5 = md5$12;
        md5$12.create = function() {
          if (!_initialized) {
            _init();
          }
          var _state = null;
          var _input = forge2.util.createBuffer();
          var _w = new Array(16);
          var md2 = {
            algorithm: "md5",
            blockLength: 64,
            digestLength: 16,
            // 56-bit length of message so far (does not including padding)
            messageLength: 0,
            // true message length
            fullMessageLength: null,
            // size of message length in bytes
            messageLengthSize: 8
          };
          md2.start = function() {
            md2.messageLength = 0;
            md2.fullMessageLength = md2.messageLength64 = [];
            var int32s = md2.messageLengthSize / 4;
            for (var i = 0; i < int32s; ++i) {
              md2.fullMessageLength.push(0);
            }
            _input = forge2.util.createBuffer();
            _state = {
              h0: 1732584193,
              h1: 4023233417,
              h2: 2562383102,
              h3: 271733878
            };
            return md2;
          };
          md2.start();
          md2.update = function(msg, encoding) {
            if (encoding === "utf8") {
              msg = forge2.util.encodeUtf8(msg);
            }
            var len = msg.length;
            md2.messageLength += len;
            len = [len / 4294967296 >>> 0, len >>> 0];
            for (var i = md2.fullMessageLength.length - 1; i >= 0; --i) {
              md2.fullMessageLength[i] += len[1];
              len[1] = len[0] + (md2.fullMessageLength[i] / 4294967296 >>> 0);
              md2.fullMessageLength[i] = md2.fullMessageLength[i] >>> 0;
              len[0] = len[1] / 4294967296 >>> 0;
            }
            _input.putBytes(msg);
            _update(_state, _w, _input);
            if (_input.read > 2048 || _input.length() === 0) {
              _input.compact();
            }
            return md2;
          };
          md2.digest = function() {
            var finalBlock = forge2.util.createBuffer();
            finalBlock.putBytes(_input.bytes());
            var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
            var overflow = remaining & md2.blockLength - 1;
            finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
            var bits2, carry = 0;
            for (var i = md2.fullMessageLength.length - 1; i >= 0; --i) {
              bits2 = md2.fullMessageLength[i] * 8 + carry;
              carry = bits2 / 4294967296 >>> 0;
              finalBlock.putInt32Le(bits2 >>> 0);
            }
            var s2 = {
              h0: _state.h0,
              h1: _state.h1,
              h2: _state.h2,
              h3: _state.h3
            };
            _update(s2, _w, finalBlock);
            var rval = forge2.util.createBuffer();
            rval.putInt32Le(s2.h0);
            rval.putInt32Le(s2.h1);
            rval.putInt32Le(s2.h2);
            rval.putInt32Le(s2.h3);
            return rval;
          };
          return md2;
        };
        var _padding = null;
        var _g = null;
        var _r = null;
        var _k = null;
        var _initialized = false;
        function _init() {
          _padding = String.fromCharCode(128);
          _padding += forge2.util.fillString(String.fromCharCode(0), 64);
          _g = [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            1,
            6,
            11,
            0,
            5,
            10,
            15,
            4,
            9,
            14,
            3,
            8,
            13,
            2,
            7,
            12,
            5,
            8,
            11,
            14,
            1,
            4,
            7,
            10,
            13,
            0,
            3,
            6,
            9,
            12,
            15,
            2,
            0,
            7,
            14,
            5,
            12,
            3,
            10,
            1,
            8,
            15,
            6,
            13,
            4,
            11,
            2,
            9
          ];
          _r = [
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21
          ];
          _k = new Array(64);
          for (var i = 0; i < 64; ++i) {
            _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 4294967296);
          }
          _initialized = true;
        }
        function _update(s, w, bytes) {
          var t, a, b, c, d, f, r, i;
          var len = bytes.length();
          while (len >= 64) {
            a = s.h0;
            b = s.h1;
            c = s.h2;
            d = s.h3;
            for (i = 0; i < 16; ++i) {
              w[i] = bytes.getInt32Le();
              f = d ^ b & (c ^ d);
              t = a + f + _k[i] + w[i];
              r = _r[i];
              a = d;
              d = c;
              c = b;
              b += t << r | t >>> 32 - r;
            }
            for (; i < 32; ++i) {
              f = c ^ d & (b ^ c);
              t = a + f + _k[i] + w[_g[i]];
              r = _r[i];
              a = d;
              d = c;
              c = b;
              b += t << r | t >>> 32 - r;
            }
            for (; i < 48; ++i) {
              f = b ^ c ^ d;
              t = a + f + _k[i] + w[_g[i]];
              r = _r[i];
              a = d;
              d = c;
              c = b;
              b += t << r | t >>> 32 - r;
            }
            for (; i < 64; ++i) {
              f = c ^ (b | ~d);
              t = a + f + _k[i] + w[_g[i]];
              r = _r[i];
              a = d;
              d = c;
              c = b;
              b += t << r | t >>> 32 - r;
            }
            s.h0 = s.h0 + a | 0;
            s.h1 = s.h1 + b | 0;
            s.h2 = s.h2 + c | 0;
            s.h3 = s.h3 + d | 0;
            len -= 64;
          }
        }
        return md5.exports;
      }
      var pem = { exports: {} };
      var hasRequiredPem;
      function requirePem() {
        if (hasRequiredPem) return pem.exports;
        hasRequiredPem = 1;
        var forge2 = requireForge();
        requireUtil();
        var pem$1 = pem.exports = forge2.pem = forge2.pem || {};
        pem$1.encode = function(msg, options) {
          options = options || {};
          var rval = "-----BEGIN " + msg.type + "-----\r\n";
          var header;
          if (msg.procType) {
            header = {
              name: "Proc-Type",
              values: [String(msg.procType.version), msg.procType.type]
            };
            rval += foldHeader(header);
          }
          if (msg.contentDomain) {
            header = { name: "Content-Domain", values: [msg.contentDomain] };
            rval += foldHeader(header);
          }
          if (msg.dekInfo) {
            header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
            if (msg.dekInfo.parameters) {
              header.values.push(msg.dekInfo.parameters);
            }
            rval += foldHeader(header);
          }
          if (msg.headers) {
            for (var i = 0; i < msg.headers.length; ++i) {
              rval += foldHeader(msg.headers[i]);
            }
          }
          if (msg.procType) {
            rval += "\r\n";
          }
          rval += forge2.util.encode64(msg.body, options.maxline || 64) + "\r\n";
          rval += "-----END " + msg.type + "-----\r\n";
          return rval;
        };
        pem$1.decode = function(str) {
          var rval = [];
          var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
          var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
          var rCRLF = /\r?\n/;
          var match;
          while (true) {
            match = rMessage.exec(str);
            if (!match) {
              break;
            }
            var type = match[1];
            if (type === "NEW CERTIFICATE REQUEST") {
              type = "CERTIFICATE REQUEST";
            }
            var msg = {
              type,
              procType: null,
              contentDomain: null,
              dekInfo: null,
              headers: [],
              body: forge2.util.decode64(match[3])
            };
            rval.push(msg);
            if (!match[2]) {
              continue;
            }
            var lines = match[2].split(rCRLF);
            var li = 0;
            while (match && li < lines.length) {
              var line = lines[li].replace(/\s+$/, "");
              for (var nl = li + 1; nl < lines.length; ++nl) {
                var next = lines[nl];
                if (!/\s/.test(next[0])) {
                  break;
                }
                line += next;
                li = nl;
              }
              match = line.match(rHeader);
              if (match) {
                var header = { name: match[1], values: [] };
                var values = match[2].split(",");
                for (var vi = 0; vi < values.length; ++vi) {
                  header.values.push(ltrim(values[vi]));
                }
                if (!msg.procType) {
                  if (header.name !== "Proc-Type") {
                    throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
                  } else if (header.values.length !== 2) {
                    throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
                  }
                  msg.procType = { version: values[0], type: values[1] };
                } else if (!msg.contentDomain && header.name === "Content-Domain") {
                  msg.contentDomain = values[0] || "";
                } else if (!msg.dekInfo && header.name === "DEK-Info") {
                  if (header.values.length === 0) {
                    throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
                  }
                  msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
                } else {
                  msg.headers.push(header);
                }
              }
              ++li;
            }
            if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
              throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
            }
          }
          if (rval.length === 0) {
            throw new Error("Invalid PEM formatted message.");
          }
          return rval;
        };
        function foldHeader(header) {
          var rval = header.name + ": ";
          var values = [];
          var insertSpace = function(match, $1) {
            return " " + $1;
          };
          for (var i = 0; i < header.values.length; ++i) {
            values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
          }
          rval += values.join(",") + "\r\n";
          var length = 0;
          var candidate = -1;
          for (var i = 0; i < rval.length; ++i, ++length) {
            if (length > 65 && candidate !== -1) {
              var insert = rval[candidate];
              if (insert === ",") {
                ++candidate;
                rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
              } else {
                rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
              }
              length = i - candidate - 1;
              candidate = -1;
              ++i;
            } else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") {
              candidate = i;
            }
          }
          return rval;
        }
        function ltrim(str) {
          return str.replace(/^\s+/, "");
        }
        return pem.exports;
      }
      var pki = { exports: {} };
      var des;
      var hasRequiredDes;
      function requireDes() {
        if (hasRequiredDes) return des;
        hasRequiredDes = 1;
        var forge2 = requireForge();
        requireCipher();
        requireCipherModes();
        requireUtil();
        des = forge2.des = forge2.des || {};
        forge2.des.startEncrypting = function(key, iv, output, mode) {
          var cipher2 = _createCipher({
            key,
            output,
            decrypt: false,
            mode: mode || (iv === null ? "ECB" : "CBC")
          });
          cipher2.start(iv);
          return cipher2;
        };
        forge2.des.createEncryptionCipher = function(key, mode) {
          return _createCipher({
            key,
            output: null,
            decrypt: false,
            mode
          });
        };
        forge2.des.startDecrypting = function(key, iv, output, mode) {
          var cipher2 = _createCipher({
            key,
            output,
            decrypt: true,
            mode: mode || (iv === null ? "ECB" : "CBC")
          });
          cipher2.start(iv);
          return cipher2;
        };
        forge2.des.createDecryptionCipher = function(key, mode) {
          return _createCipher({
            key,
            output: null,
            decrypt: true,
            mode
          });
        };
        forge2.des.Algorithm = function(name2, mode) {
          var self2 = this;
          self2.name = name2;
          self2.mode = new mode({
            blockSize: 8,
            cipher: {
              encrypt: function(inBlock, outBlock) {
                return _updateBlock(self2._keys, inBlock, outBlock, false);
              },
              decrypt: function(inBlock, outBlock) {
                return _updateBlock(self2._keys, inBlock, outBlock, true);
              }
            }
          });
          self2._init = false;
        };
        forge2.des.Algorithm.prototype.initialize = function(options) {
          if (this._init) {
            return;
          }
          var key = forge2.util.createBuffer(options.key);
          if (this.name.indexOf("3DES") === 0) {
            if (key.length() !== 24) {
              throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
            }
          }
          this._keys = _createKeys(key);
          this._init = true;
        };
        registerAlgorithm("DES-ECB", forge2.cipher.modes.ecb);
        registerAlgorithm("DES-CBC", forge2.cipher.modes.cbc);
        registerAlgorithm("DES-CFB", forge2.cipher.modes.cfb);
        registerAlgorithm("DES-OFB", forge2.cipher.modes.ofb);
        registerAlgorithm("DES-CTR", forge2.cipher.modes.ctr);
        registerAlgorithm("3DES-ECB", forge2.cipher.modes.ecb);
        registerAlgorithm("3DES-CBC", forge2.cipher.modes.cbc);
        registerAlgorithm("3DES-CFB", forge2.cipher.modes.cfb);
        registerAlgorithm("3DES-OFB", forge2.cipher.modes.ofb);
        registerAlgorithm("3DES-CTR", forge2.cipher.modes.ctr);
        function registerAlgorithm(name2, mode) {
          var factory = function() {
            return new forge2.des.Algorithm(name2, mode);
          };
          forge2.cipher.registerAlgorithm(name2, factory);
        }
        var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
        var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
        var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
        var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
        var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
        var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
        var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
        var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
        function _createKeys(key) {
          var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
          var iterations = key.length() > 8 ? 3 : 1;
          var keys = [];
          var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
          var n = 0, tmp;
          for (var j = 0; j < iterations; j++) {
            var left = key.getInt32();
            var right = key.getInt32();
            tmp = (left >>> 4 ^ right) & 252645135;
            right ^= tmp;
            left ^= tmp << 4;
            tmp = (right >>> -16 ^ left) & 65535;
            left ^= tmp;
            right ^= tmp << -16;
            tmp = (left >>> 2 ^ right) & 858993459;
            right ^= tmp;
            left ^= tmp << 2;
            tmp = (right >>> -16 ^ left) & 65535;
            left ^= tmp;
            right ^= tmp << -16;
            tmp = (left >>> 1 ^ right) & 1431655765;
            right ^= tmp;
            left ^= tmp << 1;
            tmp = (right >>> 8 ^ left) & 16711935;
            left ^= tmp;
            right ^= tmp << 8;
            tmp = (left >>> 1 ^ right) & 1431655765;
            right ^= tmp;
            left ^= tmp << 1;
            tmp = left << 8 | right >>> 20 & 240;
            left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
            right = tmp;
            for (var i = 0; i < shifts.length; ++i) {
              if (shifts[i]) {
                left = left << 2 | left >>> 26;
                right = right << 2 | right >>> 26;
              } else {
                left = left << 1 | left >>> 27;
                right = right << 1 | right >>> 27;
              }
              left &= -15;
              right &= -15;
              var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
              var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
              tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
              keys[n++] = lefttmp ^ tmp;
              keys[n++] = righttmp ^ tmp << 16;
            }
          }
          return keys;
        }
        function _updateBlock(keys, input, output, decrypt) {
          var iterations = keys.length === 32 ? 3 : 9;
          var looping;
          if (iterations === 3) {
            looping = decrypt ? [30, -2, -2] : [0, 32, 2];
          } else {
            looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
          }
          var tmp;
          var left = input[0];
          var right = input[1];
          tmp = (left >>> 4 ^ right) & 252645135;
          right ^= tmp;
          left ^= tmp << 4;
          tmp = (left >>> 16 ^ right) & 65535;
          right ^= tmp;
          left ^= tmp << 16;
          tmp = (right >>> 2 ^ left) & 858993459;
          left ^= tmp;
          right ^= tmp << 2;
          tmp = (right >>> 8 ^ left) & 16711935;
          left ^= tmp;
          right ^= tmp << 8;
          tmp = (left >>> 1 ^ right) & 1431655765;
          right ^= tmp;
          left ^= tmp << 1;
          left = left << 1 | left >>> 31;
          right = right << 1 | right >>> 31;
          for (var j = 0; j < iterations; j += 3) {
            var endloop = looping[j + 1];
            var loopinc = looping[j + 2];
            for (var i = looping[j]; i != endloop; i += loopinc) {
              var right1 = right ^ keys[i];
              var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];
              tmp = left;
              left = right;
              right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
            }
            tmp = left;
            left = right;
            right = tmp;
          }
          left = left >>> 1 | left << 31;
          right = right >>> 1 | right << 31;
          tmp = (left >>> 1 ^ right) & 1431655765;
          right ^= tmp;
          left ^= tmp << 1;
          tmp = (right >>> 8 ^ left) & 16711935;
          left ^= tmp;
          right ^= tmp << 8;
          tmp = (right >>> 2 ^ left) & 858993459;
          left ^= tmp;
          right ^= tmp << 2;
          tmp = (left >>> 16 ^ right) & 65535;
          right ^= tmp;
          left ^= tmp << 16;
          tmp = (left >>> 4 ^ right) & 252645135;
          right ^= tmp;
          left ^= tmp << 4;
          output[0] = left;
          output[1] = right;
        }
        function _createCipher(options) {
          options = options || {};
          var mode = (options.mode || "CBC").toUpperCase();
          var algorithm = "DES-" + mode;
          var cipher2;
          if (options.decrypt) {
            cipher2 = forge2.cipher.createDecipher(algorithm, options.key);
          } else {
            cipher2 = forge2.cipher.createCipher(algorithm, options.key);
          }
          var start = cipher2.start;
          cipher2.start = function(iv, options2) {
            var output = null;
            if (options2 instanceof forge2.util.ByteBuffer) {
              output = options2;
              options2 = {};
            }
            options2 = options2 || {};
            options2.output = output;
            options2.iv = iv;
            start.call(cipher2, options2);
          };
          return cipher2;
        }
        return des;
      }
      const __viteBrowserExternal = {};
      const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        default: __viteBrowserExternal
      }, Symbol.toStringTag, { value: "Module" }));
      const require$$8 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
      var pbkdf2;
      var hasRequiredPbkdf2;
      function requirePbkdf2() {
        if (hasRequiredPbkdf2) return pbkdf2;
        hasRequiredPbkdf2 = 1;
        var forge2 = requireForge();
        requireHmac();
        requireMd();
        requireUtil();
        var pkcs5 = forge2.pkcs5 = forge2.pkcs5 || {};
        var crypto2;
        if (forge2.util.isNodejs && !forge2.options.usePureJavaScript) {
          crypto2 = require$$8;
        }
        pbkdf2 = forge2.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md2, callback) {
          if (typeof md2 === "function") {
            callback = md2;
            md2 = null;
          }
          if (forge2.util.isNodejs && !forge2.options.usePureJavaScript && crypto2.pbkdf2 && (md2 === null || typeof md2 !== "object") && (crypto2.pbkdf2Sync.length > 4 || (!md2 || md2 === "sha1"))) {
            if (typeof md2 !== "string") {
              md2 = "sha1";
            }
            p = Buffer.from(p, "binary");
            s = Buffer.from(s, "binary");
            if (!callback) {
              if (crypto2.pbkdf2Sync.length === 4) {
                return crypto2.pbkdf2Sync(p, s, c, dkLen).toString("binary");
              }
              return crypto2.pbkdf2Sync(p, s, c, dkLen, md2).toString("binary");
            }
            if (crypto2.pbkdf2Sync.length === 4) {
              return crypto2.pbkdf2(p, s, c, dkLen, function(err3, key) {
                if (err3) {
                  return callback(err3);
                }
                callback(null, key.toString("binary"));
              });
            }
            return crypto2.pbkdf2(p, s, c, dkLen, md2, function(err3, key) {
              if (err3) {
                return callback(err3);
              }
              callback(null, key.toString("binary"));
            });
          }
          if (typeof md2 === "undefined" || md2 === null) {
            md2 = "sha1";
          }
          if (typeof md2 === "string") {
            if (!(md2 in forge2.md.algorithms)) {
              throw new Error("Unknown hash algorithm: " + md2);
            }
            md2 = forge2.md[md2].create();
          }
          var hLen = md2.digestLength;
          if (dkLen > 4294967295 * hLen) {
            var err2 = new Error("Derived key is too long.");
            if (callback) {
              return callback(err2);
            }
            throw err2;
          }
          var len = Math.ceil(dkLen / hLen);
          var r = dkLen - (len - 1) * hLen;
          var prf = forge2.hmac.create();
          prf.start(md2, p);
          var dk = "";
          var xor, u_c, u_c1;
          if (!callback) {
            for (var i = 1; i <= len; ++i) {
              prf.start(null, null);
              prf.update(s);
              prf.update(forge2.util.int32ToBytes(i));
              xor = u_c1 = prf.digest().getBytes();
              for (var j = 2; j <= c; ++j) {
                prf.start(null, null);
                prf.update(u_c1);
                u_c = prf.digest().getBytes();
                xor = forge2.util.xorBytes(xor, u_c, hLen);
                u_c1 = u_c;
              }
              dk += i < len ? xor : xor.substr(0, r);
            }
            return dk;
          }
          var i = 1, j;
          function outer() {
            if (i > len) {
              return callback(null, dk);
            }
            prf.start(null, null);
            prf.update(s);
            prf.update(forge2.util.int32ToBytes(i));
            xor = u_c1 = prf.digest().getBytes();
            j = 2;
            inner();
          }
          function inner() {
            if (j <= c) {
              prf.start(null, null);
              prf.update(u_c1);
              u_c = prf.digest().getBytes();
              xor = forge2.util.xorBytes(xor, u_c, hLen);
              u_c1 = u_c;
              ++j;
              return forge2.util.setImmediate(inner);
            }
            dk += i < len ? xor : xor.substr(0, r);
            ++i;
            outer();
          }
          outer();
        };
        return pbkdf2;
      }
      var random = { exports: {} };
      var sha256 = { exports: {} };
      var hasRequiredSha256;
      function requireSha256() {
        if (hasRequiredSha256) return sha256.exports;
        hasRequiredSha256 = 1;
        var forge2 = requireForge();
        requireMd();
        requireUtil();
        var sha256$1 = sha256.exports = forge2.sha256 = forge2.sha256 || {};
        forge2.md.sha256 = forge2.md.algorithms.sha256 = sha256$1;
        sha256$1.create = function() {
          if (!_initialized) {
            _init();
          }
          var _state = null;
          var _input = forge2.util.createBuffer();
          var _w = new Array(64);
          var md2 = {
            algorithm: "sha256",
            blockLength: 64,
            digestLength: 32,
            // 56-bit length of message so far (does not including padding)
            messageLength: 0,
            // true message length
            fullMessageLength: null,
            // size of message length in bytes
            messageLengthSize: 8
          };
          md2.start = function() {
            md2.messageLength = 0;
            md2.fullMessageLength = md2.messageLength64 = [];
            var int32s = md2.messageLengthSize / 4;
            for (var i = 0; i < int32s; ++i) {
              md2.fullMessageLength.push(0);
            }
            _input = forge2.util.createBuffer();
            _state = {
              h0: 1779033703,
              h1: 3144134277,
              h2: 1013904242,
              h3: 2773480762,
              h4: 1359893119,
              h5: 2600822924,
              h6: 528734635,
              h7: 1541459225
            };
            return md2;
          };
          md2.start();
          md2.update = function(msg, encoding) {
            if (encoding === "utf8") {
              msg = forge2.util.encodeUtf8(msg);
            }
            var len = msg.length;
            md2.messageLength += len;
            len = [len / 4294967296 >>> 0, len >>> 0];
            for (var i = md2.fullMessageLength.length - 1; i >= 0; --i) {
              md2.fullMessageLength[i] += len[1];
              len[1] = len[0] + (md2.fullMessageLength[i] / 4294967296 >>> 0);
              md2.fullMessageLength[i] = md2.fullMessageLength[i] >>> 0;
              len[0] = len[1] / 4294967296 >>> 0;
            }
            _input.putBytes(msg);
            _update(_state, _w, _input);
            if (_input.read > 2048 || _input.length() === 0) {
              _input.compact();
            }
            return md2;
          };
          md2.digest = function() {
            var finalBlock = forge2.util.createBuffer();
            finalBlock.putBytes(_input.bytes());
            var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
            var overflow = remaining & md2.blockLength - 1;
            finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
            var next, carry;
            var bits2 = md2.fullMessageLength[0] * 8;
            for (var i = 0; i < md2.fullMessageLength.length - 1; ++i) {
              next = md2.fullMessageLength[i + 1] * 8;
              carry = next / 4294967296 >>> 0;
              bits2 += carry;
              finalBlock.putInt32(bits2 >>> 0);
              bits2 = next >>> 0;
            }
            finalBlock.putInt32(bits2);
            var s2 = {
              h0: _state.h0,
              h1: _state.h1,
              h2: _state.h2,
              h3: _state.h3,
              h4: _state.h4,
              h5: _state.h5,
              h6: _state.h6,
              h7: _state.h7
            };
            _update(s2, _w, finalBlock);
            var rval = forge2.util.createBuffer();
            rval.putInt32(s2.h0);
            rval.putInt32(s2.h1);
            rval.putInt32(s2.h2);
            rval.putInt32(s2.h3);
            rval.putInt32(s2.h4);
            rval.putInt32(s2.h5);
            rval.putInt32(s2.h6);
            rval.putInt32(s2.h7);
            return rval;
          };
          return md2;
        };
        var _padding = null;
        var _initialized = false;
        var _k = null;
        function _init() {
          _padding = String.fromCharCode(128);
          _padding += forge2.util.fillString(String.fromCharCode(0), 64);
          _k = [
            1116352408,
            1899447441,
            3049323471,
            3921009573,
            961987163,
            1508970993,
            2453635748,
            2870763221,
            3624381080,
            310598401,
            607225278,
            1426881987,
            1925078388,
            2162078206,
            2614888103,
            3248222580,
            3835390401,
            4022224774,
            264347078,
            604807628,
            770255983,
            1249150122,
            1555081692,
            1996064986,
            2554220882,
            2821834349,
            2952996808,
            3210313671,
            3336571891,
            3584528711,
            113926993,
            338241895,
            666307205,
            773529912,
            1294757372,
            1396182291,
            1695183700,
            1986661051,
            2177026350,
            2456956037,
            2730485921,
            2820302411,
            3259730800,
            3345764771,
            3516065817,
            3600352804,
            4094571909,
            275423344,
            430227734,
            506948616,
            659060556,
            883997877,
            958139571,
            1322822218,
            1537002063,
            1747873779,
            1955562222,
            2024104815,
            2227730452,
            2361852424,
            2428436474,
            2756734187,
            3204031479,
            3329325298
          ];
          _initialized = true;
        }
        function _update(s, w, bytes) {
          var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
          var len = bytes.length();
          while (len >= 64) {
            for (i = 0; i < 16; ++i) {
              w[i] = bytes.getInt32();
            }
            for (; i < 64; ++i) {
              t1 = w[i - 2];
              t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
              t2 = w[i - 15];
              t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
              w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
            }
            a = s.h0;
            b = s.h1;
            c = s.h2;
            d = s.h3;
            e = s.h4;
            f = s.h5;
            g = s.h6;
            h = s.h7;
            for (i = 0; i < 64; ++i) {
              s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
              ch = g ^ e & (f ^ g);
              s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
              maj = a & b | c & (a ^ b);
              t1 = h + s1 + ch + _k[i] + w[i];
              t2 = s0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 >>> 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 >>> 0;
            }
            s.h0 = s.h0 + a | 0;
            s.h1 = s.h1 + b | 0;
            s.h2 = s.h2 + c | 0;
            s.h3 = s.h3 + d | 0;
            s.h4 = s.h4 + e | 0;
            s.h5 = s.h5 + f | 0;
            s.h6 = s.h6 + g | 0;
            s.h7 = s.h7 + h | 0;
            len -= 64;
          }
        }
        return sha256.exports;
      }
      var prng = { exports: {} };
      var hasRequiredPrng;
      function requirePrng() {
        if (hasRequiredPrng) return prng.exports;
        hasRequiredPrng = 1;
        var forge2 = requireForge();
        requireUtil();
        var _crypto = null;
        if (forge2.util.isNodejs && !forge2.options.usePureJavaScript && !process.versions["node-webkit"]) {
          _crypto = require$$8;
        }
        var prng$1 = prng.exports = forge2.prng = forge2.prng || {};
        prng$1.create = function(plugin) {
          var ctx = {
            plugin,
            key: null,
            seed: null,
            time: null,
            // number of reseeds so far
            reseeds: 0,
            // amount of data generated so far
            generated: 0,
            // no initial key bytes
            keyBytes: ""
          };
          var md2 = plugin.md;
          var pools = new Array(32);
          for (var i = 0; i < 32; ++i) {
            pools[i] = md2.create();
          }
          ctx.pools = pools;
          ctx.pool = 0;
          ctx.generate = function(count, callback) {
            if (!callback) {
              return ctx.generateSync(count);
            }
            var cipher2 = ctx.plugin.cipher;
            var increment = ctx.plugin.increment;
            var formatKey = ctx.plugin.formatKey;
            var formatSeed = ctx.plugin.formatSeed;
            var b = forge2.util.createBuffer();
            ctx.key = null;
            generate();
            function generate(err2) {
              if (err2) {
                return callback(err2);
              }
              if (b.length() >= count) {
                return callback(null, b.getBytes(count));
              }
              if (ctx.generated > 1048575) {
                ctx.key = null;
              }
              if (ctx.key === null) {
                return forge2.util.nextTick(function() {
                  _reseed(generate);
                });
              }
              var bytes = cipher2(ctx.key, ctx.seed);
              ctx.generated += bytes.length;
              b.putBytes(bytes);
              ctx.key = formatKey(cipher2(ctx.key, increment(ctx.seed)));
              ctx.seed = formatSeed(cipher2(ctx.key, ctx.seed));
              forge2.util.setImmediate(generate);
            }
          };
          ctx.generateSync = function(count) {
            var cipher2 = ctx.plugin.cipher;
            var increment = ctx.plugin.increment;
            var formatKey = ctx.plugin.formatKey;
            var formatSeed = ctx.plugin.formatSeed;
            ctx.key = null;
            var b = forge2.util.createBuffer();
            while (b.length() < count) {
              if (ctx.generated > 1048575) {
                ctx.key = null;
              }
              if (ctx.key === null) {
                _reseedSync();
              }
              var bytes = cipher2(ctx.key, ctx.seed);
              ctx.generated += bytes.length;
              b.putBytes(bytes);
              ctx.key = formatKey(cipher2(ctx.key, increment(ctx.seed)));
              ctx.seed = formatSeed(cipher2(ctx.key, ctx.seed));
            }
            return b.getBytes(count);
          };
          function _reseed(callback) {
            if (ctx.pools[0].messageLength >= 32) {
              _seed();
              return callback();
            }
            var needed = 32 - ctx.pools[0].messageLength << 5;
            ctx.seedFile(needed, function(err2, bytes) {
              if (err2) {
                return callback(err2);
              }
              ctx.collect(bytes);
              _seed();
              callback();
            });
          }
          function _reseedSync() {
            if (ctx.pools[0].messageLength >= 32) {
              return _seed();
            }
            var needed = 32 - ctx.pools[0].messageLength << 5;
            ctx.collect(ctx.seedFileSync(needed));
            _seed();
          }
          function _seed() {
            ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
            var md3 = ctx.plugin.md.create();
            md3.update(ctx.keyBytes);
            var _2powK = 1;
            for (var k = 0; k < 32; ++k) {
              if (ctx.reseeds % _2powK === 0) {
                md3.update(ctx.pools[k].digest().getBytes());
                ctx.pools[k].start();
              }
              _2powK = _2powK << 1;
            }
            ctx.keyBytes = md3.digest().getBytes();
            md3.start();
            md3.update(ctx.keyBytes);
            var seedBytes = md3.digest().getBytes();
            ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
            ctx.seed = ctx.plugin.formatSeed(seedBytes);
            ctx.generated = 0;
          }
          function defaultSeedFile(needed) {
            var getRandomValues = null;
            var globalScope = forge2.util.globalScope;
            var _crypto2 = globalScope.crypto || globalScope.msCrypto;
            if (_crypto2 && _crypto2.getRandomValues) {
              getRandomValues = function(arr) {
                return _crypto2.getRandomValues(arr);
              };
            }
            var b = forge2.util.createBuffer();
            if (getRandomValues) {
              while (b.length() < needed) {
                var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
                var entropy = new Uint32Array(Math.floor(count));
                try {
                  getRandomValues(entropy);
                  for (var i2 = 0; i2 < entropy.length; ++i2) {
                    b.putInt32(entropy[i2]);
                  }
                } catch (e) {
                  if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
                    throw e;
                  }
                }
              }
            }
            if (b.length() < needed) {
              var hi, lo, next;
              var seed = Math.floor(Math.random() * 65536);
              while (b.length() < needed) {
                lo = 16807 * (seed & 65535);
                hi = 16807 * (seed >> 16);
                lo += (hi & 32767) << 16;
                lo += hi >> 15;
                lo = (lo & 2147483647) + (lo >> 31);
                seed = lo & 4294967295;
                for (var i2 = 0; i2 < 3; ++i2) {
                  next = seed >>> (i2 << 3);
                  next ^= Math.floor(Math.random() * 256);
                  b.putByte(next & 255);
                }
              }
            }
            return b.getBytes(needed);
          }
          if (_crypto) {
            ctx.seedFile = function(needed, callback) {
              _crypto.randomBytes(needed, function(err2, bytes) {
                if (err2) {
                  return callback(err2);
                }
                callback(null, bytes.toString());
              });
            };
            ctx.seedFileSync = function(needed) {
              return _crypto.randomBytes(needed).toString();
            };
          } else {
            ctx.seedFile = function(needed, callback) {
              try {
                callback(null, defaultSeedFile(needed));
              } catch (e) {
                callback(e);
              }
            };
            ctx.seedFileSync = defaultSeedFile;
          }
          ctx.collect = function(bytes) {
            var count = bytes.length;
            for (var i2 = 0; i2 < count; ++i2) {
              ctx.pools[ctx.pool].update(bytes.substr(i2, 1));
              ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
            }
          };
          ctx.collectInt = function(i2, n) {
            var bytes = "";
            for (var x = 0; x < n; x += 8) {
              bytes += String.fromCharCode(i2 >> x & 255);
            }
            ctx.collect(bytes);
          };
          ctx.registerWorker = function(worker) {
            if (worker === self) {
              ctx.seedFile = function(needed, callback) {
                function listener2(e) {
                  var data = e.data;
                  if (data.forge && data.forge.prng) {
                    self.removeEventListener("message", listener2);
                    callback(data.forge.prng.err, data.forge.prng.bytes);
                  }
                }
                self.addEventListener("message", listener2);
                self.postMessage({ forge: { prng: { needed } } });
              };
            } else {
              var listener = function(e) {
                var data = e.data;
                if (data.forge && data.forge.prng) {
                  ctx.seedFile(data.forge.prng.needed, function(err2, bytes) {
                    worker.postMessage({ forge: { prng: { err: err2, bytes } } });
                  });
                }
              };
              worker.addEventListener("message", listener);
            }
          };
          return ctx;
        };
        return prng.exports;
      }
      var hasRequiredRandom;
      function requireRandom() {
        if (hasRequiredRandom) return random.exports;
        hasRequiredRandom = 1;
        var forge2 = requireForge();
        requireAes();
        requireSha256();
        requirePrng();
        requireUtil();
        (function() {
          if (forge2.random && forge2.random.getBytes) {
            random.exports = forge2.random;
            return;
          }
          (function(jQuery2) {
            var prng_aes = {};
            var _prng_aes_output = new Array(4);
            var _prng_aes_buffer = forge2.util.createBuffer();
            prng_aes.formatKey = function(key2) {
              var tmp = forge2.util.createBuffer(key2);
              key2 = new Array(4);
              key2[0] = tmp.getInt32();
              key2[1] = tmp.getInt32();
              key2[2] = tmp.getInt32();
              key2[3] = tmp.getInt32();
              return forge2.aes._expandKey(key2, false);
            };
            prng_aes.formatSeed = function(seed) {
              var tmp = forge2.util.createBuffer(seed);
              seed = new Array(4);
              seed[0] = tmp.getInt32();
              seed[1] = tmp.getInt32();
              seed[2] = tmp.getInt32();
              seed[3] = tmp.getInt32();
              return seed;
            };
            prng_aes.cipher = function(key2, seed) {
              forge2.aes._updateBlock(key2, seed, _prng_aes_output, false);
              _prng_aes_buffer.putInt32(_prng_aes_output[0]);
              _prng_aes_buffer.putInt32(_prng_aes_output[1]);
              _prng_aes_buffer.putInt32(_prng_aes_output[2]);
              _prng_aes_buffer.putInt32(_prng_aes_output[3]);
              return _prng_aes_buffer.getBytes();
            };
            prng_aes.increment = function(seed) {
              ++seed[3];
              return seed;
            };
            prng_aes.md = forge2.md.sha256;
            function spawnPrng() {
              var ctx = forge2.prng.create(prng_aes);
              ctx.getBytes = function(count, callback) {
                return ctx.generate(count, callback);
              };
              ctx.getBytesSync = function(count) {
                return ctx.generate(count);
              };
              return ctx;
            }
            var _ctx = spawnPrng();
            var getRandomValues = null;
            var globalScope = forge2.util.globalScope;
            var _crypto = globalScope.crypto || globalScope.msCrypto;
            if (_crypto && _crypto.getRandomValues) {
              getRandomValues = function(arr) {
                return _crypto.getRandomValues(arr);
              };
            }
            if (forge2.options.usePureJavaScript || !forge2.util.isNodejs && !getRandomValues) {
              _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
              if (typeof navigator !== "undefined") {
                var _navBytes = "";
                for (var key in navigator) {
                  try {
                    if (typeof navigator[key] == "string") {
                      _navBytes += navigator[key];
                    }
                  } catch (e) {
                  }
                }
                _ctx.collect(_navBytes);
                _navBytes = null;
              }
              if (jQuery2) {
                jQuery2().mousemove(function(e) {
                  _ctx.collectInt(e.clientX, 16);
                  _ctx.collectInt(e.clientY, 16);
                });
                jQuery2().keypress(function(e) {
                  _ctx.collectInt(e.charCode, 8);
                });
              }
            }
            if (!forge2.random) {
              forge2.random = _ctx;
            } else {
              for (var key in _ctx) {
                forge2.random[key] = _ctx[key];
              }
            }
            forge2.random.createInstance = spawnPrng;
            random.exports = forge2.random;
          })(typeof jQuery !== "undefined" ? jQuery : null);
        })();
        return random.exports;
      }
      var rc2;
      var hasRequiredRc2;
      function requireRc2() {
        if (hasRequiredRc2) return rc2;
        hasRequiredRc2 = 1;
        var forge2 = requireForge();
        requireUtil();
        var piTable = [
          217,
          120,
          249,
          196,
          25,
          221,
          181,
          237,
          40,
          233,
          253,
          121,
          74,
          160,
          216,
          157,
          198,
          126,
          55,
          131,
          43,
          118,
          83,
          142,
          98,
          76,
          100,
          136,
          68,
          139,
          251,
          162,
          23,
          154,
          89,
          245,
          135,
          179,
          79,
          19,
          97,
          69,
          109,
          141,
          9,
          129,
          125,
          50,
          189,
          143,
          64,
          235,
          134,
          183,
          123,
          11,
          240,
          149,
          33,
          34,
          92,
          107,
          78,
          130,
          84,
          214,
          101,
          147,
          206,
          96,
          178,
          28,
          115,
          86,
          192,
          20,
          167,
          140,
          241,
          220,
          18,
          117,
          202,
          31,
          59,
          190,
          228,
          209,
          66,
          61,
          212,
          48,
          163,
          60,
          182,
          38,
          111,
          191,
          14,
          218,
          70,
          105,
          7,
          87,
          39,
          242,
          29,
          155,
          188,
          148,
          67,
          3,
          248,
          17,
          199,
          246,
          144,
          239,
          62,
          231,
          6,
          195,
          213,
          47,
          200,
          102,
          30,
          215,
          8,
          232,
          234,
          222,
          128,
          82,
          238,
          247,
          132,
          170,
          114,
          172,
          53,
          77,
          106,
          42,
          150,
          26,
          210,
          113,
          90,
          21,
          73,
          116,
          75,
          159,
          208,
          94,
          4,
          24,
          164,
          236,
          194,
          224,
          65,
          110,
          15,
          81,
          203,
          204,
          36,
          145,
          175,
          80,
          161,
          244,
          112,
          57,
          153,
          124,
          58,
          133,
          35,
          184,
          180,
          122,
          252,
          2,
          54,
          91,
          37,
          85,
          151,
          49,
          45,
          93,
          250,
          152,
          227,
          138,
          146,
          174,
          5,
          223,
          41,
          16,
          103,
          108,
          186,
          201,
          211,
          0,
          230,
          207,
          225,
          158,
          168,
          44,
          99,
          22,
          1,
          63,
          88,
          226,
          137,
          169,
          13,
          56,
          52,
          27,
          171,
          51,
          255,
          176,
          187,
          72,
          12,
          95,
          185,
          177,
          205,
          46,
          197,
          243,
          219,
          71,
          229,
          165,
          156,
          119,
          10,
          166,
          32,
          104,
          254,
          127,
          193,
          173
        ];
        var s = [1, 2, 3, 5];
        var rol = function(word, bits2) {
          return word << bits2 & 65535 | (word & 65535) >> 16 - bits2;
        };
        var ror = function(word, bits2) {
          return (word & 65535) >> bits2 | word << 16 - bits2 & 65535;
        };
        rc2 = forge2.rc2 = forge2.rc2 || {};
        forge2.rc2.expandKey = function(key, effKeyBits) {
          if (typeof key === "string") {
            key = forge2.util.createBuffer(key);
          }
          effKeyBits = effKeyBits || 128;
          var L = key;
          var T = key.length();
          var T1 = effKeyBits;
          var T8 = Math.ceil(T1 / 8);
          var TM = 255 >> (T1 & 7);
          var i;
          for (i = T; i < 128; i++) {
            L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
          }
          L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
          for (i = 127 - T8; i >= 0; i--) {
            L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
          }
          return L;
        };
        var createCipher = function(key, bits2, encrypt) {
          var _finish = false, _input = null, _output = null, _iv = null;
          var mixRound, mashRound;
          var i, j, K = [];
          key = forge2.rc2.expandKey(key, bits2);
          for (i = 0; i < 64; i++) {
            K.push(key.getInt16Le());
          }
          if (encrypt) {
            mixRound = function(R) {
              for (i = 0; i < 4; i++) {
                R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
                R[i] = rol(R[i], s[i]);
                j++;
              }
            };
            mashRound = function(R) {
              for (i = 0; i < 4; i++) {
                R[i] += K[R[(i + 3) % 4] & 63];
              }
            };
          } else {
            mixRound = function(R) {
              for (i = 3; i >= 0; i--) {
                R[i] = ror(R[i], s[i]);
                R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
                j--;
              }
            };
            mashRound = function(R) {
              for (i = 3; i >= 0; i--) {
                R[i] -= K[R[(i + 3) % 4] & 63];
              }
            };
          }
          var runPlan = function(plan) {
            var R = [];
            for (i = 0; i < 4; i++) {
              var val = _input.getInt16Le();
              if (_iv !== null) {
                if (encrypt) {
                  val ^= _iv.getInt16Le();
                } else {
                  _iv.putInt16Le(val);
                }
              }
              R.push(val & 65535);
            }
            j = encrypt ? 0 : 63;
            for (var ptr = 0; ptr < plan.length; ptr++) {
              for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
                plan[ptr][1](R);
              }
            }
            for (i = 0; i < 4; i++) {
              if (_iv !== null) {
                if (encrypt) {
                  _iv.putInt16Le(R[i]);
                } else {
                  R[i] ^= _iv.getInt16Le();
                }
              }
              _output.putInt16Le(R[i]);
            }
          };
          var cipher2 = null;
          cipher2 = {
            /**
             * Starts or restarts the encryption or decryption process, whichever
             * was previously configured.
             *
             * To use the cipher in CBC mode, iv may be given either as a string
             * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
             *
             * @param iv the initialization vector to use, null for ECB mode.
             * @param output the output the buffer to write to, null to create one.
             */
            start: function(iv, output) {
              if (iv) {
                if (typeof iv === "string") {
                  iv = forge2.util.createBuffer(iv);
                }
              }
              _finish = false;
              _input = forge2.util.createBuffer();
              _output = output || new forge2.util.createBuffer();
              _iv = iv;
              cipher2.output = _output;
            },
            /**
             * Updates the next block.
             *
             * @param input the buffer to read from.
             */
            update: function(input) {
              if (!_finish) {
                _input.putBuffer(input);
              }
              while (_input.length() >= 8) {
                runPlan([
                  [5, mixRound],
                  [1, mashRound],
                  [6, mixRound],
                  [1, mashRound],
                  [5, mixRound]
                ]);
              }
            },
            /**
             * Finishes encrypting or decrypting.
             *
             * @param pad a padding function to use, null for PKCS#7 padding,
             *           signature(blockSize, buffer, decrypt).
             *
             * @return true if successful, false on error.
             */
            finish: function(pad) {
              var rval = true;
              if (encrypt) {
                if (pad) {
                  rval = pad(8, _input, !encrypt);
                } else {
                  var padding = _input.length() === 8 ? 8 : 8 - _input.length();
                  _input.fillWithByte(padding, padding);
                }
              }
              if (rval) {
                _finish = true;
                cipher2.update();
              }
              if (!encrypt) {
                rval = _input.length() === 0;
                if (rval) {
                  if (pad) {
                    rval = pad(8, _output, !encrypt);
                  } else {
                    var len = _output.length();
                    var count = _output.at(len - 1);
                    if (count > len) {
                      rval = false;
                    } else {
                      _output.truncate(count);
                    }
                  }
                }
              }
              return rval;
            }
          };
          return cipher2;
        };
        forge2.rc2.startEncrypting = function(key, iv, output) {
          var cipher2 = forge2.rc2.createEncryptionCipher(key, 128);
          cipher2.start(iv, output);
          return cipher2;
        };
        forge2.rc2.createEncryptionCipher = function(key, bits2) {
          return createCipher(key, bits2, true);
        };
        forge2.rc2.startDecrypting = function(key, iv, output) {
          var cipher2 = forge2.rc2.createDecryptionCipher(key, 128);
          cipher2.start(iv, output);
          return cipher2;
        };
        forge2.rc2.createDecryptionCipher = function(key, bits2) {
          return createCipher(key, bits2, false);
        };
        return rc2;
      }
      var jsbn;
      var hasRequiredJsbn;
      function requireJsbn() {
        if (hasRequiredJsbn) return jsbn;
        hasRequiredJsbn = 1;
        var forge2 = requireForge();
        jsbn = forge2.jsbn = forge2.jsbn || {};
        var dbits;
        function BigInteger(a, b, c) {
          this.data = [];
          if (a != null)
            if ("number" == typeof a) this.fromNumber(a, b, c);
            else if (b == null && "string" != typeof a) this.fromString(a, 256);
            else this.fromString(a, b);
        }
        forge2.jsbn.BigInteger = BigInteger;
        function nbi() {
          return new BigInteger(null);
        }
        function am1(i, x, w, j, c, n) {
          while (--n >= 0) {
            var v = x * this.data[i++] + w.data[j] + c;
            c = Math.floor(v / 67108864);
            w.data[j++] = v & 67108863;
          }
          return c;
        }
        function am2(i, x, w, j, c, n) {
          var xl = x & 32767, xh = x >> 15;
          while (--n >= 0) {
            var l = this.data[i] & 32767;
            var h = this.data[i++] >> 15;
            var m = xh * l + h * xl;
            l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
            c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
            w.data[j++] = l & 1073741823;
          }
          return c;
        }
        function am3(i, x, w, j, c, n) {
          var xl = x & 16383, xh = x >> 14;
          while (--n >= 0) {
            var l = this.data[i] & 16383;
            var h = this.data[i++] >> 14;
            var m = xh * l + h * xl;
            l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
            c = (l >> 28) + (m >> 14) + xh * h;
            w.data[j++] = l & 268435455;
          }
          return c;
        }
        if (typeof navigator === "undefined") {
          BigInteger.prototype.am = am3;
          dbits = 28;
        } else if (navigator.appName == "Microsoft Internet Explorer") {
          BigInteger.prototype.am = am2;
          dbits = 30;
        } else if (navigator.appName != "Netscape") {
          BigInteger.prototype.am = am1;
          dbits = 26;
        } else {
          BigInteger.prototype.am = am3;
          dbits = 28;
        }
        BigInteger.prototype.DB = dbits;
        BigInteger.prototype.DM = (1 << dbits) - 1;
        BigInteger.prototype.DV = 1 << dbits;
        var BI_FP = 52;
        BigInteger.prototype.FV = Math.pow(2, BI_FP);
        BigInteger.prototype.F1 = BI_FP - dbits;
        BigInteger.prototype.F2 = 2 * dbits - BI_FP;
        var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
        var BI_RC = new Array();
        var rr, vv;
        rr = "0".charCodeAt(0);
        for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
        rr = "a".charCodeAt(0);
        for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
        rr = "A".charCodeAt(0);
        for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
        function int2char(n) {
          return BI_RM.charAt(n);
        }
        function intAt(s, i) {
          var c = BI_RC[s.charCodeAt(i)];
          return c == null ? -1 : c;
        }
        function bnpCopyTo(r) {
          for (var i = this.t - 1; i >= 0; --i) r.data[i] = this.data[i];
          r.t = this.t;
          r.s = this.s;
        }
        function bnpFromInt(x) {
          this.t = 1;
          this.s = x < 0 ? -1 : 0;
          if (x > 0) this.data[0] = x;
          else if (x < -1) this.data[0] = x + this.DV;
          else this.t = 0;
        }
        function nbv(i) {
          var r = nbi();
          r.fromInt(i);
          return r;
        }
        function bnpFromString(s, b) {
          var k;
          if (b == 16) k = 4;
          else if (b == 8) k = 3;
          else if (b == 256) k = 8;
          else if (b == 2) k = 1;
          else if (b == 32) k = 5;
          else if (b == 4) k = 2;
          else {
            this.fromRadix(s, b);
            return;
          }
          this.t = 0;
          this.s = 0;
          var i = s.length, mi = false, sh = 0;
          while (--i >= 0) {
            var x = k == 8 ? s[i] & 255 : intAt(s, i);
            if (x < 0) {
              if (s.charAt(i) == "-") mi = true;
              continue;
            }
            mi = false;
            if (sh == 0)
              this.data[this.t++] = x;
            else if (sh + k > this.DB) {
              this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
              this.data[this.t++] = x >> this.DB - sh;
            } else
              this.data[this.t - 1] |= x << sh;
            sh += k;
            if (sh >= this.DB) sh -= this.DB;
          }
          if (k == 8 && (s[0] & 128) != 0) {
            this.s = -1;
            if (sh > 0) this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
          }
          this.clamp();
          if (mi) BigInteger.ZERO.subTo(this, this);
        }
        function bnpClamp() {
          var c = this.s & this.DM;
          while (this.t > 0 && this.data[this.t - 1] == c) --this.t;
        }
        function bnToString(b) {
          if (this.s < 0) return "-" + this.negate().toString(b);
          var k;
          if (b == 16) k = 4;
          else if (b == 8) k = 3;
          else if (b == 2) k = 1;
          else if (b == 32) k = 5;
          else if (b == 4) k = 2;
          else return this.toRadix(b);
          var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
          var p = this.DB - i * this.DB % k;
          if (i-- > 0) {
            if (p < this.DB && (d = this.data[i] >> p) > 0) {
              m = true;
              r = int2char(d);
            }
            while (i >= 0) {
              if (p < k) {
                d = (this.data[i] & (1 << p) - 1) << k - p;
                d |= this.data[--i] >> (p += this.DB - k);
              } else {
                d = this.data[i] >> (p -= k) & km;
                if (p <= 0) {
                  p += this.DB;
                  --i;
                }
              }
              if (d > 0) m = true;
              if (m) r += int2char(d);
            }
          }
          return m ? r : "0";
        }
        function bnNegate() {
          var r = nbi();
          BigInteger.ZERO.subTo(this, r);
          return r;
        }
        function bnAbs() {
          return this.s < 0 ? this.negate() : this;
        }
        function bnCompareTo(a) {
          var r = this.s - a.s;
          if (r != 0) return r;
          var i = this.t;
          r = i - a.t;
          if (r != 0) return this.s < 0 ? -r : r;
          while (--i >= 0) if ((r = this.data[i] - a.data[i]) != 0) return r;
          return 0;
        }
        function nbits(x) {
          var r = 1, t;
          if ((t = x >>> 16) != 0) {
            x = t;
            r += 16;
          }
          if ((t = x >> 8) != 0) {
            x = t;
            r += 8;
          }
          if ((t = x >> 4) != 0) {
            x = t;
            r += 4;
          }
          if ((t = x >> 2) != 0) {
            x = t;
            r += 2;
          }
          if ((t = x >> 1) != 0) {
            x = t;
            r += 1;
          }
          return r;
        }
        function bnBitLength() {
          if (this.t <= 0) return 0;
          return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
        }
        function bnpDLShiftTo(n, r) {
          var i;
          for (i = this.t - 1; i >= 0; --i) r.data[i + n] = this.data[i];
          for (i = n - 1; i >= 0; --i) r.data[i] = 0;
          r.t = this.t + n;
          r.s = this.s;
        }
        function bnpDRShiftTo(n, r) {
          for (var i = n; i < this.t; ++i) r.data[i - n] = this.data[i];
          r.t = Math.max(this.t - n, 0);
          r.s = this.s;
        }
        function bnpLShiftTo(n, r) {
          var bs = n % this.DB;
          var cbs = this.DB - bs;
          var bm = (1 << cbs) - 1;
          var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
          for (i = this.t - 1; i >= 0; --i) {
            r.data[i + ds + 1] = this.data[i] >> cbs | c;
            c = (this.data[i] & bm) << bs;
          }
          for (i = ds - 1; i >= 0; --i) r.data[i] = 0;
          r.data[ds] = c;
          r.t = this.t + ds + 1;
          r.s = this.s;
          r.clamp();
        }
        function bnpRShiftTo(n, r) {
          r.s = this.s;
          var ds = Math.floor(n / this.DB);
          if (ds >= this.t) {
            r.t = 0;
            return;
          }
          var bs = n % this.DB;
          var cbs = this.DB - bs;
          var bm = (1 << bs) - 1;
          r.data[0] = this.data[ds] >> bs;
          for (var i = ds + 1; i < this.t; ++i) {
            r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
            r.data[i - ds] = this.data[i] >> bs;
          }
          if (bs > 0) r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
          r.t = this.t - ds;
          r.clamp();
        }
        function bnpSubTo(a, r) {
          var i = 0, c = 0, m = Math.min(a.t, this.t);
          while (i < m) {
            c += this.data[i] - a.data[i];
            r.data[i++] = c & this.DM;
            c >>= this.DB;
          }
          if (a.t < this.t) {
            c -= a.s;
            while (i < this.t) {
              c += this.data[i];
              r.data[i++] = c & this.DM;
              c >>= this.DB;
            }
            c += this.s;
          } else {
            c += this.s;
            while (i < a.t) {
              c -= a.data[i];
              r.data[i++] = c & this.DM;
              c >>= this.DB;
            }
            c -= a.s;
          }
          r.s = c < 0 ? -1 : 0;
          if (c < -1) r.data[i++] = this.DV + c;
          else if (c > 0) r.data[i++] = c;
          r.t = i;
          r.clamp();
        }
        function bnpMultiplyTo(a, r) {
          var x = this.abs(), y = a.abs();
          var i = x.t;
          r.t = i + y.t;
          while (--i >= 0) r.data[i] = 0;
          for (i = 0; i < y.t; ++i) r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
          r.s = 0;
          r.clamp();
          if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
        }
        function bnpSquareTo(r) {
          var x = this.abs();
          var i = r.t = 2 * x.t;
          while (--i >= 0) r.data[i] = 0;
          for (i = 0; i < x.t - 1; ++i) {
            var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
            if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
              r.data[i + x.t] -= x.DV;
              r.data[i + x.t + 1] = 1;
            }
          }
          if (r.t > 0) r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
          r.s = 0;
          r.clamp();
        }
        function bnpDivRemTo(m, q, r) {
          var pm = m.abs();
          if (pm.t <= 0) return;
          var pt = this.abs();
          if (pt.t < pm.t) {
            if (q != null) q.fromInt(0);
            if (r != null) this.copyTo(r);
            return;
          }
          if (r == null) r = nbi();
          var y = nbi(), ts = this.s, ms2 = m.s;
          var nsh = this.DB - nbits(pm.data[pm.t - 1]);
          if (nsh > 0) {
            pm.lShiftTo(nsh, y);
            pt.lShiftTo(nsh, r);
          } else {
            pm.copyTo(y);
            pt.copyTo(r);
          }
          var ys = y.t;
          var y0 = y.data[ys - 1];
          if (y0 == 0) return;
          var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
          var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
          var i = r.t, j = i - ys, t = q == null ? nbi() : q;
          y.dlShiftTo(j, t);
          if (r.compareTo(t) >= 0) {
            r.data[r.t++] = 1;
            r.subTo(t, r);
          }
          BigInteger.ONE.dlShiftTo(ys, t);
          t.subTo(y, y);
          while (y.t < ys) y.data[y.t++] = 0;
          while (--j >= 0) {
            var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
            if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
              y.dlShiftTo(j, t);
              r.subTo(t, r);
              while (r.data[i] < --qd) r.subTo(t, r);
            }
          }
          if (q != null) {
            r.drShiftTo(ys, q);
            if (ts != ms2) BigInteger.ZERO.subTo(q, q);
          }
          r.t = ys;
          r.clamp();
          if (nsh > 0) r.rShiftTo(nsh, r);
          if (ts < 0) BigInteger.ZERO.subTo(r, r);
        }
        function bnMod(a) {
          var r = nbi();
          this.abs().divRemTo(a, null, r);
          if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
          return r;
        }
        function Classic(m) {
          this.m = m;
        }
        function cConvert(x) {
          if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
          else return x;
        }
        function cRevert(x) {
          return x;
        }
        function cReduce(x) {
          x.divRemTo(this.m, null, x);
        }
        function cMulTo(x, y, r) {
          x.multiplyTo(y, r);
          this.reduce(r);
        }
        function cSqrTo(x, r) {
          x.squareTo(r);
          this.reduce(r);
        }
        Classic.prototype.convert = cConvert;
        Classic.prototype.revert = cRevert;
        Classic.prototype.reduce = cReduce;
        Classic.prototype.mulTo = cMulTo;
        Classic.prototype.sqrTo = cSqrTo;
        function bnpInvDigit() {
          if (this.t < 1) return 0;
          var x = this.data[0];
          if ((x & 1) == 0) return 0;
          var y = x & 3;
          y = y * (2 - (x & 15) * y) & 15;
          y = y * (2 - (x & 255) * y) & 255;
          y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
          y = y * (2 - x * y % this.DV) % this.DV;
          return y > 0 ? this.DV - y : -y;
        }
        function Montgomery(m) {
          this.m = m;
          this.mp = m.invDigit();
          this.mpl = this.mp & 32767;
          this.mph = this.mp >> 15;
          this.um = (1 << m.DB - 15) - 1;
          this.mt2 = 2 * m.t;
        }
        function montConvert(x) {
          var r = nbi();
          x.abs().dlShiftTo(this.m.t, r);
          r.divRemTo(this.m, null, r);
          if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
          return r;
        }
        function montRevert(x) {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
        function montReduce(x) {
          while (x.t <= this.mt2)
            x.data[x.t++] = 0;
          for (var i = 0; i < this.m.t; ++i) {
            var j = x.data[i] & 32767;
            var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
            j = i + this.m.t;
            x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
            while (x.data[j] >= x.DV) {
              x.data[j] -= x.DV;
              x.data[++j]++;
            }
          }
          x.clamp();
          x.drShiftTo(this.m.t, x);
          if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
        }
        function montSqrTo(x, r) {
          x.squareTo(r);
          this.reduce(r);
        }
        function montMulTo(x, y, r) {
          x.multiplyTo(y, r);
          this.reduce(r);
        }
        Montgomery.prototype.convert = montConvert;
        Montgomery.prototype.revert = montRevert;
        Montgomery.prototype.reduce = montReduce;
        Montgomery.prototype.mulTo = montMulTo;
        Montgomery.prototype.sqrTo = montSqrTo;
        function bnpIsEven() {
          return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
        }
        function bnpExp(e, z) {
          if (e > 4294967295 || e < 1) return BigInteger.ONE;
          var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
          g.copyTo(r);
          while (--i >= 0) {
            z.sqrTo(r, r2);
            if ((e & 1 << i) > 0) z.mulTo(r2, g, r);
            else {
              var t = r;
              r = r2;
              r2 = t;
            }
          }
          return z.revert(r);
        }
        function bnModPowInt(e, m) {
          var z;
          if (e < 256 || m.isEven()) z = new Classic(m);
          else z = new Montgomery(m);
          return this.exp(e, z);
        }
        BigInteger.prototype.copyTo = bnpCopyTo;
        BigInteger.prototype.fromInt = bnpFromInt;
        BigInteger.prototype.fromString = bnpFromString;
        BigInteger.prototype.clamp = bnpClamp;
        BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
        BigInteger.prototype.drShiftTo = bnpDRShiftTo;
        BigInteger.prototype.lShiftTo = bnpLShiftTo;
        BigInteger.prototype.rShiftTo = bnpRShiftTo;
        BigInteger.prototype.subTo = bnpSubTo;
        BigInteger.prototype.multiplyTo = bnpMultiplyTo;
        BigInteger.prototype.squareTo = bnpSquareTo;
        BigInteger.prototype.divRemTo = bnpDivRemTo;
        BigInteger.prototype.invDigit = bnpInvDigit;
        BigInteger.prototype.isEven = bnpIsEven;
        BigInteger.prototype.exp = bnpExp;
        BigInteger.prototype.toString = bnToString;
        BigInteger.prototype.negate = bnNegate;
        BigInteger.prototype.abs = bnAbs;
        BigInteger.prototype.compareTo = bnCompareTo;
        BigInteger.prototype.bitLength = bnBitLength;
        BigInteger.prototype.mod = bnMod;
        BigInteger.prototype.modPowInt = bnModPowInt;
        BigInteger.ZERO = nbv(0);
        BigInteger.ONE = nbv(1);
        function bnClone() {
          var r = nbi();
          this.copyTo(r);
          return r;
        }
        function bnIntValue() {
          if (this.s < 0) {
            if (this.t == 1) return this.data[0] - this.DV;
            else if (this.t == 0) return -1;
          } else if (this.t == 1) return this.data[0];
          else if (this.t == 0) return 0;
          return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
        }
        function bnByteValue() {
          return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
        }
        function bnShortValue() {
          return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
        }
        function bnpChunkSize(r) {
          return Math.floor(Math.LN2 * this.DB / Math.log(r));
        }
        function bnSigNum() {
          if (this.s < 0) return -1;
          else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0;
          else return 1;
        }
        function bnpToRadix(b) {
          if (b == null) b = 10;
          if (this.signum() == 0 || b < 2 || b > 36) return "0";
          var cs = this.chunkSize(b);
          var a = Math.pow(b, cs);
          var d = nbv(a), y = nbi(), z = nbi(), r = "";
          this.divRemTo(d, y, z);
          while (y.signum() > 0) {
            r = (a + z.intValue()).toString(b).substr(1) + r;
            y.divRemTo(d, y, z);
          }
          return z.intValue().toString(b) + r;
        }
        function bnpFromRadix(s, b) {
          this.fromInt(0);
          if (b == null) b = 10;
          var cs = this.chunkSize(b);
          var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
          for (var i = 0; i < s.length; ++i) {
            var x = intAt(s, i);
            if (x < 0) {
              if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
              continue;
            }
            w = b * w + x;
            if (++j >= cs) {
              this.dMultiply(d);
              this.dAddOffset(w, 0);
              j = 0;
              w = 0;
            }
          }
          if (j > 0) {
            this.dMultiply(Math.pow(b, j));
            this.dAddOffset(w, 0);
          }
          if (mi) BigInteger.ZERO.subTo(this, this);
        }
        function bnpFromNumber(a, b, c) {
          if ("number" == typeof b) {
            if (a < 2) this.fromInt(1);
            else {
              this.fromNumber(a, c);
              if (!this.testBit(a - 1))
                this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
              if (this.isEven()) this.dAddOffset(1, 0);
              while (!this.isProbablePrime(b)) {
                this.dAddOffset(2, 0);
                if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
              }
            }
          } else {
            var x = new Array(), t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) x[0] &= (1 << t) - 1;
            else x[0] = 0;
            this.fromString(x, 256);
          }
        }
        function bnToByteArray() {
          var i = this.t, r = new Array();
          r[0] = this.s;
          var p = this.DB - i * this.DB % 8, d, k = 0;
          if (i-- > 0) {
            if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p)
              r[k++] = d | this.s << this.DB - p;
            while (i >= 0) {
              if (p < 8) {
                d = (this.data[i] & (1 << p) - 1) << 8 - p;
                d |= this.data[--i] >> (p += this.DB - 8);
              } else {
                d = this.data[i] >> (p -= 8) & 255;
                if (p <= 0) {
                  p += this.DB;
                  --i;
                }
              }
              if ((d & 128) != 0) d |= -256;
              if (k == 0 && (this.s & 128) != (d & 128)) ++k;
              if (k > 0 || d != this.s) r[k++] = d;
            }
          }
          return r;
        }
        function bnEquals(a) {
          return this.compareTo(a) == 0;
        }
        function bnMin(a) {
          return this.compareTo(a) < 0 ? this : a;
        }
        function bnMax(a) {
          return this.compareTo(a) > 0 ? this : a;
        }
        function bnpBitwiseTo(a, op, r) {
          var i, f, m = Math.min(a.t, this.t);
          for (i = 0; i < m; ++i) r.data[i] = op(this.data[i], a.data[i]);
          if (a.t < this.t) {
            f = a.s & this.DM;
            for (i = m; i < this.t; ++i) r.data[i] = op(this.data[i], f);
            r.t = this.t;
          } else {
            f = this.s & this.DM;
            for (i = m; i < a.t; ++i) r.data[i] = op(f, a.data[i]);
            r.t = a.t;
          }
          r.s = op(this.s, a.s);
          r.clamp();
        }
        function op_and(x, y) {
          return x & y;
        }
        function bnAnd(a) {
          var r = nbi();
          this.bitwiseTo(a, op_and, r);
          return r;
        }
        function op_or(x, y) {
          return x | y;
        }
        function bnOr(a) {
          var r = nbi();
          this.bitwiseTo(a, op_or, r);
          return r;
        }
        function op_xor(x, y) {
          return x ^ y;
        }
        function bnXor(a) {
          var r = nbi();
          this.bitwiseTo(a, op_xor, r);
          return r;
        }
        function op_andnot(x, y) {
          return x & ~y;
        }
        function bnAndNot(a) {
          var r = nbi();
          this.bitwiseTo(a, op_andnot, r);
          return r;
        }
        function bnNot() {
          var r = nbi();
          for (var i = 0; i < this.t; ++i) r.data[i] = this.DM & ~this.data[i];
          r.t = this.t;
          r.s = ~this.s;
          return r;
        }
        function bnShiftLeft(n) {
          var r = nbi();
          if (n < 0) this.rShiftTo(-n, r);
          else this.lShiftTo(n, r);
          return r;
        }
        function bnShiftRight(n) {
          var r = nbi();
          if (n < 0) this.lShiftTo(-n, r);
          else this.rShiftTo(n, r);
          return r;
        }
        function lbit(x) {
          if (x == 0) return -1;
          var r = 0;
          if ((x & 65535) == 0) {
            x >>= 16;
            r += 16;
          }
          if ((x & 255) == 0) {
            x >>= 8;
            r += 8;
          }
          if ((x & 15) == 0) {
            x >>= 4;
            r += 4;
          }
          if ((x & 3) == 0) {
            x >>= 2;
            r += 2;
          }
          if ((x & 1) == 0) ++r;
          return r;
        }
        function bnGetLowestSetBit() {
          for (var i = 0; i < this.t; ++i)
            if (this.data[i] != 0) return i * this.DB + lbit(this.data[i]);
          if (this.s < 0) return this.t * this.DB;
          return -1;
        }
        function cbit(x) {
          var r = 0;
          while (x != 0) {
            x &= x - 1;
            ++r;
          }
          return r;
        }
        function bnBitCount() {
          var r = 0, x = this.s & this.DM;
          for (var i = 0; i < this.t; ++i) r += cbit(this.data[i] ^ x);
          return r;
        }
        function bnTestBit(n) {
          var j = Math.floor(n / this.DB);
          if (j >= this.t) return this.s != 0;
          return (this.data[j] & 1 << n % this.DB) != 0;
        }
        function bnpChangeBit(n, op) {
          var r = BigInteger.ONE.shiftLeft(n);
          this.bitwiseTo(r, op, r);
          return r;
        }
        function bnSetBit(n) {
          return this.changeBit(n, op_or);
        }
        function bnClearBit(n) {
          return this.changeBit(n, op_andnot);
        }
        function bnFlipBit(n) {
          return this.changeBit(n, op_xor);
        }
        function bnpAddTo(a, r) {
          var i = 0, c = 0, m = Math.min(a.t, this.t);
          while (i < m) {
            c += this.data[i] + a.data[i];
            r.data[i++] = c & this.DM;
            c >>= this.DB;
          }
          if (a.t < this.t) {
            c += a.s;
            while (i < this.t) {
              c += this.data[i];
              r.data[i++] = c & this.DM;
              c >>= this.DB;
            }
            c += this.s;
          } else {
            c += this.s;
            while (i < a.t) {
              c += a.data[i];
              r.data[i++] = c & this.DM;
              c >>= this.DB;
            }
            c += a.s;
          }
          r.s = c < 0 ? -1 : 0;
          if (c > 0) r.data[i++] = c;
          else if (c < -1) r.data[i++] = this.DV + c;
          r.t = i;
          r.clamp();
        }
        function bnAdd(a) {
          var r = nbi();
          this.addTo(a, r);
          return r;
        }
        function bnSubtract(a) {
          var r = nbi();
          this.subTo(a, r);
          return r;
        }
        function bnMultiply(a) {
          var r = nbi();
          this.multiplyTo(a, r);
          return r;
        }
        function bnDivide(a) {
          var r = nbi();
          this.divRemTo(a, r, null);
          return r;
        }
        function bnRemainder(a) {
          var r = nbi();
          this.divRemTo(a, null, r);
          return r;
        }
        function bnDivideAndRemainder(a) {
          var q = nbi(), r = nbi();
          this.divRemTo(a, q, r);
          return new Array(q, r);
        }
        function bnpDMultiply(n) {
          this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
          ++this.t;
          this.clamp();
        }
        function bnpDAddOffset(n, w) {
          if (n == 0) return;
          while (this.t <= w) this.data[this.t++] = 0;
          this.data[w] += n;
          while (this.data[w] >= this.DV) {
            this.data[w] -= this.DV;
            if (++w >= this.t) this.data[this.t++] = 0;
            ++this.data[w];
          }
        }
        function NullExp() {
        }
        function nNop(x) {
          return x;
        }
        function nMulTo(x, y, r) {
          x.multiplyTo(y, r);
        }
        function nSqrTo(x, r) {
          x.squareTo(r);
        }
        NullExp.prototype.convert = nNop;
        NullExp.prototype.revert = nNop;
        NullExp.prototype.mulTo = nMulTo;
        NullExp.prototype.sqrTo = nSqrTo;
        function bnPow(e) {
          return this.exp(e, new NullExp());
        }
        function bnpMultiplyLowerTo(a, n, r) {
          var i = Math.min(this.t + a.t, n);
          r.s = 0;
          r.t = i;
          while (i > 0) r.data[--i] = 0;
          var j;
          for (j = r.t - this.t; i < j; ++i) r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
          for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a.data[i], r, i, 0, n - i);
          r.clamp();
        }
        function bnpMultiplyUpperTo(a, n, r) {
          --n;
          var i = r.t = this.t + a.t - n;
          r.s = 0;
          while (--i >= 0) r.data[i] = 0;
          for (i = Math.max(n - this.t, 0); i < a.t; ++i)
            r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
          r.clamp();
          r.drShiftTo(1, r);
        }
        function Barrett(m) {
          this.r2 = nbi();
          this.q3 = nbi();
          BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
          this.mu = this.r2.divide(m);
          this.m = m;
        }
        function barrettConvert(x) {
          if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
          else if (x.compareTo(this.m) < 0) return x;
          else {
            var r = nbi();
            x.copyTo(r);
            this.reduce(r);
            return r;
          }
        }
        function barrettRevert(x) {
          return x;
        }
        function barrettReduce(x) {
          x.drShiftTo(this.m.t - 1, this.r2);
          if (x.t > this.m.t + 1) {
            x.t = this.m.t + 1;
            x.clamp();
          }
          this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
          this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
          while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
          x.subTo(this.r2, x);
          while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
        }
        function barrettSqrTo(x, r) {
          x.squareTo(r);
          this.reduce(r);
        }
        function barrettMulTo(x, y, r) {
          x.multiplyTo(y, r);
          this.reduce(r);
        }
        Barrett.prototype.convert = barrettConvert;
        Barrett.prototype.revert = barrettRevert;
        Barrett.prototype.reduce = barrettReduce;
        Barrett.prototype.mulTo = barrettMulTo;
        Barrett.prototype.sqrTo = barrettSqrTo;
        function bnModPow(e, m) {
          var i = e.bitLength(), k, r = nbv(1), z;
          if (i <= 0) return r;
          else if (i < 18) k = 1;
          else if (i < 48) k = 3;
          else if (i < 144) k = 4;
          else if (i < 768) k = 5;
          else k = 6;
          if (i < 8)
            z = new Classic(m);
          else if (m.isEven())
            z = new Barrett(m);
          else
            z = new Montgomery(m);
          var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
          g[1] = z.convert(this);
          if (k > 1) {
            var g2 = nbi();
            z.sqrTo(g[1], g2);
            while (n <= km) {
              g[n] = nbi();
              z.mulTo(g2, g[n - 2], g[n]);
              n += 2;
            }
          }
          var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
          i = nbits(e.data[j]) - 1;
          while (j >= 0) {
            if (i >= k1) w = e.data[j] >> i - k1 & km;
            else {
              w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
              if (j > 0) w |= e.data[j - 1] >> this.DB + i - k1;
            }
            n = k;
            while ((w & 1) == 0) {
              w >>= 1;
              --n;
            }
            if ((i -= n) < 0) {
              i += this.DB;
              --j;
            }
            if (is1) {
              g[w].copyTo(r);
              is1 = false;
            } else {
              while (n > 1) {
                z.sqrTo(r, r2);
                z.sqrTo(r2, r);
                n -= 2;
              }
              if (n > 0) z.sqrTo(r, r2);
              else {
                t = r;
                r = r2;
                r2 = t;
              }
              z.mulTo(r2, g[w], r);
            }
            while (j >= 0 && (e.data[j] & 1 << i) == 0) {
              z.sqrTo(r, r2);
              t = r;
              r = r2;
              r2 = t;
              if (--i < 0) {
                i = this.DB - 1;
                --j;
              }
            }
          }
          return z.revert(r);
        }
        function bnGCD(a) {
          var x = this.s < 0 ? this.negate() : this.clone();
          var y = a.s < 0 ? a.negate() : a.clone();
          if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
          }
          var i = x.getLowestSetBit(), g = y.getLowestSetBit();
          if (g < 0) return x;
          if (i < g) g = i;
          if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
          }
          while (x.signum() > 0) {
            if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
            if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
            if (x.compareTo(y) >= 0) {
              x.subTo(y, x);
              x.rShiftTo(1, x);
            } else {
              y.subTo(x, y);
              y.rShiftTo(1, y);
            }
          }
          if (g > 0) y.lShiftTo(g, y);
          return y;
        }
        function bnpModInt(n) {
          if (n <= 0) return 0;
          var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
          if (this.t > 0)
            if (d == 0) r = this.data[0] % n;
            else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this.data[i]) % n;
          return r;
        }
        function bnModInverse(m) {
          var ac = m.isEven();
          if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;
          var u = m.clone(), v = this.clone();
          var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
          while (u.signum() != 0) {
            while (u.isEven()) {
              u.rShiftTo(1, u);
              if (ac) {
                if (!a.isEven() || !b.isEven()) {
                  a.addTo(this, a);
                  b.subTo(m, b);
                }
                a.rShiftTo(1, a);
              } else if (!b.isEven()) b.subTo(m, b);
              b.rShiftTo(1, b);
            }
            while (v.isEven()) {
              v.rShiftTo(1, v);
              if (ac) {
                if (!c.isEven() || !d.isEven()) {
                  c.addTo(this, c);
                  d.subTo(m, d);
                }
                c.rShiftTo(1, c);
              } else if (!d.isEven()) d.subTo(m, d);
              d.rShiftTo(1, d);
            }
            if (u.compareTo(v) >= 0) {
              u.subTo(v, u);
              if (ac) a.subTo(c, a);
              b.subTo(d, b);
            } else {
              v.subTo(u, v);
              if (ac) c.subTo(a, c);
              d.subTo(b, d);
            }
          }
          if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
          if (d.compareTo(m) >= 0) return d.subtract(m);
          if (d.signum() < 0) d.addTo(m, d);
          else return d;
          if (d.signum() < 0) return d.add(m);
          else return d;
        }
        var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
        var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
        function bnIsProbablePrime(t) {
          var i, x = this.abs();
          if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
            for (i = 0; i < lowprimes.length; ++i)
              if (x.data[0] == lowprimes[i]) return true;
            return false;
          }
          if (x.isEven()) return false;
          i = 1;
          while (i < lowprimes.length) {
            var m = lowprimes[i], j = i + 1;
            while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
            m = x.modInt(m);
            while (i < j) if (m % lowprimes[i++] == 0) return false;
          }
          return x.millerRabin(t);
        }
        function bnpMillerRabin(t) {
          var n1 = this.subtract(BigInteger.ONE);
          var k = n1.getLowestSetBit();
          if (k <= 0) return false;
          var r = n1.shiftRight(k);
          var prng2 = bnGetPrng();
          var a;
          for (var i = 0; i < t; ++i) {
            do {
              a = new BigInteger(this.bitLength(), prng2);
            } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
            var y = a.modPow(r, this);
            if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
              var j = 1;
              while (j++ < k && y.compareTo(n1) != 0) {
                y = y.modPowInt(2, this);
                if (y.compareTo(BigInteger.ONE) == 0) return false;
              }
              if (y.compareTo(n1) != 0) return false;
            }
          }
          return true;
        }
        function bnGetPrng() {
          return {
            // x is an array to fill with bytes
            nextBytes: function(x) {
              for (var i = 0; i < x.length; ++i) {
                x[i] = Math.floor(Math.random() * 256);
              }
            }
          };
        }
        BigInteger.prototype.chunkSize = bnpChunkSize;
        BigInteger.prototype.toRadix = bnpToRadix;
        BigInteger.prototype.fromRadix = bnpFromRadix;
        BigInteger.prototype.fromNumber = bnpFromNumber;
        BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
        BigInteger.prototype.changeBit = bnpChangeBit;
        BigInteger.prototype.addTo = bnpAddTo;
        BigInteger.prototype.dMultiply = bnpDMultiply;
        BigInteger.prototype.dAddOffset = bnpDAddOffset;
        BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
        BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
        BigInteger.prototype.modInt = bnpModInt;
        BigInteger.prototype.millerRabin = bnpMillerRabin;
        BigInteger.prototype.clone = bnClone;
        BigInteger.prototype.intValue = bnIntValue;
        BigInteger.prototype.byteValue = bnByteValue;
        BigInteger.prototype.shortValue = bnShortValue;
        BigInteger.prototype.signum = bnSigNum;
        BigInteger.prototype.toByteArray = bnToByteArray;
        BigInteger.prototype.equals = bnEquals;
        BigInteger.prototype.min = bnMin;
        BigInteger.prototype.max = bnMax;
        BigInteger.prototype.and = bnAnd;
        BigInteger.prototype.or = bnOr;
        BigInteger.prototype.xor = bnXor;
        BigInteger.prototype.andNot = bnAndNot;
        BigInteger.prototype.not = bnNot;
        BigInteger.prototype.shiftLeft = bnShiftLeft;
        BigInteger.prototype.shiftRight = bnShiftRight;
        BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
        BigInteger.prototype.bitCount = bnBitCount;
        BigInteger.prototype.testBit = bnTestBit;
        BigInteger.prototype.setBit = bnSetBit;
        BigInteger.prototype.clearBit = bnClearBit;
        BigInteger.prototype.flipBit = bnFlipBit;
        BigInteger.prototype.add = bnAdd;
        BigInteger.prototype.subtract = bnSubtract;
        BigInteger.prototype.multiply = bnMultiply;
        BigInteger.prototype.divide = bnDivide;
        BigInteger.prototype.remainder = bnRemainder;
        BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
        BigInteger.prototype.modPow = bnModPow;
        BigInteger.prototype.modInverse = bnModInverse;
        BigInteger.prototype.pow = bnPow;
        BigInteger.prototype.gcd = bnGCD;
        BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
        return jsbn;
      }
      var pkcs1 = { exports: {} };
      var sha1 = { exports: {} };
      var hasRequiredSha1;
      function requireSha1() {
        if (hasRequiredSha1) return sha1.exports;
        hasRequiredSha1 = 1;
        var forge2 = requireForge();
        requireMd();
        requireUtil();
        var sha1$1 = sha1.exports = forge2.sha1 = forge2.sha1 || {};
        forge2.md.sha1 = forge2.md.algorithms.sha1 = sha1$1;
        sha1$1.create = function() {
          if (!_initialized) {
            _init();
          }
          var _state = null;
          var _input = forge2.util.createBuffer();
          var _w = new Array(80);
          var md2 = {
            algorithm: "sha1",
            blockLength: 64,
            digestLength: 20,
            // 56-bit length of message so far (does not including padding)
            messageLength: 0,
            // true message length
            fullMessageLength: null,
            // size of message length in bytes
            messageLengthSize: 8
          };
          md2.start = function() {
            md2.messageLength = 0;
            md2.fullMessageLength = md2.messageLength64 = [];
            var int32s = md2.messageLengthSize / 4;
            for (var i = 0; i < int32s; ++i) {
              md2.fullMessageLength.push(0);
            }
            _input = forge2.util.createBuffer();
            _state = {
              h0: 1732584193,
              h1: 4023233417,
              h2: 2562383102,
              h3: 271733878,
              h4: 3285377520
            };
            return md2;
          };
          md2.start();
          md2.update = function(msg, encoding) {
            if (encoding === "utf8") {
              msg = forge2.util.encodeUtf8(msg);
            }
            var len = msg.length;
            md2.messageLength += len;
            len = [len / 4294967296 >>> 0, len >>> 0];
            for (var i = md2.fullMessageLength.length - 1; i >= 0; --i) {
              md2.fullMessageLength[i] += len[1];
              len[1] = len[0] + (md2.fullMessageLength[i] / 4294967296 >>> 0);
              md2.fullMessageLength[i] = md2.fullMessageLength[i] >>> 0;
              len[0] = len[1] / 4294967296 >>> 0;
            }
            _input.putBytes(msg);
            _update(_state, _w, _input);
            if (_input.read > 2048 || _input.length() === 0) {
              _input.compact();
            }
            return md2;
          };
          md2.digest = function() {
            var finalBlock = forge2.util.createBuffer();
            finalBlock.putBytes(_input.bytes());
            var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
            var overflow = remaining & md2.blockLength - 1;
            finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
            var next, carry;
            var bits2 = md2.fullMessageLength[0] * 8;
            for (var i = 0; i < md2.fullMessageLength.length - 1; ++i) {
              next = md2.fullMessageLength[i + 1] * 8;
              carry = next / 4294967296 >>> 0;
              bits2 += carry;
              finalBlock.putInt32(bits2 >>> 0);
              bits2 = next >>> 0;
            }
            finalBlock.putInt32(bits2);
            var s2 = {
              h0: _state.h0,
              h1: _state.h1,
              h2: _state.h2,
              h3: _state.h3,
              h4: _state.h4
            };
            _update(s2, _w, finalBlock);
            var rval = forge2.util.createBuffer();
            rval.putInt32(s2.h0);
            rval.putInt32(s2.h1);
            rval.putInt32(s2.h2);
            rval.putInt32(s2.h3);
            rval.putInt32(s2.h4);
            return rval;
          };
          return md2;
        };
        var _padding = null;
        var _initialized = false;
        function _init() {
          _padding = String.fromCharCode(128);
          _padding += forge2.util.fillString(String.fromCharCode(0), 64);
          _initialized = true;
        }
        function _update(s, w, bytes) {
          var t, a, b, c, d, e, f, i;
          var len = bytes.length();
          while (len >= 64) {
            a = s.h0;
            b = s.h1;
            c = s.h2;
            d = s.h3;
            e = s.h4;
            for (i = 0; i < 16; ++i) {
              t = bytes.getInt32();
              w[i] = t;
              f = d ^ b & (c ^ d);
              t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
              e = d;
              d = c;
              c = (b << 30 | b >>> 2) >>> 0;
              b = a;
              a = t;
            }
            for (; i < 20; ++i) {
              t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
              t = t << 1 | t >>> 31;
              w[i] = t;
              f = d ^ b & (c ^ d);
              t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
              e = d;
              d = c;
              c = (b << 30 | b >>> 2) >>> 0;
              b = a;
              a = t;
            }
            for (; i < 32; ++i) {
              t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
              t = t << 1 | t >>> 31;
              w[i] = t;
              f = b ^ c ^ d;
              t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
              e = d;
              d = c;
              c = (b << 30 | b >>> 2) >>> 0;
              b = a;
              a = t;
            }
            for (; i < 40; ++i) {
              t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
              t = t << 2 | t >>> 30;
              w[i] = t;
              f = b ^ c ^ d;
              t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
              e = d;
              d = c;
              c = (b << 30 | b >>> 2) >>> 0;
              b = a;
              a = t;
            }
            for (; i < 60; ++i) {
              t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
              t = t << 2 | t >>> 30;
              w[i] = t;
              f = b & c | d & (b ^ c);
              t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
              e = d;
              d = c;
              c = (b << 30 | b >>> 2) >>> 0;
              b = a;
              a = t;
            }
            for (; i < 80; ++i) {
              t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
              t = t << 2 | t >>> 30;
              w[i] = t;
              f = b ^ c ^ d;
              t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
              e = d;
              d = c;
              c = (b << 30 | b >>> 2) >>> 0;
              b = a;
              a = t;
            }
            s.h0 = s.h0 + a | 0;
            s.h1 = s.h1 + b | 0;
            s.h2 = s.h2 + c | 0;
            s.h3 = s.h3 + d | 0;
            s.h4 = s.h4 + e | 0;
            len -= 64;
          }
        }
        return sha1.exports;
      }
      var hasRequiredPkcs1;
      function requirePkcs1() {
        if (hasRequiredPkcs1) return pkcs1.exports;
        hasRequiredPkcs1 = 1;
        var forge2 = requireForge();
        requireUtil();
        requireRandom();
        requireSha1();
        var pkcs1$1 = pkcs1.exports = forge2.pkcs1 = forge2.pkcs1 || {};
        pkcs1$1.encode_rsa_oaep = function(key, message2, options) {
          var label;
          var seed;
          var md2;
          var mgf1Md;
          if (typeof options === "string") {
            label = options;
            seed = arguments[3] || void 0;
            md2 = arguments[4] || void 0;
          } else if (options) {
            label = options.label || void 0;
            seed = options.seed || void 0;
            md2 = options.md || void 0;
            if (options.mgf1 && options.mgf1.md) {
              mgf1Md = options.mgf1.md;
            }
          }
          if (!md2) {
            md2 = forge2.md.sha1.create();
          } else {
            md2.start();
          }
          if (!mgf1Md) {
            mgf1Md = md2;
          }
          var keyLength = Math.ceil(key.n.bitLength() / 8);
          var maxLength = keyLength - 2 * md2.digestLength - 2;
          if (message2.length > maxLength) {
            var error = new Error("RSAES-OAEP input message length is too long.");
            error.length = message2.length;
            error.maxLength = maxLength;
            throw error;
          }
          if (!label) {
            label = "";
          }
          md2.update(label, "raw");
          var lHash = md2.digest();
          var PS = "";
          var PS_length = maxLength - message2.length;
          for (var i = 0; i < PS_length; i++) {
            PS += "\0";
          }
          var DB = lHash.getBytes() + PS + "" + message2;
          if (!seed) {
            seed = forge2.random.getBytes(md2.digestLength);
          } else if (seed.length !== md2.digestLength) {
            var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
            error.seedLength = seed.length;
            error.digestLength = md2.digestLength;
            throw error;
          }
          var dbMask = rsa_mgf1(seed, keyLength - md2.digestLength - 1, mgf1Md);
          var maskedDB = forge2.util.xorBytes(DB, dbMask, DB.length);
          var seedMask = rsa_mgf1(maskedDB, md2.digestLength, mgf1Md);
          var maskedSeed = forge2.util.xorBytes(seed, seedMask, seed.length);
          return "\0" + maskedSeed + maskedDB;
        };
        pkcs1$1.decode_rsa_oaep = function(key, em, options) {
          var label;
          var md2;
          var mgf1Md;
          if (typeof options === "string") {
            label = options;
            md2 = arguments[3] || void 0;
          } else if (options) {
            label = options.label || void 0;
            md2 = options.md || void 0;
            if (options.mgf1 && options.mgf1.md) {
              mgf1Md = options.mgf1.md;
            }
          }
          var keyLength = Math.ceil(key.n.bitLength() / 8);
          if (em.length !== keyLength) {
            var error = new Error("RSAES-OAEP encoded message length is invalid.");
            error.length = em.length;
            error.expectedLength = keyLength;
            throw error;
          }
          if (md2 === void 0) {
            md2 = forge2.md.sha1.create();
          } else {
            md2.start();
          }
          if (!mgf1Md) {
            mgf1Md = md2;
          }
          if (keyLength < 2 * md2.digestLength + 2) {
            throw new Error("RSAES-OAEP key is too short for the hash function.");
          }
          if (!label) {
            label = "";
          }
          md2.update(label, "raw");
          var lHash = md2.digest().getBytes();
          var y = em.charAt(0);
          var maskedSeed = em.substring(1, md2.digestLength + 1);
          var maskedDB = em.substring(1 + md2.digestLength);
          var seedMask = rsa_mgf1(maskedDB, md2.digestLength, mgf1Md);
          var seed = forge2.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
          var dbMask = rsa_mgf1(seed, keyLength - md2.digestLength - 1, mgf1Md);
          var db = forge2.util.xorBytes(maskedDB, dbMask, maskedDB.length);
          var lHashPrime = db.substring(0, md2.digestLength);
          var error = y !== "\0";
          for (var i = 0; i < md2.digestLength; ++i) {
            error |= lHash.charAt(i) !== lHashPrime.charAt(i);
          }
          var in_ps = 1;
          var index2 = md2.digestLength;
          for (var j = md2.digestLength; j < db.length; j++) {
            var code = db.charCodeAt(j);
            var is_0 = code & 1 ^ 1;
            var error_mask = in_ps ? 65534 : 0;
            error |= code & error_mask;
            in_ps = in_ps & is_0;
            index2 += in_ps;
          }
          if (error || db.charCodeAt(index2) !== 1) {
            throw new Error("Invalid RSAES-OAEP padding.");
          }
          return db.substring(index2 + 1);
        };
        function rsa_mgf1(seed, maskLength, hash) {
          if (!hash) {
            hash = forge2.md.sha1.create();
          }
          var t = "";
          var count = Math.ceil(maskLength / hash.digestLength);
          for (var i = 0; i < count; ++i) {
            var c = String.fromCharCode(
              i >> 24 & 255,
              i >> 16 & 255,
              i >> 8 & 255,
              i & 255
            );
            hash.start();
            hash.update(seed + c);
            t += hash.digest().getBytes();
          }
          return t.substring(0, maskLength);
        }
        return pkcs1.exports;
      }
      var prime = { exports: {} };
      var hasRequiredPrime;
      function requirePrime() {
        if (hasRequiredPrime) return prime.exports;
        hasRequiredPrime = 1;
        var forge2 = requireForge();
        requireUtil();
        requireJsbn();
        requireRandom();
        (function() {
          if (forge2.prime) {
            prime.exports = forge2.prime;
            return;
          }
          var prime$1 = prime.exports = forge2.prime = forge2.prime || {};
          var BigInteger = forge2.jsbn.BigInteger;
          var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
          var THIRTY = new BigInteger(null);
          THIRTY.fromInt(30);
          var op_or = function(x, y) {
            return x | y;
          };
          prime$1.generateProbablePrime = function(bits2, options, callback) {
            if (typeof options === "function") {
              callback = options;
              options = {};
            }
            options = options || {};
            var algorithm = options.algorithm || "PRIMEINC";
            if (typeof algorithm === "string") {
              algorithm = { name: algorithm };
            }
            algorithm.options = algorithm.options || {};
            var prng2 = options.prng || forge2.random;
            var rng = {
              // x is an array to fill with bytes
              nextBytes: function(x) {
                var b = prng2.getBytesSync(x.length);
                for (var i = 0; i < x.length; ++i) {
                  x[i] = b.charCodeAt(i);
                }
              }
            };
            if (algorithm.name === "PRIMEINC") {
              return primeincFindPrime(bits2, rng, algorithm.options, callback);
            }
            throw new Error("Invalid prime generation algorithm: " + algorithm.name);
          };
          function primeincFindPrime(bits2, rng, options, callback) {
            if ("workers" in options) {
              return primeincFindPrimeWithWorkers(bits2, rng, options, callback);
            }
            return primeincFindPrimeWithoutWorkers(bits2, rng, options, callback);
          }
          function primeincFindPrimeWithoutWorkers(bits2, rng, options, callback) {
            var num = generateRandom(bits2, rng);
            var deltaIdx = 0;
            var mrTests = getMillerRabinTests(num.bitLength());
            if ("millerRabinTests" in options) {
              mrTests = options.millerRabinTests;
            }
            var maxBlockTime = 10;
            if ("maxBlockTime" in options) {
              maxBlockTime = options.maxBlockTime;
            }
            _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback);
          }
          function _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback) {
            var start = +/* @__PURE__ */ new Date();
            do {
              if (num.bitLength() > bits2) {
                num = generateRandom(bits2, rng);
              }
              if (num.isProbablePrime(mrTests)) {
                return callback(null, num);
              }
              num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
            forge2.util.setImmediate(function() {
              _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback);
            });
          }
          function primeincFindPrimeWithWorkers(bits2, rng, options, callback) {
            if (typeof Worker === "undefined") {
              return primeincFindPrimeWithoutWorkers(bits2, rng, options, callback);
            }
            var num = generateRandom(bits2, rng);
            var numWorkers = options.workers;
            var workLoad = options.workLoad || 100;
            var range = workLoad * 30 / 8;
            var workerScript = options.workerScript || "forge/prime.worker.js";
            if (numWorkers === -1) {
              return forge2.util.estimateCores(function(err2, cores) {
                if (err2) {
                  cores = 2;
                }
                numWorkers = cores - 1;
                generate();
              });
            }
            generate();
            function generate() {
              numWorkers = Math.max(1, numWorkers);
              var workers = [];
              for (var i = 0; i < numWorkers; ++i) {
                workers[i] = new Worker(workerScript);
              }
              for (var i = 0; i < numWorkers; ++i) {
                workers[i].addEventListener("message", workerMessage);
              }
              var found = false;
              function workerMessage(e) {
                if (found) {
                  return;
                }
                var data = e.data;
                if (data.found) {
                  for (var i2 = 0; i2 < workers.length; ++i2) {
                    workers[i2].terminate();
                  }
                  found = true;
                  return callback(null, new BigInteger(data.prime, 16));
                }
                if (num.bitLength() > bits2) {
                  num = generateRandom(bits2, rng);
                }
                var hex = num.toString(16);
                e.target.postMessage({
                  hex,
                  workLoad
                });
                num.dAddOffset(range, 0);
              }
            }
          }
          function generateRandom(bits2, rng) {
            var num = new BigInteger(bits2, rng);
            var bits1 = bits2 - 1;
            if (!num.testBit(bits1)) {
              num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
            }
            num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
            return num;
          }
          function getMillerRabinTests(bits2) {
            if (bits2 <= 100) return 27;
            if (bits2 <= 150) return 18;
            if (bits2 <= 200) return 15;
            if (bits2 <= 250) return 12;
            if (bits2 <= 300) return 9;
            if (bits2 <= 350) return 8;
            if (bits2 <= 400) return 7;
            if (bits2 <= 500) return 6;
            if (bits2 <= 600) return 5;
            if (bits2 <= 800) return 4;
            if (bits2 <= 1250) return 3;
            return 2;
          }
        })();
        return prime.exports;
      }
      var rsa;
      var hasRequiredRsa;
      function requireRsa() {
        if (hasRequiredRsa) return rsa;
        hasRequiredRsa = 1;
        var forge2 = requireForge();
        requireAsn1();
        requireJsbn();
        requireOids();
        requirePkcs1();
        requirePrime();
        requireRandom();
        requireUtil();
        if (typeof BigInteger === "undefined") {
          var BigInteger = forge2.jsbn.BigInteger;
        }
        var _crypto = forge2.util.isNodejs ? require$$8 : null;
        var asn12 = forge2.asn1;
        var util2 = forge2.util;
        forge2.pki = forge2.pki || {};
        rsa = forge2.pki.rsa = forge2.rsa = forge2.rsa || {};
        var pki2 = forge2.pki;
        var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
        var privateKeyValidator = {
          // PrivateKeyInfo
          name: "PrivateKeyInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            // Version (INTEGER)
            name: "PrivateKeyInfo.version",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyVersion"
          }, {
            // privateKeyAlgorithm
            name: "PrivateKeyInfo.privateKeyAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "privateKeyOid"
            }]
          }, {
            // PrivateKey
            name: "PrivateKeyInfo",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OCTETSTRING,
            constructed: false,
            capture: "privateKey"
          }]
        };
        var rsaPrivateKeyValidator = {
          // RSAPrivateKey
          name: "RSAPrivateKey",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            // Version (INTEGER)
            name: "RSAPrivateKey.version",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyVersion"
          }, {
            // modulus (n)
            name: "RSAPrivateKey.modulus",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyModulus"
          }, {
            // publicExponent (e)
            name: "RSAPrivateKey.publicExponent",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyPublicExponent"
          }, {
            // privateExponent (d)
            name: "RSAPrivateKey.privateExponent",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyPrivateExponent"
          }, {
            // prime1 (p)
            name: "RSAPrivateKey.prime1",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyPrime1"
          }, {
            // prime2 (q)
            name: "RSAPrivateKey.prime2",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyPrime2"
          }, {
            // exponent1 (d mod (p-1))
            name: "RSAPrivateKey.exponent1",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyExponent1"
          }, {
            // exponent2 (d mod (q-1))
            name: "RSAPrivateKey.exponent2",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyExponent2"
          }, {
            // coefficient ((inverse of q) mod p)
            name: "RSAPrivateKey.coefficient",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyCoefficient"
          }]
        };
        var rsaPublicKeyValidator = {
          // RSAPublicKey
          name: "RSAPublicKey",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            // modulus (n)
            name: "RSAPublicKey.modulus",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "publicKeyModulus"
          }, {
            // publicExponent (e)
            name: "RSAPublicKey.exponent",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "publicKeyExponent"
          }]
        };
        var publicKeyValidator = forge2.pki.rsa.publicKeyValidator = {
          name: "SubjectPublicKeyInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "subjectPublicKeyInfo",
          value: [{
            name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "publicKeyOid"
            }]
          }, {
            // subjectPublicKey
            name: "SubjectPublicKeyInfo.subjectPublicKey",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.BITSTRING,
            constructed: false,
            value: [{
              // RSAPublicKey
              name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              optional: true,
              captureAsn1: "rsaPublicKey"
            }]
          }]
        };
        var digestInfoValidator = {
          name: "DigestInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "DigestInfo.DigestAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "algorithmIdentifier"
            }, {
              // NULL parameters
              name: "DigestInfo.DigestAlgorithm.parameters",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.NULL,
              // captured only to check existence for md2 and md5
              capture: "parameters",
              optional: true,
              constructed: false
            }]
          }, {
            // digest
            name: "DigestInfo.digest",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OCTETSTRING,
            constructed: false,
            capture: "digest"
          }]
        };
        var emsaPkcs1v15encode = function(md2) {
          var oid;
          if (md2.algorithm in pki2.oids) {
            oid = pki2.oids[md2.algorithm];
          } else {
            var error = new Error("Unknown message digest algorithm.");
            error.algorithm = md2.algorithm;
            throw error;
          }
          var oidBytes = asn12.oidToDer(oid).getBytes();
          var digestInfo = asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.SEQUENCE,
            true,
            []
          );
          var digestAlgorithm = asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.SEQUENCE,
            true,
            []
          );
          digestAlgorithm.value.push(asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.OID,
            false,
            oidBytes
          ));
          digestAlgorithm.value.push(asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.NULL,
            false,
            ""
          ));
          var digest = asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.OCTETSTRING,
            false,
            md2.digest().getBytes()
          );
          digestInfo.value.push(digestAlgorithm);
          digestInfo.value.push(digest);
          return asn12.toDer(digestInfo).getBytes();
        };
        var _modPow = function(x, key, pub) {
          if (pub) {
            return x.modPow(key.e, key.n);
          }
          if (!key.p || !key.q) {
            return x.modPow(key.d, key.n);
          }
          if (!key.dP) {
            key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
          }
          if (!key.dQ) {
            key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
          }
          if (!key.qInv) {
            key.qInv = key.q.modInverse(key.p);
          }
          var r;
          do {
            r = new BigInteger(
              forge2.util.bytesToHex(forge2.random.getBytes(key.n.bitLength() / 8)),
              16
            );
          } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
          x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
          var xp = x.mod(key.p).modPow(key.dP, key.p);
          var xq = x.mod(key.q).modPow(key.dQ, key.q);
          while (xp.compareTo(xq) < 0) {
            xp = xp.add(key.p);
          }
          var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
          y = y.multiply(r.modInverse(key.n)).mod(key.n);
          return y;
        };
        pki2.rsa.encrypt = function(m, key, bt) {
          var pub = bt;
          var eb;
          var k = Math.ceil(key.n.bitLength() / 8);
          if (bt !== false && bt !== true) {
            pub = bt === 2;
            eb = _encodePkcs1_v1_5(m, key, bt);
          } else {
            eb = forge2.util.createBuffer();
            eb.putBytes(m);
          }
          var x = new BigInteger(eb.toHex(), 16);
          var y = _modPow(x, key, pub);
          var yhex = y.toString(16);
          var ed = forge2.util.createBuffer();
          var zeros = k - Math.ceil(yhex.length / 2);
          while (zeros > 0) {
            ed.putByte(0);
            --zeros;
          }
          ed.putBytes(forge2.util.hexToBytes(yhex));
          return ed.getBytes();
        };
        pki2.rsa.decrypt = function(ed, key, pub, ml) {
          var k = Math.ceil(key.n.bitLength() / 8);
          if (ed.length !== k) {
            var error = new Error("Encrypted message length is invalid.");
            error.length = ed.length;
            error.expected = k;
            throw error;
          }
          var y = new BigInteger(forge2.util.createBuffer(ed).toHex(), 16);
          if (y.compareTo(key.n) >= 0) {
            throw new Error("Encrypted message is invalid.");
          }
          var x = _modPow(y, key, pub);
          var xhex = x.toString(16);
          var eb = forge2.util.createBuffer();
          var zeros = k - Math.ceil(xhex.length / 2);
          while (zeros > 0) {
            eb.putByte(0);
            --zeros;
          }
          eb.putBytes(forge2.util.hexToBytes(xhex));
          if (ml !== false) {
            return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
          }
          return eb.getBytes();
        };
        pki2.rsa.createKeyPairGenerationState = function(bits2, e, options) {
          if (typeof bits2 === "string") {
            bits2 = parseInt(bits2, 10);
          }
          bits2 = bits2 || 2048;
          options = options || {};
          var prng2 = options.prng || forge2.random;
          var rng = {
            // x is an array to fill with bytes
            nextBytes: function(x) {
              var b = prng2.getBytesSync(x.length);
              for (var i = 0; i < x.length; ++i) {
                x[i] = b.charCodeAt(i);
              }
            }
          };
          var algorithm = options.algorithm || "PRIMEINC";
          var rval;
          if (algorithm === "PRIMEINC") {
            rval = {
              algorithm,
              state: 0,
              bits: bits2,
              rng,
              eInt: e || 65537,
              e: new BigInteger(null),
              p: null,
              q: null,
              qBits: bits2 >> 1,
              pBits: bits2 - (bits2 >> 1),
              pqState: 0,
              num: null,
              keys: null
            };
            rval.e.fromInt(rval.eInt);
          } else {
            throw new Error("Invalid key generation algorithm: " + algorithm);
          }
          return rval;
        };
        pki2.rsa.stepKeyPairGenerationState = function(state, n) {
          if (!("algorithm" in state)) {
            state.algorithm = "PRIMEINC";
          }
          var THIRTY = new BigInteger(null);
          THIRTY.fromInt(30);
          var deltaIdx = 0;
          var op_or = function(x, y) {
            return x | y;
          };
          var t1 = +/* @__PURE__ */ new Date();
          var t2;
          var total = 0;
          while (state.keys === null && (n <= 0 || total < n)) {
            if (state.state === 0) {
              var bits2 = state.p === null ? state.pBits : state.qBits;
              var bits1 = bits2 - 1;
              if (state.pqState === 0) {
                state.num = new BigInteger(bits2, state.rng);
                if (!state.num.testBit(bits1)) {
                  state.num.bitwiseTo(
                    BigInteger.ONE.shiftLeft(bits1),
                    op_or,
                    state.num
                  );
                }
                state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
                deltaIdx = 0;
                ++state.pqState;
              } else if (state.pqState === 1) {
                if (state.num.bitLength() > bits2) {
                  state.pqState = 0;
                } else if (state.num.isProbablePrime(
                  _getMillerRabinTests(state.num.bitLength())
                )) {
                  ++state.pqState;
                } else {
                  state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
                }
              } else if (state.pqState === 2) {
                state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
              } else if (state.pqState === 3) {
                state.pqState = 0;
                if (state.p === null) {
                  state.p = state.num;
                } else {
                  state.q = state.num;
                }
                if (state.p !== null && state.q !== null) {
                  ++state.state;
                }
                state.num = null;
              }
            } else if (state.state === 1) {
              if (state.p.compareTo(state.q) < 0) {
                state.num = state.p;
                state.p = state.q;
                state.q = state.num;
              }
              ++state.state;
            } else if (state.state === 2) {
              state.p1 = state.p.subtract(BigInteger.ONE);
              state.q1 = state.q.subtract(BigInteger.ONE);
              state.phi = state.p1.multiply(state.q1);
              ++state.state;
            } else if (state.state === 3) {
              if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
                ++state.state;
              } else {
                state.p = null;
                state.q = null;
                state.state = 0;
              }
            } else if (state.state === 4) {
              state.n = state.p.multiply(state.q);
              if (state.n.bitLength() === state.bits) {
                ++state.state;
              } else {
                state.q = null;
                state.state = 0;
              }
            } else if (state.state === 5) {
              var d = state.e.modInverse(state.phi);
              state.keys = {
                privateKey: pki2.rsa.setPrivateKey(
                  state.n,
                  state.e,
                  d,
                  state.p,
                  state.q,
                  d.mod(state.p1),
                  d.mod(state.q1),
                  state.q.modInverse(state.p)
                ),
                publicKey: pki2.rsa.setPublicKey(state.n, state.e)
              };
            }
            t2 = +/* @__PURE__ */ new Date();
            total += t2 - t1;
            t1 = t2;
          }
          return state.keys !== null;
        };
        pki2.rsa.generateKeyPair = function(bits2, e, options, callback) {
          if (arguments.length === 1) {
            if (typeof bits2 === "object") {
              options = bits2;
              bits2 = void 0;
            } else if (typeof bits2 === "function") {
              callback = bits2;
              bits2 = void 0;
            }
          } else if (arguments.length === 2) {
            if (typeof bits2 === "number") {
              if (typeof e === "function") {
                callback = e;
                e = void 0;
              } else if (typeof e !== "number") {
                options = e;
                e = void 0;
              }
            } else {
              options = bits2;
              callback = e;
              bits2 = void 0;
              e = void 0;
            }
          } else if (arguments.length === 3) {
            if (typeof e === "number") {
              if (typeof options === "function") {
                callback = options;
                options = void 0;
              }
            } else {
              callback = options;
              options = e;
              e = void 0;
            }
          }
          options = options || {};
          if (bits2 === void 0) {
            bits2 = options.bits || 2048;
          }
          if (e === void 0) {
            e = options.e || 65537;
          }
          if (!forge2.options.usePureJavaScript && !options.prng && bits2 >= 256 && bits2 <= 16384 && (e === 65537 || e === 3)) {
            if (callback) {
              if (_detectNodeCrypto("generateKeyPair")) {
                return _crypto.generateKeyPair("rsa", {
                  modulusLength: bits2,
                  publicExponent: e,
                  publicKeyEncoding: {
                    type: "spki",
                    format: "pem"
                  },
                  privateKeyEncoding: {
                    type: "pkcs8",
                    format: "pem"
                  }
                }, function(err2, pub, priv) {
                  if (err2) {
                    return callback(err2);
                  }
                  callback(null, {
                    privateKey: pki2.privateKeyFromPem(priv),
                    publicKey: pki2.publicKeyFromPem(pub)
                  });
                });
              }
              if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
                return util2.globalScope.crypto.subtle.generateKey({
                  name: "RSASSA-PKCS1-v1_5",
                  modulusLength: bits2,
                  publicExponent: _intToUint8Array(e),
                  hash: { name: "SHA-256" }
                }, true, ["sign", "verify"]).then(function(pair) {
                  return util2.globalScope.crypto.subtle.exportKey(
                    "pkcs8",
                    pair.privateKey
                  );
                }).then(void 0, function(err2) {
                  callback(err2);
                }).then(function(pkcs8) {
                  if (pkcs8) {
                    var privateKey = pki2.privateKeyFromAsn1(
                      asn12.fromDer(forge2.util.createBuffer(pkcs8))
                    );
                    callback(null, {
                      privateKey,
                      publicKey: pki2.setRsaPublicKey(privateKey.n, privateKey.e)
                    });
                  }
                });
              }
              if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
                var genOp = util2.globalScope.msCrypto.subtle.generateKey({
                  name: "RSASSA-PKCS1-v1_5",
                  modulusLength: bits2,
                  publicExponent: _intToUint8Array(e),
                  hash: { name: "SHA-256" }
                }, true, ["sign", "verify"]);
                genOp.oncomplete = function(e2) {
                  var pair = e2.target.result;
                  var exportOp = util2.globalScope.msCrypto.subtle.exportKey(
                    "pkcs8",
                    pair.privateKey
                  );
                  exportOp.oncomplete = function(e3) {
                    var pkcs8 = e3.target.result;
                    var privateKey = pki2.privateKeyFromAsn1(
                      asn12.fromDer(forge2.util.createBuffer(pkcs8))
                    );
                    callback(null, {
                      privateKey,
                      publicKey: pki2.setRsaPublicKey(privateKey.n, privateKey.e)
                    });
                  };
                  exportOp.onerror = function(err2) {
                    callback(err2);
                  };
                };
                genOp.onerror = function(err2) {
                  callback(err2);
                };
                return;
              }
            } else {
              if (_detectNodeCrypto("generateKeyPairSync")) {
                var keypair = _crypto.generateKeyPairSync("rsa", {
                  modulusLength: bits2,
                  publicExponent: e,
                  publicKeyEncoding: {
                    type: "spki",
                    format: "pem"
                  },
                  privateKeyEncoding: {
                    type: "pkcs8",
                    format: "pem"
                  }
                });
                return {
                  privateKey: pki2.privateKeyFromPem(keypair.privateKey),
                  publicKey: pki2.publicKeyFromPem(keypair.publicKey)
                };
              }
            }
          }
          var state = pki2.rsa.createKeyPairGenerationState(bits2, e, options);
          if (!callback) {
            pki2.rsa.stepKeyPairGenerationState(state, 0);
            return state.keys;
          }
          _generateKeyPair(state, options, callback);
        };
        pki2.setRsaPublicKey = pki2.rsa.setPublicKey = function(n, e) {
          var key = {
            n,
            e
          };
          key.encrypt = function(data, scheme, schemeOptions) {
            if (typeof scheme === "string") {
              scheme = scheme.toUpperCase();
            } else if (scheme === void 0) {
              scheme = "RSAES-PKCS1-V1_5";
            }
            if (scheme === "RSAES-PKCS1-V1_5") {
              scheme = {
                encode: function(m, key2, pub) {
                  return _encodePkcs1_v1_5(m, key2, 2).getBytes();
                }
              };
            } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
              scheme = {
                encode: function(m, key2) {
                  return forge2.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);
                }
              };
            } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
              scheme = { encode: function(e3) {
                return e3;
              } };
            } else if (typeof scheme === "string") {
              throw new Error('Unsupported encryption scheme: "' + scheme + '".');
            }
            var e2 = scheme.encode(data, key, true);
            return pki2.rsa.encrypt(e2, key, true);
          };
          key.verify = function(digest, signature, scheme, options) {
            if (typeof scheme === "string") {
              scheme = scheme.toUpperCase();
            } else if (scheme === void 0) {
              scheme = "RSASSA-PKCS1-V1_5";
            }
            if (options === void 0) {
              options = {
                _parseAllDigestBytes: true
              };
            }
            if (!("_parseAllDigestBytes" in options)) {
              options._parseAllDigestBytes = true;
            }
            if (scheme === "RSASSA-PKCS1-V1_5") {
              scheme = {
                verify: function(digest2, d2) {
                  d2 = _decodePkcs1_v1_5(d2, key, true);
                  var obj = asn12.fromDer(d2, {
                    parseAllBytes: options._parseAllDigestBytes
                  });
                  var capture = {};
                  var errors = [];
                  if (!asn12.validate(obj, digestInfoValidator, capture, errors)) {
                    var error = new Error(
                      "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
                    );
                    error.errors = errors;
                    throw error;
                  }
                  var oid = asn12.derToOid(capture.algorithmIdentifier);
                  if (!(oid === forge2.oids.md2 || oid === forge2.oids.md5 || oid === forge2.oids.sha1 || oid === forge2.oids.sha224 || oid === forge2.oids.sha256 || oid === forge2.oids.sha384 || oid === forge2.oids.sha512 || oid === forge2.oids["sha512-224"] || oid === forge2.oids["sha512-256"])) {
                    var error = new Error(
                      "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
                    );
                    error.oid = oid;
                    throw error;
                  }
                  if (oid === forge2.oids.md2 || oid === forge2.oids.md5) {
                    if (!("parameters" in capture)) {
                      throw new Error(
                        "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifier NULL parameters."
                      );
                    }
                  }
                  return digest2 === capture.digest;
                }
              };
            } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
              scheme = {
                verify: function(digest2, d2) {
                  d2 = _decodePkcs1_v1_5(d2, key, true);
                  return digest2 === d2;
                }
              };
            }
            var d = pki2.rsa.decrypt(signature, key, true, false);
            return scheme.verify(digest, d, key.n.bitLength());
          };
          return key;
        };
        pki2.setRsaPrivateKey = pki2.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
          var key = {
            n,
            e,
            d,
            p,
            q,
            dP,
            dQ,
            qInv
          };
          key.decrypt = function(data, scheme, schemeOptions) {
            if (typeof scheme === "string") {
              scheme = scheme.toUpperCase();
            } else if (scheme === void 0) {
              scheme = "RSAES-PKCS1-V1_5";
            }
            var d2 = pki2.rsa.decrypt(data, key, false, false);
            if (scheme === "RSAES-PKCS1-V1_5") {
              scheme = { decode: _decodePkcs1_v1_5 };
            } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
              scheme = {
                decode: function(d3, key2) {
                  return forge2.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
                }
              };
            } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
              scheme = { decode: function(d3) {
                return d3;
              } };
            } else {
              throw new Error('Unsupported encryption scheme: "' + scheme + '".');
            }
            return scheme.decode(d2, key, false);
          };
          key.sign = function(md2, scheme) {
            var bt = false;
            if (typeof scheme === "string") {
              scheme = scheme.toUpperCase();
            }
            if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
              scheme = { encode: emsaPkcs1v15encode };
              bt = 1;
            } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
              scheme = { encode: function() {
                return md2;
              } };
              bt = 1;
            }
            var d2 = scheme.encode(md2, key.n.bitLength());
            return pki2.rsa.encrypt(d2, key, bt);
          };
          return key;
        };
        pki2.wrapRsaPrivateKey = function(rsaKey) {
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // version (0)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              asn12.integerToDer(0).getBytes()
            ),
            // privateKeyAlgorithm
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(pki2.oids.rsaEncryption).getBytes()
              ),
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
            ]),
            // PrivateKey
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OCTETSTRING,
              false,
              asn12.toDer(rsaKey).getBytes()
            )
          ]);
        };
        pki2.privateKeyFromAsn1 = function(obj) {
          var capture = {};
          var errors = [];
          if (asn12.validate(obj, privateKeyValidator, capture, errors)) {
            obj = asn12.fromDer(forge2.util.createBuffer(capture.privateKey));
          }
          capture = {};
          errors = [];
          if (!asn12.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
            var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
            error.errors = errors;
            throw error;
          }
          var n, e, d, p, q, dP, dQ, qInv;
          n = forge2.util.createBuffer(capture.privateKeyModulus).toHex();
          e = forge2.util.createBuffer(capture.privateKeyPublicExponent).toHex();
          d = forge2.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
          p = forge2.util.createBuffer(capture.privateKeyPrime1).toHex();
          q = forge2.util.createBuffer(capture.privateKeyPrime2).toHex();
          dP = forge2.util.createBuffer(capture.privateKeyExponent1).toHex();
          dQ = forge2.util.createBuffer(capture.privateKeyExponent2).toHex();
          qInv = forge2.util.createBuffer(capture.privateKeyCoefficient).toHex();
          return pki2.setRsaPrivateKey(
            new BigInteger(n, 16),
            new BigInteger(e, 16),
            new BigInteger(d, 16),
            new BigInteger(p, 16),
            new BigInteger(q, 16),
            new BigInteger(dP, 16),
            new BigInteger(dQ, 16),
            new BigInteger(qInv, 16)
          );
        };
        pki2.privateKeyToAsn1 = pki2.privateKeyToRSAPrivateKey = function(key) {
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // version (0 = only 2 primes, 1 multiple primes)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              asn12.integerToDer(0).getBytes()
            ),
            // modulus (n)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.n)
            ),
            // publicExponent (e)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.e)
            ),
            // privateExponent (d)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.d)
            ),
            // privateKeyPrime1 (p)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.p)
            ),
            // privateKeyPrime2 (q)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.q)
            ),
            // privateKeyExponent1 (dP)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.dP)
            ),
            // privateKeyExponent2 (dQ)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.dQ)
            ),
            // coefficient (qInv)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.qInv)
            )
          ]);
        };
        pki2.publicKeyFromAsn1 = function(obj) {
          var capture = {};
          var errors = [];
          if (asn12.validate(obj, publicKeyValidator, capture, errors)) {
            var oid = asn12.derToOid(capture.publicKeyOid);
            if (oid !== pki2.oids.rsaEncryption) {
              var error = new Error("Cannot read public key. Unknown OID.");
              error.oid = oid;
              throw error;
            }
            obj = capture.rsaPublicKey;
          }
          errors = [];
          if (!asn12.validate(obj, rsaPublicKeyValidator, capture, errors)) {
            var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
            error.errors = errors;
            throw error;
          }
          var n = forge2.util.createBuffer(capture.publicKeyModulus).toHex();
          var e = forge2.util.createBuffer(capture.publicKeyExponent).toHex();
          return pki2.setRsaPublicKey(
            new BigInteger(n, 16),
            new BigInteger(e, 16)
          );
        };
        pki2.publicKeyToAsn1 = pki2.publicKeyToSubjectPublicKeyInfo = function(key) {
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // AlgorithmIdentifier
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // algorithm
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(pki2.oids.rsaEncryption).getBytes()
              ),
              // parameters (null)
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
            ]),
            // subjectPublicKey
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.BITSTRING, false, [
              pki2.publicKeyToRSAPublicKey(key)
            ])
          ]);
        };
        pki2.publicKeyToRSAPublicKey = function(key) {
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // modulus (n)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.n)
            ),
            // publicExponent (e)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              _bnToBytes(key.e)
            )
          ]);
        };
        function _encodePkcs1_v1_5(m, key, bt) {
          var eb = forge2.util.createBuffer();
          var k = Math.ceil(key.n.bitLength() / 8);
          if (m.length > k - 11) {
            var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
            error.length = m.length;
            error.max = k - 11;
            throw error;
          }
          eb.putByte(0);
          eb.putByte(bt);
          var padNum = k - 3 - m.length;
          var padByte;
          if (bt === 0 || bt === 1) {
            padByte = bt === 0 ? 0 : 255;
            for (var i = 0; i < padNum; ++i) {
              eb.putByte(padByte);
            }
          } else {
            while (padNum > 0) {
              var numZeros = 0;
              var padBytes = forge2.random.getBytes(padNum);
              for (var i = 0; i < padNum; ++i) {
                padByte = padBytes.charCodeAt(i);
                if (padByte === 0) {
                  ++numZeros;
                } else {
                  eb.putByte(padByte);
                }
              }
              padNum = numZeros;
            }
          }
          eb.putByte(0);
          eb.putBytes(m);
          return eb;
        }
        function _decodePkcs1_v1_5(em, key, pub, ml) {
          var k = Math.ceil(key.n.bitLength() / 8);
          var eb = forge2.util.createBuffer(em);
          var first = eb.getByte();
          var bt = eb.getByte();
          if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
            throw new Error("Encryption block is invalid.");
          }
          var padNum = 0;
          if (bt === 0) {
            padNum = k - 3 - ml;
            for (var i = 0; i < padNum; ++i) {
              if (eb.getByte() !== 0) {
                throw new Error("Encryption block is invalid.");
              }
            }
          } else if (bt === 1) {
            padNum = 0;
            while (eb.length() > 1) {
              if (eb.getByte() !== 255) {
                --eb.read;
                break;
              }
              ++padNum;
            }
          } else if (bt === 2) {
            padNum = 0;
            while (eb.length() > 1) {
              if (eb.getByte() === 0) {
                --eb.read;
                break;
              }
              ++padNum;
            }
          }
          var zero = eb.getByte();
          if (zero !== 0 || padNum !== k - 3 - eb.length()) {
            throw new Error("Encryption block is invalid.");
          }
          return eb.getBytes();
        }
        function _generateKeyPair(state, options, callback) {
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          options = options || {};
          var opts = {
            algorithm: {
              name: options.algorithm || "PRIMEINC",
              options: {
                workers: options.workers || 2,
                workLoad: options.workLoad || 100,
                workerScript: options.workerScript
              }
            }
          };
          if ("prng" in options) {
            opts.prng = options.prng;
          }
          generate();
          function generate() {
            getPrime(state.pBits, function(err2, num) {
              if (err2) {
                return callback(err2);
              }
              state.p = num;
              if (state.q !== null) {
                return finish(err2, state.q);
              }
              getPrime(state.qBits, finish);
            });
          }
          function getPrime(bits2, callback2) {
            forge2.prime.generateProbablePrime(bits2, opts, callback2);
          }
          function finish(err2, num) {
            if (err2) {
              return callback(err2);
            }
            state.q = num;
            if (state.p.compareTo(state.q) < 0) {
              var tmp = state.p;
              state.p = state.q;
              state.q = tmp;
            }
            if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
              state.p = null;
              generate();
              return;
            }
            if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
              state.q = null;
              getPrime(state.qBits, finish);
              return;
            }
            state.p1 = state.p.subtract(BigInteger.ONE);
            state.q1 = state.q.subtract(BigInteger.ONE);
            state.phi = state.p1.multiply(state.q1);
            if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
              state.p = state.q = null;
              generate();
              return;
            }
            state.n = state.p.multiply(state.q);
            if (state.n.bitLength() !== state.bits) {
              state.q = null;
              getPrime(state.qBits, finish);
              return;
            }
            var d = state.e.modInverse(state.phi);
            state.keys = {
              privateKey: pki2.rsa.setPrivateKey(
                state.n,
                state.e,
                d,
                state.p,
                state.q,
                d.mod(state.p1),
                d.mod(state.q1),
                state.q.modInverse(state.p)
              ),
              publicKey: pki2.rsa.setPublicKey(state.n, state.e)
            };
            callback(null, state.keys);
          }
        }
        function _bnToBytes(b) {
          var hex = b.toString(16);
          if (hex[0] >= "8") {
            hex = "00" + hex;
          }
          var bytes = forge2.util.hexToBytes(hex);
          if (bytes.length > 1 && // leading 0x00 for positive integer
          (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
          bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
            return bytes.substr(1);
          }
          return bytes;
        }
        function _getMillerRabinTests(bits2) {
          if (bits2 <= 100) return 27;
          if (bits2 <= 150) return 18;
          if (bits2 <= 200) return 15;
          if (bits2 <= 250) return 12;
          if (bits2 <= 300) return 9;
          if (bits2 <= 350) return 8;
          if (bits2 <= 400) return 7;
          if (bits2 <= 500) return 6;
          if (bits2 <= 600) return 5;
          if (bits2 <= 800) return 4;
          if (bits2 <= 1250) return 3;
          return 2;
        }
        function _detectNodeCrypto(fn) {
          return forge2.util.isNodejs && typeof _crypto[fn] === "function";
        }
        function _detectSubtleCrypto(fn) {
          return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.crypto === "object" && typeof util2.globalScope.crypto.subtle === "object" && typeof util2.globalScope.crypto.subtle[fn] === "function";
        }
        function _detectSubtleMsCrypto(fn) {
          return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.msCrypto === "object" && typeof util2.globalScope.msCrypto.subtle === "object" && typeof util2.globalScope.msCrypto.subtle[fn] === "function";
        }
        function _intToUint8Array(x) {
          var bytes = forge2.util.hexToBytes(x.toString(16));
          var buffer = new Uint8Array(bytes.length);
          for (var i = 0; i < bytes.length; ++i) {
            buffer[i] = bytes.charCodeAt(i);
          }
          return buffer;
        }
        return rsa;
      }
      var pbe;
      var hasRequiredPbe;
      function requirePbe() {
        if (hasRequiredPbe) return pbe;
        hasRequiredPbe = 1;
        var forge2 = requireForge();
        requireAes();
        requireAsn1();
        requireDes();
        requireMd();
        requireOids();
        requirePbkdf2();
        requirePem();
        requireRandom();
        requireRc2();
        requireRsa();
        requireUtil();
        if (typeof BigInteger === "undefined") {
          var BigInteger = forge2.jsbn.BigInteger;
        }
        var asn12 = forge2.asn1;
        var pki2 = forge2.pki = forge2.pki || {};
        pbe = pki2.pbe = forge2.pbe = forge2.pbe || {};
        var oids2 = pki2.oids;
        var encryptedPrivateKeyValidator = {
          name: "EncryptedPrivateKeyInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "encryptionOid"
            }, {
              name: "AlgorithmIdentifier.parameters",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "encryptionParams"
            }]
          }, {
            // encryptedData
            name: "EncryptedPrivateKeyInfo.encryptedData",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OCTETSTRING,
            constructed: false,
            capture: "encryptedData"
          }]
        };
        var PBES2AlgorithmsValidator = {
          name: "PBES2Algorithms",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.keyDerivationFunc",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "PBES2Algorithms.keyDerivationFunc.oid",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "kdfOid"
            }, {
              name: "PBES2Algorithms.params",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "PBES2Algorithms.params.salt",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.OCTETSTRING,
                constructed: false,
                capture: "kdfSalt"
              }, {
                name: "PBES2Algorithms.params.iterationCount",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.INTEGER,
                constructed: false,
                capture: "kdfIterationCount"
              }, {
                name: "PBES2Algorithms.params.keyLength",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.INTEGER,
                constructed: false,
                optional: true,
                capture: "keyLength"
              }, {
                // prf
                name: "PBES2Algorithms.params.prf",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.SEQUENCE,
                constructed: true,
                optional: true,
                value: [{
                  name: "PBES2Algorithms.params.prf.algorithm",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.OID,
                  constructed: false,
                  capture: "prfOid"
                }]
              }]
            }]
          }, {
            name: "PBES2Algorithms.encryptionScheme",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "PBES2Algorithms.encryptionScheme.oid",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "encOid"
            }, {
              name: "PBES2Algorithms.encryptionScheme.iv",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OCTETSTRING,
              constructed: false,
              capture: "encIv"
            }]
          }]
        };
        var pkcs12PbeParamsValidator = {
          name: "pkcs-12PbeParams",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "pkcs-12PbeParams.salt",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OCTETSTRING,
            constructed: false,
            capture: "salt"
          }, {
            name: "pkcs-12PbeParams.iterations",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "iterations"
          }]
        };
        pki2.encryptPrivateKeyInfo = function(obj, password, options) {
          options = options || {};
          options.saltSize = options.saltSize || 8;
          options.count = options.count || 2048;
          options.algorithm = options.algorithm || "aes128";
          options.prfAlgorithm = options.prfAlgorithm || "sha1";
          var salt = forge2.random.getBytesSync(options.saltSize);
          var count = options.count;
          var countBytes = asn12.integerToDer(count);
          var dkLen;
          var encryptionAlgorithm;
          var encryptedData;
          if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
            var ivLen, encOid, cipherFn;
            switch (options.algorithm) {
              case "aes128":
                dkLen = 16;
                ivLen = 16;
                encOid = oids2["aes128-CBC"];
                cipherFn = forge2.aes.createEncryptionCipher;
                break;
              case "aes192":
                dkLen = 24;
                ivLen = 16;
                encOid = oids2["aes192-CBC"];
                cipherFn = forge2.aes.createEncryptionCipher;
                break;
              case "aes256":
                dkLen = 32;
                ivLen = 16;
                encOid = oids2["aes256-CBC"];
                cipherFn = forge2.aes.createEncryptionCipher;
                break;
              case "des":
                dkLen = 8;
                ivLen = 8;
                encOid = oids2["desCBC"];
                cipherFn = forge2.des.createEncryptionCipher;
                break;
              default:
                var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
                error.algorithm = options.algorithm;
                throw error;
            }
            var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
            var md2 = prfAlgorithmToMessageDigest(prfAlgorithm);
            var dk = forge2.pkcs5.pbkdf2(password, salt, count, dkLen, md2);
            var iv = forge2.random.getBytesSync(ivLen);
            var cipher2 = cipherFn(dk);
            cipher2.start(iv);
            cipher2.update(asn12.toDer(obj));
            cipher2.finish();
            encryptedData = cipher2.output.getBytes();
            var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
            encryptionAlgorithm = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.SEQUENCE,
              true,
              [
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(oids2["pkcs5PBES2"]).getBytes()
                ),
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                  // keyDerivationFunc
                  asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.OID,
                      false,
                      asn12.oidToDer(oids2["pkcs5PBKDF2"]).getBytes()
                    ),
                    // PBKDF2-params
                    params
                  ]),
                  // encryptionScheme
                  asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.OID,
                      false,
                      asn12.oidToDer(encOid).getBytes()
                    ),
                    // iv
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.OCTETSTRING,
                      false,
                      iv
                    )
                  ])
                ])
              ]
            );
          } else if (options.algorithm === "3des") {
            dkLen = 24;
            var saltBytes = new forge2.util.ByteBuffer(salt);
            var dk = pki2.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
            var iv = pki2.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
            var cipher2 = forge2.des.createEncryptionCipher(dk);
            cipher2.start(iv);
            cipher2.update(asn12.toDer(obj));
            cipher2.finish();
            encryptedData = cipher2.output.getBytes();
            encryptionAlgorithm = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.SEQUENCE,
              true,
              [
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(oids2["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
                ),
                // pkcs-12PbeParams
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                  // salt
                  asn12.create(asn12.Class.UNIVERSAL, asn12.Type.OCTETSTRING, false, salt),
                  // iteration count
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.INTEGER,
                    false,
                    countBytes.getBytes()
                  )
                ])
              ]
            );
          } else {
            var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error.algorithm = options.algorithm;
            throw error;
          }
          var rval = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // encryptionAlgorithm
            encryptionAlgorithm,
            // encryptedData
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OCTETSTRING,
              false,
              encryptedData
            )
          ]);
          return rval;
        };
        pki2.decryptPrivateKeyInfo = function(obj, password) {
          var rval = null;
          var capture = {};
          var errors = [];
          if (!asn12.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
            var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
            error.errors = errors;
            throw error;
          }
          var oid = asn12.derToOid(capture.encryptionOid);
          var cipher2 = pki2.pbe.getCipher(oid, capture.encryptionParams, password);
          var encrypted = forge2.util.createBuffer(capture.encryptedData);
          cipher2.update(encrypted);
          if (cipher2.finish()) {
            rval = asn12.fromDer(cipher2.output);
          }
          return rval;
        };
        pki2.encryptedPrivateKeyToPem = function(epki, maxline) {
          var msg = {
            type: "ENCRYPTED PRIVATE KEY",
            body: asn12.toDer(epki).getBytes()
          };
          return forge2.pem.encode(msg, { maxline });
        };
        pki2.encryptedPrivateKeyFromPem = function(pem2) {
          var msg = forge2.pem.decode(pem2)[0];
          if (msg.type !== "ENCRYPTED PRIVATE KEY") {
            var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
          }
          return asn12.fromDer(msg.body);
        };
        pki2.encryptRsaPrivateKey = function(rsaKey, password, options) {
          options = options || {};
          if (!options.legacy) {
            var rval = pki2.wrapRsaPrivateKey(pki2.privateKeyToAsn1(rsaKey));
            rval = pki2.encryptPrivateKeyInfo(rval, password, options);
            return pki2.encryptedPrivateKeyToPem(rval);
          }
          var algorithm;
          var iv;
          var dkLen;
          var cipherFn;
          switch (options.algorithm) {
            case "aes128":
              algorithm = "AES-128-CBC";
              dkLen = 16;
              iv = forge2.random.getBytesSync(16);
              cipherFn = forge2.aes.createEncryptionCipher;
              break;
            case "aes192":
              algorithm = "AES-192-CBC";
              dkLen = 24;
              iv = forge2.random.getBytesSync(16);
              cipherFn = forge2.aes.createEncryptionCipher;
              break;
            case "aes256":
              algorithm = "AES-256-CBC";
              dkLen = 32;
              iv = forge2.random.getBytesSync(16);
              cipherFn = forge2.aes.createEncryptionCipher;
              break;
            case "3des":
              algorithm = "DES-EDE3-CBC";
              dkLen = 24;
              iv = forge2.random.getBytesSync(8);
              cipherFn = forge2.des.createEncryptionCipher;
              break;
            case "des":
              algorithm = "DES-CBC";
              dkLen = 8;
              iv = forge2.random.getBytesSync(8);
              cipherFn = forge2.des.createEncryptionCipher;
              break;
            default:
              var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
              error.algorithm = options.algorithm;
              throw error;
          }
          var dk = forge2.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
          var cipher2 = cipherFn(dk);
          cipher2.start(iv);
          cipher2.update(asn12.toDer(pki2.privateKeyToAsn1(rsaKey)));
          cipher2.finish();
          var msg = {
            type: "RSA PRIVATE KEY",
            procType: {
              version: "4",
              type: "ENCRYPTED"
            },
            dekInfo: {
              algorithm,
              parameters: forge2.util.bytesToHex(iv).toUpperCase()
            },
            body: cipher2.output.getBytes()
          };
          return forge2.pem.encode(msg);
        };
        pki2.decryptRsaPrivateKey = function(pem2, password) {
          var rval = null;
          var msg = forge2.pem.decode(pem2)[0];
          if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
            var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
            error.headerType = error;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            var dkLen;
            var cipherFn;
            switch (msg.dekInfo.algorithm) {
              case "DES-CBC":
                dkLen = 8;
                cipherFn = forge2.des.createDecryptionCipher;
                break;
              case "DES-EDE3-CBC":
                dkLen = 24;
                cipherFn = forge2.des.createDecryptionCipher;
                break;
              case "AES-128-CBC":
                dkLen = 16;
                cipherFn = forge2.aes.createDecryptionCipher;
                break;
              case "AES-192-CBC":
                dkLen = 24;
                cipherFn = forge2.aes.createDecryptionCipher;
                break;
              case "AES-256-CBC":
                dkLen = 32;
                cipherFn = forge2.aes.createDecryptionCipher;
                break;
              case "RC2-40-CBC":
                dkLen = 5;
                cipherFn = function(key) {
                  return forge2.rc2.createDecryptionCipher(key, 40);
                };
                break;
              case "RC2-64-CBC":
                dkLen = 8;
                cipherFn = function(key) {
                  return forge2.rc2.createDecryptionCipher(key, 64);
                };
                break;
              case "RC2-128-CBC":
                dkLen = 16;
                cipherFn = function(key) {
                  return forge2.rc2.createDecryptionCipher(key, 128);
                };
                break;
              default:
                var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
                error.algorithm = msg.dekInfo.algorithm;
                throw error;
            }
            var iv = forge2.util.hexToBytes(msg.dekInfo.parameters);
            var dk = forge2.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
            var cipher2 = cipherFn(dk);
            cipher2.start(iv);
            cipher2.update(forge2.util.createBuffer(msg.body));
            if (cipher2.finish()) {
              rval = cipher2.output.getBytes();
            } else {
              return rval;
            }
          } else {
            rval = msg.body;
          }
          if (msg.type === "ENCRYPTED PRIVATE KEY") {
            rval = pki2.decryptPrivateKeyInfo(asn12.fromDer(rval), password);
          } else {
            rval = asn12.fromDer(rval);
          }
          if (rval !== null) {
            rval = pki2.privateKeyFromAsn1(rval);
          }
          return rval;
        };
        pki2.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md2) {
          var j, l;
          if (typeof md2 === "undefined" || md2 === null) {
            if (!("sha1" in forge2.md)) {
              throw new Error('"sha1" hash algorithm unavailable.');
            }
            md2 = forge2.md.sha1.create();
          }
          var u = md2.digestLength;
          var v = md2.blockLength;
          var result = new forge2.util.ByteBuffer();
          var passBuf = new forge2.util.ByteBuffer();
          if (password !== null && password !== void 0) {
            for (l = 0; l < password.length; l++) {
              passBuf.putInt16(password.charCodeAt(l));
            }
            passBuf.putInt16(0);
          }
          var p = passBuf.length();
          var s = salt.length();
          var D = new forge2.util.ByteBuffer();
          D.fillWithByte(id, v);
          var Slen = v * Math.ceil(s / v);
          var S = new forge2.util.ByteBuffer();
          for (l = 0; l < Slen; l++) {
            S.putByte(salt.at(l % s));
          }
          var Plen = v * Math.ceil(p / v);
          var P = new forge2.util.ByteBuffer();
          for (l = 0; l < Plen; l++) {
            P.putByte(passBuf.at(l % p));
          }
          var I = S;
          I.putBuffer(P);
          var c = Math.ceil(n / u);
          for (var i = 1; i <= c; i++) {
            var buf = new forge2.util.ByteBuffer();
            buf.putBytes(D.bytes());
            buf.putBytes(I.bytes());
            for (var round = 0; round < iter; round++) {
              md2.start();
              md2.update(buf.getBytes());
              buf = md2.digest();
            }
            var B = new forge2.util.ByteBuffer();
            for (l = 0; l < v; l++) {
              B.putByte(buf.at(l % u));
            }
            var k = Math.ceil(s / v) + Math.ceil(p / v);
            var Inew = new forge2.util.ByteBuffer();
            for (j = 0; j < k; j++) {
              var chunk = new forge2.util.ByteBuffer(I.getBytes(v));
              var x = 511;
              for (l = B.length() - 1; l >= 0; l--) {
                x = x >> 8;
                x += B.at(l) + chunk.at(l);
                chunk.setAt(l, x & 255);
              }
              Inew.putBuffer(chunk);
            }
            I = Inew;
            result.putBuffer(buf);
          }
          result.truncate(result.length() - n);
          return result;
        };
        pki2.pbe.getCipher = function(oid, params, password) {
          switch (oid) {
            case pki2.oids["pkcs5PBES2"]:
              return pki2.pbe.getCipherForPBES2(oid, params, password);
            case pki2.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
            case pki2.oids["pbewithSHAAnd40BitRC2-CBC"]:
              return pki2.pbe.getCipherForPKCS12PBE(oid, params, password);
            default:
              var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
              error.oid = oid;
              error.supportedOids = [
                "pkcs5PBES2",
                "pbeWithSHAAnd3-KeyTripleDES-CBC",
                "pbewithSHAAnd40BitRC2-CBC"
              ];
              throw error;
          }
        };
        pki2.pbe.getCipherForPBES2 = function(oid, params, password) {
          var capture = {};
          var errors = [];
          if (!asn12.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
            var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
            error.errors = errors;
            throw error;
          }
          oid = asn12.derToOid(capture.kdfOid);
          if (oid !== pki2.oids["pkcs5PBKDF2"]) {
            var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
            error.oid = oid;
            error.supportedOids = ["pkcs5PBKDF2"];
            throw error;
          }
          oid = asn12.derToOid(capture.encOid);
          if (oid !== pki2.oids["aes128-CBC"] && oid !== pki2.oids["aes192-CBC"] && oid !== pki2.oids["aes256-CBC"] && oid !== pki2.oids["des-EDE3-CBC"] && oid !== pki2.oids["desCBC"]) {
            var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
            error.oid = oid;
            error.supportedOids = [
              "aes128-CBC",
              "aes192-CBC",
              "aes256-CBC",
              "des-EDE3-CBC",
              "desCBC"
            ];
            throw error;
          }
          var salt = capture.kdfSalt;
          var count = forge2.util.createBuffer(capture.kdfIterationCount);
          count = count.getInt(count.length() << 3);
          var dkLen;
          var cipherFn;
          switch (pki2.oids[oid]) {
            case "aes128-CBC":
              dkLen = 16;
              cipherFn = forge2.aes.createDecryptionCipher;
              break;
            case "aes192-CBC":
              dkLen = 24;
              cipherFn = forge2.aes.createDecryptionCipher;
              break;
            case "aes256-CBC":
              dkLen = 32;
              cipherFn = forge2.aes.createDecryptionCipher;
              break;
            case "des-EDE3-CBC":
              dkLen = 24;
              cipherFn = forge2.des.createDecryptionCipher;
              break;
            case "desCBC":
              dkLen = 8;
              cipherFn = forge2.des.createDecryptionCipher;
              break;
          }
          var md2 = prfOidToMessageDigest(capture.prfOid);
          var dk = forge2.pkcs5.pbkdf2(password, salt, count, dkLen, md2);
          var iv = capture.encIv;
          var cipher2 = cipherFn(dk);
          cipher2.start(iv);
          return cipher2;
        };
        pki2.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
          var capture = {};
          var errors = [];
          if (!asn12.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
            var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
            error.errors = errors;
            throw error;
          }
          var salt = forge2.util.createBuffer(capture.salt);
          var count = forge2.util.createBuffer(capture.iterations);
          count = count.getInt(count.length() << 3);
          var dkLen, dIvLen, cipherFn;
          switch (oid) {
            case pki2.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
              dkLen = 24;
              dIvLen = 8;
              cipherFn = forge2.des.startDecrypting;
              break;
            case pki2.oids["pbewithSHAAnd40BitRC2-CBC"]:
              dkLen = 5;
              dIvLen = 8;
              cipherFn = function(key2, iv2) {
                var cipher2 = forge2.rc2.createDecryptionCipher(key2, 40);
                cipher2.start(iv2, null);
                return cipher2;
              };
              break;
            default:
              var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
              error.oid = oid;
              throw error;
          }
          var md2 = prfOidToMessageDigest(capture.prfOid);
          var key = pki2.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md2);
          md2.start();
          var iv = pki2.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md2);
          return cipherFn(key, iv);
        };
        pki2.pbe.opensslDeriveBytes = function(password, salt, dkLen, md2) {
          if (typeof md2 === "undefined" || md2 === null) {
            if (!("md5" in forge2.md)) {
              throw new Error('"md5" hash algorithm unavailable.');
            }
            md2 = forge2.md.md5.create();
          }
          if (salt === null) {
            salt = "";
          }
          var digests = [hash(md2, password + salt)];
          for (var length = 16, i = 1; length < dkLen; ++i, length += 16) {
            digests.push(hash(md2, digests[i - 1] + password + salt));
          }
          return digests.join("").substr(0, dkLen);
        };
        function hash(md2, bytes) {
          return md2.start().update(bytes).digest().getBytes();
        }
        function prfOidToMessageDigest(prfOid) {
          var prfAlgorithm;
          if (!prfOid) {
            prfAlgorithm = "hmacWithSHA1";
          } else {
            prfAlgorithm = pki2.oids[asn12.derToOid(prfOid)];
            if (!prfAlgorithm) {
              var error = new Error("Unsupported PRF OID.");
              error.oid = prfOid;
              error.supported = [
                "hmacWithSHA1",
                "hmacWithSHA224",
                "hmacWithSHA256",
                "hmacWithSHA384",
                "hmacWithSHA512"
              ];
              throw error;
            }
          }
          return prfAlgorithmToMessageDigest(prfAlgorithm);
        }
        function prfAlgorithmToMessageDigest(prfAlgorithm) {
          var factory = forge2.md;
          switch (prfAlgorithm) {
            case "hmacWithSHA224":
              factory = forge2.md.sha512;
            case "hmacWithSHA1":
            case "hmacWithSHA256":
            case "hmacWithSHA384":
            case "hmacWithSHA512":
              prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
              break;
            default:
              var error = new Error("Unsupported PRF algorithm.");
              error.algorithm = prfAlgorithm;
              error.supported = [
                "hmacWithSHA1",
                "hmacWithSHA224",
                "hmacWithSHA256",
                "hmacWithSHA384",
                "hmacWithSHA512"
              ];
              throw error;
          }
          if (!factory || !(prfAlgorithm in factory)) {
            throw new Error("Unknown hash algorithm: " + prfAlgorithm);
          }
          return factory[prfAlgorithm].create();
        }
        function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
          var params = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // salt
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OCTETSTRING,
              false,
              salt
            ),
            // iteration count
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              countBytes.getBytes()
            )
          ]);
          if (prfAlgorithm !== "hmacWithSHA1") {
            params.value.push(
              // key length
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.INTEGER,
                false,
                forge2.util.hexToBytes(dkLen.toString(16))
              ),
              // AlgorithmIdentifier
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // algorithm
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(pki2.oids[prfAlgorithm]).getBytes()
                ),
                // parameters (null)
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
              ])
            );
          }
          return params;
        }
        return pbe;
      }
      var pkcs12 = { exports: {} };
      var pkcs7asn1 = { exports: {} };
      var hasRequiredPkcs7asn1;
      function requirePkcs7asn1() {
        if (hasRequiredPkcs7asn1) return pkcs7asn1.exports;
        hasRequiredPkcs7asn1 = 1;
        var forge2 = requireForge();
        requireAsn1();
        requireUtil();
        var asn12 = forge2.asn1;
        var p7v = pkcs7asn1.exports = forge2.pkcs7asn1 = forge2.pkcs7asn1 || {};
        forge2.pkcs7 = forge2.pkcs7 || {};
        forge2.pkcs7.asn1 = p7v;
        var contentInfoValidator = {
          name: "ContentInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "ContentInfo.ContentType",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OID,
            constructed: false,
            capture: "contentType"
          }, {
            name: "ContentInfo.content",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            captureAsn1: "content"
          }]
        };
        p7v.contentInfoValidator = contentInfoValidator;
        var encryptedContentInfoValidator = {
          name: "EncryptedContentInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "EncryptedContentInfo.contentType",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OID,
            constructed: false,
            capture: "contentType"
          }, {
            name: "EncryptedContentInfo.contentEncryptionAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "encAlgorithm"
            }, {
              name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
              tagClass: asn12.Class.UNIVERSAL,
              captureAsn1: "encParameter"
            }]
          }, {
            name: "EncryptedContentInfo.encryptedContent",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            type: 0,
            /* The PKCS#7 structure output by OpenSSL somewhat differs from what
             * other implementations do generate.
             *
             * OpenSSL generates a structure like this:
             * SEQUENCE {
             *    ...
             *    [0]
             *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
             *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
             *       ...
             * }
             *
             * Whereas other implementations (and this PKCS#7 module) generate:
             * SEQUENCE {
             *    ...
             *    [0] {
             *       OCTET STRING
             *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
             *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
             *          ...
             *    }
             * }
             *
             * In order to support both, we just capture the context specific
             * field here.  The OCTET STRING bit is removed below.
             */
            capture: "encryptedContent",
            captureAsn1: "encryptedContentAsn1"
          }]
        };
        p7v.envelopedDataValidator = {
          name: "EnvelopedData",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "EnvelopedData.Version",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "version"
          }, {
            name: "EnvelopedData.RecipientInfos",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SET,
            constructed: true,
            captureAsn1: "recipientInfos"
          }].concat(encryptedContentInfoValidator)
        };
        p7v.encryptedDataValidator = {
          name: "EncryptedData",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "EncryptedData.Version",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "version"
          }].concat(encryptedContentInfoValidator)
        };
        var signerValidator = {
          name: "SignerInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "SignerInfo.version",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false
          }, {
            name: "SignerInfo.issuerAndSerialNumber",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "SignerInfo.issuerAndSerialNumber.issuer",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "issuer"
            }, {
              name: "SignerInfo.issuerAndSerialNumber.serialNumber",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.INTEGER,
              constructed: false,
              capture: "serial"
            }]
          }, {
            name: "SignerInfo.digestAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "SignerInfo.digestAlgorithm.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "digestAlgorithm"
            }, {
              name: "SignerInfo.digestAlgorithm.parameter",
              tagClass: asn12.Class.UNIVERSAL,
              constructed: false,
              captureAsn1: "digestParameter",
              optional: true
            }]
          }, {
            name: "SignerInfo.authenticatedAttributes",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            capture: "authenticatedAttributes"
          }, {
            name: "SignerInfo.digestEncryptionAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            capture: "signatureAlgorithm"
          }, {
            name: "SignerInfo.encryptedDigest",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OCTETSTRING,
            constructed: false,
            capture: "signature"
          }, {
            name: "SignerInfo.unauthenticatedAttributes",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            capture: "unauthenticatedAttributes"
          }]
        };
        p7v.signedDataValidator = {
          name: "SignedData",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "SignedData.Version",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.INTEGER,
              constructed: false,
              capture: "version"
            },
            {
              name: "SignedData.DigestAlgorithms",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SET,
              constructed: true,
              captureAsn1: "digestAlgorithms"
            },
            contentInfoValidator,
            {
              name: "SignedData.Certificates",
              tagClass: asn12.Class.CONTEXT_SPECIFIC,
              type: 0,
              optional: true,
              captureAsn1: "certificates"
            },
            {
              name: "SignedData.CertificateRevocationLists",
              tagClass: asn12.Class.CONTEXT_SPECIFIC,
              type: 1,
              optional: true,
              captureAsn1: "crls"
            },
            {
              name: "SignedData.SignerInfos",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SET,
              capture: "signerInfos",
              optional: true,
              value: [signerValidator]
            }
          ]
        };
        p7v.recipientInfoValidator = {
          name: "RecipientInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "RecipientInfo.version",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "version"
          }, {
            name: "RecipientInfo.issuerAndSerial",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "RecipientInfo.issuerAndSerial.issuer",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "issuer"
            }, {
              name: "RecipientInfo.issuerAndSerial.serialNumber",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.INTEGER,
              constructed: false,
              capture: "serial"
            }]
          }, {
            name: "RecipientInfo.keyEncryptionAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "encAlgorithm"
            }, {
              name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
              tagClass: asn12.Class.UNIVERSAL,
              constructed: false,
              captureAsn1: "encParameter",
              optional: true
            }]
          }, {
            name: "RecipientInfo.encryptedKey",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OCTETSTRING,
            constructed: false,
            capture: "encKey"
          }]
        };
        return pkcs7asn1.exports;
      }
      var x509 = { exports: {} };
      var mgf1 = { exports: {} };
      var hasRequiredMgf1;
      function requireMgf1() {
        if (hasRequiredMgf1) return mgf1.exports;
        hasRequiredMgf1 = 1;
        var forge2 = requireForge();
        requireUtil();
        forge2.mgf = forge2.mgf || {};
        var mgf1$1 = mgf1.exports = forge2.mgf.mgf1 = forge2.mgf1 = forge2.mgf1 || {};
        mgf1$1.create = function(md2) {
          var mgf2 = {
            /**
             * Generate mask of specified length.
             *
             * @param {String} seed The seed for mask generation.
             * @param maskLen Number of bytes to generate.
             * @return {String} The generated mask.
             */
            generate: function(seed, maskLen) {
              var t = new forge2.util.ByteBuffer();
              var len = Math.ceil(maskLen / md2.digestLength);
              for (var i = 0; i < len; i++) {
                var c = new forge2.util.ByteBuffer();
                c.putInt32(i);
                md2.start();
                md2.update(seed + c.getBytes());
                t.putBuffer(md2.digest());
              }
              t.truncate(t.length() - maskLen);
              return t.getBytes();
            }
          };
          return mgf2;
        };
        return mgf1.exports;
      }
      var mgf;
      var hasRequiredMgf;
      function requireMgf() {
        if (hasRequiredMgf) return mgf;
        hasRequiredMgf = 1;
        var forge2 = requireForge();
        requireMgf1();
        mgf = forge2.mgf = forge2.mgf || {};
        forge2.mgf.mgf1 = forge2.mgf1;
        return mgf;
      }
      var pss = { exports: {} };
      var hasRequiredPss;
      function requirePss() {
        if (hasRequiredPss) return pss.exports;
        hasRequiredPss = 1;
        var forge2 = requireForge();
        requireRandom();
        requireUtil();
        var pss$1 = pss.exports = forge2.pss = forge2.pss || {};
        pss$1.create = function(options) {
          if (arguments.length === 3) {
            options = {
              md: arguments[0],
              mgf: arguments[1],
              saltLength: arguments[2]
            };
          }
          var hash = options.md;
          var mgf2 = options.mgf;
          var hLen = hash.digestLength;
          var salt_ = options.salt || null;
          if (typeof salt_ === "string") {
            salt_ = forge2.util.createBuffer(salt_);
          }
          var sLen;
          if ("saltLength" in options) {
            sLen = options.saltLength;
          } else if (salt_ !== null) {
            sLen = salt_.length();
          } else {
            throw new Error("Salt length not specified or specific salt not given.");
          }
          if (salt_ !== null && salt_.length() !== sLen) {
            throw new Error("Given salt length does not match length of given salt.");
          }
          var prng2 = options.prng || forge2.random;
          var pssobj = {};
          pssobj.encode = function(md2, modBits) {
            var i;
            var emBits = modBits - 1;
            var emLen = Math.ceil(emBits / 8);
            var mHash = md2.digest().getBytes();
            if (emLen < hLen + sLen + 2) {
              throw new Error("Message is too long to encrypt.");
            }
            var salt;
            if (salt_ === null) {
              salt = prng2.getBytesSync(sLen);
            } else {
              salt = salt_.bytes();
            }
            var m_ = new forge2.util.ByteBuffer();
            m_.fillWithByte(0, 8);
            m_.putBytes(mHash);
            m_.putBytes(salt);
            hash.start();
            hash.update(m_.getBytes());
            var h = hash.digest().getBytes();
            var ps = new forge2.util.ByteBuffer();
            ps.fillWithByte(0, emLen - sLen - hLen - 2);
            ps.putByte(1);
            ps.putBytes(salt);
            var db = ps.getBytes();
            var maskLen = emLen - hLen - 1;
            var dbMask = mgf2.generate(h, maskLen);
            var maskedDB = "";
            for (i = 0; i < maskLen; i++) {
              maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
            }
            var mask = 65280 >> 8 * emLen - emBits & 255;
            maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
            return maskedDB + h + String.fromCharCode(188);
          };
          pssobj.verify = function(mHash, em, modBits) {
            var i;
            var emBits = modBits - 1;
            var emLen = Math.ceil(emBits / 8);
            em = em.substr(-emLen);
            if (emLen < hLen + sLen + 2) {
              throw new Error("Inconsistent parameters to PSS signature verification.");
            }
            if (em.charCodeAt(emLen - 1) !== 188) {
              throw new Error("Encoded message does not end in 0xBC.");
            }
            var maskLen = emLen - hLen - 1;
            var maskedDB = em.substr(0, maskLen);
            var h = em.substr(maskLen, hLen);
            var mask = 65280 >> 8 * emLen - emBits & 255;
            if ((maskedDB.charCodeAt(0) & mask) !== 0) {
              throw new Error("Bits beyond keysize not zero as expected.");
            }
            var dbMask = mgf2.generate(h, maskLen);
            var db = "";
            for (i = 0; i < maskLen; i++) {
              db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
            }
            db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
            var checkLen = emLen - hLen - sLen - 2;
            for (i = 0; i < checkLen; i++) {
              if (db.charCodeAt(i) !== 0) {
                throw new Error("Leftmost octets not zero as expected");
              }
            }
            if (db.charCodeAt(checkLen) !== 1) {
              throw new Error("Inconsistent PSS signature, 0x01 marker not found");
            }
            var salt = db.substr(-sLen);
            var m_ = new forge2.util.ByteBuffer();
            m_.fillWithByte(0, 8);
            m_.putBytes(mHash);
            m_.putBytes(salt);
            hash.start();
            hash.update(m_.getBytes());
            var h_ = hash.digest().getBytes();
            return h === h_;
          };
          return pssobj;
        };
        return pss.exports;
      }
      var hasRequiredX509;
      function requireX509() {
        if (hasRequiredX509) return x509.exports;
        hasRequiredX509 = 1;
        var forge2 = requireForge();
        requireAes();
        requireAsn1();
        requireDes();
        requireMd();
        requireMgf();
        requireOids();
        requirePem();
        requirePss();
        requireRsa();
        requireUtil();
        var asn12 = forge2.asn1;
        var pki2 = x509.exports = forge2.pki = forge2.pki || {};
        var oids2 = pki2.oids;
        var _shortNames = {};
        _shortNames["CN"] = oids2["commonName"];
        _shortNames["commonName"] = "CN";
        _shortNames["C"] = oids2["countryName"];
        _shortNames["countryName"] = "C";
        _shortNames["L"] = oids2["localityName"];
        _shortNames["localityName"] = "L";
        _shortNames["ST"] = oids2["stateOrProvinceName"];
        _shortNames["stateOrProvinceName"] = "ST";
        _shortNames["O"] = oids2["organizationName"];
        _shortNames["organizationName"] = "O";
        _shortNames["OU"] = oids2["organizationalUnitName"];
        _shortNames["organizationalUnitName"] = "OU";
        _shortNames["E"] = oids2["emailAddress"];
        _shortNames["emailAddress"] = "E";
        var publicKeyValidator = forge2.pki.rsa.publicKeyValidator;
        var x509CertificateValidator = {
          name: "Certificate",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "Certificate.TBSCertificate",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "tbsCertificate",
            value: [
              {
                name: "Certificate.TBSCertificate.version",
                tagClass: asn12.Class.CONTEXT_SPECIFIC,
                type: 0,
                constructed: true,
                optional: true,
                value: [{
                  name: "Certificate.TBSCertificate.version.integer",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.INTEGER,
                  constructed: false,
                  capture: "certVersion"
                }]
              },
              {
                name: "Certificate.TBSCertificate.serialNumber",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.INTEGER,
                constructed: false,
                capture: "certSerialNumber"
              },
              {
                name: "Certificate.TBSCertificate.signature",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.SEQUENCE,
                constructed: true,
                value: [{
                  name: "Certificate.TBSCertificate.signature.algorithm",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.OID,
                  constructed: false,
                  capture: "certinfoSignatureOid"
                }, {
                  name: "Certificate.TBSCertificate.signature.parameters",
                  tagClass: asn12.Class.UNIVERSAL,
                  optional: true,
                  captureAsn1: "certinfoSignatureParams"
                }]
              },
              {
                name: "Certificate.TBSCertificate.issuer",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.SEQUENCE,
                constructed: true,
                captureAsn1: "certIssuer"
              },
              {
                name: "Certificate.TBSCertificate.validity",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.SEQUENCE,
                constructed: true,
                // Note: UTC and generalized times may both appear so the capture
                // names are based on their detected order, the names used below
                // are only for the common case, which validity time really means
                // "notBefore" and which means "notAfter" will be determined by order
                value: [{
                  // notBefore (Time) (UTC time case)
                  name: "Certificate.TBSCertificate.validity.notBefore (utc)",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.UTCTIME,
                  constructed: false,
                  optional: true,
                  capture: "certValidity1UTCTime"
                }, {
                  // notBefore (Time) (generalized time case)
                  name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.GENERALIZEDTIME,
                  constructed: false,
                  optional: true,
                  capture: "certValidity2GeneralizedTime"
                }, {
                  // notAfter (Time) (only UTC time is supported)
                  name: "Certificate.TBSCertificate.validity.notAfter (utc)",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.UTCTIME,
                  constructed: false,
                  optional: true,
                  capture: "certValidity3UTCTime"
                }, {
                  // notAfter (Time) (only UTC time is supported)
                  name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.GENERALIZEDTIME,
                  constructed: false,
                  optional: true,
                  capture: "certValidity4GeneralizedTime"
                }]
              },
              {
                // Name (subject) (RDNSequence)
                name: "Certificate.TBSCertificate.subject",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.SEQUENCE,
                constructed: true,
                captureAsn1: "certSubject"
              },
              // SubjectPublicKeyInfo
              publicKeyValidator,
              {
                // issuerUniqueID (optional)
                name: "Certificate.TBSCertificate.issuerUniqueID",
                tagClass: asn12.Class.CONTEXT_SPECIFIC,
                type: 1,
                constructed: true,
                optional: true,
                value: [{
                  name: "Certificate.TBSCertificate.issuerUniqueID.id",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.BITSTRING,
                  constructed: false,
                  // TODO: support arbitrary bit length ids
                  captureBitStringValue: "certIssuerUniqueId"
                }]
              },
              {
                // subjectUniqueID (optional)
                name: "Certificate.TBSCertificate.subjectUniqueID",
                tagClass: asn12.Class.CONTEXT_SPECIFIC,
                type: 2,
                constructed: true,
                optional: true,
                value: [{
                  name: "Certificate.TBSCertificate.subjectUniqueID.id",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.BITSTRING,
                  constructed: false,
                  // TODO: support arbitrary bit length ids
                  captureBitStringValue: "certSubjectUniqueId"
                }]
              },
              {
                // Extensions (optional)
                name: "Certificate.TBSCertificate.extensions",
                tagClass: asn12.Class.CONTEXT_SPECIFIC,
                type: 3,
                constructed: true,
                captureAsn1: "certExtensions",
                optional: true
              }
            ]
          }, {
            // AlgorithmIdentifier (signature algorithm)
            name: "Certificate.signatureAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              // algorithm
              name: "Certificate.signatureAlgorithm.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "certSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn12.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certSignatureParams"
            }]
          }, {
            // SignatureValue
            name: "Certificate.signatureValue",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.BITSTRING,
            constructed: false,
            captureBitStringValue: "certSignature"
          }]
        };
        var rsassaPssParameterValidator = {
          name: "rsapss",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "rsapss.hashAlgorithm",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            value: [{
              name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Class.SEQUENCE,
              constructed: true,
              optional: true,
              value: [{
                name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.OID,
                constructed: false,
                capture: "hashOid"
                /* parameter block omitted, for SHA1 NULL anyhow. */
              }]
            }]
          }, {
            name: "rsapss.maskGenAlgorithm",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Class.SEQUENCE,
              constructed: true,
              optional: true,
              value: [{
                name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.OID,
                constructed: false,
                capture: "maskGenOid"
              }, {
                name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.SEQUENCE,
                constructed: true,
                value: [{
                  name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.OID,
                  constructed: false,
                  capture: "maskGenHashOid"
                  /* parameter block omitted, for SHA1 NULL anyhow. */
                }]
              }]
            }]
          }, {
            name: "rsapss.saltLength",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            type: 2,
            optional: true,
            value: [{
              name: "rsapss.saltLength.saltLength",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Class.INTEGER,
              constructed: false,
              capture: "saltLength"
            }]
          }, {
            name: "rsapss.trailerField",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            type: 3,
            optional: true,
            value: [{
              name: "rsapss.trailer.trailer",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Class.INTEGER,
              constructed: false,
              capture: "trailer"
            }]
          }]
        };
        var certificationRequestInfoValidator = {
          name: "CertificationRequestInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfo",
          value: [
            {
              name: "CertificationRequestInfo.integer",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.INTEGER,
              constructed: false,
              capture: "certificationRequestInfoVersion"
            },
            {
              // Name (subject) (RDNSequence)
              name: "CertificationRequestInfo.subject",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "certificationRequestInfoSubject"
            },
            // SubjectPublicKeyInfo
            publicKeyValidator,
            {
              name: "CertificationRequestInfo.attributes",
              tagClass: asn12.Class.CONTEXT_SPECIFIC,
              type: 0,
              constructed: true,
              optional: true,
              capture: "certificationRequestInfoAttributes",
              value: [{
                name: "CertificationRequestInfo.attributes",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.SEQUENCE,
                constructed: true,
                value: [{
                  name: "CertificationRequestInfo.attributes.type",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.OID,
                  constructed: false
                }, {
                  name: "CertificationRequestInfo.attributes.value",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.SET,
                  constructed: true
                }]
              }]
            }
          ]
        };
        var certificationRequestValidator = {
          name: "CertificationRequest",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "csr",
          value: [
            certificationRequestInfoValidator,
            {
              // AlgorithmIdentifier (signature algorithm)
              name: "CertificationRequest.signatureAlgorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              value: [{
                // algorithm
                name: "CertificationRequest.signatureAlgorithm.algorithm",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.OID,
                constructed: false,
                capture: "csrSignatureOid"
              }, {
                name: "CertificationRequest.signatureAlgorithm.parameters",
                tagClass: asn12.Class.UNIVERSAL,
                optional: true,
                captureAsn1: "csrSignatureParams"
              }]
            },
            {
              // signature
              name: "CertificationRequest.signature",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "csrSignature"
            }
          ]
        };
        pki2.RDNAttributesAsArray = function(rdn, md2) {
          var rval = [];
          var set, attr, obj;
          for (var si = 0; si < rdn.value.length; ++si) {
            set = rdn.value[si];
            for (var i = 0; i < set.value.length; ++i) {
              obj = {};
              attr = set.value[i];
              obj.type = asn12.derToOid(attr.value[0].value);
              obj.value = attr.value[1].value;
              obj.valueTagClass = attr.value[1].type;
              if (obj.type in oids2) {
                obj.name = oids2[obj.type];
                if (obj.name in _shortNames) {
                  obj.shortName = _shortNames[obj.name];
                }
              }
              if (md2) {
                md2.update(obj.type);
                md2.update(obj.value);
              }
              rval.push(obj);
            }
          }
          return rval;
        };
        pki2.CRIAttributesAsArray = function(attributes) {
          var rval = [];
          for (var si = 0; si < attributes.length; ++si) {
            var seq = attributes[si];
            var type = asn12.derToOid(seq.value[0].value);
            var values = seq.value[1].value;
            for (var vi = 0; vi < values.length; ++vi) {
              var obj = {};
              obj.type = type;
              obj.value = values[vi].value;
              obj.valueTagClass = values[vi].type;
              if (obj.type in oids2) {
                obj.name = oids2[obj.type];
                if (obj.name in _shortNames) {
                  obj.shortName = _shortNames[obj.name];
                }
              }
              if (obj.type === oids2.extensionRequest) {
                obj.extensions = [];
                for (var ei = 0; ei < obj.value.length; ++ei) {
                  obj.extensions.push(pki2.certificateExtensionFromAsn1(obj.value[ei]));
                }
              }
              rval.push(obj);
            }
          }
          return rval;
        };
        function _getAttribute(obj, options) {
          if (typeof options === "string") {
            options = { shortName: options };
          }
          var rval = null;
          var attr;
          for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
            attr = obj.attributes[i];
            if (options.type && options.type === attr.type) {
              rval = attr;
            } else if (options.name && options.name === attr.name) {
              rval = attr;
            } else if (options.shortName && options.shortName === attr.shortName) {
              rval = attr;
            }
          }
          return rval;
        }
        var _readSignatureParameters = function(oid, obj, fillDefaults) {
          var params = {};
          if (oid !== oids2["RSASSA-PSS"]) {
            return params;
          }
          if (fillDefaults) {
            params = {
              hash: {
                algorithmOid: oids2["sha1"]
              },
              mgf: {
                algorithmOid: oids2["mgf1"],
                hash: {
                  algorithmOid: oids2["sha1"]
                }
              },
              saltLength: 20
            };
          }
          var capture = {};
          var errors = [];
          if (!asn12.validate(obj, rsassaPssParameterValidator, capture, errors)) {
            var error = new Error("Cannot read RSASSA-PSS parameter block.");
            error.errors = errors;
            throw error;
          }
          if (capture.hashOid !== void 0) {
            params.hash = params.hash || {};
            params.hash.algorithmOid = asn12.derToOid(capture.hashOid);
          }
          if (capture.maskGenOid !== void 0) {
            params.mgf = params.mgf || {};
            params.mgf.algorithmOid = asn12.derToOid(capture.maskGenOid);
            params.mgf.hash = params.mgf.hash || {};
            params.mgf.hash.algorithmOid = asn12.derToOid(capture.maskGenHashOid);
          }
          if (capture.saltLength !== void 0) {
            params.saltLength = capture.saltLength.charCodeAt(0);
          }
          return params;
        };
        var _createSignatureDigest = function(options) {
          switch (oids2[options.signatureOid]) {
            case "sha1WithRSAEncryption":
            // deprecated alias
            case "sha1WithRSASignature":
              return forge2.md.sha1.create();
            case "md5WithRSAEncryption":
              return forge2.md.md5.create();
            case "sha256WithRSAEncryption":
              return forge2.md.sha256.create();
            case "sha384WithRSAEncryption":
              return forge2.md.sha384.create();
            case "sha512WithRSAEncryption":
              return forge2.md.sha512.create();
            case "RSASSA-PSS":
              return forge2.md.sha256.create();
            default:
              var error = new Error(
                "Could not compute " + options.type + " digest. Unknown signature OID."
              );
              error.signatureOid = options.signatureOid;
              throw error;
          }
        };
        var _verifySignature = function(options) {
          var cert = options.certificate;
          var scheme;
          switch (cert.signatureOid) {
            case oids2.sha1WithRSAEncryption:
            // deprecated alias
            case oids2.sha1WithRSASignature:
              break;
            case oids2["RSASSA-PSS"]:
              var hash, mgf2;
              hash = oids2[cert.signatureParameters.mgf.hash.algorithmOid];
              if (hash === void 0 || forge2.md[hash] === void 0) {
                var error = new Error("Unsupported MGF hash function.");
                error.oid = cert.signatureParameters.mgf.hash.algorithmOid;
                error.name = hash;
                throw error;
              }
              mgf2 = oids2[cert.signatureParameters.mgf.algorithmOid];
              if (mgf2 === void 0 || forge2.mgf[mgf2] === void 0) {
                var error = new Error("Unsupported MGF function.");
                error.oid = cert.signatureParameters.mgf.algorithmOid;
                error.name = mgf2;
                throw error;
              }
              mgf2 = forge2.mgf[mgf2].create(forge2.md[hash].create());
              hash = oids2[cert.signatureParameters.hash.algorithmOid];
              if (hash === void 0 || forge2.md[hash] === void 0) {
                var error = new Error("Unsupported RSASSA-PSS hash function.");
                error.oid = cert.signatureParameters.hash.algorithmOid;
                error.name = hash;
                throw error;
              }
              scheme = forge2.pss.create(
                forge2.md[hash].create(),
                mgf2,
                cert.signatureParameters.saltLength
              );
              break;
          }
          return cert.publicKey.verify(
            options.md.digest().getBytes(),
            options.signature,
            scheme
          );
        };
        pki2.certificateFromPem = function(pem2, computeHash, strict) {
          var msg = forge2.pem.decode(pem2)[0];
          if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
            var error = new Error(
              'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
            );
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error(
              "Could not convert certificate from PEM; PEM is encrypted."
            );
          }
          var obj = asn12.fromDer(msg.body, strict);
          return pki2.certificateFromAsn1(obj, computeHash);
        };
        pki2.certificateToPem = function(cert, maxline) {
          var msg = {
            type: "CERTIFICATE",
            body: asn12.toDer(pki2.certificateToAsn1(cert)).getBytes()
          };
          return forge2.pem.encode(msg, { maxline });
        };
        pki2.publicKeyFromPem = function(pem2) {
          var msg = forge2.pem.decode(pem2)[0];
          if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
            var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert public key from PEM; PEM is encrypted.");
          }
          var obj = asn12.fromDer(msg.body);
          return pki2.publicKeyFromAsn1(obj);
        };
        pki2.publicKeyToPem = function(key, maxline) {
          var msg = {
            type: "PUBLIC KEY",
            body: asn12.toDer(pki2.publicKeyToAsn1(key)).getBytes()
          };
          return forge2.pem.encode(msg, { maxline });
        };
        pki2.publicKeyToRSAPublicKeyPem = function(key, maxline) {
          var msg = {
            type: "RSA PUBLIC KEY",
            body: asn12.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes()
          };
          return forge2.pem.encode(msg, { maxline });
        };
        pki2.getPublicKeyFingerprint = function(key, options) {
          options = options || {};
          var md2 = options.md || forge2.md.sha1.create();
          var type = options.type || "RSAPublicKey";
          var bytes;
          switch (type) {
            case "RSAPublicKey":
              bytes = asn12.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes();
              break;
            case "SubjectPublicKeyInfo":
              bytes = asn12.toDer(pki2.publicKeyToAsn1(key)).getBytes();
              break;
            default:
              throw new Error('Unknown fingerprint type "' + options.type + '".');
          }
          md2.start();
          md2.update(bytes);
          var digest = md2.digest();
          if (options.encoding === "hex") {
            var hex = digest.toHex();
            if (options.delimiter) {
              return hex.match(/.{2}/g).join(options.delimiter);
            }
            return hex;
          } else if (options.encoding === "binary") {
            return digest.getBytes();
          } else if (options.encoding) {
            throw new Error('Unknown encoding "' + options.encoding + '".');
          }
          return digest;
        };
        pki2.certificationRequestFromPem = function(pem2, computeHash, strict) {
          var msg = forge2.pem.decode(pem2)[0];
          if (msg.type !== "CERTIFICATE REQUEST") {
            var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
          }
          var obj = asn12.fromDer(msg.body, strict);
          return pki2.certificationRequestFromAsn1(obj, computeHash);
        };
        pki2.certificationRequestToPem = function(csr, maxline) {
          var msg = {
            type: "CERTIFICATE REQUEST",
            body: asn12.toDer(pki2.certificationRequestToAsn1(csr)).getBytes()
          };
          return forge2.pem.encode(msg, { maxline });
        };
        pki2.createCertificate = function() {
          var cert = {};
          cert.version = 2;
          cert.serialNumber = "00";
          cert.signatureOid = null;
          cert.signature = null;
          cert.siginfo = {};
          cert.siginfo.algorithmOid = null;
          cert.validity = {};
          cert.validity.notBefore = /* @__PURE__ */ new Date();
          cert.validity.notAfter = /* @__PURE__ */ new Date();
          cert.issuer = {};
          cert.issuer.getField = function(sn) {
            return _getAttribute(cert.issuer, sn);
          };
          cert.issuer.addField = function(attr) {
            _fillMissingFields([attr]);
            cert.issuer.attributes.push(attr);
          };
          cert.issuer.attributes = [];
          cert.issuer.hash = null;
          cert.subject = {};
          cert.subject.getField = function(sn) {
            return _getAttribute(cert.subject, sn);
          };
          cert.subject.addField = function(attr) {
            _fillMissingFields([attr]);
            cert.subject.attributes.push(attr);
          };
          cert.subject.attributes = [];
          cert.subject.hash = null;
          cert.extensions = [];
          cert.publicKey = null;
          cert.md = null;
          cert.setSubject = function(attrs, uniqueId) {
            _fillMissingFields(attrs);
            cert.subject.attributes = attrs;
            delete cert.subject.uniqueId;
            if (uniqueId) {
              cert.subject.uniqueId = uniqueId;
            }
            cert.subject.hash = null;
          };
          cert.setIssuer = function(attrs, uniqueId) {
            _fillMissingFields(attrs);
            cert.issuer.attributes = attrs;
            delete cert.issuer.uniqueId;
            if (uniqueId) {
              cert.issuer.uniqueId = uniqueId;
            }
            cert.issuer.hash = null;
          };
          cert.setExtensions = function(exts) {
            for (var i = 0; i < exts.length; ++i) {
              _fillMissingExtensionFields(exts[i], { cert });
            }
            cert.extensions = exts;
          };
          cert.getExtension = function(options) {
            if (typeof options === "string") {
              options = { name: options };
            }
            var rval = null;
            var ext;
            for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
              ext = cert.extensions[i];
              if (options.id && ext.id === options.id) {
                rval = ext;
              } else if (options.name && ext.name === options.name) {
                rval = ext;
              }
            }
            return rval;
          };
          cert.sign = function(key, md2) {
            cert.md = md2 || forge2.md.sha1.create();
            var algorithmOid = oids2[cert.md.algorithm + "WithRSAEncryption"];
            if (!algorithmOid) {
              var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
              error.algorithm = cert.md.algorithm;
              throw error;
            }
            cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
            cert.tbsCertificate = pki2.getTBSCertificate(cert);
            var bytes = asn12.toDer(cert.tbsCertificate);
            cert.md.update(bytes.getBytes());
            cert.signature = key.sign(cert.md);
          };
          cert.verify = function(child) {
            var rval = false;
            if (!cert.issued(child)) {
              var issuer = child.issuer;
              var subject = cert.subject;
              var error = new Error(
                "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
              );
              error.expectedIssuer = subject.attributes;
              error.actualIssuer = issuer.attributes;
              throw error;
            }
            var md2 = child.md;
            if (md2 === null) {
              md2 = _createSignatureDigest({
                signatureOid: child.signatureOid,
                type: "certificate"
              });
              var tbsCertificate = child.tbsCertificate || pki2.getTBSCertificate(child);
              var bytes = asn12.toDer(tbsCertificate);
              md2.update(bytes.getBytes());
            }
            if (md2 !== null) {
              rval = _verifySignature({
                certificate: cert,
                md: md2,
                signature: child.signature
              });
            }
            return rval;
          };
          cert.isIssuer = function(parent) {
            var rval = false;
            var i = cert.issuer;
            var s = parent.subject;
            if (i.hash && s.hash) {
              rval = i.hash === s.hash;
            } else if (i.attributes.length === s.attributes.length) {
              rval = true;
              var iattr, sattr;
              for (var n = 0; rval && n < i.attributes.length; ++n) {
                iattr = i.attributes[n];
                sattr = s.attributes[n];
                if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
                  rval = false;
                }
              }
            }
            return rval;
          };
          cert.issued = function(child) {
            return child.isIssuer(cert);
          };
          cert.generateSubjectKeyIdentifier = function() {
            return pki2.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
          };
          cert.verifySubjectKeyIdentifier = function() {
            var oid = oids2["subjectKeyIdentifier"];
            for (var i = 0; i < cert.extensions.length; ++i) {
              var ext = cert.extensions[i];
              if (ext.id === oid) {
                var ski = cert.generateSubjectKeyIdentifier().getBytes();
                return forge2.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
              }
            }
            return false;
          };
          return cert;
        };
        pki2.certificateFromAsn1 = function(obj, computeHash) {
          var capture = {};
          var errors = [];
          if (!asn12.validate(obj, x509CertificateValidator, capture, errors)) {
            var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
            error.errors = errors;
            throw error;
          }
          var oid = asn12.derToOid(capture.publicKeyOid);
          if (oid !== pki2.oids.rsaEncryption) {
            throw new Error("Cannot read public key. OID is not RSA.");
          }
          var cert = pki2.createCertificate();
          cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
          var serial = forge2.util.createBuffer(capture.certSerialNumber);
          cert.serialNumber = serial.toHex();
          cert.signatureOid = forge2.asn1.derToOid(capture.certSignatureOid);
          cert.signatureParameters = _readSignatureParameters(
            cert.signatureOid,
            capture.certSignatureParams,
            true
          );
          cert.siginfo.algorithmOid = forge2.asn1.derToOid(capture.certinfoSignatureOid);
          cert.siginfo.parameters = _readSignatureParameters(
            cert.siginfo.algorithmOid,
            capture.certinfoSignatureParams,
            false
          );
          cert.signature = capture.certSignature;
          var validity = [];
          if (capture.certValidity1UTCTime !== void 0) {
            validity.push(asn12.utcTimeToDate(capture.certValidity1UTCTime));
          }
          if (capture.certValidity2GeneralizedTime !== void 0) {
            validity.push(asn12.generalizedTimeToDate(
              capture.certValidity2GeneralizedTime
            ));
          }
          if (capture.certValidity3UTCTime !== void 0) {
            validity.push(asn12.utcTimeToDate(capture.certValidity3UTCTime));
          }
          if (capture.certValidity4GeneralizedTime !== void 0) {
            validity.push(asn12.generalizedTimeToDate(
              capture.certValidity4GeneralizedTime
            ));
          }
          if (validity.length > 2) {
            throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
          }
          if (validity.length < 2) {
            throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
          }
          cert.validity.notBefore = validity[0];
          cert.validity.notAfter = validity[1];
          cert.tbsCertificate = capture.tbsCertificate;
          if (computeHash) {
            cert.md = _createSignatureDigest({
              signatureOid: cert.signatureOid,
              type: "certificate"
            });
            var bytes = asn12.toDer(cert.tbsCertificate);
            cert.md.update(bytes.getBytes());
          }
          var imd = forge2.md.sha1.create();
          var ibytes = asn12.toDer(capture.certIssuer);
          imd.update(ibytes.getBytes());
          cert.issuer.getField = function(sn) {
            return _getAttribute(cert.issuer, sn);
          };
          cert.issuer.addField = function(attr) {
            _fillMissingFields([attr]);
            cert.issuer.attributes.push(attr);
          };
          cert.issuer.attributes = pki2.RDNAttributesAsArray(capture.certIssuer);
          if (capture.certIssuerUniqueId) {
            cert.issuer.uniqueId = capture.certIssuerUniqueId;
          }
          cert.issuer.hash = imd.digest().toHex();
          var smd = forge2.md.sha1.create();
          var sbytes = asn12.toDer(capture.certSubject);
          smd.update(sbytes.getBytes());
          cert.subject.getField = function(sn) {
            return _getAttribute(cert.subject, sn);
          };
          cert.subject.addField = function(attr) {
            _fillMissingFields([attr]);
            cert.subject.attributes.push(attr);
          };
          cert.subject.attributes = pki2.RDNAttributesAsArray(capture.certSubject);
          if (capture.certSubjectUniqueId) {
            cert.subject.uniqueId = capture.certSubjectUniqueId;
          }
          cert.subject.hash = smd.digest().toHex();
          if (capture.certExtensions) {
            cert.extensions = pki2.certificateExtensionsFromAsn1(capture.certExtensions);
          } else {
            cert.extensions = [];
          }
          cert.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
          return cert;
        };
        pki2.certificateExtensionsFromAsn1 = function(exts) {
          var rval = [];
          for (var i = 0; i < exts.value.length; ++i) {
            var extseq = exts.value[i];
            for (var ei = 0; ei < extseq.value.length; ++ei) {
              rval.push(pki2.certificateExtensionFromAsn1(extseq.value[ei]));
            }
          }
          return rval;
        };
        pki2.certificateExtensionFromAsn1 = function(ext) {
          var e = {};
          e.id = asn12.derToOid(ext.value[0].value);
          e.critical = false;
          if (ext.value[1].type === asn12.Type.BOOLEAN) {
            e.critical = ext.value[1].value.charCodeAt(0) !== 0;
            e.value = ext.value[2].value;
          } else {
            e.value = ext.value[1].value;
          }
          if (e.id in oids2) {
            e.name = oids2[e.id];
            if (e.name === "keyUsage") {
              var ev = asn12.fromDer(e.value);
              var b2 = 0;
              var b3 = 0;
              if (ev.value.length > 1) {
                b2 = ev.value.charCodeAt(1);
                b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
              }
              e.digitalSignature = (b2 & 128) === 128;
              e.nonRepudiation = (b2 & 64) === 64;
              e.keyEncipherment = (b2 & 32) === 32;
              e.dataEncipherment = (b2 & 16) === 16;
              e.keyAgreement = (b2 & 8) === 8;
              e.keyCertSign = (b2 & 4) === 4;
              e.cRLSign = (b2 & 2) === 2;
              e.encipherOnly = (b2 & 1) === 1;
              e.decipherOnly = (b3 & 128) === 128;
            } else if (e.name === "basicConstraints") {
              var ev = asn12.fromDer(e.value);
              if (ev.value.length > 0 && ev.value[0].type === asn12.Type.BOOLEAN) {
                e.cA = ev.value[0].value.charCodeAt(0) !== 0;
              } else {
                e.cA = false;
              }
              var value = null;
              if (ev.value.length > 0 && ev.value[0].type === asn12.Type.INTEGER) {
                value = ev.value[0].value;
              } else if (ev.value.length > 1) {
                value = ev.value[1].value;
              }
              if (value !== null) {
                e.pathLenConstraint = asn12.derToInteger(value);
              }
            } else if (e.name === "extKeyUsage") {
              var ev = asn12.fromDer(e.value);
              for (var vi = 0; vi < ev.value.length; ++vi) {
                var oid = asn12.derToOid(ev.value[vi].value);
                if (oid in oids2) {
                  e[oids2[oid]] = true;
                } else {
                  e[oid] = true;
                }
              }
            } else if (e.name === "nsCertType") {
              var ev = asn12.fromDer(e.value);
              var b2 = 0;
              if (ev.value.length > 1) {
                b2 = ev.value.charCodeAt(1);
              }
              e.client = (b2 & 128) === 128;
              e.server = (b2 & 64) === 64;
              e.email = (b2 & 32) === 32;
              e.objsign = (b2 & 16) === 16;
              e.reserved = (b2 & 8) === 8;
              e.sslCA = (b2 & 4) === 4;
              e.emailCA = (b2 & 2) === 2;
              e.objCA = (b2 & 1) === 1;
            } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
              e.altNames = [];
              var gn;
              var ev = asn12.fromDer(e.value);
              for (var n = 0; n < ev.value.length; ++n) {
                gn = ev.value[n];
                var altName = {
                  type: gn.type,
                  value: gn.value
                };
                e.altNames.push(altName);
                switch (gn.type) {
                  // rfc822Name
                  case 1:
                  // dNSName
                  case 2:
                  // uniformResourceIdentifier (URI)
                  case 6:
                    break;
                  // IPAddress
                  case 7:
                    altName.ip = forge2.util.bytesToIP(gn.value);
                    break;
                  // registeredID
                  case 8:
                    altName.oid = asn12.derToOid(gn.value);
                    break;
                }
              }
            } else if (e.name === "subjectKeyIdentifier") {
              var ev = asn12.fromDer(e.value);
              e.subjectKeyIdentifier = forge2.util.bytesToHex(ev.value);
            }
          }
          return e;
        };
        pki2.certificationRequestFromAsn1 = function(obj, computeHash) {
          var capture = {};
          var errors = [];
          if (!asn12.validate(obj, certificationRequestValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
            error.errors = errors;
            throw error;
          }
          var oid = asn12.derToOid(capture.publicKeyOid);
          if (oid !== pki2.oids.rsaEncryption) {
            throw new Error("Cannot read public key. OID is not RSA.");
          }
          var csr = pki2.createCertificationRequest();
          csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
          csr.signatureOid = forge2.asn1.derToOid(capture.csrSignatureOid);
          csr.signatureParameters = _readSignatureParameters(
            csr.signatureOid,
            capture.csrSignatureParams,
            true
          );
          csr.siginfo.algorithmOid = forge2.asn1.derToOid(capture.csrSignatureOid);
          csr.siginfo.parameters = _readSignatureParameters(
            csr.siginfo.algorithmOid,
            capture.csrSignatureParams,
            false
          );
          csr.signature = capture.csrSignature;
          csr.certificationRequestInfo = capture.certificationRequestInfo;
          if (computeHash) {
            csr.md = _createSignatureDigest({
              signatureOid: csr.signatureOid,
              type: "certification request"
            });
            var bytes = asn12.toDer(csr.certificationRequestInfo);
            csr.md.update(bytes.getBytes());
          }
          var smd = forge2.md.sha1.create();
          csr.subject.getField = function(sn) {
            return _getAttribute(csr.subject, sn);
          };
          csr.subject.addField = function(attr) {
            _fillMissingFields([attr]);
            csr.subject.attributes.push(attr);
          };
          csr.subject.attributes = pki2.RDNAttributesAsArray(
            capture.certificationRequestInfoSubject,
            smd
          );
          csr.subject.hash = smd.digest().toHex();
          csr.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
          csr.getAttribute = function(sn) {
            return _getAttribute(csr, sn);
          };
          csr.addAttribute = function(attr) {
            _fillMissingFields([attr]);
            csr.attributes.push(attr);
          };
          csr.attributes = pki2.CRIAttributesAsArray(
            capture.certificationRequestInfoAttributes || []
          );
          return csr;
        };
        pki2.createCertificationRequest = function() {
          var csr = {};
          csr.version = 0;
          csr.signatureOid = null;
          csr.signature = null;
          csr.siginfo = {};
          csr.siginfo.algorithmOid = null;
          csr.subject = {};
          csr.subject.getField = function(sn) {
            return _getAttribute(csr.subject, sn);
          };
          csr.subject.addField = function(attr) {
            _fillMissingFields([attr]);
            csr.subject.attributes.push(attr);
          };
          csr.subject.attributes = [];
          csr.subject.hash = null;
          csr.publicKey = null;
          csr.attributes = [];
          csr.getAttribute = function(sn) {
            return _getAttribute(csr, sn);
          };
          csr.addAttribute = function(attr) {
            _fillMissingFields([attr]);
            csr.attributes.push(attr);
          };
          csr.md = null;
          csr.setSubject = function(attrs) {
            _fillMissingFields(attrs);
            csr.subject.attributes = attrs;
            csr.subject.hash = null;
          };
          csr.setAttributes = function(attrs) {
            _fillMissingFields(attrs);
            csr.attributes = attrs;
          };
          csr.sign = function(key, md2) {
            csr.md = md2 || forge2.md.sha1.create();
            var algorithmOid = oids2[csr.md.algorithm + "WithRSAEncryption"];
            if (!algorithmOid) {
              var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
              error.algorithm = csr.md.algorithm;
              throw error;
            }
            csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
            csr.certificationRequestInfo = pki2.getCertificationRequestInfo(csr);
            var bytes = asn12.toDer(csr.certificationRequestInfo);
            csr.md.update(bytes.getBytes());
            csr.signature = key.sign(csr.md);
          };
          csr.verify = function() {
            var rval = false;
            var md2 = csr.md;
            if (md2 === null) {
              md2 = _createSignatureDigest({
                signatureOid: csr.signatureOid,
                type: "certification request"
              });
              var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);
              var bytes = asn12.toDer(cri);
              md2.update(bytes.getBytes());
            }
            if (md2 !== null) {
              rval = _verifySignature({
                certificate: csr,
                md: md2,
                signature: csr.signature
              });
            }
            return rval;
          };
          return csr;
        };
        function _dnToAsn1(obj) {
          var rval = asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.SEQUENCE,
            true,
            []
          );
          var attr, set;
          var attrs = obj.attributes;
          for (var i = 0; i < attrs.length; ++i) {
            attr = attrs[i];
            var value = attr.value;
            var valueTagClass = asn12.Type.PRINTABLESTRING;
            if ("valueTagClass" in attr) {
              valueTagClass = attr.valueTagClass;
              if (valueTagClass === asn12.Type.UTF8) {
                value = forge2.util.encodeUtf8(value);
              }
            }
            set = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SET, true, [
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // AttributeType
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(attr.type).getBytes()
                ),
                // AttributeValue
                asn12.create(asn12.Class.UNIVERSAL, valueTagClass, false, value)
              ])
            ]);
            rval.value.push(set);
          }
          return rval;
        }
        function _fillMissingFields(attrs) {
          var attr;
          for (var i = 0; i < attrs.length; ++i) {
            attr = attrs[i];
            if (typeof attr.name === "undefined") {
              if (attr.type && attr.type in pki2.oids) {
                attr.name = pki2.oids[attr.type];
              } else if (attr.shortName && attr.shortName in _shortNames) {
                attr.name = pki2.oids[_shortNames[attr.shortName]];
              }
            }
            if (typeof attr.type === "undefined") {
              if (attr.name && attr.name in pki2.oids) {
                attr.type = pki2.oids[attr.name];
              } else {
                var error = new Error("Attribute type not specified.");
                error.attribute = attr;
                throw error;
              }
            }
            if (typeof attr.shortName === "undefined") {
              if (attr.name && attr.name in _shortNames) {
                attr.shortName = _shortNames[attr.name];
              }
            }
            if (attr.type === oids2.extensionRequest) {
              attr.valueConstructed = true;
              attr.valueTagClass = asn12.Type.SEQUENCE;
              if (!attr.value && attr.extensions) {
                attr.value = [];
                for (var ei = 0; ei < attr.extensions.length; ++ei) {
                  attr.value.push(pki2.certificateExtensionToAsn1(
                    _fillMissingExtensionFields(attr.extensions[ei])
                  ));
                }
              }
            }
            if (typeof attr.value === "undefined") {
              var error = new Error("Attribute value not specified.");
              error.attribute = attr;
              throw error;
            }
          }
        }
        function _fillMissingExtensionFields(e, options) {
          options = options || {};
          if (typeof e.name === "undefined") {
            if (e.id && e.id in pki2.oids) {
              e.name = pki2.oids[e.id];
            }
          }
          if (typeof e.id === "undefined") {
            if (e.name && e.name in pki2.oids) {
              e.id = pki2.oids[e.name];
            } else {
              var error = new Error("Extension ID not specified.");
              error.extension = e;
              throw error;
            }
          }
          if (typeof e.value !== "undefined") {
            return e;
          }
          if (e.name === "keyUsage") {
            var unused = 0;
            var b2 = 0;
            var b3 = 0;
            if (e.digitalSignature) {
              b2 |= 128;
              unused = 7;
            }
            if (e.nonRepudiation) {
              b2 |= 64;
              unused = 6;
            }
            if (e.keyEncipherment) {
              b2 |= 32;
              unused = 5;
            }
            if (e.dataEncipherment) {
              b2 |= 16;
              unused = 4;
            }
            if (e.keyAgreement) {
              b2 |= 8;
              unused = 3;
            }
            if (e.keyCertSign) {
              b2 |= 4;
              unused = 2;
            }
            if (e.cRLSign) {
              b2 |= 2;
              unused = 1;
            }
            if (e.encipherOnly) {
              b2 |= 1;
              unused = 0;
            }
            if (e.decipherOnly) {
              b3 |= 128;
              unused = 7;
            }
            var value = String.fromCharCode(unused);
            if (b3 !== 0) {
              value += String.fromCharCode(b2) + String.fromCharCode(b3);
            } else if (b2 !== 0) {
              value += String.fromCharCode(b2);
            }
            e.value = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.BITSTRING,
              false,
              value
            );
          } else if (e.name === "basicConstraints") {
            e.value = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.SEQUENCE,
              true,
              []
            );
            if (e.cA) {
              e.value.value.push(asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.BOOLEAN,
                false,
                String.fromCharCode(255)
              ));
            }
            if ("pathLenConstraint" in e) {
              e.value.value.push(asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.INTEGER,
                false,
                asn12.integerToDer(e.pathLenConstraint).getBytes()
              ));
            }
          } else if (e.name === "extKeyUsage") {
            e.value = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.SEQUENCE,
              true,
              []
            );
            var seq = e.value.value;
            for (var key in e) {
              if (e[key] !== true) {
                continue;
              }
              if (key in oids2) {
                seq.push(asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(oids2[key]).getBytes()
                ));
              } else if (key.indexOf(".") !== -1) {
                seq.push(asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(key).getBytes()
                ));
              }
            }
          } else if (e.name === "nsCertType") {
            var unused = 0;
            var b2 = 0;
            if (e.client) {
              b2 |= 128;
              unused = 7;
            }
            if (e.server) {
              b2 |= 64;
              unused = 6;
            }
            if (e.email) {
              b2 |= 32;
              unused = 5;
            }
            if (e.objsign) {
              b2 |= 16;
              unused = 4;
            }
            if (e.reserved) {
              b2 |= 8;
              unused = 3;
            }
            if (e.sslCA) {
              b2 |= 4;
              unused = 2;
            }
            if (e.emailCA) {
              b2 |= 2;
              unused = 1;
            }
            if (e.objCA) {
              b2 |= 1;
              unused = 0;
            }
            var value = String.fromCharCode(unused);
            if (b2 !== 0) {
              value += String.fromCharCode(b2);
            }
            e.value = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.BITSTRING,
              false,
              value
            );
          } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
            e.value = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, []);
            var altName;
            for (var n = 0; n < e.altNames.length; ++n) {
              altName = e.altNames[n];
              var value = altName.value;
              if (altName.type === 7 && altName.ip) {
                value = forge2.util.bytesFromIP(altName.ip);
                if (value === null) {
                  var error = new Error(
                    'Extension "ip" value is not a valid IPv4 or IPv6 address.'
                  );
                  error.extension = e;
                  throw error;
                }
              } else if (altName.type === 8) {
                if (altName.oid) {
                  value = asn12.oidToDer(asn12.oidToDer(altName.oid));
                } else {
                  value = asn12.oidToDer(value);
                }
              }
              e.value.value.push(asn12.create(
                asn12.Class.CONTEXT_SPECIFIC,
                altName.type,
                false,
                value
              ));
            }
          } else if (e.name === "nsComment" && options.cert) {
            if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
              throw new Error('Invalid "nsComment" content.');
            }
            e.value = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.IA5STRING,
              false,
              e.comment
            );
          } else if (e.name === "subjectKeyIdentifier" && options.cert) {
            var ski = options.cert.generateSubjectKeyIdentifier();
            e.subjectKeyIdentifier = ski.toHex();
            e.value = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OCTETSTRING,
              false,
              ski.getBytes()
            );
          } else if (e.name === "authorityKeyIdentifier" && options.cert) {
            e.value = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, []);
            var seq = e.value.value;
            if (e.keyIdentifier) {
              var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
              seq.push(
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
              );
            }
            if (e.authorityCertIssuer) {
              var authorityCertIssuer = [
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 4, true, [
                  _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
                ])
              ];
              seq.push(
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
              );
            }
            if (e.serialNumber) {
              var serialNumber = forge2.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
              seq.push(
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
              );
            }
          } else if (e.name === "cRLDistributionPoints") {
            e.value = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, []);
            var seq = e.value.value;
            var subSeq = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.SEQUENCE,
              true,
              []
            );
            var fullNameGeneralNames = asn12.create(
              asn12.Class.CONTEXT_SPECIFIC,
              0,
              true,
              []
            );
            var altName;
            for (var n = 0; n < e.altNames.length; ++n) {
              altName = e.altNames[n];
              var value = altName.value;
              if (altName.type === 7 && altName.ip) {
                value = forge2.util.bytesFromIP(altName.ip);
                if (value === null) {
                  var error = new Error(
                    'Extension "ip" value is not a valid IPv4 or IPv6 address.'
                  );
                  error.extension = e;
                  throw error;
                }
              } else if (altName.type === 8) {
                if (altName.oid) {
                  value = asn12.oidToDer(asn12.oidToDer(altName.oid));
                } else {
                  value = asn12.oidToDer(value);
                }
              }
              fullNameGeneralNames.value.push(asn12.create(
                asn12.Class.CONTEXT_SPECIFIC,
                altName.type,
                false,
                value
              ));
            }
            subSeq.value.push(asn12.create(
              asn12.Class.CONTEXT_SPECIFIC,
              0,
              true,
              [fullNameGeneralNames]
            ));
            seq.push(subSeq);
          }
          if (typeof e.value === "undefined") {
            var error = new Error("Extension value not specified.");
            error.extension = e;
            throw error;
          }
          return e;
        }
        function _signatureParametersToAsn1(oid, params) {
          switch (oid) {
            case oids2["RSASSA-PSS"]:
              var parts = [];
              if (params.hash.algorithmOid !== void 0) {
                parts.push(asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                  asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.OID,
                      false,
                      asn12.oidToDer(params.hash.algorithmOid).getBytes()
                    ),
                    asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
                  ])
                ]));
              }
              if (params.mgf.algorithmOid !== void 0) {
                parts.push(asn12.create(asn12.Class.CONTEXT_SPECIFIC, 1, true, [
                  asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.OID,
                      false,
                      asn12.oidToDer(params.mgf.algorithmOid).getBytes()
                    ),
                    asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                      asn12.create(
                        asn12.Class.UNIVERSAL,
                        asn12.Type.OID,
                        false,
                        asn12.oidToDer(params.mgf.hash.algorithmOid).getBytes()
                      ),
                      asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
                    ])
                  ])
                ]));
              }
              if (params.saltLength !== void 0) {
                parts.push(asn12.create(asn12.Class.CONTEXT_SPECIFIC, 2, true, [
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.INTEGER,
                    false,
                    asn12.integerToDer(params.saltLength).getBytes()
                  )
                ]));
              }
              return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, parts);
            default:
              return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "");
          }
        }
        function _CRIAttributesToAsn1(csr) {
          var rval = asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, []);
          if (csr.attributes.length === 0) {
            return rval;
          }
          var attrs = csr.attributes;
          for (var i = 0; i < attrs.length; ++i) {
            var attr = attrs[i];
            var value = attr.value;
            var valueTagClass = asn12.Type.UTF8;
            if ("valueTagClass" in attr) {
              valueTagClass = attr.valueTagClass;
            }
            if (valueTagClass === asn12.Type.UTF8) {
              value = forge2.util.encodeUtf8(value);
            }
            var valueConstructed = false;
            if ("valueConstructed" in attr) {
              valueConstructed = attr.valueConstructed;
            }
            var seq = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // AttributeType
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(attr.type).getBytes()
              ),
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SET, true, [
                // AttributeValue
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  valueTagClass,
                  valueConstructed,
                  value
                )
              ])
            ]);
            rval.value.push(seq);
          }
          return rval;
        }
        var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
        var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
        function _dateToAsn1(date) {
          if (date >= jan_1_1950 && date < jan_1_2050) {
            return asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.UTCTIME,
              false,
              asn12.dateToUtcTime(date)
            );
          } else {
            return asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.GENERALIZEDTIME,
              false,
              asn12.dateToGeneralizedTime(date)
            );
          }
        }
        pki2.getTBSCertificate = function(cert) {
          var notBefore = _dateToAsn1(cert.validity.notBefore);
          var notAfter = _dateToAsn1(cert.validity.notAfter);
          var tbs = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // version
            asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
              // integer
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.INTEGER,
                false,
                asn12.integerToDer(cert.version).getBytes()
              )
            ]),
            // serialNumber
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              forge2.util.hexToBytes(cert.serialNumber)
            ),
            // signature
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // algorithm
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(cert.siginfo.algorithmOid).getBytes()
              ),
              // parameters
              _signatureParametersToAsn1(
                cert.siginfo.algorithmOid,
                cert.siginfo.parameters
              )
            ]),
            // issuer
            _dnToAsn1(cert.issuer),
            // validity
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              notBefore,
              notAfter
            ]),
            // subject
            _dnToAsn1(cert.subject),
            // SubjectPublicKeyInfo
            pki2.publicKeyToAsn1(cert.publicKey)
          ]);
          if (cert.issuer.uniqueId) {
            tbs.value.push(
              asn12.create(asn12.Class.CONTEXT_SPECIFIC, 1, true, [
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.BITSTRING,
                  false,
                  // TODO: support arbitrary bit length ids
                  String.fromCharCode(0) + cert.issuer.uniqueId
                )
              ])
            );
          }
          if (cert.subject.uniqueId) {
            tbs.value.push(
              asn12.create(asn12.Class.CONTEXT_SPECIFIC, 2, true, [
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.BITSTRING,
                  false,
                  // TODO: support arbitrary bit length ids
                  String.fromCharCode(0) + cert.subject.uniqueId
                )
              ])
            );
          }
          if (cert.extensions.length > 0) {
            tbs.value.push(pki2.certificateExtensionsToAsn1(cert.extensions));
          }
          return tbs;
        };
        pki2.getCertificationRequestInfo = function(csr) {
          var cri = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // version
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              asn12.integerToDer(csr.version).getBytes()
            ),
            // subject
            _dnToAsn1(csr.subject),
            // SubjectPublicKeyInfo
            pki2.publicKeyToAsn1(csr.publicKey),
            // attributes
            _CRIAttributesToAsn1(csr)
          ]);
          return cri;
        };
        pki2.distinguishedNameToAsn1 = function(dn) {
          return _dnToAsn1(dn);
        };
        pki2.certificateToAsn1 = function(cert) {
          var tbsCertificate = cert.tbsCertificate || pki2.getTBSCertificate(cert);
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // TBSCertificate
            tbsCertificate,
            // AlgorithmIdentifier (signature algorithm)
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // algorithm
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(cert.signatureOid).getBytes()
              ),
              // parameters
              _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
            ]),
            // SignatureValue
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.BITSTRING,
              false,
              String.fromCharCode(0) + cert.signature
            )
          ]);
        };
        pki2.certificateExtensionsToAsn1 = function(exts) {
          var rval = asn12.create(asn12.Class.CONTEXT_SPECIFIC, 3, true, []);
          var seq = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, []);
          rval.value.push(seq);
          for (var i = 0; i < exts.length; ++i) {
            seq.value.push(pki2.certificateExtensionToAsn1(exts[i]));
          }
          return rval;
        };
        pki2.certificateExtensionToAsn1 = function(ext) {
          var extseq = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, []);
          extseq.value.push(asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.OID,
            false,
            asn12.oidToDer(ext.id).getBytes()
          ));
          if (ext.critical) {
            extseq.value.push(asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.BOOLEAN,
              false,
              String.fromCharCode(255)
            ));
          }
          var value = ext.value;
          if (typeof ext.value !== "string") {
            value = asn12.toDer(value).getBytes();
          }
          extseq.value.push(asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.OCTETSTRING,
            false,
            value
          ));
          return extseq;
        };
        pki2.certificationRequestToAsn1 = function(csr) {
          var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // CertificationRequestInfo
            cri,
            // AlgorithmIdentifier (signature algorithm)
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // algorithm
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(csr.signatureOid).getBytes()
              ),
              // parameters
              _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
            ]),
            // signature
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.BITSTRING,
              false,
              String.fromCharCode(0) + csr.signature
            )
          ]);
        };
        pki2.createCaStore = function(certs) {
          var caStore = {
            // stored certificates
            certs: {}
          };
          caStore.getIssuer = function(cert2) {
            var rval = getBySubject(cert2.issuer);
            return rval;
          };
          caStore.addCertificate = function(cert2) {
            if (typeof cert2 === "string") {
              cert2 = forge2.pki.certificateFromPem(cert2);
            }
            ensureSubjectHasHash(cert2.subject);
            if (!caStore.hasCertificate(cert2)) {
              if (cert2.subject.hash in caStore.certs) {
                var tmp = caStore.certs[cert2.subject.hash];
                if (!forge2.util.isArray(tmp)) {
                  tmp = [tmp];
                }
                tmp.push(cert2);
                caStore.certs[cert2.subject.hash] = tmp;
              } else {
                caStore.certs[cert2.subject.hash] = cert2;
              }
            }
          };
          caStore.hasCertificate = function(cert2) {
            if (typeof cert2 === "string") {
              cert2 = forge2.pki.certificateFromPem(cert2);
            }
            var match = getBySubject(cert2.subject);
            if (!match) {
              return false;
            }
            if (!forge2.util.isArray(match)) {
              match = [match];
            }
            var der1 = asn12.toDer(pki2.certificateToAsn1(cert2)).getBytes();
            for (var i2 = 0; i2 < match.length; ++i2) {
              var der2 = asn12.toDer(pki2.certificateToAsn1(match[i2])).getBytes();
              if (der1 === der2) {
                return true;
              }
            }
            return false;
          };
          caStore.listAllCertificates = function() {
            var certList = [];
            for (var hash in caStore.certs) {
              if (caStore.certs.hasOwnProperty(hash)) {
                var value = caStore.certs[hash];
                if (!forge2.util.isArray(value)) {
                  certList.push(value);
                } else {
                  for (var i2 = 0; i2 < value.length; ++i2) {
                    certList.push(value[i2]);
                  }
                }
              }
            }
            return certList;
          };
          caStore.removeCertificate = function(cert2) {
            var result;
            if (typeof cert2 === "string") {
              cert2 = forge2.pki.certificateFromPem(cert2);
            }
            ensureSubjectHasHash(cert2.subject);
            if (!caStore.hasCertificate(cert2)) {
              return null;
            }
            var match = getBySubject(cert2.subject);
            if (!forge2.util.isArray(match)) {
              result = caStore.certs[cert2.subject.hash];
              delete caStore.certs[cert2.subject.hash];
              return result;
            }
            var der1 = asn12.toDer(pki2.certificateToAsn1(cert2)).getBytes();
            for (var i2 = 0; i2 < match.length; ++i2) {
              var der2 = asn12.toDer(pki2.certificateToAsn1(match[i2])).getBytes();
              if (der1 === der2) {
                result = match[i2];
                match.splice(i2, 1);
              }
            }
            if (match.length === 0) {
              delete caStore.certs[cert2.subject.hash];
            }
            return result;
          };
          function getBySubject(subject) {
            ensureSubjectHasHash(subject);
            return caStore.certs[subject.hash] || null;
          }
          function ensureSubjectHasHash(subject) {
            if (!subject.hash) {
              var md2 = forge2.md.sha1.create();
              subject.attributes = pki2.RDNAttributesAsArray(_dnToAsn1(subject), md2);
              subject.hash = md2.digest().toHex();
            }
          }
          if (certs) {
            for (var i = 0; i < certs.length; ++i) {
              var cert = certs[i];
              caStore.addCertificate(cert);
            }
          }
          return caStore;
        };
        pki2.certificateError = {
          bad_certificate: "forge.pki.BadCertificate",
          unsupported_certificate: "forge.pki.UnsupportedCertificate",
          certificate_revoked: "forge.pki.CertificateRevoked",
          certificate_expired: "forge.pki.CertificateExpired",
          certificate_unknown: "forge.pki.CertificateUnknown",
          unknown_ca: "forge.pki.UnknownCertificateAuthority"
        };
        pki2.verifyCertificateChain = function(caStore, chain, options) {
          if (typeof options === "function") {
            options = { verify: options };
          }
          options = options || {};
          chain = chain.slice(0);
          var certs = chain.slice(0);
          var validityCheckDate = options.validityCheckDate;
          if (typeof validityCheckDate === "undefined") {
            validityCheckDate = /* @__PURE__ */ new Date();
          }
          var first = true;
          var error = null;
          var depth = 0;
          do {
            var cert = chain.shift();
            var parent = null;
            var selfSigned = false;
            if (validityCheckDate) {
              if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
                error = {
                  message: "Certificate is not valid yet or has expired.",
                  error: pki2.certificateError.certificate_expired,
                  notBefore: cert.validity.notBefore,
                  notAfter: cert.validity.notAfter,
                  // TODO: we might want to reconsider renaming 'now' to
                  // 'validityCheckDate' should this API be changed in the future.
                  now: validityCheckDate
                };
              }
            }
            if (error === null) {
              parent = chain[0] || caStore.getIssuer(cert);
              if (parent === null) {
                if (cert.isIssuer(cert)) {
                  selfSigned = true;
                  parent = cert;
                }
              }
              if (parent) {
                var parents = parent;
                if (!forge2.util.isArray(parents)) {
                  parents = [parents];
                }
                var verified = false;
                while (!verified && parents.length > 0) {
                  parent = parents.shift();
                  try {
                    verified = parent.verify(cert);
                  } catch (ex) {
                  }
                }
                if (!verified) {
                  error = {
                    message: "Certificate signature is invalid.",
                    error: pki2.certificateError.bad_certificate
                  };
                }
              }
              if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
                error = {
                  message: "Certificate is not trusted.",
                  error: pki2.certificateError.unknown_ca
                };
              }
            }
            if (error === null && parent && !cert.isIssuer(parent)) {
              error = {
                message: "Certificate issuer is invalid.",
                error: pki2.certificateError.bad_certificate
              };
            }
            if (error === null) {
              var se = {
                keyUsage: true,
                basicConstraints: true
              };
              for (var i = 0; error === null && i < cert.extensions.length; ++i) {
                var ext = cert.extensions[i];
                if (ext.critical && !(ext.name in se)) {
                  error = {
                    message: "Certificate has an unsupported critical extension.",
                    error: pki2.certificateError.unsupported_certificate
                  };
                }
              }
            }
            if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {
              var bcExt = cert.getExtension("basicConstraints");
              var keyUsageExt = cert.getExtension("keyUsage");
              if (keyUsageExt !== null) {
                if (!keyUsageExt.keyCertSign || bcExt === null) {
                  error = {
                    message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                    error: pki2.certificateError.bad_certificate
                  };
                }
              }
              if (error === null && bcExt !== null && !bcExt.cA) {
                error = {
                  message: "Certificate basicConstraints indicates the certificate is not a CA.",
                  error: pki2.certificateError.bad_certificate
                };
              }
              if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
                var pathLen = depth - 1;
                if (pathLen > bcExt.pathLenConstraint) {
                  error = {
                    message: "Certificate basicConstraints pathLenConstraint violated.",
                    error: pki2.certificateError.bad_certificate
                  };
                }
              }
            }
            var vfd = error === null ? true : error.error;
            var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
            if (ret === true) {
              error = null;
            } else {
              if (vfd === true) {
                error = {
                  message: "The application rejected the certificate.",
                  error: pki2.certificateError.bad_certificate
                };
              }
              if (ret || ret === 0) {
                if (typeof ret === "object" && !forge2.util.isArray(ret)) {
                  if (ret.message) {
                    error.message = ret.message;
                  }
                  if (ret.error) {
                    error.error = ret.error;
                  }
                } else if (typeof ret === "string") {
                  error.error = ret;
                }
              }
              throw error;
            }
            first = false;
            ++depth;
          } while (chain.length > 0);
          return true;
        };
        return x509.exports;
      }
      var hasRequiredPkcs12;
      function requirePkcs12() {
        if (hasRequiredPkcs12) return pkcs12.exports;
        hasRequiredPkcs12 = 1;
        var forge2 = requireForge();
        requireAsn1();
        requireHmac();
        requireOids();
        requirePkcs7asn1();
        requirePbe();
        requireRandom();
        requireRsa();
        requireSha1();
        requireUtil();
        requireX509();
        var asn12 = forge2.asn1;
        var pki2 = forge2.pki;
        var p12 = pkcs12.exports = forge2.pkcs12 = forge2.pkcs12 || {};
        var contentInfoValidator = {
          name: "ContentInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          // a ContentInfo
          constructed: true,
          value: [{
            name: "ContentInfo.contentType",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OID,
            constructed: false,
            capture: "contentType"
          }, {
            name: "ContentInfo.content",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            constructed: true,
            captureAsn1: "content"
          }]
        };
        var pfxValidator = {
          name: "PFX",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "PFX.version",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.INTEGER,
              constructed: false,
              capture: "version"
            },
            contentInfoValidator,
            {
              name: "PFX.macData",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              optional: true,
              captureAsn1: "mac",
              value: [{
                name: "PFX.macData.mac",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.SEQUENCE,
                // DigestInfo
                constructed: true,
                value: [{
                  name: "PFX.macData.mac.digestAlgorithm",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.SEQUENCE,
                  // DigestAlgorithmIdentifier
                  constructed: true,
                  value: [{
                    name: "PFX.macData.mac.digestAlgorithm.algorithm",
                    tagClass: asn12.Class.UNIVERSAL,
                    type: asn12.Type.OID,
                    constructed: false,
                    capture: "macAlgorithm"
                  }, {
                    name: "PFX.macData.mac.digestAlgorithm.parameters",
                    tagClass: asn12.Class.UNIVERSAL,
                    captureAsn1: "macAlgorithmParameters"
                  }]
                }, {
                  name: "PFX.macData.mac.digest",
                  tagClass: asn12.Class.UNIVERSAL,
                  type: asn12.Type.OCTETSTRING,
                  constructed: false,
                  capture: "macDigest"
                }]
              }, {
                name: "PFX.macData.macSalt",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.OCTETSTRING,
                constructed: false,
                capture: "macSalt"
              }, {
                name: "PFX.macData.iterations",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.INTEGER,
                constructed: false,
                optional: true,
                capture: "macIterations"
              }]
            }
          ]
        };
        var safeBagValidator = {
          name: "SafeBag",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "SafeBag.bagId",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OID,
            constructed: false,
            capture: "bagId"
          }, {
            name: "SafeBag.bagValue",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            constructed: true,
            captureAsn1: "bagValue"
          }, {
            name: "SafeBag.bagAttributes",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SET,
            constructed: true,
            optional: true,
            capture: "bagAttributes"
          }]
        };
        var attributeValidator = {
          name: "Attribute",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "Attribute.attrId",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OID,
            constructed: false,
            capture: "oid"
          }, {
            name: "Attribute.attrValues",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SET,
            constructed: true,
            capture: "values"
          }]
        };
        var certBagValidator = {
          name: "CertBag",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "CertBag.certId",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OID,
            constructed: false,
            capture: "certId"
          }, {
            name: "CertBag.certValue",
            tagClass: asn12.Class.CONTEXT_SPECIFIC,
            constructed: true,
            /* So far we only support X.509 certificates (which are wrapped in
               an OCTET STRING, hence hard code that here). */
            value: [{
              name: "CertBag.certValue[0]",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Class.OCTETSTRING,
              constructed: false,
              capture: "cert"
            }]
          }]
        };
        function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
          var result = [];
          for (var i = 0; i < safeContents.length; i++) {
            for (var j = 0; j < safeContents[i].safeBags.length; j++) {
              var bag = safeContents[i].safeBags[j];
              if (bagType !== void 0 && bag.type !== bagType) {
                continue;
              }
              if (attrName === null) {
                result.push(bag);
                continue;
              }
              if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {
                result.push(bag);
              }
            }
          }
          return result;
        }
        p12.pkcs12FromAsn1 = function(obj, strict, password) {
          if (typeof strict === "string") {
            password = strict;
            strict = true;
          } else if (strict === void 0) {
            strict = true;
          }
          var capture = {};
          var errors = [];
          if (!asn12.validate(obj, pfxValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
            error.errors = error;
            throw error;
          }
          var pfx = {
            version: capture.version.charCodeAt(0),
            safeContents: [],
            /**
             * Gets bags with matching attributes.
             *
             * @param filter the attributes to filter by:
             *          [localKeyId] the localKeyId to search for.
             *          [localKeyIdHex] the localKeyId in hex to search for.
             *          [friendlyName] the friendly name to search for.
             *          [bagType] bag type to narrow each attribute search by.
             *
             * @return a map of attribute type to an array of matching bags or, if no
             *           attribute was given but a bag type, the map key will be the
             *           bag type.
             */
            getBags: function(filter) {
              var rval = {};
              var localKeyId;
              if ("localKeyId" in filter) {
                localKeyId = filter.localKeyId;
              } else if ("localKeyIdHex" in filter) {
                localKeyId = forge2.util.hexToBytes(filter.localKeyIdHex);
              }
              if (localKeyId === void 0 && !("friendlyName" in filter) && "bagType" in filter) {
                rval[filter.bagType] = _getBagsByAttribute(
                  pfx.safeContents,
                  null,
                  null,
                  filter.bagType
                );
              }
              if (localKeyId !== void 0) {
                rval.localKeyId = _getBagsByAttribute(
                  pfx.safeContents,
                  "localKeyId",
                  localKeyId,
                  filter.bagType
                );
              }
              if ("friendlyName" in filter) {
                rval.friendlyName = _getBagsByAttribute(
                  pfx.safeContents,
                  "friendlyName",
                  filter.friendlyName,
                  filter.bagType
                );
              }
              return rval;
            },
            /**
             * DEPRECATED: use getBags() instead.
             *
             * Get bags with matching friendlyName attribute.
             *
             * @param friendlyName the friendly name to search for.
             * @param [bagType] bag type to narrow search by.
             *
             * @return an array of bags with matching friendlyName attribute.
             */
            getBagsByFriendlyName: function(friendlyName, bagType) {
              return _getBagsByAttribute(
                pfx.safeContents,
                "friendlyName",
                friendlyName,
                bagType
              );
            },
            /**
             * DEPRECATED: use getBags() instead.
             *
             * Get bags with matching localKeyId attribute.
             *
             * @param localKeyId the localKeyId to search for.
             * @param [bagType] bag type to narrow search by.
             *
             * @return an array of bags with matching localKeyId attribute.
             */
            getBagsByLocalKeyId: function(localKeyId, bagType) {
              return _getBagsByAttribute(
                pfx.safeContents,
                "localKeyId",
                localKeyId,
                bagType
              );
            }
          };
          if (capture.version.charCodeAt(0) !== 3) {
            var error = new Error("PKCS#12 PFX of version other than 3 not supported.");
            error.version = capture.version.charCodeAt(0);
            throw error;
          }
          if (asn12.derToOid(capture.contentType) !== pki2.oids.data) {
            var error = new Error("Only PKCS#12 PFX in password integrity mode supported.");
            error.oid = asn12.derToOid(capture.contentType);
            throw error;
          }
          var data = capture.content.value[0];
          if (data.tagClass !== asn12.Class.UNIVERSAL || data.type !== asn12.Type.OCTETSTRING) {
            throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
          }
          data = _decodePkcs7Data(data);
          if (capture.mac) {
            var md2 = null;
            var macKeyBytes = 0;
            var macAlgorithm = asn12.derToOid(capture.macAlgorithm);
            switch (macAlgorithm) {
              case pki2.oids.sha1:
                md2 = forge2.md.sha1.create();
                macKeyBytes = 20;
                break;
              case pki2.oids.sha256:
                md2 = forge2.md.sha256.create();
                macKeyBytes = 32;
                break;
              case pki2.oids.sha384:
                md2 = forge2.md.sha384.create();
                macKeyBytes = 48;
                break;
              case pki2.oids.sha512:
                md2 = forge2.md.sha512.create();
                macKeyBytes = 64;
                break;
              case pki2.oids.md5:
                md2 = forge2.md.md5.create();
                macKeyBytes = 16;
                break;
            }
            if (md2 === null) {
              throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
            }
            var macSalt = new forge2.util.ByteBuffer(capture.macSalt);
            var macIterations = "macIterations" in capture ? parseInt(forge2.util.bytesToHex(capture.macIterations), 16) : 1;
            var macKey = p12.generateKey(
              password,
              macSalt,
              3,
              macIterations,
              macKeyBytes,
              md2
            );
            var mac = forge2.hmac.create();
            mac.start(md2, macKey);
            mac.update(data.value);
            var macValue = mac.getMac();
            if (macValue.getBytes() !== capture.macDigest) {
              throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
            }
          } else if (Array.isArray(obj.value) && obj.value.length > 2) {
            throw new Error("Invalid PKCS#12. macData field present but MAC was not validated.");
          }
          _decodeAuthenticatedSafe(pfx, data.value, strict, password);
          return pfx;
        };
        function _decodePkcs7Data(data) {
          if (data.composed || data.constructed) {
            var value = forge2.util.createBuffer();
            for (var i = 0; i < data.value.length; ++i) {
              value.putBytes(data.value[i].value);
            }
            data.composed = data.constructed = false;
            data.value = value.getBytes();
          }
          return data;
        }
        function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
          authSafe = asn12.fromDer(authSafe, strict);
          if (authSafe.tagClass !== asn12.Class.UNIVERSAL || authSafe.type !== asn12.Type.SEQUENCE || authSafe.constructed !== true) {
            throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
          }
          for (var i = 0; i < authSafe.value.length; i++) {
            var contentInfo = authSafe.value[i];
            var capture = {};
            var errors = [];
            if (!asn12.validate(contentInfo, contentInfoValidator, capture, errors)) {
              var error = new Error("Cannot read ContentInfo.");
              error.errors = errors;
              throw error;
            }
            var obj = {
              encrypted: false
            };
            var safeContents = null;
            var data = capture.content.value[0];
            switch (asn12.derToOid(capture.contentType)) {
              case pki2.oids.data:
                if (data.tagClass !== asn12.Class.UNIVERSAL || data.type !== asn12.Type.OCTETSTRING) {
                  throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
                }
                safeContents = _decodePkcs7Data(data).value;
                break;
              case pki2.oids.encryptedData:
                safeContents = _decryptSafeContents(data, password);
                obj.encrypted = true;
                break;
              default:
                var error = new Error("Unsupported PKCS#12 contentType.");
                error.contentType = asn12.derToOid(capture.contentType);
                throw error;
            }
            obj.safeBags = _decodeSafeContents(safeContents, strict, password);
            pfx.safeContents.push(obj);
          }
        }
        function _decryptSafeContents(data, password) {
          var capture = {};
          var errors = [];
          if (!asn12.validate(
            data,
            forge2.pkcs7.asn1.encryptedDataValidator,
            capture,
            errors
          )) {
            var error = new Error("Cannot read EncryptedContentInfo.");
            error.errors = errors;
            throw error;
          }
          var oid = asn12.derToOid(capture.contentType);
          if (oid !== pki2.oids.data) {
            var error = new Error(
              "PKCS#12 EncryptedContentInfo ContentType is not Data."
            );
            error.oid = oid;
            throw error;
          }
          oid = asn12.derToOid(capture.encAlgorithm);
          var cipher2 = pki2.pbe.getCipher(oid, capture.encParameter, password);
          var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
          var encrypted = forge2.util.createBuffer(encryptedContentAsn1.value);
          cipher2.update(encrypted);
          if (!cipher2.finish()) {
            throw new Error("Failed to decrypt PKCS#12 SafeContents.");
          }
          return cipher2.output.getBytes();
        }
        function _decodeSafeContents(safeContents, strict, password) {
          if (!strict && safeContents.length === 0) {
            return [];
          }
          safeContents = asn12.fromDer(safeContents, strict);
          if (safeContents.tagClass !== asn12.Class.UNIVERSAL || safeContents.type !== asn12.Type.SEQUENCE || safeContents.constructed !== true) {
            throw new Error(
              "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag."
            );
          }
          var res = [];
          for (var i = 0; i < safeContents.value.length; i++) {
            var safeBag = safeContents.value[i];
            var capture = {};
            var errors = [];
            if (!asn12.validate(safeBag, safeBagValidator, capture, errors)) {
              var error = new Error("Cannot read SafeBag.");
              error.errors = errors;
              throw error;
            }
            var bag = {
              type: asn12.derToOid(capture.bagId),
              attributes: _decodeBagAttributes(capture.bagAttributes)
            };
            res.push(bag);
            var validator, decoder;
            var bagAsn1 = capture.bagValue.value[0];
            switch (bag.type) {
              case pki2.oids.pkcs8ShroudedKeyBag:
                bagAsn1 = pki2.decryptPrivateKeyInfo(bagAsn1, password);
                if (bagAsn1 === null) {
                  throw new Error(
                    "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"
                  );
                }
              /* fall through */
              case pki2.oids.keyBag:
                try {
                  bag.key = pki2.privateKeyFromAsn1(bagAsn1);
                } catch (e) {
                  bag.key = null;
                  bag.asn1 = bagAsn1;
                }
                continue;
              /* Nothing more to do. */
              case pki2.oids.certBag:
                validator = certBagValidator;
                decoder = function() {
                  if (asn12.derToOid(capture.certId) !== pki2.oids.x509Certificate) {
                    var error2 = new Error(
                      "Unsupported certificate type, only X.509 supported."
                    );
                    error2.oid = asn12.derToOid(capture.certId);
                    throw error2;
                  }
                  var certAsn1 = asn12.fromDer(capture.cert, strict);
                  try {
                    bag.cert = pki2.certificateFromAsn1(certAsn1, true);
                  } catch (e) {
                    bag.cert = null;
                    bag.asn1 = certAsn1;
                  }
                };
                break;
              default:
                var error = new Error("Unsupported PKCS#12 SafeBag type.");
                error.oid = bag.type;
                throw error;
            }
            if (validator !== void 0 && !asn12.validate(bagAsn1, validator, capture, errors)) {
              var error = new Error("Cannot read PKCS#12 " + validator.name);
              error.errors = errors;
              throw error;
            }
            decoder();
          }
          return res;
        }
        function _decodeBagAttributes(attributes) {
          var decodedAttrs = {};
          if (attributes !== void 0) {
            for (var i = 0; i < attributes.length; ++i) {
              var capture = {};
              var errors = [];
              if (!asn12.validate(attributes[i], attributeValidator, capture, errors)) {
                var error = new Error("Cannot read PKCS#12 BagAttribute.");
                error.errors = errors;
                throw error;
              }
              var oid = asn12.derToOid(capture.oid);
              if (pki2.oids[oid] === void 0) {
                continue;
              }
              decodedAttrs[pki2.oids[oid]] = [];
              for (var j = 0; j < capture.values.length; ++j) {
                decodedAttrs[pki2.oids[oid]].push(capture.values[j].value);
              }
            }
          }
          return decodedAttrs;
        }
        p12.toPkcs12Asn1 = function(key, cert, password, options) {
          options = options || {};
          options.saltSize = options.saltSize || 8;
          options.count = options.count || 2048;
          options.algorithm = options.algorithm || options.encAlgorithm || "aes128";
          if (!("useMac" in options)) {
            options.useMac = true;
          }
          if (!("localKeyId" in options)) {
            options.localKeyId = null;
          }
          if (!("generateLocalKeyId" in options)) {
            options.generateLocalKeyId = true;
          }
          var localKeyId = options.localKeyId;
          var bagAttrs;
          if (localKeyId !== null) {
            localKeyId = forge2.util.hexToBytes(localKeyId);
          } else if (options.generateLocalKeyId) {
            if (cert) {
              var pairedCert = forge2.util.isArray(cert) ? cert[0] : cert;
              if (typeof pairedCert === "string") {
                pairedCert = pki2.certificateFromPem(pairedCert);
              }
              var sha12 = forge2.md.sha1.create();
              sha12.update(asn12.toDer(pki2.certificateToAsn1(pairedCert)).getBytes());
              localKeyId = sha12.digest().getBytes();
            } else {
              localKeyId = forge2.random.getBytes(20);
            }
          }
          var attrs = [];
          if (localKeyId !== null) {
            attrs.push(
              // localKeyID
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // attrId
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(pki2.oids.localKeyId).getBytes()
                ),
                // attrValues
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SET, true, [
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.OCTETSTRING,
                    false,
                    localKeyId
                  )
                ])
              ])
            );
          }
          if ("friendlyName" in options) {
            attrs.push(
              // friendlyName
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // attrId
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(pki2.oids.friendlyName).getBytes()
                ),
                // attrValues
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SET, true, [
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.BMPSTRING,
                    false,
                    options.friendlyName
                  )
                ])
              ])
            );
          }
          if (attrs.length > 0) {
            bagAttrs = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SET, true, attrs);
          }
          var contents = [];
          var chain = [];
          if (cert !== null) {
            if (forge2.util.isArray(cert)) {
              chain = cert;
            } else {
              chain = [cert];
            }
          }
          var certSafeBags = [];
          for (var i = 0; i < chain.length; ++i) {
            cert = chain[i];
            if (typeof cert === "string") {
              cert = pki2.certificateFromPem(cert);
            }
            var certBagAttrs = i === 0 ? bagAttrs : void 0;
            var certAsn1 = pki2.certificateToAsn1(cert);
            var certSafeBag = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // bagId
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(pki2.oids.certBag).getBytes()
              ),
              // bagValue
              asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                // CertBag
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                  // certId
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.OID,
                    false,
                    asn12.oidToDer(pki2.oids.x509Certificate).getBytes()
                  ),
                  // certValue (x509Certificate)
                  asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.OCTETSTRING,
                      false,
                      asn12.toDer(certAsn1).getBytes()
                    )
                  ])
                ])
              ]),
              // bagAttributes (OPTIONAL)
              certBagAttrs
            ]);
            certSafeBags.push(certSafeBag);
          }
          if (certSafeBags.length > 0) {
            var certSafeContents = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.SEQUENCE,
              true,
              certSafeBags
            );
            var certCI = (
              // PKCS#7 ContentInfo
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // contentType
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  // OID for the content type is 'data'
                  asn12.oidToDer(pki2.oids.data).getBytes()
                ),
                // content
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.OCTETSTRING,
                    false,
                    asn12.toDer(certSafeContents).getBytes()
                  )
                ])
              ])
            );
            contents.push(certCI);
          }
          var keyBag = null;
          if (key !== null) {
            var pkAsn1 = pki2.wrapRsaPrivateKey(pki2.privateKeyToAsn1(key));
            if (password === null) {
              keyBag = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // bagId
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(pki2.oids.keyBag).getBytes()
                ),
                // bagValue
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                  // PrivateKeyInfo
                  pkAsn1
                ]),
                // bagAttributes (OPTIONAL)
                bagAttrs
              ]);
            } else {
              keyBag = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // bagId
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(pki2.oids.pkcs8ShroudedKeyBag).getBytes()
                ),
                // bagValue
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                  // EncryptedPrivateKeyInfo
                  pki2.encryptPrivateKeyInfo(pkAsn1, password, options)
                ]),
                // bagAttributes (OPTIONAL)
                bagAttrs
              ]);
            }
            var keySafeContents = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [keyBag]);
            var keyCI = (
              // PKCS#7 ContentInfo
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // contentType
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  // OID for the content type is 'data'
                  asn12.oidToDer(pki2.oids.data).getBytes()
                ),
                // content
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.OCTETSTRING,
                    false,
                    asn12.toDer(keySafeContents).getBytes()
                  )
                ])
              ])
            );
            contents.push(keyCI);
          }
          var safe = asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.SEQUENCE,
            true,
            contents
          );
          var macData;
          if (options.useMac) {
            var sha12 = forge2.md.sha1.create();
            var macSalt = new forge2.util.ByteBuffer(
              forge2.random.getBytes(options.saltSize)
            );
            var count = options.count;
            var key = p12.generateKey(password, macSalt, 3, count, 20);
            var mac = forge2.hmac.create();
            mac.start(sha12, key);
            mac.update(asn12.toDer(safe).getBytes());
            var macValue = mac.getMac();
            macData = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // mac DigestInfo
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // digestAlgorithm
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                  // algorithm = SHA-1
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.OID,
                    false,
                    asn12.oidToDer(pki2.oids.sha1).getBytes()
                  ),
                  // parameters = Null
                  asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
                ]),
                // digest
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OCTETSTRING,
                  false,
                  macValue.getBytes()
                )
              ]),
              // macSalt OCTET STRING
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OCTETSTRING,
                false,
                macSalt.getBytes()
              ),
              // iterations INTEGER (XXX: Only support count < 65536)
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.INTEGER,
                false,
                asn12.integerToDer(count).getBytes()
              )
            ]);
          }
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // version (3)
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              asn12.integerToDer(3).getBytes()
            ),
            // PKCS#7 ContentInfo
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // contentType
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                // OID for the content type is 'data'
                asn12.oidToDer(pki2.oids.data).getBytes()
              ),
              // content
              asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OCTETSTRING,
                  false,
                  asn12.toDer(safe).getBytes()
                )
              ])
            ]),
            macData
          ]);
        };
        p12.generateKey = forge2.pbe.generatePkcs12Key;
        return pkcs12.exports;
      }
      var hasRequiredPki;
      function requirePki() {
        if (hasRequiredPki) return pki.exports;
        hasRequiredPki = 1;
        var forge2 = requireForge();
        requireAsn1();
        requireOids();
        requirePbe();
        requirePem();
        requirePbkdf2();
        requirePkcs12();
        requirePss();
        requireRsa();
        requireUtil();
        requireX509();
        var asn12 = forge2.asn1;
        var pki$1 = pki.exports = forge2.pki = forge2.pki || {};
        pki$1.pemToDer = function(pem2) {
          var msg = forge2.pem.decode(pem2)[0];
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert PEM to DER; PEM is encrypted.");
          }
          return forge2.util.createBuffer(msg.body);
        };
        pki$1.privateKeyFromPem = function(pem2) {
          var msg = forge2.pem.decode(pem2)[0];
          if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
            var error = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert private key from PEM; PEM is encrypted.");
          }
          var obj = asn12.fromDer(msg.body);
          return pki$1.privateKeyFromAsn1(obj);
        };
        pki$1.privateKeyToPem = function(key, maxline) {
          var msg = {
            type: "RSA PRIVATE KEY",
            body: asn12.toDer(pki$1.privateKeyToAsn1(key)).getBytes()
          };
          return forge2.pem.encode(msg, { maxline });
        };
        pki$1.privateKeyInfoToPem = function(pki2, maxline) {
          var msg = {
            type: "PRIVATE KEY",
            body: asn12.toDer(pki2).getBytes()
          };
          return forge2.pem.encode(msg, { maxline });
        };
        return pki.exports;
      }
      var tls_1;
      var hasRequiredTls;
      function requireTls() {
        if (hasRequiredTls) return tls_1;
        hasRequiredTls = 1;
        var forge2 = requireForge();
        requireAsn1();
        requireHmac();
        requireMd5();
        requirePem();
        requirePki();
        requireRandom();
        requireSha1();
        requireUtil();
        var prf_TLS1 = function(secret, label, seed, length) {
          var rval = forge2.util.createBuffer();
          var idx = secret.length >> 1;
          var slen = idx + (secret.length & 1);
          var s1 = secret.substr(0, slen);
          var s2 = secret.substr(idx, slen);
          var ai = forge2.util.createBuffer();
          var hmac2 = forge2.hmac.create();
          seed = label + seed;
          var md5itr = Math.ceil(length / 16);
          var sha1itr = Math.ceil(length / 20);
          hmac2.start("MD5", s1);
          var md5bytes = forge2.util.createBuffer();
          ai.putBytes(seed);
          for (var i = 0; i < md5itr; ++i) {
            hmac2.start(null, null);
            hmac2.update(ai.getBytes());
            ai.putBuffer(hmac2.digest());
            hmac2.start(null, null);
            hmac2.update(ai.bytes() + seed);
            md5bytes.putBuffer(hmac2.digest());
          }
          hmac2.start("SHA1", s2);
          var sha1bytes = forge2.util.createBuffer();
          ai.clear();
          ai.putBytes(seed);
          for (var i = 0; i < sha1itr; ++i) {
            hmac2.start(null, null);
            hmac2.update(ai.getBytes());
            ai.putBuffer(hmac2.digest());
            hmac2.start(null, null);
            hmac2.update(ai.bytes() + seed);
            sha1bytes.putBuffer(hmac2.digest());
          }
          rval.putBytes(forge2.util.xorBytes(
            md5bytes.getBytes(),
            sha1bytes.getBytes(),
            length
          ));
          return rval;
        };
        var hmac_sha1 = function(key2, seqNum, record) {
          var hmac2 = forge2.hmac.create();
          hmac2.start("SHA1", key2);
          var b = forge2.util.createBuffer();
          b.putInt32(seqNum[0]);
          b.putInt32(seqNum[1]);
          b.putByte(record.type);
          b.putByte(record.version.major);
          b.putByte(record.version.minor);
          b.putInt16(record.length);
          b.putBytes(record.fragment.bytes());
          hmac2.update(b.getBytes());
          return hmac2.digest().getBytes();
        };
        var deflate = function(c, record, s) {
          var rval = false;
          try {
            var bytes = c.deflate(record.fragment.getBytes());
            record.fragment = forge2.util.createBuffer(bytes);
            record.length = bytes.length;
            rval = true;
          } catch (ex) {
          }
          return rval;
        };
        var inflate = function(c, record, s) {
          var rval = false;
          try {
            var bytes = c.inflate(record.fragment.getBytes());
            record.fragment = forge2.util.createBuffer(bytes);
            record.length = bytes.length;
            rval = true;
          } catch (ex) {
          }
          return rval;
        };
        var readVector = function(b, lenBytes) {
          var len = 0;
          switch (lenBytes) {
            case 1:
              len = b.getByte();
              break;
            case 2:
              len = b.getInt16();
              break;
            case 3:
              len = b.getInt24();
              break;
            case 4:
              len = b.getInt32();
              break;
          }
          return forge2.util.createBuffer(b.getBytes(len));
        };
        var writeVector = function(b, lenBytes, v) {
          b.putInt(v.length(), lenBytes << 3);
          b.putBuffer(v);
        };
        var tls = {};
        tls.Versions = {
          TLS_1_0: { major: 3, minor: 1 },
          TLS_1_1: { major: 3, minor: 2 },
          TLS_1_2: { major: 3, minor: 3 }
        };
        tls.SupportedVersions = [
          tls.Versions.TLS_1_1,
          tls.Versions.TLS_1_0
        ];
        tls.Version = tls.SupportedVersions[0];
        tls.MaxFragment = 16384 - 1024;
        tls.ConnectionEnd = {
          server: 0,
          client: 1
        };
        tls.PRFAlgorithm = {
          tls_prf_sha256: 0
        };
        tls.BulkCipherAlgorithm = {
          none: null,
          rc4: 0,
          des3: 1,
          aes: 2
        };
        tls.CipherType = {
          stream: 0,
          block: 1,
          aead: 2
        };
        tls.MACAlgorithm = {
          none: null,
          hmac_md5: 0,
          hmac_sha1: 1,
          hmac_sha256: 2,
          hmac_sha384: 3,
          hmac_sha512: 4
        };
        tls.CompressionMethod = {
          none: 0,
          deflate: 1
        };
        tls.ContentType = {
          change_cipher_spec: 20,
          alert: 21,
          handshake: 22,
          application_data: 23,
          heartbeat: 24
        };
        tls.HandshakeType = {
          hello_request: 0,
          client_hello: 1,
          server_hello: 2,
          certificate: 11,
          server_key_exchange: 12,
          certificate_request: 13,
          server_hello_done: 14,
          certificate_verify: 15,
          client_key_exchange: 16,
          finished: 20
        };
        tls.Alert = {};
        tls.Alert.Level = {
          warning: 1,
          fatal: 2
        };
        tls.Alert.Description = {
          close_notify: 0,
          unexpected_message: 10,
          bad_record_mac: 20,
          decryption_failed: 21,
          record_overflow: 22,
          decompression_failure: 30,
          handshake_failure: 40,
          bad_certificate: 42,
          unsupported_certificate: 43,
          certificate_revoked: 44,
          certificate_expired: 45,
          certificate_unknown: 46,
          illegal_parameter: 47,
          unknown_ca: 48,
          access_denied: 49,
          decode_error: 50,
          decrypt_error: 51,
          export_restriction: 60,
          protocol_version: 70,
          insufficient_security: 71,
          internal_error: 80,
          user_canceled: 90,
          no_renegotiation: 100
        };
        tls.HeartbeatMessageType = {
          heartbeat_request: 1,
          heartbeat_response: 2
        };
        tls.CipherSuites = {};
        tls.getCipherSuite = function(twoBytes) {
          var rval = null;
          for (var key2 in tls.CipherSuites) {
            var cs = tls.CipherSuites[key2];
            if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
              rval = cs;
              break;
            }
          }
          return rval;
        };
        tls.handleUnexpected = function(c, record) {
          var ignore = !c.open && c.entity === tls.ConnectionEnd.client;
          if (!ignore) {
            c.error(c, {
              message: "Unexpected message. Received TLS record out of order.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.unexpected_message
              }
            });
          }
        };
        tls.handleHelloRequest = function(c, record, length) {
          if (!c.handshaking && c.handshakes > 0) {
            tls.queue(c, tls.createAlert(c, {
              level: tls.Alert.Level.warning,
              description: tls.Alert.Description.no_renegotiation
            }));
            tls.flush(c);
          }
          c.process();
        };
        tls.parseHelloMessage = function(c, record, length) {
          var msg = null;
          var client2 = c.entity === tls.ConnectionEnd.client;
          if (length < 38) {
            c.error(c, {
              message: client2 ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          } else {
            var b = record.fragment;
            var remaining = b.length();
            msg = {
              version: {
                major: b.getByte(),
                minor: b.getByte()
              },
              random: forge2.util.createBuffer(b.getBytes(32)),
              session_id: readVector(b, 1),
              extensions: []
            };
            if (client2) {
              msg.cipher_suite = b.getBytes(2);
              msg.compression_method = b.getByte();
            } else {
              msg.cipher_suites = readVector(b, 2);
              msg.compression_methods = readVector(b, 1);
            }
            remaining = length - (remaining - b.length());
            if (remaining > 0) {
              var exts = readVector(b, 2);
              while (exts.length() > 0) {
                msg.extensions.push({
                  type: [exts.getByte(), exts.getByte()],
                  data: readVector(exts, 2)
                });
              }
              if (!client2) {
                for (var i = 0; i < msg.extensions.length; ++i) {
                  var ext = msg.extensions[i];
                  if (ext.type[0] === 0 && ext.type[1] === 0) {
                    var snl = readVector(ext.data, 2);
                    while (snl.length() > 0) {
                      var snType = snl.getByte();
                      if (snType !== 0) {
                        break;
                      }
                      c.session.extensions.server_name.serverNameList.push(
                        readVector(snl, 2).getBytes()
                      );
                    }
                  }
                }
              }
            }
            if (c.session.version) {
              if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) {
                return c.error(c, {
                  message: "TLS version change is disallowed during renegotiation.",
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.protocol_version
                  }
                });
              }
            }
            if (client2) {
              c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);
            } else {
              var tmp = forge2.util.createBuffer(msg.cipher_suites.bytes());
              while (tmp.length() > 0) {
                c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));
                if (c.session.cipherSuite !== null) {
                  break;
                }
              }
            }
            if (c.session.cipherSuite === null) {
              return c.error(c, {
                message: "No cipher suites in common.",
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.handshake_failure
                },
                cipherSuite: forge2.util.bytesToHex(msg.cipher_suite)
              });
            }
            if (client2) {
              c.session.compressionMethod = msg.compression_method;
            } else {
              c.session.compressionMethod = tls.CompressionMethod.none;
            }
          }
          return msg;
        };
        tls.createSecurityParameters = function(c, msg) {
          var client2 = c.entity === tls.ConnectionEnd.client;
          var msgRandom = msg.random.bytes();
          var cRandom = client2 ? c.session.sp.client_random : msgRandom;
          var sRandom = client2 ? msgRandom : tls.createRandom().getBytes();
          c.session.sp = {
            entity: c.entity,
            prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
            bulk_cipher_algorithm: null,
            cipher_type: null,
            enc_key_length: null,
            block_length: null,
            fixed_iv_length: null,
            record_iv_length: null,
            mac_algorithm: null,
            mac_length: null,
            mac_key_length: null,
            compression_algorithm: c.session.compressionMethod,
            pre_master_secret: null,
            master_secret: null,
            client_random: cRandom,
            server_random: sRandom
          };
        };
        tls.handleServerHello = function(c, record, length) {
          var msg = tls.parseHelloMessage(c, record, length);
          if (c.fail) {
            return;
          }
          if (msg.version.minor <= c.version.minor) {
            c.version.minor = msg.version.minor;
          } else {
            return c.error(c, {
              message: "Incompatible TLS version.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
          c.session.version = c.version;
          var sessionId = msg.session_id.bytes();
          if (sessionId.length > 0 && sessionId === c.session.id) {
            c.expect = SCC;
            c.session.resuming = true;
            c.session.sp.server_random = msg.random.bytes();
          } else {
            c.expect = SCE;
            c.session.resuming = false;
            tls.createSecurityParameters(c, msg);
          }
          c.session.id = sessionId;
          c.process();
        };
        tls.handleClientHello = function(c, record, length) {
          var msg = tls.parseHelloMessage(c, record, length);
          if (c.fail) {
            return;
          }
          var sessionId = msg.session_id.bytes();
          var session = null;
          if (c.sessionCache) {
            session = c.sessionCache.getSession(sessionId);
            if (session === null) {
              sessionId = "";
            } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
              session = null;
              sessionId = "";
            }
          }
          if (sessionId.length === 0) {
            sessionId = forge2.random.getBytes(32);
          }
          c.session.id = sessionId;
          c.session.clientHelloVersion = msg.version;
          c.session.sp = {};
          if (session) {
            c.version = c.session.version = session.version;
            c.session.sp = session.sp;
          } else {
            var version;
            for (var i = 1; i < tls.SupportedVersions.length; ++i) {
              version = tls.SupportedVersions[i];
              if (version.minor <= msg.version.minor) {
                break;
              }
            }
            c.version = { major: version.major, minor: version.minor };
            c.session.version = c.version;
          }
          if (session !== null) {
            c.expect = CCC;
            c.session.resuming = true;
            c.session.sp.client_random = msg.random.bytes();
          } else {
            c.expect = c.verifyClient !== false ? CCE : CKE;
            c.session.resuming = false;
            tls.createSecurityParameters(c, msg);
          }
          c.open = true;
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createServerHello(c)
          }));
          if (c.session.resuming) {
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.change_cipher_spec,
              data: tls.createChangeCipherSpec()
            }));
            c.state.pending = tls.createConnectionState(c);
            c.state.current.write = c.state.pending.write;
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createFinished(c)
            }));
          } else {
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createCertificate(c)
            }));
            if (!c.fail) {
              tls.queue(c, tls.createRecord(c, {
                type: tls.ContentType.handshake,
                data: tls.createServerKeyExchange(c)
              }));
              if (c.verifyClient !== false) {
                tls.queue(c, tls.createRecord(c, {
                  type: tls.ContentType.handshake,
                  data: tls.createCertificateRequest(c)
                }));
              }
              tls.queue(c, tls.createRecord(c, {
                type: tls.ContentType.handshake,
                data: tls.createServerHelloDone(c)
              }));
            }
          }
          tls.flush(c);
          c.process();
        };
        tls.handleCertificate = function(c, record, length) {
          if (length < 3) {
            return c.error(c, {
              message: "Invalid Certificate message. Message too short.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          }
          var b = record.fragment;
          var msg = {
            certificate_list: readVector(b, 3)
          };
          var cert, asn12;
          var certs = [];
          try {
            while (msg.certificate_list.length() > 0) {
              cert = readVector(msg.certificate_list, 3);
              asn12 = forge2.asn1.fromDer(cert);
              cert = forge2.pki.certificateFromAsn1(asn12, true);
              certs.push(cert);
            }
          } catch (ex) {
            return c.error(c, {
              message: "Could not parse certificate list.",
              cause: ex,
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.bad_certificate
              }
            });
          }
          var client2 = c.entity === tls.ConnectionEnd.client;
          if ((client2 || c.verifyClient === true) && certs.length === 0) {
            c.error(c, {
              message: client2 ? "No server certificate provided." : "No client certificate provided.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          } else if (certs.length === 0) {
            c.expect = client2 ? SKE : CKE;
          } else {
            if (client2) {
              c.session.serverCertificate = certs[0];
            } else {
              c.session.clientCertificate = certs[0];
            }
            if (tls.verifyCertificateChain(c, certs)) {
              c.expect = client2 ? SKE : CKE;
            }
          }
          c.process();
        };
        tls.handleServerKeyExchange = function(c, record, length) {
          if (length > 0) {
            return c.error(c, {
              message: "Invalid key parameters. Only RSA is supported.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.unsupported_certificate
              }
            });
          }
          c.expect = SCR;
          c.process();
        };
        tls.handleClientKeyExchange = function(c, record, length) {
          if (length < 48) {
            return c.error(c, {
              message: "Invalid key parameters. Only RSA is supported.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.unsupported_certificate
              }
            });
          }
          var b = record.fragment;
          var msg = {
            enc_pre_master_secret: readVector(b, 2).getBytes()
          };
          var privateKey = null;
          if (c.getPrivateKey) {
            try {
              privateKey = c.getPrivateKey(c, c.session.serverCertificate);
              privateKey = forge2.pki.privateKeyFromPem(privateKey);
            } catch (ex) {
              c.error(c, {
                message: "Could not get private key.",
                cause: ex,
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.internal_error
                }
              });
            }
          }
          if (privateKey === null) {
            return c.error(c, {
              message: "No private key set.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.internal_error
              }
            });
          }
          try {
            var sp = c.session.sp;
            sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
            var version = c.session.clientHelloVersion;
            if (version.major !== sp.pre_master_secret.charCodeAt(0) || version.minor !== sp.pre_master_secret.charCodeAt(1)) {
              throw new Error("TLS version rollback attack detected.");
            }
          } catch (ex) {
            sp.pre_master_secret = forge2.random.getBytes(48);
          }
          c.expect = CCC;
          if (c.session.clientCertificate !== null) {
            c.expect = CCV;
          }
          c.process();
        };
        tls.handleCertificateRequest = function(c, record, length) {
          if (length < 3) {
            return c.error(c, {
              message: "Invalid CertificateRequest. Message too short.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          }
          var b = record.fragment;
          var msg = {
            certificate_types: readVector(b, 1),
            certificate_authorities: readVector(b, 2)
          };
          c.session.certificateRequest = msg;
          c.expect = SHD;
          c.process();
        };
        tls.handleCertificateVerify = function(c, record, length) {
          if (length < 2) {
            return c.error(c, {
              message: "Invalid CertificateVerify. Message too short.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          }
          var b = record.fragment;
          b.read -= 4;
          var msgBytes = b.bytes();
          b.read += 4;
          var msg = {
            signature: readVector(b, 2).getBytes()
          };
          var verify = forge2.util.createBuffer();
          verify.putBuffer(c.session.md5.digest());
          verify.putBuffer(c.session.sha1.digest());
          verify = verify.getBytes();
          try {
            var cert = c.session.clientCertificate;
            if (!cert.publicKey.verify(verify, msg.signature, "NONE")) {
              throw new Error("CertificateVerify signature does not match.");
            }
            c.session.md5.update(msgBytes);
            c.session.sha1.update(msgBytes);
          } catch (ex) {
            return c.error(c, {
              message: "Bad signature in CertificateVerify.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.handshake_failure
              }
            });
          }
          c.expect = CCC;
          c.process();
        };
        tls.handleServerHelloDone = function(c, record, length) {
          if (length > 0) {
            return c.error(c, {
              message: "Invalid ServerHelloDone message. Invalid length.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.record_overflow
              }
            });
          }
          if (c.serverCertificate === null) {
            var error = {
              message: "No server certificate provided. Not enough security.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.insufficient_security
              }
            };
            var depth = 0;
            var ret = c.verify(c, error.alert.description, depth, []);
            if (ret !== true) {
              if (ret || ret === 0) {
                if (typeof ret === "object" && !forge2.util.isArray(ret)) {
                  if (ret.message) {
                    error.message = ret.message;
                  }
                  if (ret.alert) {
                    error.alert.description = ret.alert;
                  }
                } else if (typeof ret === "number") {
                  error.alert.description = ret;
                }
              }
              return c.error(c, error);
            }
          }
          if (c.session.certificateRequest !== null) {
            record = tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createCertificate(c)
            });
            tls.queue(c, record);
          }
          record = tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createClientKeyExchange(c)
          });
          tls.queue(c, record);
          c.expect = SER;
          var callback = function(c2, signature) {
            if (c2.session.certificateRequest !== null && c2.session.clientCertificate !== null) {
              tls.queue(c2, tls.createRecord(c2, {
                type: tls.ContentType.handshake,
                data: tls.createCertificateVerify(c2, signature)
              }));
            }
            tls.queue(c2, tls.createRecord(c2, {
              type: tls.ContentType.change_cipher_spec,
              data: tls.createChangeCipherSpec()
            }));
            c2.state.pending = tls.createConnectionState(c2);
            c2.state.current.write = c2.state.pending.write;
            tls.queue(c2, tls.createRecord(c2, {
              type: tls.ContentType.handshake,
              data: tls.createFinished(c2)
            }));
            c2.expect = SCC;
            tls.flush(c2);
            c2.process();
          };
          if (c.session.certificateRequest === null || c.session.clientCertificate === null) {
            return callback(c, null);
          }
          tls.getClientSignature(c, callback);
        };
        tls.handleChangeCipherSpec = function(c, record) {
          if (record.fragment.getByte() !== 1) {
            return c.error(c, {
              message: "Invalid ChangeCipherSpec message received.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          }
          var client2 = c.entity === tls.ConnectionEnd.client;
          if (c.session.resuming && client2 || !c.session.resuming && !client2) {
            c.state.pending = tls.createConnectionState(c);
          }
          c.state.current.read = c.state.pending.read;
          if (!c.session.resuming && client2 || c.session.resuming && !client2) {
            c.state.pending = null;
          }
          c.expect = client2 ? SFI : CFI;
          c.process();
        };
        tls.handleFinished = function(c, record, length) {
          var b = record.fragment;
          b.read -= 4;
          var msgBytes = b.bytes();
          b.read += 4;
          var vd = record.fragment.getBytes();
          b = forge2.util.createBuffer();
          b.putBuffer(c.session.md5.digest());
          b.putBuffer(c.session.sha1.digest());
          var client2 = c.entity === tls.ConnectionEnd.client;
          var label = client2 ? "server finished" : "client finished";
          var sp = c.session.sp;
          var vdl = 12;
          var prf = prf_TLS1;
          b = prf(sp.master_secret, label, b.getBytes(), vdl);
          if (b.getBytes() !== vd) {
            return c.error(c, {
              message: "Invalid verify_data in Finished message.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.decrypt_error
              }
            });
          }
          c.session.md5.update(msgBytes);
          c.session.sha1.update(msgBytes);
          if (c.session.resuming && client2 || !c.session.resuming && !client2) {
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.change_cipher_spec,
              data: tls.createChangeCipherSpec()
            }));
            c.state.current.write = c.state.pending.write;
            c.state.pending = null;
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createFinished(c)
            }));
          }
          c.expect = client2 ? SAD : CAD;
          c.handshaking = false;
          ++c.handshakes;
          c.peerCertificate = client2 ? c.session.serverCertificate : c.session.clientCertificate;
          tls.flush(c);
          c.isConnected = true;
          c.connected(c);
          c.process();
        };
        tls.handleAlert = function(c, record) {
          var b = record.fragment;
          var alert = {
            level: b.getByte(),
            description: b.getByte()
          };
          var msg;
          switch (alert.description) {
            case tls.Alert.Description.close_notify:
              msg = "Connection closed.";
              break;
            case tls.Alert.Description.unexpected_message:
              msg = "Unexpected message.";
              break;
            case tls.Alert.Description.bad_record_mac:
              msg = "Bad record MAC.";
              break;
            case tls.Alert.Description.decryption_failed:
              msg = "Decryption failed.";
              break;
            case tls.Alert.Description.record_overflow:
              msg = "Record overflow.";
              break;
            case tls.Alert.Description.decompression_failure:
              msg = "Decompression failed.";
              break;
            case tls.Alert.Description.handshake_failure:
              msg = "Handshake failure.";
              break;
            case tls.Alert.Description.bad_certificate:
              msg = "Bad certificate.";
              break;
            case tls.Alert.Description.unsupported_certificate:
              msg = "Unsupported certificate.";
              break;
            case tls.Alert.Description.certificate_revoked:
              msg = "Certificate revoked.";
              break;
            case tls.Alert.Description.certificate_expired:
              msg = "Certificate expired.";
              break;
            case tls.Alert.Description.certificate_unknown:
              msg = "Certificate unknown.";
              break;
            case tls.Alert.Description.illegal_parameter:
              msg = "Illegal parameter.";
              break;
            case tls.Alert.Description.unknown_ca:
              msg = "Unknown certificate authority.";
              break;
            case tls.Alert.Description.access_denied:
              msg = "Access denied.";
              break;
            case tls.Alert.Description.decode_error:
              msg = "Decode error.";
              break;
            case tls.Alert.Description.decrypt_error:
              msg = "Decrypt error.";
              break;
            case tls.Alert.Description.export_restriction:
              msg = "Export restriction.";
              break;
            case tls.Alert.Description.protocol_version:
              msg = "Unsupported protocol version.";
              break;
            case tls.Alert.Description.insufficient_security:
              msg = "Insufficient security.";
              break;
            case tls.Alert.Description.internal_error:
              msg = "Internal error.";
              break;
            case tls.Alert.Description.user_canceled:
              msg = "User canceled.";
              break;
            case tls.Alert.Description.no_renegotiation:
              msg = "Renegotiation not supported.";
              break;
            default:
              msg = "Unknown error.";
              break;
          }
          if (alert.description === tls.Alert.Description.close_notify) {
            return c.close();
          }
          c.error(c, {
            message: msg,
            send: false,
            // origin is the opposite end
            origin: c.entity === tls.ConnectionEnd.client ? "server" : "client",
            alert
          });
          c.process();
        };
        tls.handleHandshake = function(c, record) {
          var b = record.fragment;
          var type = b.getByte();
          var length = b.getInt24();
          if (length > b.length()) {
            c.fragmented = record;
            record.fragment = forge2.util.createBuffer();
            b.read -= 4;
            return c.process();
          }
          c.fragmented = null;
          b.read -= 4;
          var bytes = b.bytes(length + 4);
          b.read += 4;
          if (type in hsTable[c.entity][c.expect]) {
            if (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {
              c.handshaking = true;
              c.session = {
                version: null,
                extensions: {
                  server_name: {
                    serverNameList: []
                  }
                },
                cipherSuite: null,
                compressionMethod: null,
                serverCertificate: null,
                clientCertificate: null,
                md5: forge2.md.md5.create(),
                sha1: forge2.md.sha1.create()
              };
            }
            if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {
              c.session.md5.update(bytes);
              c.session.sha1.update(bytes);
            }
            hsTable[c.entity][c.expect][type](c, record, length);
          } else {
            tls.handleUnexpected(c, record);
          }
        };
        tls.handleApplicationData = function(c, record) {
          c.data.putBuffer(record.fragment);
          c.dataReady(c);
          c.process();
        };
        tls.handleHeartbeat = function(c, record) {
          var b = record.fragment;
          var type = b.getByte();
          var length = b.getInt16();
          var payload = b.getBytes(length);
          if (type === tls.HeartbeatMessageType.heartbeat_request) {
            if (c.handshaking || length > payload.length) {
              return c.process();
            }
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.heartbeat,
              data: tls.createHeartbeat(
                tls.HeartbeatMessageType.heartbeat_response,
                payload
              )
            }));
            tls.flush(c);
          } else if (type === tls.HeartbeatMessageType.heartbeat_response) {
            if (payload !== c.expectedHeartbeatPayload) {
              return c.process();
            }
            if (c.heartbeatReceived) {
              c.heartbeatReceived(c, forge2.util.createBuffer(payload));
            }
          }
          c.process();
        };
        var SHE = 0;
        var SCE = 1;
        var SKE = 2;
        var SCR = 3;
        var SHD = 4;
        var SCC = 5;
        var SFI = 6;
        var SAD = 7;
        var SER = 8;
        var CHE = 0;
        var CCE = 1;
        var CKE = 2;
        var CCV = 3;
        var CCC = 4;
        var CFI = 5;
        var CAD = 6;
        var __ = tls.handleUnexpected;
        var R0 = tls.handleChangeCipherSpec;
        var R1 = tls.handleAlert;
        var R2 = tls.handleHandshake;
        var R3 = tls.handleApplicationData;
        var R4 = tls.handleHeartbeat;
        var ctTable = [];
        ctTable[tls.ConnectionEnd.client] = [
          //      CC,AL,HS,AD,HB
          /*SHE*/
          [__, R1, R2, __, R4],
          /*SCE*/
          [__, R1, R2, __, R4],
          /*SKE*/
          [__, R1, R2, __, R4],
          /*SCR*/
          [__, R1, R2, __, R4],
          /*SHD*/
          [__, R1, R2, __, R4],
          /*SCC*/
          [R0, R1, __, __, R4],
          /*SFI*/
          [__, R1, R2, __, R4],
          /*SAD*/
          [__, R1, R2, R3, R4],
          /*SER*/
          [__, R1, R2, __, R4]
        ];
        ctTable[tls.ConnectionEnd.server] = [
          //      CC,AL,HS,AD
          /*CHE*/
          [__, R1, R2, __, R4],
          /*CCE*/
          [__, R1, R2, __, R4],
          /*CKE*/
          [__, R1, R2, __, R4],
          /*CCV*/
          [__, R1, R2, __, R4],
          /*CCC*/
          [R0, R1, __, __, R4],
          /*CFI*/
          [__, R1, R2, __, R4],
          /*CAD*/
          [__, R1, R2, R3, R4],
          /*CER*/
          [__, R1, R2, __, R4]
        ];
        var H0 = tls.handleHelloRequest;
        var H1 = tls.handleServerHello;
        var H2 = tls.handleCertificate;
        var H3 = tls.handleServerKeyExchange;
        var H4 = tls.handleCertificateRequest;
        var H5 = tls.handleServerHelloDone;
        var H6 = tls.handleFinished;
        var hsTable = [];
        hsTable[tls.ConnectionEnd.client] = [
          //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI
          /*SHE*/
          [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*SCE*/
          [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __],
          /*SKE*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],
          /*SCR*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],
          /*SHD*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],
          /*SCC*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*SFI*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
          /*SAD*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*SER*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
        ];
        var H7 = tls.handleClientHello;
        var H8 = tls.handleClientKeyExchange;
        var H9 = tls.handleCertificateVerify;
        hsTable[tls.ConnectionEnd.server] = [
          //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI
          /*CHE*/
          [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*CCE*/
          [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __],
          /*CKE*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],
          /*CCV*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],
          /*CCC*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*CFI*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
          /*CAD*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*CER*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
        ];
        tls.generateKeys = function(c, sp) {
          var prf = prf_TLS1;
          var random2 = sp.client_random + sp.server_random;
          if (!c.session.resuming) {
            sp.master_secret = prf(
              sp.pre_master_secret,
              "master secret",
              random2,
              48
            ).bytes();
            sp.pre_master_secret = null;
          }
          random2 = sp.server_random + sp.client_random;
          var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
          var tls10 = c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor;
          if (tls10) {
            length += 2 * sp.fixed_iv_length;
          }
          var km = prf(sp.master_secret, "key expansion", random2, length);
          var rval = {
            client_write_MAC_key: km.getBytes(sp.mac_key_length),
            server_write_MAC_key: km.getBytes(sp.mac_key_length),
            client_write_key: km.getBytes(sp.enc_key_length),
            server_write_key: km.getBytes(sp.enc_key_length)
          };
          if (tls10) {
            rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
            rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
          }
          return rval;
        };
        tls.createConnectionState = function(c) {
          var client2 = c.entity === tls.ConnectionEnd.client;
          var createMode = function() {
            var mode = {
              // two 32-bit numbers, first is most significant
              sequenceNumber: [0, 0],
              macKey: null,
              macLength: 0,
              macFunction: null,
              cipherState: null,
              cipherFunction: function(record) {
                return true;
              },
              compressionState: null,
              compressFunction: function(record) {
                return true;
              },
              updateSequenceNumber: function() {
                if (mode.sequenceNumber[1] === 4294967295) {
                  mode.sequenceNumber[1] = 0;
                  ++mode.sequenceNumber[0];
                } else {
                  ++mode.sequenceNumber[1];
                }
              }
            };
            return mode;
          };
          var state = {
            read: createMode(),
            write: createMode()
          };
          state.read.update = function(c2, record) {
            if (!state.read.cipherFunction(record, state.read)) {
              c2.error(c2, {
                message: "Could not decrypt record or bad MAC.",
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  // doesn't matter if decryption failed or MAC was
                  // invalid, return the same error so as not to reveal
                  // which one occurred
                  description: tls.Alert.Description.bad_record_mac
                }
              });
            } else if (!state.read.compressFunction(c2, record, state.read)) {
              c2.error(c2, {
                message: "Could not decompress record.",
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.decompression_failure
                }
              });
            }
            return !c2.fail;
          };
          state.write.update = function(c2, record) {
            if (!state.write.compressFunction(c2, record, state.write)) {
              c2.error(c2, {
                message: "Could not compress record.",
                send: false,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.internal_error
                }
              });
            } else if (!state.write.cipherFunction(record, state.write)) {
              c2.error(c2, {
                message: "Could not encrypt record.",
                send: false,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.internal_error
                }
              });
            }
            return !c2.fail;
          };
          if (c.session) {
            var sp = c.session.sp;
            c.session.cipherSuite.initSecurityParameters(sp);
            sp.keys = tls.generateKeys(c, sp);
            state.read.macKey = client2 ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
            state.write.macKey = client2 ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
            c.session.cipherSuite.initConnectionState(state, c, sp);
            switch (sp.compression_algorithm) {
              case tls.CompressionMethod.none:
                break;
              case tls.CompressionMethod.deflate:
                state.read.compressFunction = inflate;
                state.write.compressFunction = deflate;
                break;
              default:
                throw new Error("Unsupported compression algorithm.");
            }
          }
          return state;
        };
        tls.createRandom = function() {
          var d = /* @__PURE__ */ new Date();
          var utc = +d + d.getTimezoneOffset() * 6e4;
          var rval = forge2.util.createBuffer();
          rval.putInt32(utc);
          rval.putBytes(forge2.random.getBytes(28));
          return rval;
        };
        tls.createRecord = function(c, options) {
          if (!options.data) {
            return null;
          }
          var record = {
            type: options.type,
            version: {
              major: c.version.major,
              minor: c.version.minor
            },
            length: options.data.length(),
            fragment: options.data
          };
          return record;
        };
        tls.createAlert = function(c, alert) {
          var b = forge2.util.createBuffer();
          b.putByte(alert.level);
          b.putByte(alert.description);
          return tls.createRecord(c, {
            type: tls.ContentType.alert,
            data: b
          });
        };
        tls.createClientHello = function(c) {
          c.session.clientHelloVersion = {
            major: c.version.major,
            minor: c.version.minor
          };
          var cipherSuites = forge2.util.createBuffer();
          for (var i = 0; i < c.cipherSuites.length; ++i) {
            var cs = c.cipherSuites[i];
            cipherSuites.putByte(cs.id[0]);
            cipherSuites.putByte(cs.id[1]);
          }
          var cSuites = cipherSuites.length();
          var compressionMethods = forge2.util.createBuffer();
          compressionMethods.putByte(tls.CompressionMethod.none);
          var cMethods = compressionMethods.length();
          var extensions2 = forge2.util.createBuffer();
          if (c.virtualHost) {
            var ext = forge2.util.createBuffer();
            ext.putByte(0);
            ext.putByte(0);
            var serverName = forge2.util.createBuffer();
            serverName.putByte(0);
            writeVector(serverName, 2, forge2.util.createBuffer(c.virtualHost));
            var snList = forge2.util.createBuffer();
            writeVector(snList, 2, serverName);
            writeVector(ext, 2, snList);
            extensions2.putBuffer(ext);
          }
          var extLength = extensions2.length();
          if (extLength > 0) {
            extLength += 2;
          }
          var sessionId = c.session.id;
          var length = sessionId.length + 1 + // session ID vector
          2 + // version (major + minor)
          4 + 28 + // random time and random bytes
          2 + cSuites + // cipher suites vector
          1 + cMethods + // compression methods vector
          extLength;
          var rval = forge2.util.createBuffer();
          rval.putByte(tls.HandshakeType.client_hello);
          rval.putInt24(length);
          rval.putByte(c.version.major);
          rval.putByte(c.version.minor);
          rval.putBytes(c.session.sp.client_random);
          writeVector(rval, 1, forge2.util.createBuffer(sessionId));
          writeVector(rval, 2, cipherSuites);
          writeVector(rval, 1, compressionMethods);
          if (extLength > 0) {
            writeVector(rval, 2, extensions2);
          }
          return rval;
        };
        tls.createServerHello = function(c) {
          var sessionId = c.session.id;
          var length = sessionId.length + 1 + // session ID vector
          2 + // version (major + minor)
          4 + 28 + // random time and random bytes
          2 + // chosen cipher suite
          1;
          var rval = forge2.util.createBuffer();
          rval.putByte(tls.HandshakeType.server_hello);
          rval.putInt24(length);
          rval.putByte(c.version.major);
          rval.putByte(c.version.minor);
          rval.putBytes(c.session.sp.server_random);
          writeVector(rval, 1, forge2.util.createBuffer(sessionId));
          rval.putByte(c.session.cipherSuite.id[0]);
          rval.putByte(c.session.cipherSuite.id[1]);
          rval.putByte(c.session.compressionMethod);
          return rval;
        };
        tls.createCertificate = function(c) {
          var client2 = c.entity === tls.ConnectionEnd.client;
          var cert = null;
          if (c.getCertificate) {
            var hint;
            if (client2) {
              hint = c.session.certificateRequest;
            } else {
              hint = c.session.extensions.server_name.serverNameList;
            }
            cert = c.getCertificate(c, hint);
          }
          var certList = forge2.util.createBuffer();
          if (cert !== null) {
            try {
              if (!forge2.util.isArray(cert)) {
                cert = [cert];
              }
              var asn12 = null;
              for (var i = 0; i < cert.length; ++i) {
                var msg = forge2.pem.decode(cert[i])[0];
                if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
                  var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
                  error.headerType = msg.type;
                  throw error;
                }
                if (msg.procType && msg.procType.type === "ENCRYPTED") {
                  throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
                }
                var der = forge2.util.createBuffer(msg.body);
                if (asn12 === null) {
                  asn12 = forge2.asn1.fromDer(der.bytes(), false);
                }
                var certBuffer = forge2.util.createBuffer();
                writeVector(certBuffer, 3, der);
                certList.putBuffer(certBuffer);
              }
              cert = forge2.pki.certificateFromAsn1(asn12);
              if (client2) {
                c.session.clientCertificate = cert;
              } else {
                c.session.serverCertificate = cert;
              }
            } catch (ex) {
              return c.error(c, {
                message: "Could not send certificate list.",
                cause: ex,
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.bad_certificate
                }
              });
            }
          }
          var length = 3 + certList.length();
          var rval = forge2.util.createBuffer();
          rval.putByte(tls.HandshakeType.certificate);
          rval.putInt24(length);
          writeVector(rval, 3, certList);
          return rval;
        };
        tls.createClientKeyExchange = function(c) {
          var b = forge2.util.createBuffer();
          b.putByte(c.session.clientHelloVersion.major);
          b.putByte(c.session.clientHelloVersion.minor);
          b.putBytes(forge2.random.getBytes(46));
          var sp = c.session.sp;
          sp.pre_master_secret = b.getBytes();
          var key2 = c.session.serverCertificate.publicKey;
          b = key2.encrypt(sp.pre_master_secret);
          var length = b.length + 2;
          var rval = forge2.util.createBuffer();
          rval.putByte(tls.HandshakeType.client_key_exchange);
          rval.putInt24(length);
          rval.putInt16(b.length);
          rval.putBytes(b);
          return rval;
        };
        tls.createServerKeyExchange = function(c) {
          var rval = forge2.util.createBuffer();
          return rval;
        };
        tls.getClientSignature = function(c, callback) {
          var b = forge2.util.createBuffer();
          b.putBuffer(c.session.md5.digest());
          b.putBuffer(c.session.sha1.digest());
          b = b.getBytes();
          c.getSignature = c.getSignature || function(c2, b2, callback2) {
            var privateKey = null;
            if (c2.getPrivateKey) {
              try {
                privateKey = c2.getPrivateKey(c2, c2.session.clientCertificate);
                privateKey = forge2.pki.privateKeyFromPem(privateKey);
              } catch (ex) {
                c2.error(c2, {
                  message: "Could not get private key.",
                  cause: ex,
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.internal_error
                  }
                });
              }
            }
            if (privateKey === null) {
              c2.error(c2, {
                message: "No private key set.",
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.internal_error
                }
              });
            } else {
              b2 = privateKey.sign(b2, null);
            }
            callback2(c2, b2);
          };
          c.getSignature(c, b, callback);
        };
        tls.createCertificateVerify = function(c, signature) {
          var length = signature.length + 2;
          var rval = forge2.util.createBuffer();
          rval.putByte(tls.HandshakeType.certificate_verify);
          rval.putInt24(length);
          rval.putInt16(signature.length);
          rval.putBytes(signature);
          return rval;
        };
        tls.createCertificateRequest = function(c) {
          var certTypes = forge2.util.createBuffer();
          certTypes.putByte(1);
          var cAs = forge2.util.createBuffer();
          for (var key2 in c.caStore.certs) {
            var cert = c.caStore.certs[key2];
            var dn = forge2.pki.distinguishedNameToAsn1(cert.subject);
            var byteBuffer = forge2.asn1.toDer(dn);
            cAs.putInt16(byteBuffer.length());
            cAs.putBuffer(byteBuffer);
          }
          var length = 1 + certTypes.length() + 2 + cAs.length();
          var rval = forge2.util.createBuffer();
          rval.putByte(tls.HandshakeType.certificate_request);
          rval.putInt24(length);
          writeVector(rval, 1, certTypes);
          writeVector(rval, 2, cAs);
          return rval;
        };
        tls.createServerHelloDone = function(c) {
          var rval = forge2.util.createBuffer();
          rval.putByte(tls.HandshakeType.server_hello_done);
          rval.putInt24(0);
          return rval;
        };
        tls.createChangeCipherSpec = function() {
          var rval = forge2.util.createBuffer();
          rval.putByte(1);
          return rval;
        };
        tls.createFinished = function(c) {
          var b = forge2.util.createBuffer();
          b.putBuffer(c.session.md5.digest());
          b.putBuffer(c.session.sha1.digest());
          var client2 = c.entity === tls.ConnectionEnd.client;
          var sp = c.session.sp;
          var vdl = 12;
          var prf = prf_TLS1;
          var label = client2 ? "client finished" : "server finished";
          b = prf(sp.master_secret, label, b.getBytes(), vdl);
          var rval = forge2.util.createBuffer();
          rval.putByte(tls.HandshakeType.finished);
          rval.putInt24(b.length());
          rval.putBuffer(b);
          return rval;
        };
        tls.createHeartbeat = function(type, payload, payloadLength) {
          if (typeof payloadLength === "undefined") {
            payloadLength = payload.length;
          }
          var rval = forge2.util.createBuffer();
          rval.putByte(type);
          rval.putInt16(payloadLength);
          rval.putBytes(payload);
          var plaintextLength = rval.length();
          var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
          rval.putBytes(forge2.random.getBytes(paddingLength));
          return rval;
        };
        tls.queue = function(c, record) {
          if (!record) {
            return;
          }
          if (record.fragment.length() === 0) {
            if (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec) {
              return;
            }
          }
          if (record.type === tls.ContentType.handshake) {
            var bytes = record.fragment.bytes();
            c.session.md5.update(bytes);
            c.session.sha1.update(bytes);
            bytes = null;
          }
          var records;
          if (record.fragment.length() <= tls.MaxFragment) {
            records = [record];
          } else {
            records = [];
            var data = record.fragment.bytes();
            while (data.length > tls.MaxFragment) {
              records.push(tls.createRecord(c, {
                type: record.type,
                data: forge2.util.createBuffer(data.slice(0, tls.MaxFragment))
              }));
              data = data.slice(tls.MaxFragment);
            }
            if (data.length > 0) {
              records.push(tls.createRecord(c, {
                type: record.type,
                data: forge2.util.createBuffer(data)
              }));
            }
          }
          for (var i = 0; i < records.length && !c.fail; ++i) {
            var rec = records[i];
            var s = c.state.current.write;
            if (s.update(c, rec)) {
              c.records.push(rec);
            }
          }
        };
        tls.flush = function(c) {
          for (var i = 0; i < c.records.length; ++i) {
            var record = c.records[i];
            c.tlsData.putByte(record.type);
            c.tlsData.putByte(record.version.major);
            c.tlsData.putByte(record.version.minor);
            c.tlsData.putInt16(record.fragment.length());
            c.tlsData.putBuffer(c.records[i].fragment);
          }
          c.records = [];
          return c.tlsDataReady(c);
        };
        var _certErrorToAlertDesc = function(error) {
          switch (error) {
            case true:
              return true;
            case forge2.pki.certificateError.bad_certificate:
              return tls.Alert.Description.bad_certificate;
            case forge2.pki.certificateError.unsupported_certificate:
              return tls.Alert.Description.unsupported_certificate;
            case forge2.pki.certificateError.certificate_revoked:
              return tls.Alert.Description.certificate_revoked;
            case forge2.pki.certificateError.certificate_expired:
              return tls.Alert.Description.certificate_expired;
            case forge2.pki.certificateError.certificate_unknown:
              return tls.Alert.Description.certificate_unknown;
            case forge2.pki.certificateError.unknown_ca:
              return tls.Alert.Description.unknown_ca;
            default:
              return tls.Alert.Description.bad_certificate;
          }
        };
        var _alertDescToCertError = function(desc) {
          switch (desc) {
            case true:
              return true;
            case tls.Alert.Description.bad_certificate:
              return forge2.pki.certificateError.bad_certificate;
            case tls.Alert.Description.unsupported_certificate:
              return forge2.pki.certificateError.unsupported_certificate;
            case tls.Alert.Description.certificate_revoked:
              return forge2.pki.certificateError.certificate_revoked;
            case tls.Alert.Description.certificate_expired:
              return forge2.pki.certificateError.certificate_expired;
            case tls.Alert.Description.certificate_unknown:
              return forge2.pki.certificateError.certificate_unknown;
            case tls.Alert.Description.unknown_ca:
              return forge2.pki.certificateError.unknown_ca;
            default:
              return forge2.pki.certificateError.bad_certificate;
          }
        };
        tls.verifyCertificateChain = function(c, chain) {
          try {
            var options = {};
            for (var key2 in c.verifyOptions) {
              options[key2] = c.verifyOptions[key2];
            }
            options.verify = function(vfd, depth, chain2) {
              var desc = _certErrorToAlertDesc(vfd);
              var ret = c.verify(c, vfd, depth, chain2);
              if (ret !== true) {
                if (typeof ret === "object" && !forge2.util.isArray(ret)) {
                  var error = new Error("The application rejected the certificate.");
                  error.send = true;
                  error.alert = {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.bad_certificate
                  };
                  if (ret.message) {
                    error.message = ret.message;
                  }
                  if (ret.alert) {
                    error.alert.description = ret.alert;
                  }
                  throw error;
                }
                if (ret !== vfd) {
                  ret = _alertDescToCertError(ret);
                }
              }
              return ret;
            };
            forge2.pki.verifyCertificateChain(c.caStore, chain, options);
          } catch (ex) {
            var err2 = ex;
            if (typeof err2 !== "object" || forge2.util.isArray(err2)) {
              err2 = {
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: _certErrorToAlertDesc(ex)
                }
              };
            }
            if (!("send" in err2)) {
              err2.send = true;
            }
            if (!("alert" in err2)) {
              err2.alert = {
                level: tls.Alert.Level.fatal,
                description: _certErrorToAlertDesc(err2.error)
              };
            }
            c.error(c, err2);
          }
          return !c.fail;
        };
        tls.createSessionCache = function(cache, capacity) {
          var rval = null;
          if (cache && cache.getSession && cache.setSession && cache.order) {
            rval = cache;
          } else {
            rval = {};
            rval.cache = cache || {};
            rval.capacity = Math.max(capacity || 100, 1);
            rval.order = [];
            for (var key2 in cache) {
              if (rval.order.length <= capacity) {
                rval.order.push(key2);
              } else {
                delete cache[key2];
              }
            }
            rval.getSession = function(sessionId) {
              var session = null;
              var key3 = null;
              if (sessionId) {
                key3 = forge2.util.bytesToHex(sessionId);
              } else if (rval.order.length > 0) {
                key3 = rval.order[0];
              }
              if (key3 !== null && key3 in rval.cache) {
                session = rval.cache[key3];
                delete rval.cache[key3];
                for (var i in rval.order) {
                  if (rval.order[i] === key3) {
                    rval.order.splice(i, 1);
                    break;
                  }
                }
              }
              return session;
            };
            rval.setSession = function(sessionId, session) {
              if (rval.order.length === rval.capacity) {
                var key3 = rval.order.shift();
                delete rval.cache[key3];
              }
              var key3 = forge2.util.bytesToHex(sessionId);
              rval.order.push(key3);
              rval.cache[key3] = session;
            };
          }
          return rval;
        };
        tls.createConnection = function(options) {
          var caStore = null;
          if (options.caStore) {
            if (forge2.util.isArray(options.caStore)) {
              caStore = forge2.pki.createCaStore(options.caStore);
            } else {
              caStore = options.caStore;
            }
          } else {
            caStore = forge2.pki.createCaStore();
          }
          var cipherSuites = options.cipherSuites || null;
          if (cipherSuites === null) {
            cipherSuites = [];
            for (var key2 in tls.CipherSuites) {
              cipherSuites.push(tls.CipherSuites[key2]);
            }
          }
          var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;
          var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;
          var c = {
            version: { major: tls.Version.major, minor: tls.Version.minor },
            entity,
            sessionId: options.sessionId,
            caStore,
            sessionCache,
            cipherSuites,
            connected: options.connected,
            virtualHost: options.virtualHost || null,
            verifyClient: options.verifyClient || false,
            verify: options.verify || function(cn, vfd, dpth, cts) {
              return vfd;
            },
            verifyOptions: options.verifyOptions || {},
            getCertificate: options.getCertificate || null,
            getPrivateKey: options.getPrivateKey || null,
            getSignature: options.getSignature || null,
            input: forge2.util.createBuffer(),
            tlsData: forge2.util.createBuffer(),
            data: forge2.util.createBuffer(),
            tlsDataReady: options.tlsDataReady,
            dataReady: options.dataReady,
            heartbeatReceived: options.heartbeatReceived,
            closed: options.closed,
            error: function(c2, ex) {
              ex.origin = ex.origin || (c2.entity === tls.ConnectionEnd.client ? "client" : "server");
              if (ex.send) {
                tls.queue(c2, tls.createAlert(c2, ex.alert));
                tls.flush(c2);
              }
              var fatal = ex.fatal !== false;
              if (fatal) {
                c2.fail = true;
              }
              options.error(c2, ex);
              if (fatal) {
                c2.close(false);
              }
            },
            deflate: options.deflate || null,
            inflate: options.inflate || null
          };
          c.reset = function(clearFail) {
            c.version = { major: tls.Version.major, minor: tls.Version.minor };
            c.record = null;
            c.session = null;
            c.peerCertificate = null;
            c.state = {
              pending: null,
              current: null
            };
            c.expect = c.entity === tls.ConnectionEnd.client ? SHE : CHE;
            c.fragmented = null;
            c.records = [];
            c.open = false;
            c.handshakes = 0;
            c.handshaking = false;
            c.isConnected = false;
            c.fail = !(clearFail || typeof clearFail === "undefined");
            c.input.clear();
            c.tlsData.clear();
            c.data.clear();
            c.state.current = tls.createConnectionState(c);
          };
          c.reset();
          var _update = function(c2, record) {
            var aligned = record.type - tls.ContentType.change_cipher_spec;
            var handlers = ctTable[c2.entity][c2.expect];
            if (aligned in handlers) {
              handlers[aligned](c2, record);
            } else {
              tls.handleUnexpected(c2, record);
            }
          };
          var _readRecordHeader = function(c2) {
            var rval = 0;
            var b = c2.input;
            var len = b.length();
            if (len < 5) {
              rval = 5 - len;
            } else {
              c2.record = {
                type: b.getByte(),
                version: {
                  major: b.getByte(),
                  minor: b.getByte()
                },
                length: b.getInt16(),
                fragment: forge2.util.createBuffer(),
                ready: false
              };
              var compatibleVersion = c2.record.version.major === c2.version.major;
              if (compatibleVersion && c2.session && c2.session.version) {
                compatibleVersion = c2.record.version.minor === c2.version.minor;
              }
              if (!compatibleVersion) {
                c2.error(c2, {
                  message: "Incompatible TLS version.",
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.protocol_version
                  }
                });
              }
            }
            return rval;
          };
          var _readRecord = function(c2) {
            var rval = 0;
            var b = c2.input;
            var len = b.length();
            if (len < c2.record.length) {
              rval = c2.record.length - len;
            } else {
              c2.record.fragment.putBytes(b.getBytes(c2.record.length));
              b.compact();
              var s = c2.state.current.read;
              if (s.update(c2, c2.record)) {
                if (c2.fragmented !== null) {
                  if (c2.fragmented.type === c2.record.type) {
                    c2.fragmented.fragment.putBuffer(c2.record.fragment);
                    c2.record = c2.fragmented;
                  } else {
                    c2.error(c2, {
                      message: "Invalid fragmented record.",
                      send: true,
                      alert: {
                        level: tls.Alert.Level.fatal,
                        description: tls.Alert.Description.unexpected_message
                      }
                    });
                  }
                }
                c2.record.ready = true;
              }
            }
            return rval;
          };
          c.handshake = function(sessionId) {
            if (c.entity !== tls.ConnectionEnd.client) {
              c.error(c, {
                message: "Cannot initiate handshake as a server.",
                fatal: false
              });
            } else if (c.handshaking) {
              c.error(c, {
                message: "Handshake already in progress.",
                fatal: false
              });
            } else {
              if (c.fail && !c.open && c.handshakes === 0) {
                c.fail = false;
              }
              c.handshaking = true;
              sessionId = sessionId || "";
              var session = null;
              if (sessionId.length > 0) {
                if (c.sessionCache) {
                  session = c.sessionCache.getSession(sessionId);
                }
                if (session === null) {
                  sessionId = "";
                }
              }
              if (sessionId.length === 0 && c.sessionCache) {
                session = c.sessionCache.getSession();
                if (session !== null) {
                  sessionId = session.id;
                }
              }
              c.session = {
                id: sessionId,
                version: null,
                cipherSuite: null,
                compressionMethod: null,
                serverCertificate: null,
                certificateRequest: null,
                clientCertificate: null,
                sp: {},
                md5: forge2.md.md5.create(),
                sha1: forge2.md.sha1.create()
              };
              if (session) {
                c.version = session.version;
                c.session.sp = session.sp;
              }
              c.session.sp.client_random = tls.createRandom().getBytes();
              c.open = true;
              tls.queue(c, tls.createRecord(c, {
                type: tls.ContentType.handshake,
                data: tls.createClientHello(c)
              }));
              tls.flush(c);
            }
          };
          c.process = function(data) {
            var rval = 0;
            if (data) {
              c.input.putBytes(data);
            }
            if (!c.fail) {
              if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) {
                c.record = null;
              }
              if (c.record === null) {
                rval = _readRecordHeader(c);
              }
              if (!c.fail && c.record !== null && !c.record.ready) {
                rval = _readRecord(c);
              }
              if (!c.fail && c.record !== null && c.record.ready) {
                _update(c, c.record);
              }
            }
            return rval;
          };
          c.prepare = function(data) {
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.application_data,
              data: forge2.util.createBuffer(data)
            }));
            return tls.flush(c);
          };
          c.prepareHeartbeatRequest = function(payload, payloadLength) {
            if (payload instanceof forge2.util.ByteBuffer) {
              payload = payload.bytes();
            }
            if (typeof payloadLength === "undefined") {
              payloadLength = payload.length;
            }
            c.expectedHeartbeatPayload = payload;
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.heartbeat,
              data: tls.createHeartbeat(
                tls.HeartbeatMessageType.heartbeat_request,
                payload,
                payloadLength
              )
            }));
            return tls.flush(c);
          };
          c.close = function(clearFail) {
            if (!c.fail && c.sessionCache && c.session) {
              var session = {
                id: c.session.id,
                version: c.session.version,
                sp: c.session.sp
              };
              session.sp.keys = null;
              c.sessionCache.setSession(session.id, session);
            }
            if (c.open) {
              c.open = false;
              c.input.clear();
              if (c.isConnected || c.handshaking) {
                c.isConnected = c.handshaking = false;
                tls.queue(c, tls.createAlert(c, {
                  level: tls.Alert.Level.warning,
                  description: tls.Alert.Description.close_notify
                }));
                tls.flush(c);
              }
              c.closed(c);
            }
            c.reset(clearFail);
          };
          return c;
        };
        tls_1 = forge2.tls = forge2.tls || {};
        for (var key in tls) {
          if (typeof tls[key] !== "function") {
            forge2.tls[key] = tls[key];
          }
        }
        forge2.tls.prf_tls1 = prf_TLS1;
        forge2.tls.hmac_sha1 = hmac_sha1;
        forge2.tls.createSessionCache = tls.createSessionCache;
        forge2.tls.createConnection = tls.createConnection;
        return tls_1;
      }
      var hasRequiredAesCipherSuites;
      function requireAesCipherSuites() {
        if (hasRequiredAesCipherSuites) return aesCipherSuites.exports;
        hasRequiredAesCipherSuites = 1;
        var forge2 = requireForge();
        requireAes();
        requireTls();
        var tls = aesCipherSuites.exports = forge2.tls;
        tls.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
          id: [0, 47],
          name: "TLS_RSA_WITH_AES_128_CBC_SHA",
          initSecurityParameters: function(sp) {
            sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
            sp.cipher_type = tls.CipherType.block;
            sp.enc_key_length = 16;
            sp.block_length = 16;
            sp.fixed_iv_length = 16;
            sp.record_iv_length = 16;
            sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
            sp.mac_length = 20;
            sp.mac_key_length = 20;
          },
          initConnectionState
        };
        tls.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
          id: [0, 53],
          name: "TLS_RSA_WITH_AES_256_CBC_SHA",
          initSecurityParameters: function(sp) {
            sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
            sp.cipher_type = tls.CipherType.block;
            sp.enc_key_length = 32;
            sp.block_length = 16;
            sp.fixed_iv_length = 16;
            sp.record_iv_length = 16;
            sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
            sp.mac_length = 20;
            sp.mac_key_length = 20;
          },
          initConnectionState
        };
        function initConnectionState(state, c, sp) {
          var client2 = c.entity === forge2.tls.ConnectionEnd.client;
          state.read.cipherState = {
            init: false,
            cipher: forge2.cipher.createDecipher("AES-CBC", client2 ? sp.keys.server_write_key : sp.keys.client_write_key),
            iv: client2 ? sp.keys.server_write_IV : sp.keys.client_write_IV
          };
          state.write.cipherState = {
            init: false,
            cipher: forge2.cipher.createCipher("AES-CBC", client2 ? sp.keys.client_write_key : sp.keys.server_write_key),
            iv: client2 ? sp.keys.client_write_IV : sp.keys.server_write_IV
          };
          state.read.cipherFunction = decrypt_aes_cbc_sha1;
          state.write.cipherFunction = encrypt_aes_cbc_sha1;
          state.read.macLength = state.write.macLength = sp.mac_length;
          state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
        }
        function encrypt_aes_cbc_sha1(record, s) {
          var rval = false;
          var mac = s.macFunction(s.macKey, s.sequenceNumber, record);
          record.fragment.putBytes(mac);
          s.updateSequenceNumber();
          var iv;
          if (record.version.minor === tls.Versions.TLS_1_0.minor) {
            iv = s.cipherState.init ? null : s.cipherState.iv;
          } else {
            iv = forge2.random.getBytesSync(16);
          }
          s.cipherState.init = true;
          var cipher2 = s.cipherState.cipher;
          cipher2.start({ iv });
          if (record.version.minor >= tls.Versions.TLS_1_1.minor) {
            cipher2.output.putBytes(iv);
          }
          cipher2.update(record.fragment);
          if (cipher2.finish(encrypt_aes_cbc_sha1_padding)) {
            record.fragment = cipher2.output;
            record.length = record.fragment.length();
            rval = true;
          }
          return rval;
        }
        function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
          if (!decrypt) {
            var padding = blockSize - input.length() % blockSize;
            input.fillWithByte(padding - 1, padding);
          }
          return true;
        }
        function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
          var rval = true;
          if (decrypt) {
            var len = output.length();
            var paddingLength = output.last();
            for (var i = len - 1 - paddingLength; i < len - 1; ++i) {
              rval = rval && output.at(i) == paddingLength;
            }
            if (rval) {
              output.truncate(paddingLength + 1);
            }
          }
          return rval;
        }
        function decrypt_aes_cbc_sha1(record, s) {
          var rval = false;
          var iv;
          if (record.version.minor === tls.Versions.TLS_1_0.minor) {
            iv = s.cipherState.init ? null : s.cipherState.iv;
          } else {
            iv = record.fragment.getBytes(16);
          }
          s.cipherState.init = true;
          var cipher2 = s.cipherState.cipher;
          cipher2.start({ iv });
          cipher2.update(record.fragment);
          rval = cipher2.finish(decrypt_aes_cbc_sha1_padding);
          var macLen = s.macLength;
          var mac = forge2.random.getBytesSync(macLen);
          var len = cipher2.output.length();
          if (len >= macLen) {
            record.fragment = cipher2.output.getBytes(len - macLen);
            mac = cipher2.output.getBytes(macLen);
          } else {
            record.fragment = cipher2.output.getBytes();
          }
          record.fragment = forge2.util.createBuffer(record.fragment);
          record.length = record.fragment.length();
          var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);
          s.updateSequenceNumber();
          rval = compareMacs(s.macKey, mac, mac2) && rval;
          return rval;
        }
        function compareMacs(key, mac1, mac2) {
          var hmac2 = forge2.hmac.create();
          hmac2.start("SHA1", key);
          hmac2.update(mac1);
          mac1 = hmac2.digest().getBytes();
          hmac2.start(null, null);
          hmac2.update(mac2);
          mac2 = hmac2.digest().getBytes();
          return mac1 === mac2;
        }
        return aesCipherSuites.exports;
      }
      var sha512 = { exports: {} };
      var hasRequiredSha512;
      function requireSha512() {
        if (hasRequiredSha512) return sha512.exports;
        hasRequiredSha512 = 1;
        var forge2 = requireForge();
        requireMd();
        requireUtil();
        var sha512$1 = sha512.exports = forge2.sha512 = forge2.sha512 || {};
        forge2.md.sha512 = forge2.md.algorithms.sha512 = sha512$1;
        var sha384 = forge2.sha384 = forge2.sha512.sha384 = forge2.sha512.sha384 || {};
        sha384.create = function() {
          return sha512$1.create("SHA-384");
        };
        forge2.md.sha384 = forge2.md.algorithms.sha384 = sha384;
        forge2.sha512.sha256 = forge2.sha512.sha256 || {
          create: function() {
            return sha512$1.create("SHA-512/256");
          }
        };
        forge2.md["sha512/256"] = forge2.md.algorithms["sha512/256"] = forge2.sha512.sha256;
        forge2.sha512.sha224 = forge2.sha512.sha224 || {
          create: function() {
            return sha512$1.create("SHA-512/224");
          }
        };
        forge2.md["sha512/224"] = forge2.md.algorithms["sha512/224"] = forge2.sha512.sha224;
        sha512$1.create = function(algorithm) {
          if (!_initialized) {
            _init();
          }
          if (typeof algorithm === "undefined") {
            algorithm = "SHA-512";
          }
          if (!(algorithm in _states)) {
            throw new Error("Invalid SHA-512 algorithm: " + algorithm);
          }
          var _state = _states[algorithm];
          var _h = null;
          var _input = forge2.util.createBuffer();
          var _w = new Array(80);
          for (var wi = 0; wi < 80; ++wi) {
            _w[wi] = new Array(2);
          }
          var digestLength = 64;
          switch (algorithm) {
            case "SHA-384":
              digestLength = 48;
              break;
            case "SHA-512/256":
              digestLength = 32;
              break;
            case "SHA-512/224":
              digestLength = 28;
              break;
          }
          var md2 = {
            // SHA-512 => sha512
            algorithm: algorithm.replace("-", "").toLowerCase(),
            blockLength: 128,
            digestLength,
            // 56-bit length of message so far (does not including padding)
            messageLength: 0,
            // true message length
            fullMessageLength: null,
            // size of message length in bytes
            messageLengthSize: 16
          };
          md2.start = function() {
            md2.messageLength = 0;
            md2.fullMessageLength = md2.messageLength128 = [];
            var int32s = md2.messageLengthSize / 4;
            for (var i = 0; i < int32s; ++i) {
              md2.fullMessageLength.push(0);
            }
            _input = forge2.util.createBuffer();
            _h = new Array(_state.length);
            for (var i = 0; i < _state.length; ++i) {
              _h[i] = _state[i].slice(0);
            }
            return md2;
          };
          md2.start();
          md2.update = function(msg, encoding) {
            if (encoding === "utf8") {
              msg = forge2.util.encodeUtf8(msg);
            }
            var len = msg.length;
            md2.messageLength += len;
            len = [len / 4294967296 >>> 0, len >>> 0];
            for (var i = md2.fullMessageLength.length - 1; i >= 0; --i) {
              md2.fullMessageLength[i] += len[1];
              len[1] = len[0] + (md2.fullMessageLength[i] / 4294967296 >>> 0);
              md2.fullMessageLength[i] = md2.fullMessageLength[i] >>> 0;
              len[0] = len[1] / 4294967296 >>> 0;
            }
            _input.putBytes(msg);
            _update(_h, _w, _input);
            if (_input.read > 2048 || _input.length() === 0) {
              _input.compact();
            }
            return md2;
          };
          md2.digest = function() {
            var finalBlock = forge2.util.createBuffer();
            finalBlock.putBytes(_input.bytes());
            var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
            var overflow = remaining & md2.blockLength - 1;
            finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
            var next, carry;
            var bits2 = md2.fullMessageLength[0] * 8;
            for (var i = 0; i < md2.fullMessageLength.length - 1; ++i) {
              next = md2.fullMessageLength[i + 1] * 8;
              carry = next / 4294967296 >>> 0;
              bits2 += carry;
              finalBlock.putInt32(bits2 >>> 0);
              bits2 = next >>> 0;
            }
            finalBlock.putInt32(bits2);
            var h = new Array(_h.length);
            for (var i = 0; i < _h.length; ++i) {
              h[i] = _h[i].slice(0);
            }
            _update(h, _w, finalBlock);
            var rval = forge2.util.createBuffer();
            var hlen;
            if (algorithm === "SHA-512") {
              hlen = h.length;
            } else if (algorithm === "SHA-384") {
              hlen = h.length - 2;
            } else {
              hlen = h.length - 4;
            }
            for (var i = 0; i < hlen; ++i) {
              rval.putInt32(h[i][0]);
              if (i !== hlen - 1 || algorithm !== "SHA-512/224") {
                rval.putInt32(h[i][1]);
              }
            }
            return rval;
          };
          return md2;
        };
        var _padding = null;
        var _initialized = false;
        var _k = null;
        var _states = null;
        function _init() {
          _padding = String.fromCharCode(128);
          _padding += forge2.util.fillString(String.fromCharCode(0), 128);
          _k = [
            [1116352408, 3609767458],
            [1899447441, 602891725],
            [3049323471, 3964484399],
            [3921009573, 2173295548],
            [961987163, 4081628472],
            [1508970993, 3053834265],
            [2453635748, 2937671579],
            [2870763221, 3664609560],
            [3624381080, 2734883394],
            [310598401, 1164996542],
            [607225278, 1323610764],
            [1426881987, 3590304994],
            [1925078388, 4068182383],
            [2162078206, 991336113],
            [2614888103, 633803317],
            [3248222580, 3479774868],
            [3835390401, 2666613458],
            [4022224774, 944711139],
            [264347078, 2341262773],
            [604807628, 2007800933],
            [770255983, 1495990901],
            [1249150122, 1856431235],
            [1555081692, 3175218132],
            [1996064986, 2198950837],
            [2554220882, 3999719339],
            [2821834349, 766784016],
            [2952996808, 2566594879],
            [3210313671, 3203337956],
            [3336571891, 1034457026],
            [3584528711, 2466948901],
            [113926993, 3758326383],
            [338241895, 168717936],
            [666307205, 1188179964],
            [773529912, 1546045734],
            [1294757372, 1522805485],
            [1396182291, 2643833823],
            [1695183700, 2343527390],
            [1986661051, 1014477480],
            [2177026350, 1206759142],
            [2456956037, 344077627],
            [2730485921, 1290863460],
            [2820302411, 3158454273],
            [3259730800, 3505952657],
            [3345764771, 106217008],
            [3516065817, 3606008344],
            [3600352804, 1432725776],
            [4094571909, 1467031594],
            [275423344, 851169720],
            [430227734, 3100823752],
            [506948616, 1363258195],
            [659060556, 3750685593],
            [883997877, 3785050280],
            [958139571, 3318307427],
            [1322822218, 3812723403],
            [1537002063, 2003034995],
            [1747873779, 3602036899],
            [1955562222, 1575990012],
            [2024104815, 1125592928],
            [2227730452, 2716904306],
            [2361852424, 442776044],
            [2428436474, 593698344],
            [2756734187, 3733110249],
            [3204031479, 2999351573],
            [3329325298, 3815920427],
            [3391569614, 3928383900],
            [3515267271, 566280711],
            [3940187606, 3454069534],
            [4118630271, 4000239992],
            [116418474, 1914138554],
            [174292421, 2731055270],
            [289380356, 3203993006],
            [460393269, 320620315],
            [685471733, 587496836],
            [852142971, 1086792851],
            [1017036298, 365543100],
            [1126000580, 2618297676],
            [1288033470, 3409855158],
            [1501505948, 4234509866],
            [1607167915, 987167468],
            [1816402316, 1246189591]
          ];
          _states = {};
          _states["SHA-512"] = [
            [1779033703, 4089235720],
            [3144134277, 2227873595],
            [1013904242, 4271175723],
            [2773480762, 1595750129],
            [1359893119, 2917565137],
            [2600822924, 725511199],
            [528734635, 4215389547],
            [1541459225, 327033209]
          ];
          _states["SHA-384"] = [
            [3418070365, 3238371032],
            [1654270250, 914150663],
            [2438529370, 812702999],
            [355462360, 4144912697],
            [1731405415, 4290775857],
            [2394180231, 1750603025],
            [3675008525, 1694076839],
            [1203062813, 3204075428]
          ];
          _states["SHA-512/256"] = [
            [573645204, 4230739756],
            [2673172387, 3360449730],
            [596883563, 1867755857],
            [2520282905, 1497426621],
            [2519219938, 2827943907],
            [3193839141, 1401305490],
            [721525244, 746961066],
            [246885852, 2177182882]
          ];
          _states["SHA-512/224"] = [
            [2352822216, 424955298],
            [1944164710, 2312950998],
            [502970286, 855612546],
            [1738396948, 1479516111],
            [258812777, 2077511080],
            [2011393907, 79989058],
            [1067287976, 1780299464],
            [286451373, 2446758561]
          ];
          _initialized = true;
        }
        function _update(s, w, bytes) {
          var t1_hi, t1_lo;
          var t2_hi, t2_lo;
          var s0_hi, s0_lo;
          var s1_hi, s1_lo;
          var ch_hi, ch_lo;
          var maj_hi, maj_lo;
          var a_hi, a_lo;
          var b_hi, b_lo;
          var c_hi, c_lo;
          var d_hi, d_lo;
          var e_hi, e_lo;
          var f_hi, f_lo;
          var g_hi, g_lo;
          var h_hi, h_lo;
          var i, hi, lo, w2, w7, w15, w16;
          var len = bytes.length();
          while (len >= 128) {
            for (i = 0; i < 16; ++i) {
              w[i][0] = bytes.getInt32() >>> 0;
              w[i][1] = bytes.getInt32() >>> 0;
            }
            for (; i < 80; ++i) {
              w2 = w[i - 2];
              hi = w2[0];
              lo = w2[1];
              t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19
              (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)
              hi >>> 6) >>> 0;
              t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19
              (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)
              (hi << 26 | lo >>> 6)) >>> 0;
              w15 = w[i - 15];
              hi = w15[0];
              lo = w15[1];
              t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1
              (hi >>> 8 | lo << 24) ^ // ROTR 8
              hi >>> 7) >>> 0;
              t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1
              (hi << 24 | lo >>> 8) ^ // ROTR 8
              (hi << 25 | lo >>> 7)) >>> 0;
              w7 = w[i - 7];
              w16 = w[i - 16];
              lo = t1_lo + w7[1] + t2_lo + w16[1];
              w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
              w[i][1] = lo >>> 0;
            }
            a_hi = s[0][0];
            a_lo = s[0][1];
            b_hi = s[1][0];
            b_lo = s[1][1];
            c_hi = s[2][0];
            c_lo = s[2][1];
            d_hi = s[3][0];
            d_lo = s[3][1];
            e_hi = s[4][0];
            e_lo = s[4][1];
            f_hi = s[5][0];
            f_lo = s[5][1];
            g_hi = s[6][0];
            g_lo = s[6][1];
            h_hi = s[7][0];
            h_lo = s[7][1];
            for (i = 0; i < 80; ++i) {
              s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
              (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
              (e_lo >>> 9 | e_hi << 23)) >>> 0;
              s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
              (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
              (e_lo << 23 | e_hi >>> 9)) >>> 0;
              ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
              ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
              s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
              (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
              (a_lo >>> 7 | a_hi << 25)) >>> 0;
              s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
              (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
              (a_lo << 25 | a_hi >>> 7)) >>> 0;
              maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
              maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
              lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];
              t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0;
              t1_lo = lo >>> 0;
              lo = s0_lo + maj_lo;
              t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
              t2_lo = lo >>> 0;
              h_hi = g_hi;
              h_lo = g_lo;
              g_hi = f_hi;
              g_lo = f_lo;
              f_hi = e_hi;
              f_lo = e_lo;
              lo = d_lo + t1_lo;
              e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
              e_lo = lo >>> 0;
              d_hi = c_hi;
              d_lo = c_lo;
              c_hi = b_hi;
              c_lo = b_lo;
              b_hi = a_hi;
              b_lo = a_lo;
              lo = t1_lo + t2_lo;
              a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
              a_lo = lo >>> 0;
            }
            lo = s[0][1] + a_lo;
            s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
            s[0][1] = lo >>> 0;
            lo = s[1][1] + b_lo;
            s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
            s[1][1] = lo >>> 0;
            lo = s[2][1] + c_lo;
            s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
            s[2][1] = lo >>> 0;
            lo = s[3][1] + d_lo;
            s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
            s[3][1] = lo >>> 0;
            lo = s[4][1] + e_lo;
            s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
            s[4][1] = lo >>> 0;
            lo = s[5][1] + f_lo;
            s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
            s[5][1] = lo >>> 0;
            lo = s[6][1] + g_lo;
            s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
            s[6][1] = lo >>> 0;
            lo = s[7][1] + h_lo;
            s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
            s[7][1] = lo >>> 0;
            len -= 128;
          }
        }
        return sha512.exports;
      }
      var asn1Validator = {};
      var hasRequiredAsn1Validator;
      function requireAsn1Validator() {
        if (hasRequiredAsn1Validator) return asn1Validator;
        hasRequiredAsn1Validator = 1;
        var forge2 = requireForge();
        requireAsn1();
        var asn12 = forge2.asn1;
        asn1Validator.privateKeyValidator = {
          // PrivateKeyInfo
          name: "PrivateKeyInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            // Version (INTEGER)
            name: "PrivateKeyInfo.version",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "privateKeyVersion"
          }, {
            // privateKeyAlgorithm
            name: "PrivateKeyInfo.privateKeyAlgorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "privateKeyOid"
            }]
          }, {
            // PrivateKey
            name: "PrivateKeyInfo",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OCTETSTRING,
            constructed: false,
            capture: "privateKey"
          }]
        };
        asn1Validator.publicKeyValidator = {
          name: "SubjectPublicKeyInfo",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "subjectPublicKeyInfo",
          value: [
            {
              name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "AlgorithmIdentifier.algorithm",
                tagClass: asn12.Class.UNIVERSAL,
                type: asn12.Type.OID,
                constructed: false,
                capture: "publicKeyOid"
              }]
            },
            // capture group for ed25519PublicKey
            {
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.BITSTRING,
              constructed: false,
              composed: true,
              captureBitStringValue: "ed25519PublicKey"
            }
            // FIXME: this is capture group for rsaPublicKey, use it in this API or
            // discard?
            /* {
              // subjectPublicKey
              name: 'SubjectPublicKeyInfo.subjectPublicKey',
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              value: [{
                // RSAPublicKey
                name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.SEQUENCE,
                constructed: true,
                optional: true,
                captureAsn1: 'rsaPublicKey'
              }]
            } */
          ]
        };
        return asn1Validator;
      }
      var ed25519_1;
      var hasRequiredEd25519;
      function requireEd25519() {
        if (hasRequiredEd25519) return ed25519_1;
        hasRequiredEd25519 = 1;
        var forge2 = requireForge();
        requireJsbn();
        requireRandom();
        requireSha512();
        requireUtil();
        var asn1Validator2 = requireAsn1Validator();
        var publicKeyValidator = asn1Validator2.publicKeyValidator;
        var privateKeyValidator = asn1Validator2.privateKeyValidator;
        if (typeof BigInteger === "undefined") {
          var BigInteger = forge2.jsbn.BigInteger;
        }
        var ByteBuffer = forge2.util.ByteBuffer;
        var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
        forge2.pki = forge2.pki || {};
        ed25519_1 = forge2.pki.ed25519 = forge2.ed25519 = forge2.ed25519 || {};
        var ed25519 = forge2.ed25519;
        ed25519.constants = {};
        ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
        ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
        ed25519.constants.SEED_BYTE_LENGTH = 32;
        ed25519.constants.SIGN_BYTE_LENGTH = 64;
        ed25519.constants.HASH_BYTE_LENGTH = 64;
        ed25519.generateKeyPair = function(options) {
          options = options || {};
          var seed = options.seed;
          if (seed === void 0) {
            seed = forge2.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
          } else if (typeof seed === "string") {
            if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
              throw new TypeError(
                '"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length."
              );
            }
          } else if (!(seed instanceof Uint8Array)) {
            throw new TypeError(
              '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
            );
          }
          seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
          var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
          var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
          for (var i = 0; i < 32; ++i) {
            sk[i] = seed[i];
          }
          crypto_sign_keypair(pk, sk);
          return { publicKey: pk, privateKey: sk };
        };
        ed25519.privateKeyFromAsn1 = function(obj) {
          var capture = {};
          var errors = [];
          var valid = forge2.asn1.validate(obj, privateKeyValidator, capture, errors);
          if (!valid) {
            var error = new Error("Invalid Key.");
            error.errors = errors;
            throw error;
          }
          var oid = forge2.asn1.derToOid(capture.privateKeyOid);
          var ed25519Oid = forge2.oids.EdDSA25519;
          if (oid !== ed25519Oid) {
            throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
          }
          var privateKey = capture.privateKey;
          var privateKeyBytes = messageToNativeBuffer({
            message: forge2.asn1.fromDer(privateKey).value,
            encoding: "binary"
          });
          return { privateKeyBytes };
        };
        ed25519.publicKeyFromAsn1 = function(obj) {
          var capture = {};
          var errors = [];
          var valid = forge2.asn1.validate(obj, publicKeyValidator, capture, errors);
          if (!valid) {
            var error = new Error("Invalid Key.");
            error.errors = errors;
            throw error;
          }
          var oid = forge2.asn1.derToOid(capture.publicKeyOid);
          var ed25519Oid = forge2.oids.EdDSA25519;
          if (oid !== ed25519Oid) {
            throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
          }
          var publicKeyBytes = capture.ed25519PublicKey;
          if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
            throw new Error("Key length is invalid.");
          }
          return messageToNativeBuffer({
            message: publicKeyBytes,
            encoding: "binary"
          });
        };
        ed25519.publicKeyFromPrivateKey = function(options) {
          options = options || {};
          var privateKey = messageToNativeBuffer({
            message: options.privateKey,
            encoding: "binary"
          });
          if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
            throw new TypeError(
              '"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
            );
          }
          var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
          for (var i = 0; i < pk.length; ++i) {
            pk[i] = privateKey[32 + i];
          }
          return pk;
        };
        ed25519.sign = function(options) {
          options = options || {};
          var msg = messageToNativeBuffer(options);
          var privateKey = messageToNativeBuffer({
            message: options.privateKey,
            encoding: "binary"
          });
          if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
            var keyPair = ed25519.generateKeyPair({ seed: privateKey });
            privateKey = keyPair.privateKey;
          } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
            throw new TypeError(
              '"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
            );
          }
          var signedMsg = new NativeBuffer(
            ed25519.constants.SIGN_BYTE_LENGTH + msg.length
          );
          crypto_sign(signedMsg, msg, msg.length, privateKey);
          var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
          for (var i = 0; i < sig.length; ++i) {
            sig[i] = signedMsg[i];
          }
          return sig;
        };
        ed25519.verify = function(options) {
          options = options || {};
          var msg = messageToNativeBuffer(options);
          if (options.signature === void 0) {
            throw new TypeError(
              '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
            );
          }
          var sig = messageToNativeBuffer({
            message: options.signature,
            encoding: "binary"
          });
          if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
            throw new TypeError(
              '"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH
            );
          }
          var publicKey = messageToNativeBuffer({
            message: options.publicKey,
            encoding: "binary"
          });
          if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
            throw new TypeError(
              '"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH
            );
          }
          var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
          var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
          var i;
          for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) {
            sm[i] = sig[i];
          }
          for (i = 0; i < msg.length; ++i) {
            sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];
          }
          return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
        };
        function messageToNativeBuffer(options) {
          var message2 = options.message;
          if (message2 instanceof Uint8Array || message2 instanceof NativeBuffer) {
            return message2;
          }
          var encoding = options.encoding;
          if (message2 === void 0) {
            if (options.md) {
              message2 = options.md.digest().getBytes();
              encoding = "binary";
            } else {
              throw new TypeError('"options.message" or "options.md" not specified.');
            }
          }
          if (typeof message2 === "string" && !encoding) {
            throw new TypeError('"options.encoding" must be "binary" or "utf8".');
          }
          if (typeof message2 === "string") {
            if (typeof Buffer !== "undefined") {
              return Buffer.from(message2, encoding);
            }
            message2 = new ByteBuffer(message2, encoding);
          } else if (!(message2 instanceof ByteBuffer)) {
            throw new TypeError(
              '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
            );
          }
          var buffer = new NativeBuffer(message2.length());
          for (var i = 0; i < buffer.length; ++i) {
            buffer[i] = message2.at(i);
          }
          return buffer;
        }
        var gf0 = gf();
        var gf1 = gf([1]);
        var D = gf([
          30883,
          4953,
          19914,
          30187,
          55467,
          16705,
          2637,
          112,
          59544,
          30585,
          16505,
          36039,
          65139,
          11119,
          27886,
          20995
        ]);
        var D2 = gf([
          61785,
          9906,
          39828,
          60374,
          45398,
          33411,
          5274,
          224,
          53552,
          61171,
          33010,
          6542,
          64743,
          22239,
          55772,
          9222
        ]);
        var X = gf([
          54554,
          36645,
          11616,
          51542,
          42930,
          38181,
          51040,
          26924,
          56412,
          64982,
          57905,
          49316,
          21502,
          52590,
          14035,
          8553
        ]);
        var Y = gf([
          26200,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214
        ]);
        var L = new Float64Array([
          237,
          211,
          245,
          92,
          26,
          99,
          18,
          88,
          214,
          156,
          247,
          162,
          222,
          249,
          222,
          20,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          16
        ]);
        var I = gf([
          41136,
          18958,
          6951,
          50414,
          58488,
          44335,
          6150,
          12099,
          55207,
          15867,
          153,
          11085,
          57099,
          20417,
          9344,
          11139
        ]);
        function sha5122(msg, msgLen) {
          var md2 = forge2.md.sha512.create();
          var buffer = new ByteBuffer(msg);
          md2.update(buffer.getBytes(msgLen), "binary");
          var hash = md2.digest().getBytes();
          if (typeof Buffer !== "undefined") {
            return Buffer.from(hash, "binary");
          }
          var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
          for (var i = 0; i < 64; ++i) {
            out[i] = hash.charCodeAt(i);
          }
          return out;
        }
        function crypto_sign_keypair(pk, sk) {
          var p = [gf(), gf(), gf(), gf()];
          var i;
          var d = sha5122(sk, 32);
          d[0] &= 248;
          d[31] &= 127;
          d[31] |= 64;
          scalarbase(p, d);
          pack(pk, p);
          for (i = 0; i < 32; ++i) {
            sk[i + 32] = pk[i];
          }
          return 0;
        }
        function crypto_sign(sm, m, n, sk) {
          var i, j, x = new Float64Array(64);
          var p = [gf(), gf(), gf(), gf()];
          var d = sha5122(sk, 32);
          d[0] &= 248;
          d[31] &= 127;
          d[31] |= 64;
          var smlen = n + 64;
          for (i = 0; i < n; ++i) {
            sm[64 + i] = m[i];
          }
          for (i = 0; i < 32; ++i) {
            sm[32 + i] = d[32 + i];
          }
          var r = sha5122(sm.subarray(32), n + 32);
          reduce(r);
          scalarbase(p, r);
          pack(sm, p);
          for (i = 32; i < 64; ++i) {
            sm[i] = sk[i];
          }
          var h = sha5122(sm, n + 64);
          reduce(h);
          for (i = 32; i < 64; ++i) {
            x[i] = 0;
          }
          for (i = 0; i < 32; ++i) {
            x[i] = r[i];
          }
          for (i = 0; i < 32; ++i) {
            for (j = 0; j < 32; j++) {
              x[i + j] += h[i] * d[j];
            }
          }
          modL(sm.subarray(32), x);
          return smlen;
        }
        function crypto_sign_open(m, sm, n, pk) {
          var i, mlen;
          var t = new NativeBuffer(32);
          var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
          mlen = -1;
          if (n < 64) {
            return -1;
          }
          if (unpackneg(q, pk)) {
            return -1;
          }
          for (i = 0; i < n; ++i) {
            m[i] = sm[i];
          }
          for (i = 0; i < 32; ++i) {
            m[i + 32] = pk[i];
          }
          var h = sha5122(m, n);
          reduce(h);
          scalarmult(p, q, h);
          scalarbase(q, sm.subarray(32));
          add(p, q);
          pack(t, p);
          n -= 64;
          if (crypto_verify_32(sm, 0, t, 0)) {
            for (i = 0; i < n; ++i) {
              m[i] = 0;
            }
            return -1;
          }
          for (i = 0; i < n; ++i) {
            m[i] = sm[i + 64];
          }
          mlen = n;
          return mlen;
        }
        function modL(r, x) {
          var carry, i, j, k;
          for (i = 63; i >= 32; --i) {
            carry = 0;
            for (j = i - 32, k = i - 12; j < k; ++j) {
              x[j] += carry - 16 * x[i] * L[j - (i - 32)];
              carry = x[j] + 128 >> 8;
              x[j] -= carry * 256;
            }
            x[j] += carry;
            x[i] = 0;
          }
          carry = 0;
          for (j = 0; j < 32; ++j) {
            x[j] += carry - (x[31] >> 4) * L[j];
            carry = x[j] >> 8;
            x[j] &= 255;
          }
          for (j = 0; j < 32; ++j) {
            x[j] -= carry * L[j];
          }
          for (i = 0; i < 32; ++i) {
            x[i + 1] += x[i] >> 8;
            r[i] = x[i] & 255;
          }
        }
        function reduce(r) {
          var x = new Float64Array(64);
          for (var i = 0; i < 64; ++i) {
            x[i] = r[i];
            r[i] = 0;
          }
          modL(r, x);
        }
        function add(p, q) {
          var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
          Z(a, p[1], p[0]);
          Z(t, q[1], q[0]);
          M(a, a, t);
          A(b, p[0], p[1]);
          A(t, q[0], q[1]);
          M(b, b, t);
          M(c, p[3], q[3]);
          M(c, c, D2);
          M(d, p[2], q[2]);
          A(d, d, d);
          Z(e, b, a);
          Z(f, d, c);
          A(g, d, c);
          A(h, b, a);
          M(p[0], e, f);
          M(p[1], h, g);
          M(p[2], g, f);
          M(p[3], e, h);
        }
        function cswap(p, q, b) {
          for (var i = 0; i < 4; ++i) {
            sel25519(p[i], q[i], b);
          }
        }
        function pack(r, p) {
          var tx = gf(), ty = gf(), zi = gf();
          inv25519(zi, p[2]);
          M(tx, p[0], zi);
          M(ty, p[1], zi);
          pack25519(r, ty);
          r[31] ^= par25519(tx) << 7;
        }
        function pack25519(o, n) {
          var i, j, b;
          var m = gf(), t = gf();
          for (i = 0; i < 16; ++i) {
            t[i] = n[i];
          }
          car25519(t);
          car25519(t);
          car25519(t);
          for (j = 0; j < 2; ++j) {
            m[0] = t[0] - 65517;
            for (i = 1; i < 15; ++i) {
              m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
              m[i - 1] &= 65535;
            }
            m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
            b = m[15] >> 16 & 1;
            m[14] &= 65535;
            sel25519(t, m, 1 - b);
          }
          for (i = 0; i < 16; i++) {
            o[2 * i] = t[i] & 255;
            o[2 * i + 1] = t[i] >> 8;
          }
        }
        function unpackneg(r, p) {
          var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
          set25519(r[2], gf1);
          unpack25519(r[1], p);
          S(num, r[1]);
          M(den, num, D);
          Z(num, num, r[2]);
          A(den, r[2], den);
          S(den2, den);
          S(den4, den2);
          M(den6, den4, den2);
          M(t, den6, num);
          M(t, t, den);
          pow2523(t, t);
          M(t, t, num);
          M(t, t, den);
          M(t, t, den);
          M(r[0], t, den);
          S(chk, r[0]);
          M(chk, chk, den);
          if (neq25519(chk, num)) {
            M(r[0], r[0], I);
          }
          S(chk, r[0]);
          M(chk, chk, den);
          if (neq25519(chk, num)) {
            return -1;
          }
          if (par25519(r[0]) === p[31] >> 7) {
            Z(r[0], gf0, r[0]);
          }
          M(r[3], r[0], r[1]);
          return 0;
        }
        function unpack25519(o, n) {
          var i;
          for (i = 0; i < 16; ++i) {
            o[i] = n[2 * i] + (n[2 * i + 1] << 8);
          }
          o[15] &= 32767;
        }
        function pow2523(o, i) {
          var c = gf();
          var a;
          for (a = 0; a < 16; ++a) {
            c[a] = i[a];
          }
          for (a = 250; a >= 0; --a) {
            S(c, c);
            if (a !== 1) {
              M(c, c, i);
            }
          }
          for (a = 0; a < 16; ++a) {
            o[a] = c[a];
          }
        }
        function neq25519(a, b) {
          var c = new NativeBuffer(32);
          var d = new NativeBuffer(32);
          pack25519(c, a);
          pack25519(d, b);
          return crypto_verify_32(c, 0, d, 0);
        }
        function crypto_verify_32(x, xi, y, yi) {
          return vn(x, xi, y, yi, 32);
        }
        function vn(x, xi, y, yi, n) {
          var i, d = 0;
          for (i = 0; i < n; ++i) {
            d |= x[xi + i] ^ y[yi + i];
          }
          return (1 & d - 1 >>> 8) - 1;
        }
        function par25519(a) {
          var d = new NativeBuffer(32);
          pack25519(d, a);
          return d[0] & 1;
        }
        function scalarmult(p, q, s) {
          var b, i;
          set25519(p[0], gf0);
          set25519(p[1], gf1);
          set25519(p[2], gf1);
          set25519(p[3], gf0);
          for (i = 255; i >= 0; --i) {
            b = s[i / 8 | 0] >> (i & 7) & 1;
            cswap(p, q, b);
            add(q, p);
            add(p, p);
            cswap(p, q, b);
          }
        }
        function scalarbase(p, s) {
          var q = [gf(), gf(), gf(), gf()];
          set25519(q[0], X);
          set25519(q[1], Y);
          set25519(q[2], gf1);
          M(q[3], X, Y);
          scalarmult(p, q, s);
        }
        function set25519(r, a) {
          var i;
          for (i = 0; i < 16; i++) {
            r[i] = a[i] | 0;
          }
        }
        function inv25519(o, i) {
          var c = gf();
          var a;
          for (a = 0; a < 16; ++a) {
            c[a] = i[a];
          }
          for (a = 253; a >= 0; --a) {
            S(c, c);
            if (a !== 2 && a !== 4) {
              M(c, c, i);
            }
          }
          for (a = 0; a < 16; ++a) {
            o[a] = c[a];
          }
        }
        function car25519(o) {
          var i, v, c = 1;
          for (i = 0; i < 16; ++i) {
            v = o[i] + c + 65535;
            c = Math.floor(v / 65536);
            o[i] = v - c * 65536;
          }
          o[0] += c - 1 + 37 * (c - 1);
        }
        function sel25519(p, q, b) {
          var t, c = ~(b - 1);
          for (var i = 0; i < 16; ++i) {
            t = c & (p[i] ^ q[i]);
            p[i] ^= t;
            q[i] ^= t;
          }
        }
        function gf(init) {
          var i, r = new Float64Array(16);
          if (init) {
            for (i = 0; i < init.length; ++i) {
              r[i] = init[i];
            }
          }
          return r;
        }
        function A(o, a, b) {
          for (var i = 0; i < 16; ++i) {
            o[i] = a[i] + b[i];
          }
        }
        function Z(o, a, b) {
          for (var i = 0; i < 16; ++i) {
            o[i] = a[i] - b[i];
          }
        }
        function S(o, a) {
          M(o, a, a);
        }
        function M(o, a, b) {
          var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
          v = a[0];
          t0 += v * b0;
          t1 += v * b1;
          t2 += v * b2;
          t3 += v * b3;
          t4 += v * b4;
          t5 += v * b5;
          t6 += v * b6;
          t7 += v * b7;
          t8 += v * b8;
          t9 += v * b9;
          t10 += v * b10;
          t11 += v * b11;
          t12 += v * b12;
          t13 += v * b13;
          t14 += v * b14;
          t15 += v * b15;
          v = a[1];
          t1 += v * b0;
          t2 += v * b1;
          t3 += v * b2;
          t4 += v * b3;
          t5 += v * b4;
          t6 += v * b5;
          t7 += v * b6;
          t8 += v * b7;
          t9 += v * b8;
          t10 += v * b9;
          t11 += v * b10;
          t12 += v * b11;
          t13 += v * b12;
          t14 += v * b13;
          t15 += v * b14;
          t16 += v * b15;
          v = a[2];
          t2 += v * b0;
          t3 += v * b1;
          t4 += v * b2;
          t5 += v * b3;
          t6 += v * b4;
          t7 += v * b5;
          t8 += v * b6;
          t9 += v * b7;
          t10 += v * b8;
          t11 += v * b9;
          t12 += v * b10;
          t13 += v * b11;
          t14 += v * b12;
          t15 += v * b13;
          t16 += v * b14;
          t17 += v * b15;
          v = a[3];
          t3 += v * b0;
          t4 += v * b1;
          t5 += v * b2;
          t6 += v * b3;
          t7 += v * b4;
          t8 += v * b5;
          t9 += v * b6;
          t10 += v * b7;
          t11 += v * b8;
          t12 += v * b9;
          t13 += v * b10;
          t14 += v * b11;
          t15 += v * b12;
          t16 += v * b13;
          t17 += v * b14;
          t18 += v * b15;
          v = a[4];
          t4 += v * b0;
          t5 += v * b1;
          t6 += v * b2;
          t7 += v * b3;
          t8 += v * b4;
          t9 += v * b5;
          t10 += v * b6;
          t11 += v * b7;
          t12 += v * b8;
          t13 += v * b9;
          t14 += v * b10;
          t15 += v * b11;
          t16 += v * b12;
          t17 += v * b13;
          t18 += v * b14;
          t19 += v * b15;
          v = a[5];
          t5 += v * b0;
          t6 += v * b1;
          t7 += v * b2;
          t8 += v * b3;
          t9 += v * b4;
          t10 += v * b5;
          t11 += v * b6;
          t12 += v * b7;
          t13 += v * b8;
          t14 += v * b9;
          t15 += v * b10;
          t16 += v * b11;
          t17 += v * b12;
          t18 += v * b13;
          t19 += v * b14;
          t20 += v * b15;
          v = a[6];
          t6 += v * b0;
          t7 += v * b1;
          t8 += v * b2;
          t9 += v * b3;
          t10 += v * b4;
          t11 += v * b5;
          t12 += v * b6;
          t13 += v * b7;
          t14 += v * b8;
          t15 += v * b9;
          t16 += v * b10;
          t17 += v * b11;
          t18 += v * b12;
          t19 += v * b13;
          t20 += v * b14;
          t21 += v * b15;
          v = a[7];
          t7 += v * b0;
          t8 += v * b1;
          t9 += v * b2;
          t10 += v * b3;
          t11 += v * b4;
          t12 += v * b5;
          t13 += v * b6;
          t14 += v * b7;
          t15 += v * b8;
          t16 += v * b9;
          t17 += v * b10;
          t18 += v * b11;
          t19 += v * b12;
          t20 += v * b13;
          t21 += v * b14;
          t22 += v * b15;
          v = a[8];
          t8 += v * b0;
          t9 += v * b1;
          t10 += v * b2;
          t11 += v * b3;
          t12 += v * b4;
          t13 += v * b5;
          t14 += v * b6;
          t15 += v * b7;
          t16 += v * b8;
          t17 += v * b9;
          t18 += v * b10;
          t19 += v * b11;
          t20 += v * b12;
          t21 += v * b13;
          t22 += v * b14;
          t23 += v * b15;
          v = a[9];
          t9 += v * b0;
          t10 += v * b1;
          t11 += v * b2;
          t12 += v * b3;
          t13 += v * b4;
          t14 += v * b5;
          t15 += v * b6;
          t16 += v * b7;
          t17 += v * b8;
          t18 += v * b9;
          t19 += v * b10;
          t20 += v * b11;
          t21 += v * b12;
          t22 += v * b13;
          t23 += v * b14;
          t24 += v * b15;
          v = a[10];
          t10 += v * b0;
          t11 += v * b1;
          t12 += v * b2;
          t13 += v * b3;
          t14 += v * b4;
          t15 += v * b5;
          t16 += v * b6;
          t17 += v * b7;
          t18 += v * b8;
          t19 += v * b9;
          t20 += v * b10;
          t21 += v * b11;
          t22 += v * b12;
          t23 += v * b13;
          t24 += v * b14;
          t25 += v * b15;
          v = a[11];
          t11 += v * b0;
          t12 += v * b1;
          t13 += v * b2;
          t14 += v * b3;
          t15 += v * b4;
          t16 += v * b5;
          t17 += v * b6;
          t18 += v * b7;
          t19 += v * b8;
          t20 += v * b9;
          t21 += v * b10;
          t22 += v * b11;
          t23 += v * b12;
          t24 += v * b13;
          t25 += v * b14;
          t26 += v * b15;
          v = a[12];
          t12 += v * b0;
          t13 += v * b1;
          t14 += v * b2;
          t15 += v * b3;
          t16 += v * b4;
          t17 += v * b5;
          t18 += v * b6;
          t19 += v * b7;
          t20 += v * b8;
          t21 += v * b9;
          t22 += v * b10;
          t23 += v * b11;
          t24 += v * b12;
          t25 += v * b13;
          t26 += v * b14;
          t27 += v * b15;
          v = a[13];
          t13 += v * b0;
          t14 += v * b1;
          t15 += v * b2;
          t16 += v * b3;
          t17 += v * b4;
          t18 += v * b5;
          t19 += v * b6;
          t20 += v * b7;
          t21 += v * b8;
          t22 += v * b9;
          t23 += v * b10;
          t24 += v * b11;
          t25 += v * b12;
          t26 += v * b13;
          t27 += v * b14;
          t28 += v * b15;
          v = a[14];
          t14 += v * b0;
          t15 += v * b1;
          t16 += v * b2;
          t17 += v * b3;
          t18 += v * b4;
          t19 += v * b5;
          t20 += v * b6;
          t21 += v * b7;
          t22 += v * b8;
          t23 += v * b9;
          t24 += v * b10;
          t25 += v * b11;
          t26 += v * b12;
          t27 += v * b13;
          t28 += v * b14;
          t29 += v * b15;
          v = a[15];
          t15 += v * b0;
          t16 += v * b1;
          t17 += v * b2;
          t18 += v * b3;
          t19 += v * b4;
          t20 += v * b5;
          t21 += v * b6;
          t22 += v * b7;
          t23 += v * b8;
          t24 += v * b9;
          t25 += v * b10;
          t26 += v * b11;
          t27 += v * b12;
          t28 += v * b13;
          t29 += v * b14;
          t30 += v * b15;
          t0 += 38 * t16;
          t1 += 38 * t17;
          t2 += 38 * t18;
          t3 += 38 * t19;
          t4 += 38 * t20;
          t5 += 38 * t21;
          t6 += 38 * t22;
          t7 += 38 * t23;
          t8 += 38 * t24;
          t9 += 38 * t25;
          t10 += 38 * t26;
          t11 += 38 * t27;
          t12 += 38 * t28;
          t13 += 38 * t29;
          t14 += 38 * t30;
          c = 1;
          v = t0 + c + 65535;
          c = Math.floor(v / 65536);
          t0 = v - c * 65536;
          v = t1 + c + 65535;
          c = Math.floor(v / 65536);
          t1 = v - c * 65536;
          v = t2 + c + 65535;
          c = Math.floor(v / 65536);
          t2 = v - c * 65536;
          v = t3 + c + 65535;
          c = Math.floor(v / 65536);
          t3 = v - c * 65536;
          v = t4 + c + 65535;
          c = Math.floor(v / 65536);
          t4 = v - c * 65536;
          v = t5 + c + 65535;
          c = Math.floor(v / 65536);
          t5 = v - c * 65536;
          v = t6 + c + 65535;
          c = Math.floor(v / 65536);
          t6 = v - c * 65536;
          v = t7 + c + 65535;
          c = Math.floor(v / 65536);
          t7 = v - c * 65536;
          v = t8 + c + 65535;
          c = Math.floor(v / 65536);
          t8 = v - c * 65536;
          v = t9 + c + 65535;
          c = Math.floor(v / 65536);
          t9 = v - c * 65536;
          v = t10 + c + 65535;
          c = Math.floor(v / 65536);
          t10 = v - c * 65536;
          v = t11 + c + 65535;
          c = Math.floor(v / 65536);
          t11 = v - c * 65536;
          v = t12 + c + 65535;
          c = Math.floor(v / 65536);
          t12 = v - c * 65536;
          v = t13 + c + 65535;
          c = Math.floor(v / 65536);
          t13 = v - c * 65536;
          v = t14 + c + 65535;
          c = Math.floor(v / 65536);
          t14 = v - c * 65536;
          v = t15 + c + 65535;
          c = Math.floor(v / 65536);
          t15 = v - c * 65536;
          t0 += c - 1 + 37 * (c - 1);
          c = 1;
          v = t0 + c + 65535;
          c = Math.floor(v / 65536);
          t0 = v - c * 65536;
          v = t1 + c + 65535;
          c = Math.floor(v / 65536);
          t1 = v - c * 65536;
          v = t2 + c + 65535;
          c = Math.floor(v / 65536);
          t2 = v - c * 65536;
          v = t3 + c + 65535;
          c = Math.floor(v / 65536);
          t3 = v - c * 65536;
          v = t4 + c + 65535;
          c = Math.floor(v / 65536);
          t4 = v - c * 65536;
          v = t5 + c + 65535;
          c = Math.floor(v / 65536);
          t5 = v - c * 65536;
          v = t6 + c + 65535;
          c = Math.floor(v / 65536);
          t6 = v - c * 65536;
          v = t7 + c + 65535;
          c = Math.floor(v / 65536);
          t7 = v - c * 65536;
          v = t8 + c + 65535;
          c = Math.floor(v / 65536);
          t8 = v - c * 65536;
          v = t9 + c + 65535;
          c = Math.floor(v / 65536);
          t9 = v - c * 65536;
          v = t10 + c + 65535;
          c = Math.floor(v / 65536);
          t10 = v - c * 65536;
          v = t11 + c + 65535;
          c = Math.floor(v / 65536);
          t11 = v - c * 65536;
          v = t12 + c + 65535;
          c = Math.floor(v / 65536);
          t12 = v - c * 65536;
          v = t13 + c + 65535;
          c = Math.floor(v / 65536);
          t13 = v - c * 65536;
          v = t14 + c + 65535;
          c = Math.floor(v / 65536);
          t14 = v - c * 65536;
          v = t15 + c + 65535;
          c = Math.floor(v / 65536);
          t15 = v - c * 65536;
          t0 += c - 1 + 37 * (c - 1);
          o[0] = t0;
          o[1] = t1;
          o[2] = t2;
          o[3] = t3;
          o[4] = t4;
          o[5] = t5;
          o[6] = t6;
          o[7] = t7;
          o[8] = t8;
          o[9] = t9;
          o[10] = t10;
          o[11] = t11;
          o[12] = t12;
          o[13] = t13;
          o[14] = t14;
          o[15] = t15;
        }
        return ed25519_1;
      }
      var kem;
      var hasRequiredKem;
      function requireKem() {
        if (hasRequiredKem) return kem;
        hasRequiredKem = 1;
        var forge2 = requireForge();
        requireUtil();
        requireRandom();
        requireJsbn();
        kem = forge2.kem = forge2.kem || {};
        var BigInteger = forge2.jsbn.BigInteger;
        forge2.kem.rsa = {};
        forge2.kem.rsa.create = function(kdf, options) {
          options = options || {};
          var prng2 = options.prng || forge2.random;
          var kem2 = {};
          kem2.encrypt = function(publicKey, keyLength) {
            var byteLength = Math.ceil(publicKey.n.bitLength() / 8);
            var r;
            do {
              r = new BigInteger(
                forge2.util.bytesToHex(prng2.getBytesSync(byteLength)),
                16
              ).mod(publicKey.n);
            } while (r.compareTo(BigInteger.ONE) <= 0);
            r = forge2.util.hexToBytes(r.toString(16));
            var zeros = byteLength - r.length;
            if (zeros > 0) {
              r = forge2.util.fillString(String.fromCharCode(0), zeros) + r;
            }
            var encapsulation = publicKey.encrypt(r, "NONE");
            var key = kdf.generate(r, keyLength);
            return { encapsulation, key };
          };
          kem2.decrypt = function(privateKey, encapsulation, keyLength) {
            var r = privateKey.decrypt(encapsulation, "NONE");
            return kdf.generate(r, keyLength);
          };
          return kem2;
        };
        forge2.kem.kdf1 = function(md2, digestLength) {
          _createKDF(this, md2, 0, digestLength || md2.digestLength);
        };
        forge2.kem.kdf2 = function(md2, digestLength) {
          _createKDF(this, md2, 1, digestLength || md2.digestLength);
        };
        function _createKDF(kdf, md2, counterStart, digestLength) {
          kdf.generate = function(x, length) {
            var key = new forge2.util.ByteBuffer();
            var k = Math.ceil(length / digestLength) + counterStart;
            var c = new forge2.util.ByteBuffer();
            for (var i = counterStart; i < k; ++i) {
              c.putInt32(i);
              md2.start();
              md2.update(x + c.getBytes());
              var hash = md2.digest();
              key.putBytes(hash.getBytes(digestLength));
            }
            key.truncate(key.length() - length);
            return key.getBytes();
          };
        }
        return kem;
      }
      var log;
      var hasRequiredLog;
      function requireLog() {
        if (hasRequiredLog) return log;
        hasRequiredLog = 1;
        var forge2 = requireForge();
        requireUtil();
        log = forge2.log = forge2.log || {};
        forge2.log.levels = [
          "none",
          "error",
          "warning",
          "info",
          "debug",
          "verbose",
          "max"
        ];
        var sLevelInfo = {};
        var sLoggers = [];
        var sConsoleLogger = null;
        forge2.log.LEVEL_LOCKED = 1 << 1;
        forge2.log.NO_LEVEL_CHECK = 1 << 2;
        forge2.log.INTERPOLATE = 1 << 3;
        for (var i = 0; i < forge2.log.levels.length; ++i) {
          var level = forge2.log.levels[i];
          sLevelInfo[level] = {
            index: i,
            name: level.toUpperCase()
          };
        }
        forge2.log.logMessage = function(message2) {
          var messageLevelIndex = sLevelInfo[message2.level].index;
          for (var i2 = 0; i2 < sLoggers.length; ++i2) {
            var logger2 = sLoggers[i2];
            if (logger2.flags & forge2.log.NO_LEVEL_CHECK) {
              logger2.f(message2);
            } else {
              var loggerLevelIndex = sLevelInfo[logger2.level].index;
              if (messageLevelIndex <= loggerLevelIndex) {
                logger2.f(logger2, message2);
              }
            }
          }
        };
        forge2.log.prepareStandard = function(message2) {
          if (!("standard" in message2)) {
            message2.standard = sLevelInfo[message2.level].name + //' ' + +message.timestamp +
            " [" + message2.category + "] " + message2.message;
          }
        };
        forge2.log.prepareFull = function(message2) {
          if (!("full" in message2)) {
            var args = [message2.message];
            args = args.concat([]);
            message2.full = forge2.util.format.apply(this, args);
          }
        };
        forge2.log.prepareStandardFull = function(message2) {
          if (!("standardFull" in message2)) {
            forge2.log.prepareStandard(message2);
            message2.standardFull = message2.standard;
          }
        };
        {
          var levels = ["error", "warning", "info", "debug", "verbose"];
          for (var i = 0; i < levels.length; ++i) {
            (function(level2) {
              forge2.log[level2] = function(category, message2) {
                var args = Array.prototype.slice.call(arguments).slice(2);
                var msg = {
                  timestamp: /* @__PURE__ */ new Date(),
                  level: level2,
                  category,
                  message: message2,
                  "arguments": args
                  /*standard*/
                  /*full*/
                  /*fullMessage*/
                };
                forge2.log.logMessage(msg);
              };
            })(levels[i]);
          }
        }
        forge2.log.makeLogger = function(logFunction) {
          var logger2 = {
            flags: 0,
            f: logFunction
          };
          forge2.log.setLevel(logger2, "none");
          return logger2;
        };
        forge2.log.setLevel = function(logger2, level2) {
          var rval = false;
          if (logger2 && !(logger2.flags & forge2.log.LEVEL_LOCKED)) {
            for (var i2 = 0; i2 < forge2.log.levels.length; ++i2) {
              var aValidLevel = forge2.log.levels[i2];
              if (level2 == aValidLevel) {
                logger2.level = level2;
                rval = true;
                break;
              }
            }
          }
          return rval;
        };
        forge2.log.lock = function(logger2, lock2) {
          if (typeof lock2 === "undefined" || lock2) {
            logger2.flags |= forge2.log.LEVEL_LOCKED;
          } else {
            logger2.flags &= ~forge2.log.LEVEL_LOCKED;
          }
        };
        forge2.log.addLogger = function(logger2) {
          sLoggers.push(logger2);
        };
        if (typeof console !== "undefined" && "log" in console) {
          var logger;
          if (console.error && console.warn && console.info && console.debug) {
            var levelHandlers = {
              error: console.error,
              warning: console.warn,
              info: console.info,
              debug: console.debug,
              verbose: console.debug
            };
            var f = function(logger2, message2) {
              forge2.log.prepareStandard(message2);
              var handler = levelHandlers[message2.level];
              var args = [message2.standard];
              args = args.concat(message2["arguments"].slice());
              handler.apply(console, args);
            };
            logger = forge2.log.makeLogger(f);
          } else {
            var f = function(logger2, message2) {
              forge2.log.prepareStandardFull(message2);
              console.log(message2.standardFull);
            };
            logger = forge2.log.makeLogger(f);
          }
          forge2.log.setLevel(logger, "debug");
          forge2.log.addLogger(logger);
          sConsoleLogger = logger;
        } else {
          console = {
            log: function() {
            }
          };
        }
        if (sConsoleLogger !== null && typeof window !== "undefined" && window.location) {
          var query = new URL(window.location.href).searchParams;
          if (query.has("console.level")) {
            forge2.log.setLevel(
              sConsoleLogger,
              query.get("console.level").slice(-1)[0]
            );
          }
          if (query.has("console.lock")) {
            var lock = query.get("console.lock").slice(-1)[0];
            if (lock == "true") {
              forge2.log.lock(sConsoleLogger);
            }
          }
        }
        forge2.log.consoleLogger = sConsoleLogger;
        return log;
      }
      var md_all;
      var hasRequiredMd_all;
      function requireMd_all() {
        if (hasRequiredMd_all) return md_all;
        hasRequiredMd_all = 1;
        md_all = requireMd();
        requireMd5();
        requireSha1();
        requireSha256();
        requireSha512();
        return md_all;
      }
      var pkcs7 = { exports: {} };
      var hasRequiredPkcs7;
      function requirePkcs7() {
        if (hasRequiredPkcs7) return pkcs7.exports;
        hasRequiredPkcs7 = 1;
        var forge2 = requireForge();
        requireAes();
        requireAsn1();
        requireDes();
        requireOids();
        requirePem();
        requirePkcs7asn1();
        requireRandom();
        requireUtil();
        requireX509();
        var asn12 = forge2.asn1;
        var p7 = pkcs7.exports = forge2.pkcs7 = forge2.pkcs7 || {};
        p7.messageFromPem = function(pem2) {
          var msg = forge2.pem.decode(pem2)[0];
          if (msg.type !== "PKCS7") {
            var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
          }
          var obj = asn12.fromDer(msg.body);
          return p7.messageFromAsn1(obj);
        };
        p7.messageToPem = function(msg, maxline) {
          var pemObj = {
            type: "PKCS7",
            body: asn12.toDer(msg.toAsn1()).getBytes()
          };
          return forge2.pem.encode(pemObj, { maxline });
        };
        p7.messageFromAsn1 = function(obj) {
          var capture = {};
          var errors = [];
          if (!asn12.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
            error.errors = errors;
            throw error;
          }
          var contentType2 = asn12.derToOid(capture.contentType);
          var msg;
          switch (contentType2) {
            case forge2.pki.oids.envelopedData:
              msg = p7.createEnvelopedData();
              break;
            case forge2.pki.oids.encryptedData:
              msg = p7.createEncryptedData();
              break;
            case forge2.pki.oids.signedData:
              msg = p7.createSignedData();
              break;
            default:
              throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType2 + " is not (yet) supported.");
          }
          msg.fromAsn1(capture.content.value[0]);
          return msg;
        };
        p7.createSignedData = function() {
          var msg = null;
          msg = {
            type: forge2.pki.oids.signedData,
            version: 1,
            certificates: [],
            crls: [],
            // TODO: add json-formatted signer stuff here?
            signers: [],
            // populated during sign()
            digestAlgorithmIdentifiers: [],
            contentInfo: null,
            signerInfos: [],
            fromAsn1: function(obj) {
              _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
              msg.certificates = [];
              msg.crls = [];
              msg.digestAlgorithmIdentifiers = [];
              msg.contentInfo = null;
              msg.signerInfos = [];
              if (msg.rawCapture.certificates) {
                var certs = msg.rawCapture.certificates.value;
                for (var i = 0; i < certs.length; ++i) {
                  msg.certificates.push(forge2.pki.certificateFromAsn1(certs[i]));
                }
              }
            },
            toAsn1: function() {
              if (!msg.contentInfo) {
                msg.sign();
              }
              var certs = [];
              for (var i = 0; i < msg.certificates.length; ++i) {
                certs.push(forge2.pki.certificateToAsn1(msg.certificates[i]));
              }
              var crls = [];
              var signedData = asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                  // Version
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.INTEGER,
                    false,
                    asn12.integerToDer(msg.version).getBytes()
                  ),
                  // DigestAlgorithmIdentifiers
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.SET,
                    true,
                    msg.digestAlgorithmIdentifiers
                  ),
                  // ContentInfo
                  msg.contentInfo
                ])
              ]);
              if (certs.length > 0) {
                signedData.value[0].value.push(
                  asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, certs)
                );
              }
              if (crls.length > 0) {
                signedData.value[0].value.push(
                  asn12.create(asn12.Class.CONTEXT_SPECIFIC, 1, true, crls)
                );
              }
              signedData.value[0].value.push(
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.SET,
                  true,
                  msg.signerInfos
                )
              );
              return asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.SEQUENCE,
                true,
                [
                  // ContentType
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.OID,
                    false,
                    asn12.oidToDer(msg.type).getBytes()
                  ),
                  // [0] SignedData
                  signedData
                ]
              );
            },
            /**
             * Add (another) entity to list of signers.
             *
             * Note: If authenticatedAttributes are provided, then, per RFC 2315,
             * they must include at least two attributes: content type and
             * message digest. The message digest attribute value will be
             * auto-calculated during signing and will be ignored if provided.
             *
             * Here's an example of providing these two attributes:
             *
             * forge.pkcs7.createSignedData();
             * p7.addSigner({
             *   issuer: cert.issuer.attributes,
             *   serialNumber: cert.serialNumber,
             *   key: privateKey,
             *   digestAlgorithm: forge.pki.oids.sha1,
             *   authenticatedAttributes: [{
             *     type: forge.pki.oids.contentType,
             *     value: forge.pki.oids.data
             *   }, {
             *     type: forge.pki.oids.messageDigest
             *   }]
             * });
             *
             * TODO: Support [subjectKeyIdentifier] as signer's ID.
             *
             * @param signer the signer information:
             *          key the signer's private key.
             *          [certificate] a certificate containing the public key
             *            associated with the signer's private key; use this option as
             *            an alternative to specifying signer.issuer and
             *            signer.serialNumber.
             *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
             *          [serialNumber] the signer's certificate's serial number in
             *           hexadecimal (eg: cert.serialNumber).
             *          [digestAlgorithm] the message digest OID, as a string, to use
             *            (eg: forge.pki.oids.sha1).
             *          [authenticatedAttributes] an optional array of attributes
             *            to also sign along with the content.
             */
            addSigner: function(signer) {
              var issuer = signer.issuer;
              var serialNumber = signer.serialNumber;
              if (signer.certificate) {
                var cert = signer.certificate;
                if (typeof cert === "string") {
                  cert = forge2.pki.certificateFromPem(cert);
                }
                issuer = cert.issuer.attributes;
                serialNumber = cert.serialNumber;
              }
              var key = signer.key;
              if (!key) {
                throw new Error(
                  "Could not add PKCS#7 signer; no private key specified."
                );
              }
              if (typeof key === "string") {
                key = forge2.pki.privateKeyFromPem(key);
              }
              var digestAlgorithm = signer.digestAlgorithm || forge2.pki.oids.sha1;
              switch (digestAlgorithm) {
                case forge2.pki.oids.sha1:
                case forge2.pki.oids.sha256:
                case forge2.pki.oids.sha384:
                case forge2.pki.oids.sha512:
                case forge2.pki.oids.md5:
                  break;
                default:
                  throw new Error(
                    "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
                  );
              }
              var authenticatedAttributes = signer.authenticatedAttributes || [];
              if (authenticatedAttributes.length > 0) {
                var contentType2 = false;
                var messageDigest = false;
                for (var i = 0; i < authenticatedAttributes.length; ++i) {
                  var attr = authenticatedAttributes[i];
                  if (!contentType2 && attr.type === forge2.pki.oids.contentType) {
                    contentType2 = true;
                    if (messageDigest) {
                      break;
                    }
                    continue;
                  }
                  if (!messageDigest && attr.type === forge2.pki.oids.messageDigest) {
                    messageDigest = true;
                    if (contentType2) {
                      break;
                    }
                    continue;
                  }
                }
                if (!contentType2 || !messageDigest) {
                  throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
                }
              }
              msg.signers.push({
                key,
                version: 1,
                issuer,
                serialNumber,
                digestAlgorithm,
                signatureAlgorithm: forge2.pki.oids.rsaEncryption,
                signature: null,
                authenticatedAttributes,
                unauthenticatedAttributes: []
              });
            },
            /**
             * Signs the content.
             * @param options Options to apply when signing:
             *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
             */
            sign: function(options) {
              options = options || {};
              if (typeof msg.content !== "object" || msg.contentInfo === null) {
                msg.contentInfo = asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.SEQUENCE,
                  true,
                  [
                    // ContentType
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.OID,
                      false,
                      asn12.oidToDer(forge2.pki.oids.data).getBytes()
                    )
                  ]
                );
                if ("content" in msg) {
                  var content;
                  if (msg.content instanceof forge2.util.ByteBuffer) {
                    content = msg.content.bytes();
                  } else if (typeof msg.content === "string") {
                    content = forge2.util.encodeUtf8(msg.content);
                  }
                  if (options.detached) {
                    msg.detachedContent = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.OCTETSTRING, false, content);
                  } else {
                    msg.contentInfo.value.push(
                      // [0] EXPLICIT content
                      asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                        asn12.create(
                          asn12.Class.UNIVERSAL,
                          asn12.Type.OCTETSTRING,
                          false,
                          content
                        )
                      ])
                    );
                  }
                }
              }
              if (msg.signers.length === 0) {
                return;
              }
              var mds = addDigestAlgorithmIds();
              addSignerInfos(mds);
            },
            verify: function() {
              throw new Error("PKCS#7 signature verification not yet implemented.");
            },
            /**
             * Add a certificate.
             *
             * @param cert the certificate to add.
             */
            addCertificate: function(cert) {
              if (typeof cert === "string") {
                cert = forge2.pki.certificateFromPem(cert);
              }
              msg.certificates.push(cert);
            },
            /**
             * Add a certificate revokation list.
             *
             * @param crl the certificate revokation list to add.
             */
            addCertificateRevokationList: function(crl) {
              throw new Error("PKCS#7 CRL support not yet implemented.");
            }
          };
          return msg;
          function addDigestAlgorithmIds() {
            var mds = {};
            for (var i = 0; i < msg.signers.length; ++i) {
              var signer = msg.signers[i];
              var oid = signer.digestAlgorithm;
              if (!(oid in mds)) {
                mds[oid] = forge2.md[forge2.pki.oids[oid]].create();
              }
              if (signer.authenticatedAttributes.length === 0) {
                signer.md = mds[oid];
              } else {
                signer.md = forge2.md[forge2.pki.oids[oid]].create();
              }
            }
            msg.digestAlgorithmIdentifiers = [];
            for (var oid in mds) {
              msg.digestAlgorithmIdentifiers.push(
                // AlgorithmIdentifier
                asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                  // algorithm
                  asn12.create(
                    asn12.Class.UNIVERSAL,
                    asn12.Type.OID,
                    false,
                    asn12.oidToDer(oid).getBytes()
                  ),
                  // parameters (null)
                  asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
                ])
              );
            }
            return mds;
          }
          function addSignerInfos(mds) {
            var content;
            if (msg.detachedContent) {
              content = msg.detachedContent;
            } else {
              content = msg.contentInfo.value[1];
              content = content.value[0];
            }
            if (!content) {
              throw new Error(
                "Could not sign PKCS#7 message; there is no content to sign."
              );
            }
            var contentType2 = asn12.derToOid(msg.contentInfo.value[0].value);
            var bytes = asn12.toDer(content);
            bytes.getByte();
            asn12.getBerValueLength(bytes);
            bytes = bytes.getBytes();
            for (var oid in mds) {
              mds[oid].start().update(bytes);
            }
            var signingTime = /* @__PURE__ */ new Date();
            for (var i = 0; i < msg.signers.length; ++i) {
              var signer = msg.signers[i];
              if (signer.authenticatedAttributes.length === 0) {
                if (contentType2 !== forge2.pki.oids.data) {
                  throw new Error(
                    "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
                  );
                }
              } else {
                signer.authenticatedAttributesAsn1 = asn12.create(
                  asn12.Class.CONTEXT_SPECIFIC,
                  0,
                  true,
                  []
                );
                var attrsAsn1 = asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.SET,
                  true,
                  []
                );
                for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
                  var attr = signer.authenticatedAttributes[ai];
                  if (attr.type === forge2.pki.oids.messageDigest) {
                    attr.value = mds[signer.digestAlgorithm].digest();
                  } else if (attr.type === forge2.pki.oids.signingTime) {
                    if (!attr.value) {
                      attr.value = signingTime;
                    }
                  }
                  attrsAsn1.value.push(_attributeToAsn1(attr));
                  signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
                }
                bytes = asn12.toDer(attrsAsn1).getBytes();
                signer.md.start().update(bytes);
              }
              signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
            }
            msg.signerInfos = _signersToAsn1(msg.signers);
          }
        };
        p7.createEncryptedData = function() {
          var msg = null;
          msg = {
            type: forge2.pki.oids.encryptedData,
            version: 0,
            encryptedContent: {
              algorithm: forge2.pki.oids["aes256-CBC"]
            },
            /**
             * Reads an EncryptedData content block (in ASN.1 format)
             *
             * @param obj The ASN.1 representation of the EncryptedData content block
             */
            fromAsn1: function(obj) {
              _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
            },
            /**
             * Decrypt encrypted content
             *
             * @param key The (symmetric) key as a byte buffer
             */
            decrypt: function(key) {
              if (key !== void 0) {
                msg.encryptedContent.key = key;
              }
              _decryptContent(msg);
            }
          };
          return msg;
        };
        p7.createEnvelopedData = function() {
          var msg = null;
          msg = {
            type: forge2.pki.oids.envelopedData,
            version: 0,
            recipients: [],
            encryptedContent: {
              algorithm: forge2.pki.oids["aes256-CBC"]
            },
            /**
             * Reads an EnvelopedData content block (in ASN.1 format)
             *
             * @param obj the ASN.1 representation of the EnvelopedData content block.
             */
            fromAsn1: function(obj) {
              var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
              msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
            },
            toAsn1: function() {
              return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                // ContentType
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(msg.type).getBytes()
                ),
                // [0] EnvelopedData
                asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
                  asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                    // Version
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.INTEGER,
                      false,
                      asn12.integerToDer(msg.version).getBytes()
                    ),
                    // RecipientInfos
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.SET,
                      true,
                      _recipientsToAsn1(msg.recipients)
                    ),
                    // EncryptedContentInfo
                    asn12.create(
                      asn12.Class.UNIVERSAL,
                      asn12.Type.SEQUENCE,
                      true,
                      _encryptedContentToAsn1(msg.encryptedContent)
                    )
                  ])
                ])
              ]);
            },
            /**
             * Find recipient by X.509 certificate's issuer.
             *
             * @param cert the certificate with the issuer to look for.
             *
             * @return the recipient object.
             */
            findRecipient: function(cert) {
              var sAttr = cert.issuer.attributes;
              for (var i = 0; i < msg.recipients.length; ++i) {
                var r = msg.recipients[i];
                var rAttr = r.issuer;
                if (r.serialNumber !== cert.serialNumber) {
                  continue;
                }
                if (rAttr.length !== sAttr.length) {
                  continue;
                }
                var match = true;
                for (var j = 0; j < sAttr.length; ++j) {
                  if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
                    match = false;
                    break;
                  }
                }
                if (match) {
                  return r;
                }
              }
              return null;
            },
            /**
             * Decrypt enveloped content
             *
             * @param recipient The recipient object related to the private key
             * @param privKey The (RSA) private key object
             */
            decrypt: function(recipient, privKey) {
              if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
                switch (recipient.encryptedContent.algorithm) {
                  case forge2.pki.oids.rsaEncryption:
                  case forge2.pki.oids.desCBC:
                    var key = privKey.decrypt(recipient.encryptedContent.content);
                    msg.encryptedContent.key = forge2.util.createBuffer(key);
                    break;
                  default:
                    throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
                }
              }
              _decryptContent(msg);
            },
            /**
             * Add (another) entity to list of recipients.
             *
             * @param cert The certificate of the entity to add.
             */
            addRecipient: function(cert) {
              msg.recipients.push({
                version: 0,
                issuer: cert.issuer.attributes,
                serialNumber: cert.serialNumber,
                encryptedContent: {
                  // We simply assume rsaEncryption here, since forge.pki only
                  // supports RSA so far.  If the PKI module supports other
                  // ciphers one day, we need to modify this one as well.
                  algorithm: forge2.pki.oids.rsaEncryption,
                  key: cert.publicKey
                }
              });
            },
            /**
             * Encrypt enveloped content.
             *
             * This function supports two optional arguments, cipher and key, which
             * can be used to influence symmetric encryption.  Unless cipher is
             * provided, the cipher specified in encryptedContent.algorithm is used
             * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
             * is (re-)used.  If that one's not set, a random key will be generated
             * automatically.
             *
             * @param [key] The key to be used for symmetric encryption.
             * @param [cipher] The OID of the symmetric cipher to use.
             */
            encrypt: function(key, cipher2) {
              if (msg.encryptedContent.content === void 0) {
                cipher2 = cipher2 || msg.encryptedContent.algorithm;
                key = key || msg.encryptedContent.key;
                var keyLen, ivLen, ciphFn;
                switch (cipher2) {
                  case forge2.pki.oids["aes128-CBC"]:
                    keyLen = 16;
                    ivLen = 16;
                    ciphFn = forge2.aes.createEncryptionCipher;
                    break;
                  case forge2.pki.oids["aes192-CBC"]:
                    keyLen = 24;
                    ivLen = 16;
                    ciphFn = forge2.aes.createEncryptionCipher;
                    break;
                  case forge2.pki.oids["aes256-CBC"]:
                    keyLen = 32;
                    ivLen = 16;
                    ciphFn = forge2.aes.createEncryptionCipher;
                    break;
                  case forge2.pki.oids["des-EDE3-CBC"]:
                    keyLen = 24;
                    ivLen = 8;
                    ciphFn = forge2.des.createEncryptionCipher;
                    break;
                  default:
                    throw new Error("Unsupported symmetric cipher, OID " + cipher2);
                }
                if (key === void 0) {
                  key = forge2.util.createBuffer(forge2.random.getBytes(keyLen));
                } else if (key.length() != keyLen) {
                  throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
                }
                msg.encryptedContent.algorithm = cipher2;
                msg.encryptedContent.key = key;
                msg.encryptedContent.parameter = forge2.util.createBuffer(
                  forge2.random.getBytes(ivLen)
                );
                var ciph = ciphFn(key);
                ciph.start(msg.encryptedContent.parameter.copy());
                ciph.update(msg.content);
                if (!ciph.finish()) {
                  throw new Error("Symmetric encryption failed.");
                }
                msg.encryptedContent.content = ciph.output;
              }
              for (var i = 0; i < msg.recipients.length; ++i) {
                var recipient = msg.recipients[i];
                if (recipient.encryptedContent.content !== void 0) {
                  continue;
                }
                switch (recipient.encryptedContent.algorithm) {
                  case forge2.pki.oids.rsaEncryption:
                    recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
                      msg.encryptedContent.key.data
                    );
                    break;
                  default:
                    throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
                }
              }
            }
          };
          return msg;
        };
        function _recipientFromAsn1(obj) {
          var capture = {};
          var errors = [];
          if (!asn12.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
            error.errors = errors;
            throw error;
          }
          return {
            version: capture.version.charCodeAt(0),
            issuer: forge2.pki.RDNAttributesAsArray(capture.issuer),
            serialNumber: forge2.util.createBuffer(capture.serial).toHex(),
            encryptedContent: {
              algorithm: asn12.derToOid(capture.encAlgorithm),
              parameter: capture.encParameter ? capture.encParameter.value : void 0,
              content: capture.encKey
            }
          };
        }
        function _recipientToAsn1(obj) {
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // Version
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              asn12.integerToDer(obj.version).getBytes()
            ),
            // IssuerAndSerialNumber
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // Name
              forge2.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
              // Serial
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.INTEGER,
                false,
                forge2.util.hexToBytes(obj.serialNumber)
              )
            ]),
            // KeyEncryptionAlgorithmIdentifier
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // Algorithm
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(obj.encryptedContent.algorithm).getBytes()
              ),
              // Parameter, force NULL, only RSA supported for now.
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
            ]),
            // EncryptedKey
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OCTETSTRING,
              false,
              obj.encryptedContent.content
            )
          ]);
        }
        function _recipientsFromAsn1(infos) {
          var ret = [];
          for (var i = 0; i < infos.length; ++i) {
            ret.push(_recipientFromAsn1(infos[i]));
          }
          return ret;
        }
        function _recipientsToAsn1(recipients) {
          var ret = [];
          for (var i = 0; i < recipients.length; ++i) {
            ret.push(_recipientToAsn1(recipients[i]));
          }
          return ret;
        }
        function _signerToAsn1(obj) {
          var rval = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // version
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.INTEGER,
              false,
              asn12.integerToDer(obj.version).getBytes()
            ),
            // issuerAndSerialNumber
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // name
              forge2.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
              // serial
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.INTEGER,
                false,
                forge2.util.hexToBytes(obj.serialNumber)
              )
            ]),
            // digestAlgorithm
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // algorithm
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(obj.digestAlgorithm).getBytes()
              ),
              // parameters (null)
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
            ])
          ]);
          if (obj.authenticatedAttributesAsn1) {
            rval.value.push(obj.authenticatedAttributesAsn1);
          }
          rval.value.push(asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // algorithm
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OID,
              false,
              asn12.oidToDer(obj.signatureAlgorithm).getBytes()
            ),
            // parameters (null)
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
          ]));
          rval.value.push(asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.OCTETSTRING,
            false,
            obj.signature
          ));
          if (obj.unauthenticatedAttributes.length > 0) {
            var attrsAsn1 = asn12.create(asn12.Class.CONTEXT_SPECIFIC, 1, true, []);
            for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
              var attr = obj.unauthenticatedAttributes[i];
              attrsAsn1.values.push(_attributeToAsn1(attr));
            }
            rval.value.push(attrsAsn1);
          }
          return rval;
        }
        function _signersToAsn1(signers) {
          var ret = [];
          for (var i = 0; i < signers.length; ++i) {
            ret.push(_signerToAsn1(signers[i]));
          }
          return ret;
        }
        function _attributeToAsn1(attr) {
          var value;
          if (attr.type === forge2.pki.oids.contentType) {
            value = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OID,
              false,
              asn12.oidToDer(attr.value).getBytes()
            );
          } else if (attr.type === forge2.pki.oids.messageDigest) {
            value = asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OCTETSTRING,
              false,
              attr.value.bytes()
            );
          } else if (attr.type === forge2.pki.oids.signingTime) {
            var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
            var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
            var date = attr.value;
            if (typeof date === "string") {
              var timestamp = Date.parse(date);
              if (!isNaN(timestamp)) {
                date = new Date(timestamp);
              } else if (date.length === 13) {
                date = asn12.utcTimeToDate(date);
              } else {
                date = asn12.generalizedTimeToDate(date);
              }
            }
            if (date >= jan_1_1950 && date < jan_1_2050) {
              value = asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.UTCTIME,
                false,
                asn12.dateToUtcTime(date)
              );
            } else {
              value = asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.GENERALIZEDTIME,
                false,
                asn12.dateToGeneralizedTime(date)
              );
            }
          }
          return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // AttributeType
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OID,
              false,
              asn12.oidToDer(attr.type).getBytes()
            ),
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SET, true, [
              // AttributeValue
              value
            ])
          ]);
        }
        function _encryptedContentToAsn1(ec2) {
          return [
            // ContentType, always Data for the moment
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OID,
              false,
              asn12.oidToDer(forge2.pki.oids.data).getBytes()
            ),
            // ContentEncryptionAlgorithmIdentifier
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // Algorithm
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OID,
                false,
                asn12.oidToDer(ec2.algorithm).getBytes()
              ),
              // Parameters (IV)
              !ec2.parameter ? void 0 : asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OCTETSTRING,
                false,
                ec2.parameter.getBytes()
              )
            ]),
            // [0] EncryptedContent
            asn12.create(asn12.Class.CONTEXT_SPECIFIC, 0, true, [
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.OCTETSTRING,
                false,
                ec2.content.getBytes()
              )
            ])
          ];
        }
        function _fromAsn1(msg, obj, validator) {
          var capture = {};
          var errors = [];
          if (!asn12.validate(obj, validator, capture, errors)) {
            var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
            error.errors = error;
            throw error;
          }
          var contentType2 = asn12.derToOid(capture.contentType);
          if (contentType2 !== forge2.pki.oids.data) {
            throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
          }
          if (capture.encryptedContent) {
            var content = "";
            if (forge2.util.isArray(capture.encryptedContent)) {
              for (var i = 0; i < capture.encryptedContent.length; ++i) {
                if (capture.encryptedContent[i].type !== asn12.Type.OCTETSTRING) {
                  throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
                }
                content += capture.encryptedContent[i].value;
              }
            } else {
              content = capture.encryptedContent;
            }
            msg.encryptedContent = {
              algorithm: asn12.derToOid(capture.encAlgorithm),
              parameter: forge2.util.createBuffer(capture.encParameter.value),
              content: forge2.util.createBuffer(content)
            };
          }
          if (capture.content) {
            var content = "";
            if (forge2.util.isArray(capture.content)) {
              for (var i = 0; i < capture.content.length; ++i) {
                if (capture.content[i].type !== asn12.Type.OCTETSTRING) {
                  throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
                }
                content += capture.content[i].value;
              }
            } else {
              content = capture.content;
            }
            msg.content = forge2.util.createBuffer(content);
          }
          msg.version = capture.version.charCodeAt(0);
          msg.rawCapture = capture;
          return capture;
        }
        function _decryptContent(msg) {
          if (msg.encryptedContent.key === void 0) {
            throw new Error("Symmetric key not available.");
          }
          if (msg.content === void 0) {
            var ciph;
            switch (msg.encryptedContent.algorithm) {
              case forge2.pki.oids["aes128-CBC"]:
              case forge2.pki.oids["aes192-CBC"]:
              case forge2.pki.oids["aes256-CBC"]:
                ciph = forge2.aes.createDecryptionCipher(msg.encryptedContent.key);
                break;
              case forge2.pki.oids["desCBC"]:
              case forge2.pki.oids["des-EDE3-CBC"]:
                ciph = forge2.des.createDecryptionCipher(msg.encryptedContent.key);
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
            }
            ciph.start(msg.encryptedContent.parameter);
            ciph.update(msg.encryptedContent.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric decryption failed.");
            }
            msg.content = ciph.output;
          }
        }
        return pkcs7.exports;
      }
      var ssh = { exports: {} };
      var hasRequiredSsh;
      function requireSsh() {
        if (hasRequiredSsh) return ssh.exports;
        hasRequiredSsh = 1;
        var forge2 = requireForge();
        requireAes();
        requireHmac();
        requireMd5();
        requireSha1();
        requireUtil();
        var ssh$1 = ssh.exports = forge2.ssh = forge2.ssh || {};
        ssh$1.privateKeyToPutty = function(privateKey, passphrase, comment) {
          comment = comment || "";
          passphrase = passphrase || "";
          var algorithm = "ssh-rsa";
          var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
          var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
          ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
          ppk += "Comment: " + comment + "\r\n";
          var pubbuffer = forge2.util.createBuffer();
          _addStringToBuffer(pubbuffer, algorithm);
          _addBigIntegerToBuffer(pubbuffer, privateKey.e);
          _addBigIntegerToBuffer(pubbuffer, privateKey.n);
          var pub = forge2.util.encode64(pubbuffer.bytes(), 64);
          var length = Math.floor(pub.length / 66) + 1;
          ppk += "Public-Lines: " + length + "\r\n";
          ppk += pub;
          var privbuffer = forge2.util.createBuffer();
          _addBigIntegerToBuffer(privbuffer, privateKey.d);
          _addBigIntegerToBuffer(privbuffer, privateKey.p);
          _addBigIntegerToBuffer(privbuffer, privateKey.q);
          _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
          var priv;
          if (!passphrase) {
            priv = forge2.util.encode64(privbuffer.bytes(), 64);
          } else {
            var encLen = privbuffer.length() + 16 - 1;
            encLen -= encLen % 16;
            var padding = _sha1(privbuffer.bytes());
            padding.truncate(padding.length() - encLen + privbuffer.length());
            privbuffer.putBuffer(padding);
            var aeskey = forge2.util.createBuffer();
            aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
            aeskey.putBuffer(_sha1("\0\0\0", passphrase));
            var cipher2 = forge2.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
            cipher2.start(forge2.util.createBuffer().fillWithByte(0, 16));
            cipher2.update(privbuffer.copy());
            cipher2.finish();
            var encrypted = cipher2.output;
            encrypted.truncate(16);
            priv = forge2.util.encode64(encrypted.bytes(), 64);
          }
          length = Math.floor(priv.length / 66) + 1;
          ppk += "\r\nPrivate-Lines: " + length + "\r\n";
          ppk += priv;
          var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
          var macbuffer = forge2.util.createBuffer();
          _addStringToBuffer(macbuffer, algorithm);
          _addStringToBuffer(macbuffer, encryptionAlgorithm);
          _addStringToBuffer(macbuffer, comment);
          macbuffer.putInt32(pubbuffer.length());
          macbuffer.putBuffer(pubbuffer);
          macbuffer.putInt32(privbuffer.length());
          macbuffer.putBuffer(privbuffer);
          var hmac2 = forge2.hmac.create();
          hmac2.start("sha1", mackey);
          hmac2.update(macbuffer.bytes());
          ppk += "\r\nPrivate-MAC: " + hmac2.digest().toHex() + "\r\n";
          return ppk;
        };
        ssh$1.publicKeyToOpenSSH = function(key, comment) {
          var type = "ssh-rsa";
          comment = comment || "";
          var buffer = forge2.util.createBuffer();
          _addStringToBuffer(buffer, type);
          _addBigIntegerToBuffer(buffer, key.e);
          _addBigIntegerToBuffer(buffer, key.n);
          return type + " " + forge2.util.encode64(buffer.bytes()) + " " + comment;
        };
        ssh$1.privateKeyToOpenSSH = function(privateKey, passphrase) {
          if (!passphrase) {
            return forge2.pki.privateKeyToPem(privateKey);
          }
          return forge2.pki.encryptRsaPrivateKey(
            privateKey,
            passphrase,
            { legacy: true, algorithm: "aes128" }
          );
        };
        ssh$1.getPublicKeyFingerprint = function(key, options) {
          options = options || {};
          var md2 = options.md || forge2.md.md5.create();
          var type = "ssh-rsa";
          var buffer = forge2.util.createBuffer();
          _addStringToBuffer(buffer, type);
          _addBigIntegerToBuffer(buffer, key.e);
          _addBigIntegerToBuffer(buffer, key.n);
          md2.start();
          md2.update(buffer.getBytes());
          var digest = md2.digest();
          if (options.encoding === "hex") {
            var hex = digest.toHex();
            if (options.delimiter) {
              return hex.match(/.{2}/g).join(options.delimiter);
            }
            return hex;
          } else if (options.encoding === "binary") {
            return digest.getBytes();
          } else if (options.encoding) {
            throw new Error('Unknown encoding "' + options.encoding + '".');
          }
          return digest;
        };
        function _addBigIntegerToBuffer(buffer, val) {
          var hexVal = val.toString(16);
          if (hexVal[0] >= "8") {
            hexVal = "00" + hexVal;
          }
          var bytes = forge2.util.hexToBytes(hexVal);
          buffer.putInt32(bytes.length);
          buffer.putBytes(bytes);
        }
        function _addStringToBuffer(buffer, val) {
          buffer.putInt32(val.length);
          buffer.putString(val);
        }
        function _sha1() {
          var sha = forge2.md.sha1.create();
          var num = arguments.length;
          for (var i = 0; i < num; ++i) {
            sha.update(arguments[i]);
          }
          return sha.digest();
        }
        return ssh.exports;
      }
      var lib;
      var hasRequiredLib;
      function requireLib() {
        if (hasRequiredLib) return lib;
        hasRequiredLib = 1;
        lib = requireForge();
        requireAes();
        requireAesCipherSuites();
        requireAsn1();
        requireCipher();
        requireDes();
        requireEd25519();
        requireHmac();
        requireKem();
        requireLog();
        requireMd_all();
        requireMgf1();
        requirePbkdf2();
        requirePem();
        requirePkcs1();
        requirePkcs12();
        requirePkcs7();
        requirePki();
        requirePrime();
        requirePrng();
        requirePss();
        requireRandom();
        requireRc2();
        requireSsh();
        requireTls();
        requireUtil();
        return lib;
      }
      var libExports = requireLib();
      const forge = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
      const IV = "0102030405060708";
      const PRESET_KEY = "0CoJUm6Qyw8W8jud";
      const PUBLIC_KEY = "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDgtQn2JZ34ZC28NWYpAUd98iZ37BUrX/aKzmFbt7clFSs6sXqHauqKWqdtLkF2KexO40H1YTX8z2lSgBBOAxLsvaklV8k4cBFK9snQXE9/DDaFt6Rr7iVZMldczhC0JNgTz+SHXT6CBHuX3e9SdB1Ua44oncaTWz7OBGLbCiK45wIDAQAB\n-----END PUBLIC KEY-----";
      const BASE62 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      const aesEncrypt = (text, key, iv) => {
        const cipher2 = forge.cipher.createCipher("AES-CBC", key);
        cipher2.start({ iv });
        cipher2.update(forge.util.createBuffer(text, "utf8"));
        cipher2.finish();
        return forge.util.encode64(cipher2.output.getBytes());
      };
      const rsaEncrypt = (text, key) => {
        const publicKey = forge.pki.publicKeyFromPem(key);
        const encrypted = publicKey.encrypt(text, "NONE");
        return forge.util.bytesToHex(encrypted);
      };
      const weapi = (object) => {
        const text = JSON.stringify(object);
        const secretKey = Array.from(
          { length: 16 },
          () => BASE62.charAt(Math.floor(Math.random() * 62))
        ).join("");
        return {
          params: aesEncrypt(aesEncrypt(text, PRESET_KEY, IV), secretKey, IV),
          encSecKey: rsaEncrypt(secretKey.split("").reverse().join(""), PUBLIC_KEY)
        };
      };
      const CLIENT_CONFIG = {
        web: {
          cookie: true,
          userAgent: void 0
        },
        android: {
          cookie: "os=android;appver=9.1.78;channel=netease;osver=14;buildver=241009150147;",
          userAgent: "NeteaseMusic/9.1.78.241009150147(9001078);Dalvik/2.1.0 (Linux; U; Android 14; V2318A Build/TP1A.220624.014)"
        },
        pc: {
          cookie: "os=pc;appver=3.0.18.203152;channel=netease;osver=Microsoft-Windows-10-Professional-build-19045-64bit;",
          userAgent: "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Safari/537.36 Chrome/91.0.4472.164 NeteaseMusicDesktop/3.0.18.203152"
        }
      };
      const weapiRequest = (url, config) => {
        const { data = {}, clientType = "pc", ip, originResponse = false } = config;
        data.csrf_token = /* csrfToken ? csrfToken[1] : */
        "";
        const encryptedData = weapi(data);
        console.log({
          url,
          data,
          encryptedData
        });
        const headers = {
          "content-type": "application/x-www-form-urlencoded",
          "user-agent": CLIENT_CONFIG[clientType].userAgent
        };
        if (ip) {
          headers["X-Real-IP"] = ip;
          headers["X-Forwarded-For"] = ip;
        }
        const baseUrl = "https://music.163.com";
        const fullUrl = new URL(url.replace("api", "weapi"), baseUrl);
        return new Promise((resolve, reject) => {
          _GM_xmlhttpRequest({
            url: fullUrl.toString() + `?csrf_token=${data.csrf_token}`,
            method: "POST",
            responseType: "json",
            headers,
            cookie: CLIENT_CONFIG[clientType].cookie,
            data: `params=${encodeURIComponent(
        encryptedData.params
      )}&encSecKey=${encodeURIComponent(encryptedData.encSecKey)}`,
            onload: (res) => resolve(originResponse ? res : res.response),
            onerror: reject
          });
        });
      };
      const BUCKET = "jd-musicrep-privatecloud-audio-public";
      const getUserAccount = () => weapiRequest("/api/nuser/account/get", {
        data: {}
      });
      const uploadAudioToNos = async ({ file, bucket, objectKey, token, fileMd5, contentType: contentType2 }) => {
        const lbsUrl = `https://wanproxy.127.net/lbs?version=1.0&bucketname=${bucket}`;
        const lbs = await (await fetch(lbsUrl)).json();
        const safeObjectKey = objectKey.replace("/", "%2F");
        const uploadUrl = `${lbs.upload[0]}/${bucket}/${safeObjectKey}?offset=0&complete=true&version=1.0`.replace(
          "http://",
          "https://"
        );
        const response = await fetch(uploadUrl, {
          method: "post",
          headers: {
            "x-nos-token": token,
            "Content-MD5": fileMd5,
            "Content-Type": contentType2
          },
          body: file
        });
        let result = {};
        try {
          result = await response.json();
        } catch (error) {
          console.log("uploadAudioToNos parse error", error);
        }
        if (!response.ok) {
          msgError("上传失败：文件未通过 NOS 校验");
          throw new Error(result?.message || "上传失败：文件未通过 NOS 校验");
        }
        return result;
      };
      const uploadLocalSong = async (file, options = {}) => {
        const {
          defaultBitrate = 999e3,
          defaultAlbum,
          defaultArtist,
          defaultTitle,
          defaultArtists = []
        } = options || {};
        let defaultResult = {};
        try {
          const ext = file.name.split(".").pop() || "mp3";
          const fileMd5 = await getFileMD5(file);
          const bitrate = defaultBitrate;
          const filename = file.name.replace("." + ext, "").replace(/\s/g, "").replace(/\./g, "_");
          const contentType2 = file.type || "audio/mpeg";
          const checkRes = await weapiRequest("/api/cloud/upload/check", {
            data: {
              ext: "",
              bitrate: String(bitrate),
              md5: fileMd5,
              length: file.size,
              songId: "0",
              version: 1
            }
          });
          console.log("检查文件是否存在，checkRes", checkRes);
          if (checkRes.code != 200) {
            msgError("文件检查失败：" + checkRes.message || checkRes.msg || "");
            throw new Error(checkRes.message || checkRes.msg || "文件检查失败");
          }
          const { needUpload, songId } = checkRes;
          if (needUpload) {
            console.log("检测到云盘没有该文件，需要上传文件");
            const uploadTokenRes = await weapiRequest("/api/nos/token/alloc", {
              data: {
                bucket: BUCKET,
                ext,
                filename,
                local: false,
                nos_product: 3,
                type: "audio",
                md5: fileMd5
              }
            });
            if (uploadTokenRes.code !== 200) {
              msgError("上传授权失败");
              throw new Error(uploadTokenRes.message || "上传授权失败");
            }
            console.log("获取到上传授权，uploadTokenRes", uploadTokenRes);
            await uploadAudioToNos({
              file,
              bucket: BUCKET,
              objectKey: uploadTokenRes.result.objectKey,
              token: uploadTokenRes.result.token,
              fileMd5,
              contentType: contentType2
            });
            console.log("上传文件成功");
          }
          const tokenRes = await weapiRequest("/api/nos/token/alloc", {
            data: {
              bucket: "",
              ext,
              filename,
              local: false,
              nos_product: 3,
              type: "audio",
              md5: fileMd5
            }
          });
          console.log("申请上传token，tokenRes", tokenRes);
          if (tokenRes.code != 200) {
            msgError("获取上传token失败");
            throw new Error(tokenRes.message || tokenRes.msg || "获取上传token失败");
          }
          const { bucket, docId, objectKey, outerUrl, resourceId, token } = tokenRes.result;
          const {
            album = defaultAlbum,
            artist = defaultArtist,
            artists = defaultArtists,
            title = defaultTitle
          } = await getAudioMetadata(file);
          defaultResult = {
            ...defaultResult,
            artist,
            artists,
            album,
            md5: fileMd5,
            ext,
            bitrate
          };
          const uploadInfoRes = await weapiRequest("/api/upload/cloud/info/v2", {
            data: {
              md5: fileMd5,
              songid: songId,
              filename: file.name,
              song: title || filename,
              album: album || "未知专辑",
              artist: artist || artists.join(",") || "未知歌手",
              bitrate: String(bitrate),
              resourceId
            }
          });
          console.log("获取上传信息，uploadInfoRes", uploadInfoRes);
          defaultResult = {
            ...defaultResult,
            id: uploadInfoRes.songId
          };
          if (uploadInfoRes.code != 200) {
            msgError("获取上传信息失败");
            throw new Error(uploadInfoRes.message || uploadInfoRes.msg || "获取上传信息失败");
          }
          const pubRes = await weapiRequest("/api/cloud/pub/v2", {
            data: {
              songid: uploadInfoRes.songId
            }
          });
          console.log("发布资源，pubRes", pubRes);
          if (![200, 201].includes(pubRes.code)) {
            msgError(`歌曲： ${file.name} 发布失败`);
            throw new Error(pubRes.message || pubRes.msg || "歌曲发布失败");
          }
          const { songName, bitrate: realBitrate, fileSize } = pubRes.privateCloud;
          defaultResult = {
            ...defaultResult,
            name: songName,
            size: fileSize,
            bitrate: realBitrate
          };
          return defaultResult;
        } catch (error) {
          console.log("error", error);
          throw error;
        }
      };
      const mapToList = (map) => {
        return Object.entries(map).map(([key, value]) => ({
          label: key,
          value
        }));
      };
      const Area = {
        全部: -100,
        内地: 200,
        港台: 2,
        欧美: 5,
        日本: 4,
        韩国: 3,
        其他: 6
      };
      const AreaList = mapToList(Area);
      const Genre = {
        全部: -100,
        流行: 1,
        嘻哈: 6,
        摇滚: 2,
        电子: 4,
        民谣: 3,
        "R&B": 8,
        民歌: 10,
        轻音乐: 9,
        爵士: 5,
        古典: 14,
        乡村: 25,
        蓝调: 20
      };
      const GenreList = mapToList(Genre);
      const Sex = {
        全部: -100,
        男: 0,
        女: 1,
        组合: 2
      };
      const SexList = mapToList(Sex);
      const getCommonParams = () => ({
        g_tk: 1124214810,
        loginUin: getCookie("uin") || "0",
        hostUin: 0,
        inCharset: "utf8",
        outCharset: "utf-8",
        // format: 'json',
        notice: 0,
        platform: "yqq.json",
        needNewCode: 0
      });
      const _guid = Math.round(2147483647 * Math.random()) * (/* @__PURE__ */ new Date()).getUTCMilliseconds() % 1e10;
      const FileType = {
        m4a: {
          s: "C400",
          e: ".m4a"
        },
        128: {
          s: "M500",
          e: ".mp3"
        },
        320: {
          s: "M800",
          e: ".mp3"
        },
        ape: {
          s: "A000",
          e: ".ape"
        },
        flac: {
          s: "F000",
          e: ".flac"
        }
      };
      const ResourceType = {
        歌曲: "song",
        专辑: "album",
        视频: "mv",
        歌单: "playlist",
        歌手: "user",
        歌词: "lyric"
      };
      const FlacTag = {
        标题: "title",
        艺术家: "artist",
        专辑: "album",
        年份: "year",
        流派: "genre",
        评论: "comment",
        音轨: "track",
        碟片: "disc",
        作曲家: "composer",
        作词家: "lyricist",
        歌词: "lyrics"
      };
      mapToList(FlacTag);
      const FLAC_TAGS = Object.entries(FlacTag).reduce(
        (acc, [key, value]) => {
          acc[value] = key;
          return acc;
        },
        {}
      );
      const getSongInfo = async (songmid, options = {}) => {
        const { songid = "" } = options;
        const params = {
          ...getCommonParams(),
          format: "json",
          inCharset: "utf8",
          outCharset: "utf-8",
          notice: 0,
          platform: "yqq.json",
          needNewCode: 0,
          data: JSON.stringify({
            comm: {
              ct: 24,
              cv: 0
            },
            songinfo: {
              method: "get_song_detail_yqq",
              param: {
                song_type: 0,
                song_mid: songmid,
                song_id: songid
              },
              module: "music.pf_song_detail_svr"
            }
          })
        };
        const res = await qqMusicRequest(
          `/cgi-bin/musicu.fcg?${new URLSearchParams(params).toString()}`,
          {},
          "u"
        );
        if (res.code === 0) {
          return res.songinfo?.data;
        }
        throw new Error("获取歌曲信息失败");
      };
      const getSongLyric = async (songmid) => {
        const params = {
          songmid,
          format: "json",
          outCharset: "utf-8",
          pcachetime: dayjs().valueOf()
        };
        const res = await qqMusicRequest(
          `/lyric/fcgi-bin/fcg_query_lyric_new.fcg?${new URLSearchParams(params)}`,
          {}
        );
        if (res.code === 0) {
          const lyric = window.atob(res.lyric);
          const bytes = Uint8Array.from(lyric, (c) => c.charCodeAt(0));
          const decoder = new TextDecoder();
          const decodedText = decoder.decode(bytes);
          return decodedText;
        }
        throw new Error("获取歌曲歌词失败");
      };
      const getSongPlayUrl = async (songmid, options = {}) => {
        const { quality = "flac" } = options;
        const songmidList = Array.isArray(songmid) ? songmid : [songmid];
        const fileInfo = FileType[quality];
        const fileNames = songmidList.map((item, index2) => `${fileInfo.s}${item}${item}${fileInfo.e}`);
        const uin = getCookie("uin");
        const params = {
          format: "json",
          sign: "zzannc1o6o9b4i971602f3554385022046ab796512b7012",
          data: JSON.stringify({
            req_0: {
              module: "vkey.GetVkeyServer",
              method: "CgiGetVkey",
              param: {
                filename: fileNames,
                guid: _guid + "",
                songmid: songmidList,
                songtype: [0],
                uin,
                loginflag: 1,
                platform: "20"
              }
            },
            loginUin: uin,
            comm: {
              uin,
              format: "json",
              ct: 24,
              cv: 0
            }
          })
        };
        const res = await qqMusicRequest(
          `/cgi-bin/musicu.fcg?${new URLSearchParams(params)}`,
          {},
          "u"
        );
        console.log("res", res);
        if (res.code === 0) {
          const data = res.req_0.data;
          const domain = data.sip?.find((i) => !i.startsWith("http://ws")) || data.sip[0];
          let playUrl = {};
          data.midurlinfo.forEach((item) => {
            playUrl[item.songmid] = {
              url: item.purl ? `${domain}${item.purl}` : "",
              error: !item.purl && "暂无播放链接"
            };
          });
          return playUrl;
        }
        throw new Error("获取歌曲播放链接失败");
      };
      function stringToBytes(str, encoding = "utf8") {
        if (encoding === "utf8") {
          const utf8 = unescape(encodeURIComponent(str));
          const bytes = new Uint8Array(utf8.length);
          for (let i = 0; i < utf8.length; i++) {
            bytes[i] = utf8.charCodeAt(i);
          }
          return bytes;
        } else if (encoding === "ascii") {
          const bytes = new Uint8Array(str.length);
          for (let i = 0; i < str.length; i++) {
            bytes[i] = str.charCodeAt(i) & 255;
          }
          return bytes;
        } else if (encoding === "hex") {
          const bytes = new Uint8Array(str.length / 2);
          for (let i = 0; i < str.length; i += 2) {
            bytes[i / 2] = parseInt(str.substr(i, 2), 16);
          }
          return bytes;
        }
        throw new Error(`Unsupported encoding: ${encoding}`);
      }
      function bytesToString(bytes, encoding = "utf8") {
        if (encoding === "utf8") {
          let str = "";
          for (let i = 0; i < bytes.length; i++) {
            str += String.fromCharCode(bytes[i]);
          }
          try {
            return decodeURIComponent(escape(str));
          } catch (e) {
            return str;
          }
        } else if (encoding === "ascii") {
          let str = "";
          for (let i = 0; i < bytes.length; i++) {
            str += String.fromCharCode(bytes[i] & 255);
          }
          return str;
        } else if (encoding === "hex") {
          let hex = "";
          for (let i = 0; i < bytes.length; i++) {
            const h = bytes[i].toString(16);
            hex += h.length === 1 ? "0" + h : h;
          }
          return hex;
        }
        throw new Error(`Unsupported encoding: ${encoding}`);
      }
      class BrowserBuffer {
        constructor(data, byteOffset, length) {
          if (typeof data === "number") {
            this._data = new Uint8Array(data);
            this._view = new DataView(this._data.buffer);
          } else if (data instanceof Uint8Array) {
            this._data = data;
            this._view = new DataView(this._data.buffer, data.byteOffset, data.byteLength);
          } else if (typeof data === "string") {
            const encoding = byteOffset || "utf8";
            this._data = stringToBytes(data, encoding);
            this._view = new DataView(this._data.buffer);
          } else if (data instanceof ArrayBuffer) {
            const offset = byteOffset || 0;
            const len = length !== void 0 ? length : data.byteLength - offset;
            this._data = new Uint8Array(data, offset, len);
            this._view = new DataView(data, offset, len);
          } else if (data instanceof BrowserBuffer) {
            this._data = data._data;
            this._view = data._view;
          } else if (Array.isArray(data)) {
            this._data = new Uint8Array(data);
            this._view = new DataView(this._data.buffer);
          } else if (data === void 0) {
            this._data = new Uint8Array(0);
            this._view = new DataView(this._data.buffer);
          } else {
            this._data = new Uint8Array(data);
            this._view = new DataView(this._data.buffer);
          }
        }
        /**
         * 读取无符号 8 位整数
         */
        readUInt8(offset) {
          return this._view.getUint8(offset);
        }
        /**
         * 读取无符号 16 位整数（大端序）
         */
        readUInt16BE(offset) {
          return this._view.getUint16(offset, false);
        }
        /**
         * 读取无符号 16 位整数（小端序）
         */
        readUInt16LE(offset) {
          return this._view.getUint16(offset, true);
        }
        /**
         * 读取无符号 32 位整数（大端序）
         */
        readUInt32BE(offset) {
          return this._view.getUint32(offset, false);
        }
        /**
         * 读取无符号 32 位整数（小端序）
         */
        readUInt32LE(offset) {
          return this._view.getUint32(offset, true);
        }
        /**
         * 读取无符号整数（大端序，可变长度）
         */
        readUIntBE(offset, byteLength) {
          let value = 0;
          for (let i = 0; i < byteLength; i++) {
            value = (value << 8) + this._view.getUint8(offset + i);
          }
          return value;
        }
        /**
         * 写入无符号 8 位整数
         */
        writeUInt8(value, offset) {
          this._view.setUint8(offset, value);
        }
        /**
         * 写入无符号 16 位整数（大端序）
         */
        writeUInt16BE(value, offset) {
          this._view.setUint16(offset, value, false);
        }
        /**
         * 写入无符号 32 位整数（大端序）
         */
        writeUInt32BE(value, offset) {
          this._view.setUint32(offset, value, false);
        }
        /**
         * 写入无符号 32 位整数（小端序）
         */
        writeUInt32LE(value, offset) {
          this._view.setUint32(offset, value, true);
        }
        /**
         * 写入无符号整数（大端序，可变长度）
         */
        writeUIntBE(value, offset, byteLength) {
          for (let i = byteLength - 1; i >= 0; i--) {
            this._view.setUint8(offset + i, value & 255);
            value = value >> 8;
          }
        }
        /**
         * 转换为字符串
         */
        toString(encoding = "utf8") {
          return bytesToString(this._data, encoding);
        }
        /**
         * 切片
         */
        slice(start, end) {
          const sliced = this._data.slice(start, end);
          return new BrowserBuffer(sliced);
        }
        /**
         * 获取长度
         */
        get length() {
          return this._data.length;
        }
        /**
         * 获取底层 ArrayBuffer
         */
        get buffer() {
          return this._data.buffer;
        }
        /**
         * 转换为 Uint8Array
         */
        toUint8Array() {
          return new Uint8Array(this._data);
        }
        /**
         * 转换为 ArrayBuffer
         */
        toArrayBuffer() {
          const buf = this.buffer;
          if (typeof SharedArrayBuffer !== "undefined" && buf instanceof SharedArrayBuffer) {
            throw new Error("Cannot convert SharedArrayBuffer to ArrayBuffer");
          }
          return buf.slice(
            this._data.byteOffset,
            this._data.byteOffset + this._data.byteLength
          );
        }
        /**
         * 创建指定大小的 Buffer
         */
        static alloc(size) {
          return new BrowserBuffer(size);
        }
        /**
         * 从数据创建 Buffer
         */
        static from(data, encoding) {
          if (data instanceof BrowserBuffer) {
            return data;
          }
          if (data instanceof Uint8Array) {
            return new BrowserBuffer(data);
          }
          if (data instanceof ArrayBuffer) {
            return new BrowserBuffer(data);
          }
          if (typeof data === "string") {
            return new BrowserBuffer(data, encoding);
          }
          if (Array.isArray(data)) {
            return new BrowserBuffer(new Uint8Array(data));
          }
          throw new Error("Unsupported data type");
        }
        /**
         * 连接多个 Buffer
         */
        static concat(buffers) {
          let totalLength = 0;
          for (let i = 0; i < buffers.length; i++) {
            totalLength += buffers[i].length;
          }
          const result = new Uint8Array(totalLength);
          let offset = 0;
          for (let i = 0; i < buffers.length; i++) {
            const buf = buffers[i];
            if (buf instanceof BrowserBuffer) {
              result.set(buf._data, offset);
              offset += buf.length;
            } else if (buf instanceof Uint8Array) {
              result.set(buf, offset);
              offset += buf.length;
            }
          }
          return new BrowserBuffer(result);
        }
      }
      function detectImageType(data) {
        let bytes;
        if (data instanceof Uint8Array) {
          bytes = data;
        } else if (data instanceof ArrayBuffer) {
          bytes = new Uint8Array(data);
        } else if (data instanceof BrowserBuffer) {
          bytes = data.toUint8Array();
        } else {
          bytes = new Uint8Array(data);
        }
        if (bytes.length >= 3 && bytes[0] === 255 && bytes[1] === 216 && bytes[2] === 255) {
          return { mime: "image/jpeg" };
        }
        if (bytes.length >= 8 && bytes[0] === 137 && bytes[1] === 80 && bytes[2] === 78 && bytes[3] === 71 && bytes[4] === 13 && bytes[5] === 10 && bytes[6] === 26 && bytes[7] === 10) {
          return { mime: "image/png" };
        }
        if (bytes.length >= 4 && bytes[0] === 71 && bytes[1] === 73 && bytes[2] === 70 && bytes[3] === 56) {
          return { mime: "image/gif" };
        }
        if (bytes.length >= 12 && bytes[0] === 82 && bytes[1] === 73 && bytes[2] === 70 && bytes[3] === 70 && bytes[8] === 87 && bytes[9] === 69 && bytes[10] === 66 && bytes[11] === 80) {
          return { mime: "image/webp" };
        }
        throw new Error("Unsupported image type");
      }
      function parseJpegSize(bytes) {
        let offset = 2;
        while (offset < bytes.length) {
          if (bytes[offset] !== 255) {
            offset++;
            continue;
          }
          const marker = bytes[offset + 1];
          if (marker >= 192 && marker <= 195) {
            const height = bytes[offset + 5] << 8 | bytes[offset + 6];
            const width = bytes[offset + 7] << 8 | bytes[offset + 8];
            return { width, height };
          }
          if (marker === 216 || marker === 217) {
            offset += 2;
          } else if (marker >= 208 && marker <= 215) {
            offset += 2;
          } else {
            const length = bytes[offset + 2] << 8 | bytes[offset + 3];
            offset += 2 + length;
          }
        }
        throw new Error("Could not determine JPEG dimensions");
      }
      function parsePngSize(bytes) {
        if (bytes.length < 24) {
          throw new Error("Invalid PNG file");
        }
        const width = bytes[16] << 24 | bytes[17] << 16 | bytes[18] << 8 | bytes[19];
        const height = bytes[20] << 24 | bytes[21] << 16 | bytes[22] << 8 | bytes[23];
        return { width, height };
      }
      function getImageSize(data) {
        let bytes;
        if (data instanceof Uint8Array) {
          bytes = data;
        } else if (data instanceof ArrayBuffer) {
          bytes = new Uint8Array(data);
        } else if (data instanceof BrowserBuffer) {
          bytes = data.toUint8Array();
        } else {
          bytes = new Uint8Array(data);
        }
        const type = detectImageType(bytes);
        if (type.mime === "image/jpeg") {
          return parseJpegSize(bytes);
        } else if (type.mime === "image/png") {
          return parsePngSize(bytes);
        } else {
          throw new Error(`Unsupported image type: ${type.mime}`);
        }
      }
      function formatVorbisComment(vendorString, commentList) {
        const bufferArray = [];
        const vendorStringBuffer = BrowserBuffer.from(vendorString, "utf8");
        const vendorLengthBuffer = BrowserBuffer.alloc(4);
        vendorLengthBuffer.writeUInt32LE(vendorStringBuffer.length, 0);
        const userCommentListLengthBuffer = BrowserBuffer.alloc(4);
        userCommentListLengthBuffer.writeUInt32LE(commentList.length, 0);
        bufferArray.push(vendorLengthBuffer, vendorStringBuffer, userCommentListLengthBuffer);
        for (let i = 0; i < commentList.length; i++) {
          const comment = commentList[i];
          const commentBuffer = BrowserBuffer.from(comment, "utf8");
          const lengthBuffer = BrowserBuffer.alloc(4);
          lengthBuffer.writeUInt32LE(commentBuffer.length, 0);
          bufferArray.push(lengthBuffer, commentBuffer);
        }
        return BrowserBuffer.concat(bufferArray);
      }
      const STREAMINFO = 0;
      const PADDING = 1;
      const APPLICATION = 2;
      const SEEKTABLE = 3;
      const VORBIS_COMMENT = 4;
      const CUESHEET = 5;
      const PICTURE = 6;
      async function toBrowserBuffer(data) {
        if (data instanceof BrowserBuffer) {
          return data;
        }
        if (data instanceof Uint8Array) {
          return new BrowserBuffer(data);
        }
        if (data instanceof ArrayBuffer) {
          return new BrowserBuffer(data);
        }
        if (data instanceof File || data instanceof Blob) {
          const arrayBuffer = await data.arrayBuffer();
          return new BrowserBuffer(arrayBuffer);
        }
        throw new Error(
          "Unsupported data type. Expected ArrayBuffer, Uint8Array, File, Blob, or BrowserBuffer."
        );
      }
      class Metaflac {
        /**
         * 创建 Metaflac 实例
         * @param flac - FLAC 文件数据
         */
        constructor(flac) {
          this.buffer = null;
          this.streamInfo = null;
          this.blocks = [];
          this.padding = null;
          this.vorbisComment = null;
          this.vendorString = "";
          this.tags = [];
          this.pictures = [];
          this.picturesSpecs = [];
          this.picturesDatas = [];
          this.framesOffset = 0;
          if (flac instanceof File || flac instanceof Blob) {
            throw new Error(
              "File and Blob objects must be loaded asynchronously. Use Metaflac.fromFile() or Metaflac.fromBlob() instead."
            );
          }
          this.flac = flac;
          this.init();
        }
        /**
         * 从 File 对象创建 Metaflac 实例（异步）
         * @param file - File 对象
         * @returns Promise<Metaflac>
         */
        static async fromFile(file) {
          const buffer = await toBrowserBuffer(file);
          return new Metaflac(buffer);
        }
        /**
         * 从 Blob 对象创建 Metaflac 实例（异步）
         * @param blob - Blob 对象
         * @returns Promise<Metaflac>
         */
        static async fromBlob(blob) {
          const buffer = await toBrowserBuffer(blob);
          return new Metaflac(buffer);
        }
        /**
         * 从 ArrayBuffer 创建 Metaflac 实例
         * @param arrayBuffer - ArrayBuffer 对象
         * @returns Metaflac
         */
        static fromArrayBuffer(arrayBuffer) {
          return new Metaflac(arrayBuffer);
        }
        /**
         * 从 Uint8Array 创建 Metaflac 实例
         * @param uint8Array - Uint8Array 对象
         * @returns Metaflac
         */
        static fromUint8Array(uint8Array) {
          return new Metaflac(uint8Array);
        }
        init() {
          if (this.flac instanceof BrowserBuffer) {
            this.buffer = this.flac;
          } else if (this.flac instanceof Uint8Array) {
            this.buffer = new BrowserBuffer(this.flac);
          } else if (this.flac instanceof ArrayBuffer) {
            this.buffer = new BrowserBuffer(this.flac);
          } else {
            throw new Error("Metaflac(flac) flac must be ArrayBuffer, Uint8Array, or BrowserBuffer.");
          }
          let offset = 0;
          const marker = this.buffer.slice(0, offset += 4).toString("ascii");
          if (marker !== "fLaC") {
            throw new Error("The file does not appear to be a FLAC file.");
          }
          let blockType = 0;
          let isLastBlock = false;
          while (!isLastBlock) {
            blockType = this.buffer.readUInt8(offset++);
            isLastBlock = blockType > 128;
            blockType = blockType % 128;
            const blockLength = this.buffer.readUIntBE(offset, 3);
            offset += 3;
            if (blockType === STREAMINFO) {
              this.streamInfo = this.buffer.slice(offset, offset + blockLength);
            }
            if (blockType === PADDING) {
              this.padding = this.buffer.slice(offset, offset + blockLength);
            }
            if (blockType === VORBIS_COMMENT) {
              this.vorbisComment = this.buffer.slice(offset, offset + blockLength);
              this.parseVorbisComment();
            }
            if (blockType === PICTURE) {
              this.pictures.push(this.buffer.slice(offset, offset + blockLength));
              this.parsePictureBlock();
            }
            if ([APPLICATION, SEEKTABLE, CUESHEET].includes(blockType)) {
              this.blocks.push([blockType, this.buffer.slice(offset, offset + blockLength)]);
            }
            offset += blockLength;
          }
          this.framesOffset = offset;
        }
        parseVorbisComment() {
          if (!this.vorbisComment) {
            return;
          }
          const vendorLength = this.vorbisComment.readUInt32LE(0);
          this.vendorString = this.vorbisComment.slice(4, vendorLength + 4).toString("utf8");
          this.vorbisComment.readUInt32LE(4 + vendorLength);
          const userCommentListBuffer = this.vorbisComment.slice(4 + vendorLength + 4);
          for (let offset = 0; offset < userCommentListBuffer.length; ) {
            const length = userCommentListBuffer.readUInt32LE(offset);
            offset += 4;
            const comment = userCommentListBuffer.slice(offset, offset + length).toString("utf8");
            offset += length;
            this.tags.push(comment);
          }
        }
        parsePictureBlock() {
          this.pictures.forEach((picture) => {
            let offset = 0;
            const type = picture.readUInt32BE(offset);
            offset += 4;
            const mimeTypeLength = picture.readUInt32BE(offset);
            offset += 4;
            const mime = picture.slice(offset, offset + mimeTypeLength).toString("ascii");
            offset += mimeTypeLength;
            const descriptionLength = picture.readUInt32BE(offset);
            offset += 4;
            const description = picture.slice(offset, offset + descriptionLength).toString("utf8");
            offset += descriptionLength;
            const width = picture.readUInt32BE(offset);
            offset += 4;
            const height = picture.readUInt32BE(offset);
            offset += 4;
            const depth = picture.readUInt32BE(offset);
            offset += 4;
            const colors = picture.readUInt32BE(offset);
            offset += 4;
            const pictureDataLength = picture.readUInt32BE(offset);
            offset += 4;
            this.picturesDatas.push(picture.slice(offset, offset + pictureDataLength));
            this.picturesSpecs.push(
              this.buildSpecification({
                type,
                mime,
                description,
                width,
                height,
                depth,
                colors
              })
            );
          });
        }
        /**
         * 获取所有图片规格
         * @returns 图片规格数组
         */
        getPicturesSpecs() {
          return this.picturesSpecs;
        }
        /**
         * Get the MD5 signature from the STREAMINFO block.
         */
        getMd5sum() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return this.streamInfo.slice(18, 34).toString("hex");
        }
        /**
         * Get the minimum block size from the STREAMINFO block.
         */
        getMinBlocksize() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return this.streamInfo.readUInt16BE(0);
        }
        /**
         * Get the maximum block size from the STREAMINFO block.
         */
        getMaxBlocksize() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return this.streamInfo.readUInt16BE(2);
        }
        /**
         * Get the minimum frame size from the STREAMINFO block.
         */
        getMinFramesize() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return this.streamInfo.readUIntBE(4, 3);
        }
        /**
         * Get the maximum frame size from the STREAMINFO block.
         */
        getMaxFramesize() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return this.streamInfo.readUIntBE(7, 3);
        }
        /**
         * Get the sample rate from the STREAMINFO block.
         */
        getSampleRate() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return this.streamInfo.readUIntBE(10, 3) >> 4;
        }
        /**
         * Get the number of channels from the STREAMINFO block.
         */
        getChannels() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return (this.streamInfo.readUIntBE(10, 3) & 15) >> 1;
        }
        /**
         * Get the # of bits per sample from the STREAMINFO block.
         */
        getBps() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return (this.streamInfo.readUIntBE(12, 2) & 496) >> 4;
        }
        /**
         * Get the total # of samples from the STREAMINFO block.
         */
        getTotalSamples() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          return this.streamInfo.readUIntBE(13, 5) & 68719476735;
        }
        /**
         * Show the vendor string from the VORBIS_COMMENT block.
         */
        getVendorTag() {
          return this.vendorString;
        }
        /**
         * Get all tags where the the field name matches NAME.
         *
         * @param name - 标签名称
         * @returns 匹配的标签字符串（多个用换行符分隔）
         */
        getTag(name2) {
          return this.tags.filter((item) => {
            const itemName = item.split("=")[0];
            return itemName === name2;
          }).join("\n");
        }
        /**
         * Remove all tags whose field name is NAME.
         *
         * @param name - 标签名称
         */
        removeTag(name2) {
          this.tags = this.tags.filter((item) => {
            const itemName = item.split("=")[0];
            return itemName !== name2;
          });
        }
        /**
         * Remove first tag whose field name is NAME.
         *
         * @param name - 标签名称
         */
        removeFirstTag(name2) {
          const found = this.tags.findIndex((item) => {
            return item.split("=")[0] === name2;
          });
          if (found !== -1) {
            this.tags.splice(found, 1);
          }
        }
        /**
         * Remove all tags, leaving only the vendor string.
         */
        removeAllTags() {
          this.tags = [];
        }
        /**
         * Add a tag.
         * The FIELD must comply with the Vorbis comment spec, of the form NAME=VALUE. If there is currently no tag block, one will be created.
         *
         * @param field - 标签字段，格式为 NAME=VALUE
         */
        setTag(field) {
          if (field.indexOf("=") === -1) {
            throw new Error(`malformed vorbis comment field "${field}", field contains no '=' character`);
          }
          this.tags.push(field);
        }
        /**
         * Import tags from a string.
         * Each line should be of the form NAME=VALUE.
         *
         * @param tagsString - 标签字符串，每行一个标签
         */
        importTagsFromString(tagsString) {
          const tags = tagsString.split("\n").filter((line) => line.trim());
          tags.forEach((line) => {
            if (line.indexOf("=") === -1) {
              throw new Error(`malformed vorbis comment "${line}", contains no '=' character`);
            }
          });
          this.tags = this.tags.concat(tags);
        }
        /**
         * Export tags to a string.
         * Each line will be of the form NAME=VALUE.
         *
         * @returns 标签字符串
         */
        exportTagsToString() {
          return this.tags.join("\n");
        }
        /**
         * Import a picture and store it in a PICTURE metadata block.
         *
         * @param picture - 图片数据
         */
        importPictureFromBuffer(picture) {
          let pictureBuffer;
          if (picture instanceof BrowserBuffer) {
            pictureBuffer = picture;
          } else if (picture instanceof Uint8Array) {
            pictureBuffer = new BrowserBuffer(picture);
          } else if (picture instanceof ArrayBuffer) {
            pictureBuffer = new BrowserBuffer(picture);
          } else {
            throw new Error("Picture must be Uint8Array, ArrayBuffer, or BrowserBuffer");
          }
          const pictureArray = pictureBuffer.toUint8Array();
          const { mime } = detectImageType(pictureArray);
          if (mime !== "image/jpeg" && mime !== "image/png") {
            throw new Error(
              `only support image/jpeg and image/png picture temporarily, current import ${mime}`
            );
          }
          const dimensions = getImageSize(pictureArray);
          const spec = this.buildSpecification({
            mime,
            width: dimensions.width,
            height: dimensions.height
          });
          this.pictures.push(this.buildPictureBlock(pictureBuffer, spec));
          this.picturesSpecs.push(spec);
          this.picturesDatas.push(pictureBuffer);
        }
        /**
         * Import a picture from File or Blob (async).
         *
         * @param file - 图片文件
         * @returns Promise<void>
         */
        async importPictureFromFile(file) {
          const arrayBuffer = await file.arrayBuffer();
          this.importPictureFromBuffer(arrayBuffer);
        }
        /**
         * Export PICTURE block to a Blob.
         *
         * @param index - 图片索引，默认为 0
         * @returns Blob
         */
        exportPictureToBlob(index2 = 0) {
          if (this.picturesDatas.length > index2) {
            const pictureData = this.picturesDatas[index2];
            const spec = this.picturesSpecs[index2];
            return new Blob([pictureData.toArrayBuffer()], { type: spec.mime });
          }
          throw new Error(`Picture index ${index2} does not exist`);
        }
        /**
         * Export PICTURE block to ArrayBuffer.
         *
         * @param index - 图片索引，默认为 0
         * @returns ArrayBuffer
         */
        exportPictureToArrayBuffer(index2 = 0) {
          if (this.picturesDatas.length > index2) {
            return this.picturesDatas[index2].toArrayBuffer();
          }
          throw new Error(`Picture index ${index2} does not exist`);
        }
        /**
         * Remove a picture at the specified index.
         *
         * @param index - 图片索引，默认为 0
         */
        removePicture(index2 = 0) {
          if (this.pictures.length > index2) {
            this.pictures.splice(index2, 1);
            this.picturesSpecs.splice(index2, 1);
            this.picturesDatas.splice(index2, 1);
          } else {
            throw new Error(`Picture index ${index2} does not exist`);
          }
        }
        /**
         * Remove all pictures.
         */
        removeAllPictures() {
          this.pictures = [];
          this.picturesSpecs = [];
          this.picturesDatas = [];
        }
        /**
         * Return all tags.
         */
        getAllTags() {
          return this.tags;
        }
        buildSpecification(spec = {}) {
          const defaults = {
            type: 3,
            mime: "image/jpeg",
            description: "",
            width: 0,
            height: 0,
            depth: 24,
            colors: 0
          };
          return Object.assign(defaults, spec);
        }
        /**
         * Build a picture block.
         *
         * @param picture - 图片数据
         * @param specification - 图片规格
         * @returns BrowserBuffer
         */
        buildPictureBlock(picture, specification) {
          const pictureType = BrowserBuffer.alloc(4);
          const mimeLength = BrowserBuffer.alloc(4);
          const mime = BrowserBuffer.from(specification.mime, "ascii");
          const descriptionLength = BrowserBuffer.alloc(4);
          const description = BrowserBuffer.from(specification.description, "utf8");
          const width = BrowserBuffer.alloc(4);
          const height = BrowserBuffer.alloc(4);
          const depth = BrowserBuffer.alloc(4);
          const colors = BrowserBuffer.alloc(4);
          const pictureLength = BrowserBuffer.alloc(4);
          pictureType.writeUInt32BE(specification.type, 0);
          mimeLength.writeUInt32BE(specification.mime.length, 0);
          descriptionLength.writeUInt32BE(specification.description.length, 0);
          width.writeUInt32BE(specification.width, 0);
          height.writeUInt32BE(specification.height, 0);
          depth.writeUInt32BE(specification.depth, 0);
          colors.writeUInt32BE(specification.colors, 0);
          pictureLength.writeUInt32BE(picture.length, 0);
          return BrowserBuffer.concat([
            pictureType,
            mimeLength,
            mime,
            descriptionLength,
            description,
            width,
            height,
            depth,
            colors,
            pictureLength,
            picture
          ]);
        }
        buildMetadataBlock(type, block, isLast = false) {
          const header = BrowserBuffer.alloc(4);
          if (isLast) {
            type += 128;
          }
          header.writeUIntBE(type, 0, 1);
          header.writeUIntBE(block.length, 1, 3);
          return BrowserBuffer.concat([header, block]);
        }
        buildMetadata() {
          if (!this.streamInfo) {
            throw new Error("StreamInfo is not available");
          }
          const bufferArray = [];
          bufferArray.push(this.buildMetadataBlock(STREAMINFO, this.streamInfo));
          this.blocks.forEach((block) => {
            bufferArray.push(this.buildMetadataBlock(...block));
          });
          bufferArray.push(
            this.buildMetadataBlock(VORBIS_COMMENT, formatVorbisComment(this.vendorString, this.tags))
          );
          this.pictures.forEach((block) => {
            bufferArray.push(this.buildMetadataBlock(PICTURE, block));
          });
          const padding = this.padding || BrowserBuffer.alloc(4);
          bufferArray.push(this.buildMetadataBlock(PADDING, padding, true));
          return bufferArray;
        }
        buildStream() {
          if (!this.buffer) {
            throw new Error("Buffer is not available");
          }
          const metadata = this.buildMetadata();
          return [this.buffer.slice(0, 4), ...metadata, this.buffer.slice(this.framesOffset)];
        }
        /**
         * Save changes and return ArrayBuffer.
         *
         * @returns ArrayBuffer
         */
        save() {
          const stream = this.buildStream();
          const result = BrowserBuffer.concat(stream);
          return result.toArrayBuffer();
        }
        /**
         * Save changes and return Blob.
         *
         * @returns Blob
         */
        saveAsBlob() {
          const arrayBuffer = this.save();
          return new Blob([arrayBuffer], { type: "audio/flac" });
        }
        /**
         * Save changes and return BrowserBuffer.
         *
         * @returns BrowserBuffer
         */
        saveAsBuffer() {
          const stream = this.buildStream();
          return BrowserBuffer.concat(stream);
        }
      }
      const parseTags = (tags) => {
        const result = {};
        tags.forEach((tag) => {
          const equalIndex = tag.indexOf("=");
          if (equalIndex === -1) return;
          const name2 = tag.substring(0, equalIndex).toLowerCase();
          const value = tag.substring(equalIndex + 1);
          if (result[name2]) {
            result[name2] = result[name2] + "\n" + value;
          } else {
            result[name2] = value;
          }
        });
        return result;
      };
      const readAllFlacTag = async (file) => {
        try {
          const metaflac = await Metaflac.fromBlob(file);
          const tags = metaflac.getAllTags();
          const parsedTags = parseTags(tags);
          console.log("解析后的标签:", parsedTags);
          return parsedTags;
        } catch (error) {
          console.error("读取 FLAC 标签失败:", error);
          return {};
        }
      };
      const readFlacTag = async (file, tagName) => {
        try {
          const metaflac = await Metaflac.fromBlob(file);
          const tagString = metaflac.getTag(tagName.toUpperCase());
          if (!tagString) {
            return void 0;
          }
          const lines = tagString.split("\n");
          if (lines.length > 0) {
            const equalIndex = lines[0].indexOf("=");
            if (equalIndex !== -1) {
              return lines[0].substring(equalIndex + 1);
            }
          }
          return void 0;
        } catch (error) {
          console.error(`读取 FLAC 标签 ${tagName} 失败:`, error);
          return void 0;
        }
      };
      const writeFlacTag = async (file, tagName, tagValue) => {
        try {
          const metaflac = await Metaflac.fromBlob(file);
          metaflac.removeTag(tagName.toUpperCase());
          metaflac.setTag(`${tagName.toUpperCase()}=${tagValue}`);
          const newBlob = metaflac.saveAsBlob();
          console.log("给 FLAC 写标签成功");
          return newBlob;
        } catch (error) {
          console.error("给 FLAC 写标签失败:", error);
          throw new Error("给 FLAC 写标签失败");
        }
      };
      const readFlacPictures = async (file) => {
        try {
          const metaflac = await Metaflac.fromBlob(file);
          const pictures = metaflac.getPicturesSpecs?.() || [];
          return pictures.map((_, index2) => metaflac.exportPictureToBlob(index2));
        } catch (error) {
          console.error("读取 FLAC 封面图片失败:", error);
          return [];
        }
      };
      const embedFlacPicture = async (file, picture) => {
        try {
          const metaflac = await Metaflac.fromBlob(file);
          await metaflac.importPictureFromFile(picture);
          const newBlob = metaflac.saveAsBlob();
          console.log("给 FLAC 嵌入图片成功");
          return newBlob;
        } catch (error) {
          console.error("给 FLAC 嵌入图片失败:", error);
          return file;
        }
      };
      const writeFlacTagAndPicture = async (file, tagName, tagValue, picture) => {
        try {
          const metaflac = await Metaflac.fromBlob(file);
          console.log("metaflac", metaflac, metaflac.getAllTags());
          if (tagName && tagValue) {
            metaflac.removeTag(tagName.toUpperCase());
            metaflac.setTag(`${tagName.toUpperCase()}=${tagValue}`);
          }
          if (picture) {
            await metaflac.importPictureFromFile(picture);
          }
          const outputFile = metaflac.saveAsBlob();
          return outputFile || file;
        } catch (error) {
          console.error("同时写入歌词和封面失败:", error);
          return file;
        }
      };
      const getFileBlob = async (url) => {
        const response = await fetch(url);
        const blob = await response.blob();
        return { blob, response };
      };
      const downloadAsJson = (data, filename, options = {}) => {
        try {
          const { space = 2, timestamp = false } = options;
          const jsonString = JSON.stringify(data, null, space);
          const blob = new Blob([jsonString], { type: "application/json" });
          const blobUrl = window.URL.createObjectURL(blob);
          let finalFilename = filename;
          if (timestamp) {
            const date = /* @__PURE__ */ new Date();
            const timeString = `${date.getFullYear()}${String(date.getMonth() + 1).padStart(2, "0")}${String(
        date.getDate()
      ).padStart(2, "0")}_${String(date.getHours()).padStart(2, "0")}${String(
        date.getMinutes()
      ).padStart(2, "0")}${String(date.getSeconds()).padStart(2, "0")}`;
            finalFilename = `${filename}_${timeString}`;
          }
          const a = document.createElement("a");
          a.href = blobUrl;
          a.download = `${finalFilename}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          window.URL.revokeObjectURL(blobUrl);
          return true;
        } catch (error) {
          console.error("JSON数据下载失败:", error);
          return false;
        }
      };
      const downloadAsLRC = (lrcContent, filename, options = {}) => {
        try {
          const { timestamp = false } = options;
          let finalFilename = filename;
          if (timestamp) {
            const now = /* @__PURE__ */ new Date();
            const ts = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, "0")}${String(
        now.getDate()
      ).padStart(2, "0")}_${String(now.getHours()).padStart(2, "0")}${String(
        now.getMinutes()
      ).padStart(2, "0")}${String(now.getSeconds()).padStart(2, "0")}`;
            finalFilename = `${filename}_${ts}`;
          }
          const blob = new Blob([lrcContent], { type: "text/plain" });
          const blobUrl = window.URL.createObjectURL(blob);
          downloadFileWithBlob(blob, `${finalFilename}.lrc`);
          window.URL.revokeObjectURL(blobUrl);
          return true;
        } catch (error) {
          console.error("LRC歌词下载失败:", error);
          return false;
        }
      };
      const downloadFileWithBlob = (file, name2) => {
        const blobUrl = window.URL.createObjectURL(file);
        const a = document.createElement("a");
        a.href = blobUrl;
        a.download = name2;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(blobUrl);
      };
      const audio = new Audio();
      const usePlayMusic = () => {
        const { downloadConfig } = useConfig();
        const { quality: downloadQuality, downloadLyric, embedLyricCover } = downloadConfig;
        const [currentMid, setCurrentMid] = useState("");
        const [isPlaying, setIsPlaying] = useState();
        const [currentTime, setCurrentTime] = useState(0);
        const [duration, setDuration] = useState(0);
        const urlMap = useRef({});
        const songInfoMap = useRef({});
        const getSongInfo$1 = async (mid) => {
          if (songInfoMap.current[mid]) {
            return songInfoMap.current[mid];
          }
          const res = await getSongInfo(mid);
          const songInfo = res.track_info;
          songInfoMap.current[mid] = songInfo;
          return songInfo;
        };
        const getUrl = async (mid, quality = downloadQuality) => {
          const key = mid + quality;
          if (urlMap.current[key]) {
            return urlMap.current[key];
          }
          const res = await getSongPlayUrl(mid, { quality });
          const url = res[mid]?.url || "";
          if (!url) throw new Error("获取歌曲播放地址失败");
          urlMap.current[key] = url;
          console.log("url", url);
          return url;
        };
        const getLyric = async (mid) => {
          const res = await getSongLyric(mid);
          return res;
        };
        const play = async (mid, quality = downloadQuality) => {
          try {
            if (mid === currentMid) {
              audio.play();
              return;
            }
            const url = await getUrl(mid, quality);
            audio.src = url;
            audio.play();
            setCurrentMid(mid);
            return new Promise((resolve) => {
              audio.onended = () => {
                resolve(true);
                setIsPlaying(void 0);
              };
            });
          } catch (error) {
            console.log("error", error);
          } finally {
            setIsPlaying(mid);
          }
        };
        const playList = async (midList) => {
          for (const mid of midList) {
            await play(mid);
          }
        };
        const download = async (mid, quality = downloadQuality) => {
          try {
            const songInfo = await getSongInfo$1(mid);
            const { name: name2, album: { mid: albumMid } = {} } = songInfo;
            const url = await getUrl(mid, quality);
            console.log(`当前下载歌曲${name2},音质为${quality},链接为${url}`);
            const finalExt = url.split("?")[0].split(".").pop();
            const { blob } = await getFileBlob(url.replace("http://", "https://"));
            let outputFile = blob;
            if (songInfo) {
              const { name: name3, album: { name: albumName }, singer } = songInfo;
              if (name3) {
                outputFile = await writeFlacTag(outputFile, FlacTag.标题, name3);
              }
              if (albumName) {
                outputFile = await writeFlacTag(outputFile, FlacTag.专辑, albumName);
              }
              if (singer) {
                outputFile = await writeFlacTag(outputFile, FlacTag.艺术家, singer.map((item) => item.name).join(","));
              }
            }
            let lyric = "";
            try {
              lyric = await getLyric(mid);
              console.log(`获取到歌词《${name2}》`, lyric);
            } catch (error) {
              console.log(`获取歌词失败《${name2}》`, error);
            }
            let coverBlob;
            if (albumMid) {
              const cover = getAlbumPicUrl(albumMid);
              const { blob: blob2 } = await getFileBlob(cover.replace("http://", "https://"));
              coverBlob = blob2;
            }
            if (embedLyricCover) {
              switch (finalExt) {
                case "flac":
                  outputFile = await writeFlacTagAndPicture(blob, "lyrics", lyric, coverBlob);
                  break;
                default:
                  console.log("当前格式不支持");
                  break;
              }
            }
            if (downloadLyric) {
              downloadAsLRC(lyric, name2);
            }
            downloadFileWithBlob(outputFile, `${name2}.${finalExt}`);
          } catch (error) {
            console.log("error", error);
          }
        };
        const convertToNeteaseMusic = async (mid, options) => {
          const { quality = downloadQuality, onChange } = options || {};
          const loadingKey = "convert-to-netease-music" + mid;
          const msgLoading2 = (msg) => {
            message$1.loading({
              key: loadingKey,
              content: msg,
              duration: 0
            });
          };
          const log2 = (msg, ...rest) => {
            console.log(msg, ...rest);
            onChange?.(msg);
            msgLoading2(msg);
          };
          try {
            log2(`开始获取歌曲信息：${mid}`);
            const songInfo = await getSongInfo$1(mid);
            const { name: name2, album: { mid: albumMid } = {} } = songInfo;
            log2(`获取到歌曲信息：${name2}`, songInfo);
            const url = await getUrl(mid, quality);
            log2(`获取到歌曲《${name2}》播放地址`, url);
            const finalExt = url.split("?")[0].split(".").pop();
            log2(`开始下载歌曲《${name2}》`, url);
            const { blob } = await getFileBlob(url.replace("http://", "https://"));
            let outputFile = blob;
            if (songInfo) {
              const { name: name3, album: { name: albumName }, singer } = songInfo;
              if (name3) {
                outputFile = await writeFlacTag(outputFile, FlacTag.标题, name3);
              }
              if (albumName) {
                outputFile = await writeFlacTag(outputFile, FlacTag.专辑, albumName);
              }
              if (singer) {
                outputFile = await writeFlacTag(outputFile, FlacTag.艺术家, singer.map((item) => item.name).join(","));
              }
              log2(`写入歌曲信息到文件《${name3}》`, { name: name3, albumName, singer });
            }
            if (embedLyricCover) {
              log2(`开始写入歌词和封面《${name2}》`);
              let lyric = "";
              try {
                lyric = await getLyric(mid);
                log2(`获取到歌词《${name2}》`, lyric);
              } catch (error) {
                log2(`获取歌词失败《${name2}》`, error);
              }
              let coverBlob;
              if (albumMid) {
                const cover = getAlbumPicUrl(albumMid);
                const { blob: blob2 } = await getFileBlob(cover.replace("http://", "https://"));
                coverBlob = blob2;
                log2(`获取到封面《${name2}》`, coverBlob);
              }
              switch (finalExt) {
                case "flac":
                  outputFile = await writeFlacTagAndPicture(blob, "lyrics", lyric, coverBlob);
                  log2(`写入歌词和封面成功《${name2}》`, outputFile);
                  break;
                default:
                  log2("当前格式不支持嵌入歌词和封面");
                  break;
              }
            }
            log2(`开始转存网易云《${name2}》`, outputFile);
            const res = await uploadLocalSong(new File([outputFile], `${name2}.${finalExt}`));
            log2(`转存网易云成功《${name2}》`, res);
          } catch (error) {
            log2(`转存网易云失败《${name}》`, error);
          } finally {
            message$1.destroy(loadingKey);
          }
        };
        const pause = () => {
          audio.pause();
          setIsPlaying(void 0);
        };
        const stop = () => {
          audio.pause();
          audio.currentTime = 0;
          setIsPlaying(void 0);
        };
        useEffect(() => {
          audio.onloadedmetadata = () => {
            setDuration(audio.duration);
          };
          audio.onpause = () => {
            setIsPlaying(void 0);
          };
        }, [currentMid]);
        return {
          isPlaying,
          currentTime,
          duration,
          audio,
          play,
          pause,
          stop,
          download,
          playList,
          getUrl,
          getLyric,
          getSongInfo: getSongInfo$1,
          convertToNeteaseMusic
        };
      };
      const useGetAlbumDetail = () => {
        const [currentMid, setCurrentMid] = useState("");
        const [albumInfo, setAlbumInfo] = useState();
        const [isLoading, setIsLoading] = useState(false);
        const albumInfoMap = useRef({});
        const { downloadConfig, functionConfig } = useConfig();
        const { quality: downloadQuality } = downloadConfig;
        const { uploadConcurrency } = functionConfig;
        const { play, getUrl, download, getLyric } = usePlayMusic();
        const getAlbumDetail = async (mid) => {
          try {
            setIsLoading(true);
            if (albumInfoMap.current[mid]) {
              return albumInfoMap.current[mid];
            }
            const res = await getAlbumInfo(mid);
            console.log("专辑详情", res);
            albumInfoMap.current[mid] = res;
            setAlbumInfo(res);
            return res;
          } catch (error) {
            console.error("获取专辑详情失败:", error);
          } finally {
            setIsLoading(false);
          }
        };
        const getAlbumSongList = async (mid) => {
          try {
            setIsLoading(true);
            const res = await getAlbumDetail(mid);
            return res?.list;
          } catch (error) {
            console.error("获取专辑歌曲列表失败:", error);
          } finally {
            setIsLoading(false);
          }
        };
        const getAlbumSongUrl = async (mid) => {
          const res = await getAlbumSongList(mid);
          const ids = res?.map((item) => {
            return {
              id: item.songmid,
              name: item.songname,
              file: item
            };
          });
          const promiseArr = ids?.map((item) => async () => {
            const qualityList = getFileQualityList(item.file);
            const finalQuality = qualityList.includes(downloadQuality) ? downloadQuality : qualityList[0];
            const url = await getUrl(item.id, finalQuality);
            return {
              ...item,
              url,
              quality: finalQuality
            };
          });
          const urls = await promiseLimit(promiseArr, 6);
          console.log("专辑歌曲播放地址:", urls);
          return urls;
        };
        const downloadAlbumSong = async (mid, options) => {
          try {
            const { onChange } = options || {};
            const albumSongList = await getAlbumSongList(mid);
            console.log("准备下载专辑歌曲:", albumSongList);
            let index2 = 1;
            const successList = [];
            const errorList = [];
            const promiseArr = albumSongList?.map((item) => async () => {
              try {
                const { songmid, songname } = item;
                console.log(`正在下载: songmid=${songmid}, songname=${songname}`);
                await download(songmid);
                console.log(`第${index2}首歌曲《${songname}》下载完成！`);
                successList.push(item);
                index2++;
                onChange?.({
                  songList: albumSongList,
                  index: index2
                });
              } catch (error) {
                errorList.push(item);
              }
            });
            const songList = await promiseLimit(promiseArr, uploadConcurrency);
            return {
              successList,
              errorList,
              songList,
              total: albumSongList?.length
            };
          } catch (error) {
            console.error("下载专辑歌曲失败:", error);
          }
        };
        const getDownLoadJson = async (mid) => {
          const albumDetail = await getAlbumDetail(mid);
          const { name: name2, list } = albumDetail || {};
          const promiseArr = list?.map((item) => async () => {
            const lrcContent = await getLyric(item.songmid);
            const qualityList = getFileQualityList(item);
            const finalQuality = qualityList.includes(downloadQuality) ? downloadQuality : qualityList[0];
            const url = await getUrl(item.songmid, finalQuality);
            return {
              songName: item.songname,
              url,
              lrcContent
            };
          });
          const songList = await promiseLimit(promiseArr, uploadConcurrency);
          return {
            albumName: name2,
            albumCover: getAlbumPicUrl(mid),
            list: songList
          };
        };
        const playAlbum = async (mid) => {
          const songList = await getAlbumSongList(mid);
          console.log("songList", songList);
          if (!songList?.length) return;
          for (const item of songList) {
            console.log("当前正在播放", item.songname);
            await play(item.songmid);
          }
        };
        return {
          albumInfo,
          isLoading,
          getAlbumDetail,
          getAlbumSongList,
          playAlbum,
          getAlbumSongUrl,
          downloadAlbumSong,
          getDownLoadJson
        };
      };
      const useGetData = (api, params, options) => {
        const {
          // 监控项
          monitors,
          // 终止函数，什么条件下不执行
          returnFunction,
          // 初始值
          initialValue = {},
          // 拿到数据后执行的函数
          callback
        } = options || {};
        const [data, setData] = useState(initialValue);
        const [loading2, setLoading] = useState(false);
        const getData = async () => {
          try {
            setLoading(true);
            const res = await api(params);
            setData(res || {});
            callback && callback(res || {});
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        useEffect(() => {
          if (returnFunction && returnFunction()) return;
          getData();
        }, monitors || []);
        return {
          /** 数据 */
          data,
          /** 手动更改数据 */
          setData,
          /** 是否加载中 */
          loading: loading2,
          /** 手动获取数据 */
          getData
        };
      };
      const getSongListCategory = async () => {
        const params = {
          format: "json",
          outCharset: "utf-8"
        };
        const res = await qqMusicRequest(
          `/splcloud/fcgi-bin/fcg_get_diss_tag_conf.fcg?${new URLSearchParams(params)}`,
          {}
        );
        if (res.code === 0) {
          return res.data?.categories;
        }
        throw new Error("获取歌单分类列表失败");
      };
      const getSongList = async (options = {}) => {
        const { limit = 20, page = 0, sortId = 5, categoryId = 1e7 } = options;
        const sin = page * limit;
        const ein = limit * (page + 1) - 1;
        const params = {
          categoryId,
          sortId,
          sin,
          ein,
          format: "json",
          outCharset: "utf-8",
          picmid: 1
        };
        const res = await qqMusicRequest(
          `/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg?${new URLSearchParams(params).toString()}`,
          {}
        );
        if (res.code === 0) {
          return res.data;
        }
        throw new Error("获取歌单列表失败");
      };
      const getSongListDetail = async (disstid) => {
        const disstidStr = Array.isArray(disstid) ? disstid.join(",") : disstid;
        const params = {
          disstid: disstidStr,
          format: "json",
          outCharset: "utf-8",
          type: "1",
          json: "1",
          utf8: "1",
          onlysong: "0",
          new_format: "1"
        };
        const res = await qqMusicRequest(
          `/qzone/fcg-bin/fcg_ucc_getcdinfo_byids_cp.fcg?${new URLSearchParams(params).toString()}`,
          {}
        );
        if (res.code === 0) {
          return res.cdlist;
        }
        throw new Error("获取歌单详情失败");
      };
      const useGetSonglistDetail = () => {
        const [playlistInfo, setPlaylistInfo] = useState();
        const [isLoading, setIsLoading] = useState(false);
        const playlistInfoMap = useRef({});
        const { downloadConfig, functionConfig } = useConfig();
        const { quality: downloadQuality } = downloadConfig;
        const { uploadConcurrency } = functionConfig;
        const { play, getUrl, download, getLyric, convertToNeteaseMusic } = usePlayMusic();
        const getPlaylistDetail = async (dissid) => {
          try {
            setIsLoading(true);
            if (playlistInfoMap.current[dissid]) {
              return playlistInfoMap.current[dissid];
            }
            const res = await getSongListDetail(dissid);
            console.log("歌单详情:", res);
            const playlistDetail = Array.isArray(res) ? res[0] : res;
            playlistInfoMap.current[dissid] = playlistDetail;
            return playlistDetail;
          } catch (error) {
            console.error("获取歌单详情失败:", error);
          } finally {
            setIsLoading(false);
          }
        };
        const getPlaylistSongList = async (dissid) => {
          try {
            setIsLoading(true);
            const res = await getPlaylistDetail(dissid);
            return res?.songlist;
          } catch (error) {
            console.error("获取歌单歌曲列表失败:", error);
          } finally {
            setIsLoading(false);
          }
        };
        const getPlaylistSongUrl = async (dissid) => {
          const res = await getPlaylistSongList(dissid);
          const ids = res?.map((item) => {
            return {
              id: item.mid,
              name: item.name,
              file: item.file
            };
          });
          const promiseArr = ids?.map((item) => async () => {
            const qualityList = getFile_qualityList(item.file);
            const finalQuality = qualityList.includes(downloadQuality) ? downloadQuality : qualityList[0];
            const url = await getUrl(item.id, finalQuality);
            return {
              ...item,
              url,
              quality: finalQuality
            };
          });
          const urls = await promiseLimit(promiseArr, 6);
          console.log("歌单歌曲播放地址:", urls);
          return urls;
        };
        const downloadPlaylistSong = async (dissid) => {
          try {
            const songList = await getPlaylistSongList(dissid);
            console.log("准备下载歌单歌曲:", songList);
            for (const item of songList || []) {
              const { mid, name: name2, file } = item;
              console.log(`正在下载: mid=${mid}, name=${name2}`);
              await download(mid);
            }
          } catch (error) {
            console.error("下载歌单歌曲失败:", error);
          }
        };
        const convertToNeteaseMusicPlaylistSong = async (dissid) => {
          const loadingKey = "convert-to-netease-music-playlist-song";
          message$1.loading({
            key: loadingKey,
            content: `正在转存歌单歌曲...`,
            duration: 0
          });
          try {
            const songList = await getPlaylistSongList(dissid);
            const task = songList?.map((item) => async () => {
              const { mid, name: name2 } = item;
              console.log(`正在转存: mid=${mid}, name=${name2}`);
              await convertToNeteaseMusic(mid, {
                onChange: (msg) => {
                  message$1.loading({
                    key: loadingKey,
                    content: msg,
                    duration: 0
                  });
                }
              });
            });
            await promiseLimit(task, uploadConcurrency);
            message$1.success({
              key: loadingKey,
              content: `转存歌单歌曲成功`,
              duration: 0
            });
          } catch (error) {
            console.log("error", error);
          }
        };
        const getPlaylistDownloadJson = async (dissid) => {
          const playlistDetail = await getPlaylistDetail(dissid);
          const { dissname, songlist } = playlistDetail || {};
          const promiseArr = songlist?.map((item) => async () => {
            const lrcContent = await getLyric(item.mid);
            const qualityList = getFile_qualityList(item.file);
            const finalQuality = qualityList.includes(downloadQuality) ? downloadQuality : qualityList[0];
            const url = await getUrl(item.mid, finalQuality);
            return {
              songName: item.name,
              url,
              lrcContent
            };
          });
          const songList = await promiseLimit(promiseArr, 6);
          return {
            playlistName: dissname,
            playlistCover: playlistDetail?.pic_mid ? `https://y.gtimg.cn/music/photo_new/T002R300x300M000${playlistDetail.pic_mid}.jpg` : "",
            songList
          };
        };
        const playPlaylist = async (dissid) => {
          const songList = await getPlaylistSongList(dissid);
          console.log("歌单歌曲列表:", songList);
          if (!songList?.length) return;
          for (const item of songList) {
            console.log("当前正在播放", item.name);
            await play(item.mid);
          }
        };
        return {
          playlistInfo,
          isLoading,
          getPlaylistDetail,
          getPlaylistSongList,
          playPlaylist,
          getPlaylistSongUrl,
          downloadPlaylistSong,
          getPlaylistDownloadJson,
          convertToNeteaseMusicPlaylistSong
        };
      };
      const useVisible = (props = {}, ref) => {
        const {
          onOpen = NOOP,
          onClose = NOOP,
          onReset = NOOP,
          resetOnOpen = true,
          resetOnClose = false
        } = props;
        const [visible, setVisible] = useState(false);
        const open = (params) => {
          resetOnOpen && reset();
          setVisible(true);
          onOpen(params);
        };
        const close = () => {
          resetOnClose && reset();
          setVisible(false);
          onClose();
        };
        const reset = () => {
          setVisible(false);
          onReset();
        };
        const resolve = useRef(null);
        const reject = useRef(null);
        const submit = () => {
          return new Promise((_resolve, _reject) => {
            resolve.current = _resolve;
            reject.current = _reject;
          });
        };
        ref && useImperativeHandle(ref, () => ({
          open,
          close,
          reset,
          submit,
          resolve,
          reject
        }));
        return {
          visible,
          open,
          close,
          reset,
          submit,
          resolve,
          reject
        };
      };
      const NOOP = () => {
      };
      const getSingerInfo = async (singermid) => {
        const params = {
          singermid,
          format: "xml",
          outCharset: "utf-8",
          utf8: "1",
          r: dayjs().valueOf() + ""
        };
        return qqMusicRequest(
          `/splcloud/fcgi-bin/fcg_get_singer_desc.fcg?${new URLSearchParams(params).toString()}`,
          {
            method: "GET",
            responseType: "text"
            // 改为 text 因为返回的是 XML
          }
        );
      };
      const getSingerAlbum = async (singermid, options = {}) => {
        const { begin = 0, num = 80 } = options;
        const params = {
          format: "json",
          singermid,
          data: JSON.stringify({
            comm: {
              ct: 24,
              cv: 0
            },
            singer: {
              method: "GetAlbumList",
              param: {
                sort: 5,
                singermid,
                begin,
                num
              },
              module: "music.musichallAlbum.AlbumListServer"
            }
          })
        };
        const res = await qqMusicRequest(
          `/cgi-bin/musicu.fcg?${new URLSearchParams(params).toString()}`,
          {},
          "u"
        );
        if (res.code === 0) {
          return res.singer?.data;
        }
        throw new Error("获取歌手专辑失败");
      };
      const getSingerAllAlbum = async (singermid) => {
        const allAlbum = [];
        let begin = 0;
        const num = 80;
        let hasMore = true;
        while (hasMore) {
          const res = await getSingerAlbum(singermid, { begin, num });
          if (res) {
            allAlbum.push(...res.albumList);
            hasMore = allAlbum.length < res.total;
          } else {
            hasMore = false;
          }
          begin += num;
        }
        return allAlbum;
      };
      const getSingerList = async (options) => {
        const { area = -100, sex = -100, genre = -100, cur_page = 1 } = options;
        const params = {
          format: "json",
          data: JSON.stringify({
            comm: {
              ct: 24,
              cv: 0
            },
            singerList: {
              module: "Music.SingerListServer",
              method: "get_singer_list",
              param: {
                area: +area,
                sex: +sex,
                genre: +genre,
                index: -100,
                sin: (cur_page - 1) * 80,
                num: 80,
                cur_page
              }
            }
          })
        };
        const res = await qqMusicRequest(
          `/cgi-bin/musicu.fcg?${new URLSearchParams(params).toString()}`,
          {},
          "u"
        );
        if (res.code === 0) {
          return res.singerList?.data;
        }
        throw new Error("获取歌手列表失败");
      };
      const getSingerFollowCount = async (singermid) => {
        const params = {
          singermid,
          format: "json",
          outCharset: "utf-8",
          utf8: "1",
          rnd: dayjs().valueOf() + ""
        };
        return qqMusicRequest(
          `/rsc/fcgi-bin/fcg_order_singer_getnum.fcg?${new URLSearchParams(params).toString()}`,
          {},
          "c"
        );
      };
      const getSingerHotSong = async (singermid, options = {}) => {
        const { sin = 0, num = 60 } = options;
        const params = {
          singermid,
          format: "json",
          data: JSON.stringify({
            comm: {
              ct: 24,
              cv: 0
            },
            singer: {
              method: "get_singer_detail_info",
              param: {
                sort: 5,
                singermid,
                sin,
                num
              },
              module: "music.web_singer_info_svr"
            }
          })
        };
        const res = await qqMusicRequest(
          `/cgi-bin/musicu.fcg?${new URLSearchParams(params).toString()}`,
          {},
          "u"
        );
        if (res.code === 0) {
          return res.singer?.data;
        }
        throw new Error("获取歌手热门歌曲失败");
      };
      const getSingerAllHotSong = async (singermid, options) => {
        const { onChange } = options || {};
        let sin = 0;
        const num = 60;
        let hasMore = true;
        const result = {
          code: 200,
          total: 0,
          totalSong: 0,
          totalAlbum: 0,
          totalMV: 0,
          songList: [],
          singerBrief: "",
          singerInfo: {},
          extras: []
        };
        while (hasMore) {
          const res = await getSingerHotSong(singermid, { sin, num });
          if (res) {
            Object.assign(result, {
              total: res.total_song,
              singerBrief: res.singer_brief,
              singerInfo: res.singer_info,
              totalSong: res.total_song,
              totalAlbum: res.total_album,
              totalMV: res.total_mv,
              songList: [...result.songList, ...res.songlist],
              extras: [...result.extras, ...res.extras]
            });
            onChange?.(result);
            hasMore = result.songList.length < res.total_song;
          } else {
            hasMore = false;
          }
          sin += num;
        }
        console.log("result", result);
        return result;
      };
      const getSimilarSinger = async (singer_mid, options = {}) => {
        const { start = 0, num = 5 } = options;
        const params = {
          singer_mid,
          format: "json",
          outCharset: "utf-8",
          utf8: "1",
          start: start + "",
          num: num + ""
        };
        const res = await qqMusicRequest(
          `/v8/fcg-bin/fcg_v8_simsinger.fcg?${new URLSearchParams(params).toString()}`,
          {}
        );
        return res.singers;
      };
      const getSingerPic = (singermid, options) => {
        const { size = "800x800" } = {};
        return `https://y.qq.com/music/photo_new/T001R${size}M000${singermid}.jpg?max_age=2592000`;
      };
      const copy = async (text, options = {}) => {
        try {
          if (navigator.clipboard && window.isSecureContext) {
            if (options.html) {
              const type = "text/html";
              const blob = new Blob([text], { type });
              const data = [new ClipboardItem({ [type]: blob })];
              await navigator.clipboard.write(data);
            } else {
              await navigator.clipboard.writeText(text);
            }
          } else {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.cssText = "position: fixed; top: -9999px; left: -9999px";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
              document.execCommand("copy");
            } catch (err2) {
              throw new Error("复制失败，请检查浏览器权限设置");
            } finally {
              document.body.removeChild(textArea);
            }
          }
        } catch (err2) {
          throw new Error(
            err2 instanceof Error ? err2.message : "复制失败，请重试"
          );
        }
      };
      const styles$a = {
        "copy-text": "_copy-text_1att4_1",
        "copy-btn": "_copy-btn_1att4_12"
      };
      var classnames = { exports: {} };
      /*!
      	Copyright (c) 2018 Jed Watson.
      	Licensed under the MIT License (MIT), see
      	http://jedwatson.github.io/classnames
      */
      var hasRequiredClassnames;
      function requireClassnames() {
        if (hasRequiredClassnames) return classnames.exports;
        hasRequiredClassnames = 1;
        (function(module) {
          (function() {
            var hasOwn = {}.hasOwnProperty;
            function classNames2() {
              var classes = "";
              for (var i = 0; i < arguments.length; i++) {
                var arg = arguments[i];
                if (arg) {
                  classes = appendClass(classes, parseValue(arg));
                }
              }
              return classes;
            }
            function parseValue(arg) {
              if (typeof arg === "string" || typeof arg === "number") {
                return arg;
              }
              if (typeof arg !== "object") {
                return "";
              }
              if (Array.isArray(arg)) {
                return classNames2.apply(null, arg);
              }
              if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                return arg.toString();
              }
              var classes = "";
              for (var key in arg) {
                if (hasOwn.call(arg, key) && arg[key]) {
                  classes = appendClass(classes, key);
                }
              }
              return classes;
            }
            function appendClass(value, newClass) {
              if (!newClass) {
                return value;
              }
              if (value) {
                return value + " " + newClass;
              }
              return value + newClass;
            }
            if (module.exports) {
              classNames2.default = classNames2;
              module.exports = classNames2;
            } else {
              window.classNames = classNames2;
            }
          })();
        })(classnames);
        return classnames.exports;
      }
      var classnamesExports = requireClassnames();
      const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
      const styles$9 = {
        "text-overflow-show-tips-container": "_text-overflow-show-tips-container_btabq_1"
      };
      function TextOverflowShowTips({
        text,
        tooltipProps,
        className,
        ...restProps
      }) {
        const containerRef = useRef(null);
        const { width: containerWidth } = useSize(containerRef) || {};
        const isTooLong = useMemo(() => {
          if (containerWidth) {
            const textWidth = getTextWidth(text);
            return containerWidth < textWidth;
          }
          return false;
        }, [text, containerWidth]);
        const containerStyle = {
          maxWidth: "100%",
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap"
        };
        return isTooLong ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: text, ...tooltipProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            ...restProps,
            className: classNames(styles$9["text-overflow-show-tips-container"], className),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: containerRef, style: containerStyle, children: text })
          }
        ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: containerRef, style: containerStyle, ...restProps, className, children: text });
      }
      function getTextWidth(text, font = "14px Arial") {
        const span = document.createElement("span");
        span.style.visibility = "hidden";
        span.style.whiteSpace = "nowrap";
        span.style.font = font;
        span.style.position = "absolute";
        span.style.top = "-9999px";
        span.style.left = "-9999px";
        span.innerText = text;
        document.body.appendChild(span);
        const width = span.offsetWidth;
        document.body.removeChild(span);
        return width;
      }
      function CopyText(props) {
        const { text, className, ...rest } = props;
        const handleCopy = () => {
          copy(text);
          msgSuccess("复制成功");
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classNames(styles$a["copy-text"], className), ...rest, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextOverflowShowTips,
            {
              text: text + "",
              tooltipProps: {
                getPopupContainer: (node) => {
                  return document.body;
                }
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "link",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CopyOutlined, {}),
              onClick: handleCopy,
              className: styles$a["copy-btn"]
            }
          )
        ] });
      }
      function MyButton(props) {
        const { loading: loading2, onClick, ...rest } = props;
        const [_loading, setLoading] = useState(loading2);
        const handleClick = async (...args) => {
          try {
            setLoading(true);
            await onClick?.(...args);
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        useEffect(() => {
          setLoading(loading2);
        }, [loading2]);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { ...rest, onClick: handleClick, loading: _loading });
      }
      const Styles$1 = {
        "select-search": "_select-search_19wb1_1"
      };
      const { Group } = Input;
      const defaultSearchParams$3 = {
        prop: "xm",
        value: ""
      };
      function SelectSearch(props) {
        const {
          value,
          onChange,
          defaultValue,
          SearchSelectOptions,
          selectProps,
          inputProps,
          width = 300,
          selectWidth = 80,
          inputWidth = 180
        } = props;
        const [searchParams, setSearchParams] = useState(() => {
          if (value?.prop == void 0) return defaultValue || defaultSearchParams$3;
          return {
            ...defaultValue || defaultSearchParams$3,
            ...value
          };
        });
        useEffect(() => {
          if (value?.prop == void 0) return;
          if (typeof value !== "object") return console.warn("value类型错误,必须为对象");
          setSearchParams({
            ...value
          });
        }, [value]);
        const handleSearchSelectChange = (value2) => {
          const newSearchParams = {
            ...searchParams,
            prop: value2
          };
          setSearchParams(newSearchParams);
          onChange?.(newSearchParams, searchParams);
        };
        const handleSearchInputChange = (e) => {
          const value2 = e.target.value;
          const newSearchParams = {
            ...searchParams,
            value: value2
          };
          setSearchParams(newSearchParams);
          onChange?.(newSearchParams, searchParams);
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Group,
          {
            compact: true,
            style: {
              width
            },
            className: Styles$1["select-search"],
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select,
                {
                  options: SearchSelectOptions || defaultSearchSelectOptions,
                  placeholder: "请选择",
                  value: searchParams.prop,
                  onChange: handleSearchSelectChange,
                  style: {
                    width: selectWidth,
                    borderRadius: "6px 0 0 6px"
                  },
                  ...selectProps
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  placeholder: `请输入`,
                  style: { width: inputWidth, height: 32 },
                  value: searchParams.value,
                  onChange: handleSearchInputChange,
                  allowClear: true,
                  ...inputProps
                }
              )
            ]
          }
        );
      }
      const defaultSearchSelectOptions = [
        {
          value: "xh",
          label: "学号"
        },
        {
          value: "xm",
          label: "姓名"
        }
      ];
      const styles$8 = {};
      const { RangePicker: AntRangePicker } = DatePicker;
      const RangePicker = ({
        value,
        onChange,
        format = "YYYY-MM-DD",
        className,
        placeholder = ["开始日期", "结束日期"],
        ...rest
      }) => {
        const toDayjs = (val) => {
          if (!val) return null;
          if (dayjs.isDayjs(val)) return val;
          return dayjs(val);
        };
        const rangeValue = Array.isArray(value) ? [toDayjs(value[0]), toDayjs(value[1])] : null;
        const handleChange = (dates, dateStrings) => {
          console.log("dates", dates);
          console.log("dateStrings", dateStrings);
          if (dates && onChange) {
            onChange(
              dates.map((date) => date ? date.format(format) : ""),
              dateStrings
            );
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          AntRangePicker,
          {
            value: rangeValue,
            onChange: handleChange,
            format,
            className: classNames(styles$8["rangePicker"], className),
            placeholder,
            ...rest
          }
        );
      };
      const filterOption = (inputValue, option) => {
        return option.label.toLowerCase().indexOf(inputValue.toLowerCase()) >= 0;
      };
      const COMPONENT_TYPE_MAP = {
        input: Input,
        select: Select,
        selectSearch: SelectSearch,
        rangePicker: RangePicker,
        treeSelect: TreeSelect
      };
      const defaultComponentProps = {
        input: {
          placeholder: "请输入",
          style: { width: "200px" },
          allowClear: true
        },
        select: {
          placeholder: "请选择",
          style: { width: "200px" },
          allowClear: true,
          maxTagCount: 2,
          showSearch: true,
          filterOption
        },
        selectSearch: {},
        rangePicker: {},
        treeSelect: {
          treeCheckable: true,
          allowClear: true,
          treeExpandAction: "click",
          filterTreeNode: (inputValue, treeNode) => {
            return treeNode.props.title.toLowerCase().indexOf(inputValue.toLowerCase()) >= 0;
          },
          placeholder: "请选择",
          style: {
            width: "200px"
          }
        }
      };
      const { Item: Item$3 } = Form;
      const SearchFormItem = (props) => {
        const { name: name2, type = "input", label = "", inputProps = {}, ...formItemProps } = props;
        const InputComponent = COMPONENT_TYPE_MAP[type];
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Item$3, { name: name2, label, ...formItemProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputComponent, { ...{ ...defaultComponentProps[type], ...inputProps } }) });
      };
      function AdvancedSearch(props) {
        Form.useFormInstance();
        const { params, items = [] } = props;
        const [optionsMap, setOptionsMap] = useState({});
        useEffect(() => {
          const asyncFn = async () => {
            try {
              items.map(async (item) => {
                if (!item.getOptionsApi) return;
                const res = await item.getOptionsApi(params);
                setOptionsMap((prev) => {
                  return {
                    ...prev,
                    [item.name]: res.data
                  };
                });
                item.getOptionsApiAfter?.(res.data);
              });
            } catch (error) {
              console.log("error", error);
            }
          };
          asyncFn();
        }, []);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: items.map((item) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            SearchFormItem,
            {
              name: item.name,
              label: item.label,
              type: item.type,
              inputProps: {
                ...item.inputProps,
                options: optionsMap[item.name] || item.options
              }
            },
            item.name
          );
        }) });
      }
      const Styles = {
        "search-form": "_search-form_10eg9_1"
      };
      const { Item: Item$2 } = Form;
      const SearchForm = (props, ref) => {
        const [formRef] = Form.useForm();
        const {
          options = [],
          advancedOptions = [],
          searchParams = {},
          onSearch = () => {
          },
          loading: loading2 = false,
          keepAdvancedSearchValue = true,
          ...restFormProps
        } = props;
        useEffect(() => {
          !keepAdvancedSearchValue && formRef.resetFields();
          formRef.setFieldsValue(searchParams);
        }, [searchParams]);
        const [optionsMap, setOptionsMap] = useState({});
        useEffect(() => {
          const asyncFn = async () => {
            try {
              options.map(async (item) => {
                if (!item.getOptionsApi || !item.name) return;
                const res = await item.getOptionsApi(searchParams);
                setOptionsMap((prev) => {
                  return {
                    ...prev,
                    [item.name]: res.data
                  };
                });
                item.getOptionsApiAfter?.(res.data);
              });
            } catch (error) {
              console.log("error", error);
            }
          };
          asyncFn();
        }, []);
        const [isAdvancedSearch, setIsAdvancedSearch] = useState(false);
        const handleSearch = () => {
          const values = formRef.getFieldsValue();
          console.log("values", values);
          onSearch(values);
        };
        const handleReset = () => {
          formRef.resetFields();
          handleSearch();
        };
        useImperativeHandle(ref, () => ({
          reset: handleReset,
          search: handleSearch,
          getValues: formRef.getFieldsValue
        }));
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Form,
          {
            layout: "inline",
            form: formRef,
            className: Styles["search-form"],
            ...restFormProps,
            children: [
              options.map((item) => {
                const { getOptionsApi, getOptionsApiAfter, ...rest } = item;
                return /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SearchFormItem,
                  {
                    ...rest,
                    inputProps: {
                      ...item.inputProps,
                      options: optionsMap[item.name] || item.options
                    }
                  },
                  item.name || item.label
                );
              }),
              isAdvancedSearch && /* @__PURE__ */ jsxRuntimeExports.jsx(AdvancedSearch, { params: searchParams, items: advancedOptions }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Item$2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleSearch, shape: "round", loading: loading2, children: "查询" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Item$2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleReset, shape: "round", children: "重置" }) }),
              advancedOptions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Item$2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "link", onClick: () => setIsAdvancedSearch(!isAdvancedSearch), children: isAdvancedSearch ? "关闭" : "高级搜索" }) })
            ]
          }
        );
      };
      const SearchForm$1 = forwardRef(SearchForm);
      const footer$2 = "_footer_e7ura_48";
      const styles$7 = {
        "album-detail-modal": "_album-detail-modal_e7ura_1",
        "modal-header": "_modal-header_e7ura_1",
        "album-basic-info": "_album-basic-info_e7ura_6",
        "album-info": "_album-info_e7ura_11",
        "album-name": "_album-name_e7ura_16",
        "album-meta": "_album-meta_e7ura_19",
        "song-table": "_song-table_e7ura_24",
        "song-name": "_song-name_e7ura_27",
        "artist-item": "_artist-item_e7ura_33",
        "artist-name": "_artist-name_e7ura_37",
        "artist-separator": "_artist-separator_e7ura_41",
        "song-duration": "_song-duration_e7ura_45",
        footer: footer$2,
        "selected-count": "_selected-count_e7ura_55"
      };
      const { Text: Text$4, Title: Title$3 } = Typography;
      const AlbumDetail = forwardRef((_, ref) => {
        const { visible, close } = useVisible(
          {
            onOpen(params) {
              if (params?.albummid) {
                setCurrentMid(params.albummid);
              }
            },
            onReset() {
              setCurrentMid("");
              setInputMid("");
              setSelectedRowKeys([]);
              setSelectedRows([]);
              setList([]);
            }
          },
          ref
        );
        const [currentMid, setCurrentMid] = useState("");
        const [inputMid, setInputMid] = useState("");
        const { downloadConfig } = useConfig();
        const { quality: defaultQuality } = downloadConfig;
        const { getAlbumDetail, getAlbumSongList, isLoading, getDownLoadJson } = useGetAlbumDetail();
        const { play, isPlaying, pause, download, convertToNeteaseMusic } = usePlayMusic();
        const { data: detail, loading: detailLoading } = useGetData(
          getAlbumDetail,
          currentMid,
          {
            initialValue: void 0,
            returnFunction: () => !currentMid || !visible,
            monitors: [currentMid, visible]
          }
        );
        const {
          data: list,
          loading: loading2,
          setData: setList
        } = useGetData(getAlbumSongList, currentMid, {
          initialValue: [],
          returnFunction: () => !currentMid || !visible,
          monitors: [currentMid, visible],
          callback: (data) => {
            console.log("data", data);
          }
        });
        const handleChooseQuality = (record, quality) => {
          setList(
            list?.map((item) => {
              if (item.songmid === record.songmid) {
                return {
                  ...item,
                  quality
                };
              }
              return item;
            }) || []
          );
        };
        const handlePlay = (record) => {
          if (isPlaying) {
            pause();
          } else {
            const { quality } = record;
            const finalQuality = getQuality$3(record, defaultQuality, quality);
            play(record.songmid, finalQuality);
          }
        };
        const [downloading, setDownloading] = useState("");
        const handleDownload = async (record) => {
          try {
            if (downloading === record.songmid) return;
            setDownloading(record.songmid);
            const { quality } = record;
            const finalQuality = getQuality$3(record, defaultQuality, quality);
            await download(record.songmid, finalQuality);
          } catch (error) {
            console.log("error", error);
          } finally {
            setDownloading("");
          }
        };
        const songColumns = [
          {
            title: "歌曲",
            dataIndex: "songname",
            key: "songname",
            width: 300,
            render: (text) => /* @__PURE__ */ jsxRuntimeExports.jsx(Text$4, { className: styles$7["song-name"], title: text, children: text })
          },
          {
            title: "歌手",
            dataIndex: "singer",
            key: "singer",
            width: 240,
            render: (singers = []) => /* @__PURE__ */ jsxRuntimeExports.jsx(Space, { size: "small", wrap: true, children: singers.length > 0 ? singers.map((s, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$7["artist-item"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { size: 30, style: { marginRight: 4 }, src: getSingerPic(s.mid) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$7["artist-name"], children: s.name }),
              index2 < singers.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$7["artist-separator"], children: "/" })
            ] }, s.mid || index2)) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "-" }) })
          },
          // 音质选择器
          {
            title: "音质",
            key: "quality",
            width: 100,
            align: "center",
            render: (_2, record) => {
              const qualityList = getFileQualityList(record);
              const defaultValue = qualityList.includes(defaultQuality) ? defaultQuality : qualityList[0];
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select,
                {
                  options: qualityList.map((quality) => ({
                    label: quality,
                    value: quality
                  })),
                  defaultValue,
                  style: { width: "100%" },
                  onChange: (value) => {
                    handleChooseQuality(record, value);
                  }
                }
              );
            }
          },
          // 格式
          {
            title: "格式",
            key: "format",
            width: 150,
            align: "center",
            render: (_2, record) => {
              const qualityList = getFileQualityList(record);
              const qualityColorMap = {
                flac: "green",
                ape: "volcano",
                320: "blue",
                m4a: "orange",
                128: "gray"
              };
              const qualityTextMap = {
                flac: "FLAC",
                ape: "APE",
                320: "320k",
                m4a: "M4A",
                128: "128k"
              };
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Space, { wrap: true, children: qualityList.map((quality) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: qualityColorMap[quality], children: qualityTextMap[quality] || quality }, quality)) });
            }
          },
          {
            title: "时长",
            dataIndex: "interval",
            key: "interval",
            width: 100,
            align: "center",
            render: (interval) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Text$4, { className: styles$7["song-duration"], children: [
              Math.floor((interval || 0) / 60),
              ":",
              ((interval || 0) % 60).toString().padStart(2, "0")
            ] })
          },
          {
            title: "操作",
            key: "action",
            width: 200,
            align: "center",
            fixed: "right",
            render: (_2, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "播放", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "link",
                  size: "small",
                  icon: isPlaying === record.songmid ? /* @__PURE__ */ jsxRuntimeExports.jsx(PauseCircleOutlined, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                  onClick: () => handlePlay(record),
                  children: "播放"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "下载", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}),
                  loading: downloading === record.songmid,
                  onClick: () => handleDownload(record),
                  children: "下载"
                }
              ) })
            ] })
          }
        ];
        const [selectedRowKeys, setSelectedRowKeys] = useState([]);
        const [selectedRows, setSelectedRows] = useState([]);
        const rowSelection = {
          preserveSelectedRowKeys: true,
          selectedRowKeys,
          onChange: (selectedRowKeys2, selectedRows2) => {
            setSelectedRowKeys(selectedRowKeys2);
            setSelectedRows(selectedRows2);
            console.log("selectedRowKeys", selectedRowKeys2);
            console.log("selectedRows", selectedRows2);
          }
        };
        const renderTitle = () => {
          const albumName = detail?.name || "专辑详情";
          const singerName = detail?.singername || "";
          const publishDate = detail?.aDate || "";
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7["modal-header"], children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Title$3, { level: 4, className: styles$7["modal-title"], children: "专辑详情" }),
            detail && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7["album-basic-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Image,
                {
                  src: currentMid ? getAlbumPicUrl(currentMid) : "",
                  alt: albumName,
                  width: 80,
                  height: 80,
                  style: { borderRadius: 8 },
                  fallback: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3Ik1RnG4W+FgYxN"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7["album-info"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Title$3, { level: 5, className: styles$7["album-name"], children: albumName }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7["album-meta"], children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Text$4, { type: "secondary", className: styles$7["singer-name"], children: singerName || "未知歌手" }),
                  publishDate && /* @__PURE__ */ jsxRuntimeExports.jsxs(Text$4, { type: "secondary", className: styles$7["publish-date"], children: [
                    "· ",
                    publishDate
                  ] })
                ] })
              ] })
            ] })
          ] });
        };
        const handleBatchDownload = async () => {
          if (selectedRows.length === 0) {
            msgWarning("请先选择要下载的歌曲");
            return;
          }
          const loadingKey = "download-album-song";
          try {
            message$1.loading({
              key: loadingKey,
              content: `正在准备下载 ${selectedRows.length} 首歌曲...`,
              duration: 0
            });
            let index2 = 1;
            for (const song of selectedRows) {
              message$1.loading({
                key: loadingKey,
                content: `正在下载第 ${index2} 首歌曲 ${song.songname}...`,
                duration: 0
              });
              const finalQuality = getQuality$3(song, defaultQuality);
              await download(song.songmid, finalQuality);
              message$1.success({
                key: loadingKey,
                content: `第 ${index2} 首歌曲 ${song.songname} 下载成功！`,
                duration: 1
              });
              index2++;
            }
            message$1.success({
              key: loadingKey,
              content: `成功下载 ${selectedRows.length} 首歌曲！`,
              duration: 1
            });
          } catch (error) {
            console.error("批量下载失败:", error);
            message$1.destroy(loadingKey);
            msgError("批量下载失败: " + error.message);
          } finally {
            message$1.destroy(loadingKey);
          }
        };
        const handleBatchDownloadNeteaseMusic = async () => {
          if (selectedRows.length === 0) {
            msgWarning("请先选择要转存网易云的歌曲");
            return;
          }
          const loadingKey = "download-album-song-netease";
          try {
            message$1.loading({
              key: loadingKey,
              content: `正在准备转存网易云 ${selectedRows.length} 首歌曲...`,
              duration: 0
            });
            let index2 = 1;
            for (const song of selectedRows) {
              console.log("song", song);
              const record = song;
              const finalQuality = getQuality$3(record, defaultQuality, record.quality);
              message$1.loading({
                key: loadingKey,
                content: `正在转存第 ${index2} 首歌曲 ${song.songname}...`,
                duration: 0
              });
              await convertToNeteaseMusic(song.songmid, { quality: finalQuality });
              message$1.success({
                content: `第 ${index2} 首歌曲 ${song.songname} 转存成功！`,
                duration: 1
              });
              index2++;
            }
            message$1.success({
              key: loadingKey,
              content: `成功转存 ${selectedRows.length} 首歌曲！`,
              duration: 1
            });
          } catch (error) {
            console.error("批量转存网易云失败:", error);
            msgError("批量转存网易云失败: " + error.message);
          } finally {
            message$1.destroy(loadingKey);
          }
        };
        const handleDownloadAllJson = async () => {
          if (!currentMid) return;
          const loadingKey = "download-album-json";
          try {
            message$1.loading({
              key: loadingKey,
              content: `正在下载专辑JSON...`,
              duration: 0
            });
            const res = await getDownLoadJson(currentMid);
            downloadAsJson([res], `${detail?.name}.json`);
            message$1.destroy(loadingKey);
            msgSuccess("成功下载专辑JSON！");
          } catch (error) {
            console.log("error", error);
          } finally {
            message$1.destroy(loadingKey);
          }
        };
        const renderFooter = () => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7["footer"], children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7["selected-count"], children: [
              "已选择 ",
              selectedRows.length,
              " 首歌曲"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
              selectedRowKeys?.length < list.length ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    setSelectedRowKeys(list?.map((item) => item.songmid) || []);
                    setSelectedRows(list || []);
                  },
                  children: "全部选择"
                }
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    setSelectedRowKeys([]);
                    setSelectedRows([]);
                  },
                  children: "清空选择"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(MyButton, { type: "primary", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}), onClick: handleBatchDownload, children: [
                "下载选中歌曲",
                selectedRows?.length ? `(${selectedRows?.length})` : ""
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                MyButton,
                {
                  type: "primary",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CloudDownloadOutlined, {}),
                  onClick: handleBatchDownloadNeteaseMusic,
                  children: [
                    "转存网易云",
                    selectedRows?.length ? `(${selectedRows?.length})` : ""
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FileOutlined, {}), type: "primary", onClick: handleDownloadAllJson, children: "下载全部歌曲JSON" })
            ] })
          ] });
        };
        const handleInputChange = (e) => {
          setInputMid(e.target.value.trim());
        };
        const handleOpenById = () => {
          if (!inputMid) return;
          setCurrentMid(inputMid);
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            title: renderTitle(),
            open: visible,
            onCancel: close,
            width: 1200,
            centered: true,
            destroyOnHidden: true,
            className: styles$7["album-detail-modal"],
            footer: renderFooter(),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: 12, display: "flex", gap: 8 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    placeholder: "请输入专辑ID/MID，如 003rJSwm3TechU",
                    value: inputMid,
                    onChange: handleInputChange,
                    onPressEnter: handleOpenById,
                    allowClear: true,
                    "aria-label": "专辑ID输入框"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "primary",
                    onClick: handleOpenById,
                    loading: loading2 || detailLoading || isLoading,
                    children: "打开"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Table,
                {
                  columns: songColumns,
                  dataSource: list || [],
                  rowSelection,
                  rowKey: "songmid",
                  loading: loading2 || detailLoading || isLoading,
                  scroll: { y: 400, x: 600 },
                  pagination: {
                    showSizeChanger: true,
                    showQuickJumper: true,
                    showTotal: (total) => `共 ${total} 首歌曲`
                  },
                  className: styles$7["song-table"]
                }
              )
            ]
          }
        );
      });
      const getQuality$3 = (record, defaultQuality, chooseQuality) => {
        const qualityList = getFileQualityList(record);
        const songDefaultQuality = qualityList.includes(defaultQuality) ? defaultQuality : qualityList[0];
        const finalQuality = chooseQuality || songDefaultQuality;
        return finalQuality;
      };
      const { Link, Text: Text$3 } = Typography;
      const GITHUB_CONFIG = {
        owner: "520Qiuyu",
        repo: "QQMusic",
        homepage: "https://github.com/520Qiuyu/QQMusic",
        authorUrl: "https://github.com/520Qiuyu",
        scriptUrl: "https://raw.githubusercontent.com/520Qiuyu/QQMusic/main/dist/qqmusic.user.js"
      };
      const GithubInfo = forwardRef((_props, ref) => {
        const { visible, close } = useVisible(
          {
            onOpen: () => {
              fetchRepoInfo();
            }
          },
          ref
        );
        const [repoInfo, setRepoInfo] = useState(null);
        const [loading2, setLoading] = useState(false);
        const { functionConfig, setFunctionConfig } = useConfig();
        const fetchRepoInfo = async () => {
          setLoading(true);
          try {
            const response = await fetch(
              `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}`
            );
            if (response.ok) {
              const data = await response.json();
              setRepoInfo({
                stars: data.stargazers_count || 0,
                forks: data.forks_count || 0,
                watchers: data.watchers_count || 0,
                description: data.description || "",
                language: data.language || "",
                updatedAt: data.updated_at || "",
                createdAt: data.created_at || "",
                openIssues: data.open_issues_count || 0,
                license: data.license?.name || "无",
                defaultBranch: data.default_branch || "main",
                avatarUrl: data.owner?.avatar_url || "",
                authorName: data.owner?.login || GITHUB_CONFIG.owner
              });
            }
          } catch (error) {
            console.error("获取 GitHub 信息失败:", error);
          } finally {
            setLoading(false);
          }
        };
        const formatDate = (dateString) => {
          if (!dateString) return "-";
          const date = new Date(dateString);
          return date.toLocaleDateString("zh-CN", {
            year: "numeric",
            month: "long",
            day: "numeric"
          });
        };
        const handleDoubleClickDefaultBranch = () => {
          setFunctionConfig({
            ...functionConfig,
            enableTestModal: !functionConfig.enableTestModal
          });
          close();
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            title: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(GithubOutlined, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "GitHub 信息" })
            ] }),
            open: visible,
            onCancel: close,
            footer: null,
            centered: true,
            width: 700,
            zIndex: 99999,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Spin, { spinning: loading2, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Descriptions, { column: 1, bordered: true, size: "small", styles: { label: { width: 120 } }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "项目主页", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Space, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { href: GITHUB_CONFIG.homepage, target: "_blank", rel: "noopener noreferrer", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(LinkOutlined, {}),
                " ",
                GITHUB_CONFIG.homepage
              ] }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "作者主页", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                repoInfo?.avatarUrl && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Image,
                  {
                    src: repoInfo.avatarUrl,
                    alt: repoInfo.authorName || "作者头像",
                    width: 60,
                    height: 60,
                    style: {
                      borderRadius: "50%",
                      objectFit: "cover",
                      cursor: "pointer"
                    }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { href: GITHUB_CONFIG.authorUrl, target: "_blank", rel: "noopener noreferrer", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(GithubOutlined, {}),
                  " ",
                  GITHUB_CONFIG.authorUrl
                ] })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "项目描述", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { children: repoInfo?.description || "暂无描述" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "统计信息", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "large", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(StarOutlined, { style: { color: "#faad14" } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { strong: true, children: repoInfo?.stars || 0 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { type: "secondary", children: "Stars" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(ForkOutlined, { style: { color: "#1890ff" } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { strong: true, children: repoInfo?.forks || 0 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { type: "secondary", children: "Forks" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOutlined, { style: { color: "#52c41a" } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { strong: true, children: repoInfo?.watchers || 0 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { type: "secondary", children: "Watchers" })
                ] })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "主要语言", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { children: repoInfo?.language || "未知" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "默认分支", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Text$3,
                {
                  code: true,
                  onDoubleClick: handleDoubleClickDefaultBranch,
                  style: { cursor: "pointer", userSelect: "none" },
                  children: repoInfo?.defaultBranch || "main"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "许可证", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { children: repoInfo?.license || "无" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "开放 Issues", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { children: repoInfo?.openIssues || 0 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "创建时间", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { children: formatDate(repoInfo?.createdAt) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "更新时间", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { children: formatDate(repoInfo?.updatedAt) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions.Item, { label: "操作", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "primary",
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(GithubOutlined, {}),
                    href: GITHUB_CONFIG.homepage,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: "访问仓库"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(StarOutlined, {}),
                    href: `${GITHUB_CONFIG.homepage}/stargazers`,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: "查看 Stars"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "primary",
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UploadOutlined, {}),
                    href: GITHUB_CONFIG.scriptUrl,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: "更新脚本"
                  }
                )
              ] }) })
            ] }) })
          }
        );
      });
      var lodash$1 = { exports: {} };
      /**
       * @license
       * Lodash <https://lodash.com/>
       * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
       * Released under MIT license <https://lodash.com/license>
       * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
       * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
       */
      var lodash = lodash$1.exports;
      var hasRequiredLodash;
      function requireLodash() {
        if (hasRequiredLodash) return lodash$1.exports;
        hasRequiredLodash = 1;
        (function(module, exports) {
          (function() {
            var undefined$1;
            var VERSION = "4.17.21";
            var LARGE_ARRAY_SIZE = 200;
            var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
            var HASH_UNDEFINED = "__lodash_hash_undefined__";
            var MAX_MEMOIZE_SIZE = 500;
            var PLACEHOLDER = "__lodash_placeholder__";
            var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
            var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
            var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
            var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
            var HOT_COUNT = 800, HOT_SPAN = 16;
            var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
            var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
            var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
            var wrapFlags = [
              ["ary", WRAP_ARY_FLAG],
              ["bind", WRAP_BIND_FLAG],
              ["bindKey", WRAP_BIND_KEY_FLAG],
              ["curry", WRAP_CURRY_FLAG],
              ["curryRight", WRAP_CURRY_RIGHT_FLAG],
              ["flip", WRAP_FLIP_FLAG],
              ["partial", WRAP_PARTIAL_FLAG],
              ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
              ["rearg", WRAP_REARG_FLAG]
            ];
            var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
            var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
            var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
            var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
            var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
            var reTrimStart = /^\s+/;
            var reWhitespace = /\s/;
            var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
            var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
            var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
            var reEscapeChar = /\\(\\)?/g;
            var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
            var reFlags = /\w*$/;
            var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
            var reIsBinary = /^0b[01]+$/i;
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            var reIsOctal = /^0o[0-7]+$/i;
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
            var reNoMatch = /($^)/;
            var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
            var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
            var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
            var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
            var reApos = RegExp(rsApos, "g");
            var reComboMark = RegExp(rsCombo, "g");
            var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
            var reUnicodeWord = RegExp([
              rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
              rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
              rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
              rsUpper + "+" + rsOptContrUpper,
              rsOrdUpper,
              rsOrdLower,
              rsDigits,
              rsEmoji
            ].join("|"), "g");
            var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
            var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
            var contextProps = [
              "Array",
              "Buffer",
              "DataView",
              "Date",
              "Error",
              "Float32Array",
              "Float64Array",
              "Function",
              "Int8Array",
              "Int16Array",
              "Int32Array",
              "Map",
              "Math",
              "Object",
              "Promise",
              "RegExp",
              "Set",
              "String",
              "Symbol",
              "TypeError",
              "Uint8Array",
              "Uint8ClampedArray",
              "Uint16Array",
              "Uint32Array",
              "WeakMap",
              "_",
              "clearTimeout",
              "isFinite",
              "parseInt",
              "setTimeout"
            ];
            var templateCounter = -1;
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
            var cloneableTags = {};
            cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
            cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
            var deburredLetters = {
              // Latin-1 Supplement block.
              "À": "A",
              "Á": "A",
              "Â": "A",
              "Ã": "A",
              "Ä": "A",
              "Å": "A",
              "à": "a",
              "á": "a",
              "â": "a",
              "ã": "a",
              "ä": "a",
              "å": "a",
              "Ç": "C",
              "ç": "c",
              "Ð": "D",
              "ð": "d",
              "È": "E",
              "É": "E",
              "Ê": "E",
              "Ë": "E",
              "è": "e",
              "é": "e",
              "ê": "e",
              "ë": "e",
              "Ì": "I",
              "Í": "I",
              "Î": "I",
              "Ï": "I",
              "ì": "i",
              "í": "i",
              "î": "i",
              "ï": "i",
              "Ñ": "N",
              "ñ": "n",
              "Ò": "O",
              "Ó": "O",
              "Ô": "O",
              "Õ": "O",
              "Ö": "O",
              "Ø": "O",
              "ò": "o",
              "ó": "o",
              "ô": "o",
              "õ": "o",
              "ö": "o",
              "ø": "o",
              "Ù": "U",
              "Ú": "U",
              "Û": "U",
              "Ü": "U",
              "ù": "u",
              "ú": "u",
              "û": "u",
              "ü": "u",
              "Ý": "Y",
              "ý": "y",
              "ÿ": "y",
              "Æ": "Ae",
              "æ": "ae",
              "Þ": "Th",
              "þ": "th",
              "ß": "ss",
              // Latin Extended-A block.
              "Ā": "A",
              "Ă": "A",
              "Ą": "A",
              "ā": "a",
              "ă": "a",
              "ą": "a",
              "Ć": "C",
              "Ĉ": "C",
              "Ċ": "C",
              "Č": "C",
              "ć": "c",
              "ĉ": "c",
              "ċ": "c",
              "č": "c",
              "Ď": "D",
              "Đ": "D",
              "ď": "d",
              "đ": "d",
              "Ē": "E",
              "Ĕ": "E",
              "Ė": "E",
              "Ę": "E",
              "Ě": "E",
              "ē": "e",
              "ĕ": "e",
              "ė": "e",
              "ę": "e",
              "ě": "e",
              "Ĝ": "G",
              "Ğ": "G",
              "Ġ": "G",
              "Ģ": "G",
              "ĝ": "g",
              "ğ": "g",
              "ġ": "g",
              "ģ": "g",
              "Ĥ": "H",
              "Ħ": "H",
              "ĥ": "h",
              "ħ": "h",
              "Ĩ": "I",
              "Ī": "I",
              "Ĭ": "I",
              "Į": "I",
              "İ": "I",
              "ĩ": "i",
              "ī": "i",
              "ĭ": "i",
              "į": "i",
              "ı": "i",
              "Ĵ": "J",
              "ĵ": "j",
              "Ķ": "K",
              "ķ": "k",
              "ĸ": "k",
              "Ĺ": "L",
              "Ļ": "L",
              "Ľ": "L",
              "Ŀ": "L",
              "Ł": "L",
              "ĺ": "l",
              "ļ": "l",
              "ľ": "l",
              "ŀ": "l",
              "ł": "l",
              "Ń": "N",
              "Ņ": "N",
              "Ň": "N",
              "Ŋ": "N",
              "ń": "n",
              "ņ": "n",
              "ň": "n",
              "ŋ": "n",
              "Ō": "O",
              "Ŏ": "O",
              "Ő": "O",
              "ō": "o",
              "ŏ": "o",
              "ő": "o",
              "Ŕ": "R",
              "Ŗ": "R",
              "Ř": "R",
              "ŕ": "r",
              "ŗ": "r",
              "ř": "r",
              "Ś": "S",
              "Ŝ": "S",
              "Ş": "S",
              "Š": "S",
              "ś": "s",
              "ŝ": "s",
              "ş": "s",
              "š": "s",
              "Ţ": "T",
              "Ť": "T",
              "Ŧ": "T",
              "ţ": "t",
              "ť": "t",
              "ŧ": "t",
              "Ũ": "U",
              "Ū": "U",
              "Ŭ": "U",
              "Ů": "U",
              "Ű": "U",
              "Ų": "U",
              "ũ": "u",
              "ū": "u",
              "ŭ": "u",
              "ů": "u",
              "ű": "u",
              "ų": "u",
              "Ŵ": "W",
              "ŵ": "w",
              "Ŷ": "Y",
              "ŷ": "y",
              "Ÿ": "Y",
              "Ź": "Z",
              "Ż": "Z",
              "Ž": "Z",
              "ź": "z",
              "ż": "z",
              "ž": "z",
              "Ĳ": "IJ",
              "ĳ": "ij",
              "Œ": "Oe",
              "œ": "oe",
              "ŉ": "'n",
              "ſ": "s"
            };
            var htmlEscapes = {
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;"
            };
            var htmlUnescapes = {
              "&amp;": "&",
              "&lt;": "<",
              "&gt;": ">",
              "&quot;": '"',
              "&#39;": "'"
            };
            var stringEscapes = {
              "\\": "\\",
              "'": "'",
              "\n": "n",
              "\r": "r",
              "\u2028": "u2028",
              "\u2029": "u2029"
            };
            var freeParseFloat = parseFloat, freeParseInt = parseInt;
            var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
            var freeSelf = typeof self == "object" && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function("return this")();
            var freeExports = exports && !exports.nodeType && exports;
            var freeModule = freeExports && true && module && !module.nodeType && module;
            var moduleExports = freeModule && freeModule.exports === freeExports;
            var freeProcess = moduleExports && freeGlobal.process;
            var nodeUtil = (function() {
              try {
                var types = freeModule && freeModule.require && freeModule.require("util").types;
                if (types) {
                  return types;
                }
                return freeProcess && freeProcess.binding && freeProcess.binding("util");
              } catch (e) {
              }
            })();
            var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
            function apply(func, thisArg, args) {
              switch (args.length) {
                case 0:
                  return func.call(thisArg);
                case 1:
                  return func.call(thisArg, args[0]);
                case 2:
                  return func.call(thisArg, args[0], args[1]);
                case 3:
                  return func.call(thisArg, args[0], args[1], args[2]);
              }
              return func.apply(thisArg, args);
            }
            function arrayAggregator(array, setter, iteratee, accumulator) {
              var index2 = -1, length = array == null ? 0 : array.length;
              while (++index2 < length) {
                var value = array[index2];
                setter(accumulator, value, iteratee(value), array);
              }
              return accumulator;
            }
            function arrayEach(array, iteratee) {
              var index2 = -1, length = array == null ? 0 : array.length;
              while (++index2 < length) {
                if (iteratee(array[index2], index2, array) === false) {
                  break;
                }
              }
              return array;
            }
            function arrayEachRight(array, iteratee) {
              var length = array == null ? 0 : array.length;
              while (length--) {
                if (iteratee(array[length], length, array) === false) {
                  break;
                }
              }
              return array;
            }
            function arrayEvery(array, predicate) {
              var index2 = -1, length = array == null ? 0 : array.length;
              while (++index2 < length) {
                if (!predicate(array[index2], index2, array)) {
                  return false;
                }
              }
              return true;
            }
            function arrayFilter(array, predicate) {
              var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
              while (++index2 < length) {
                var value = array[index2];
                if (predicate(value, index2, array)) {
                  result[resIndex++] = value;
                }
              }
              return result;
            }
            function arrayIncludes(array, value) {
              var length = array == null ? 0 : array.length;
              return !!length && baseIndexOf(array, value, 0) > -1;
            }
            function arrayIncludesWith(array, value, comparator) {
              var index2 = -1, length = array == null ? 0 : array.length;
              while (++index2 < length) {
                if (comparator(value, array[index2])) {
                  return true;
                }
              }
              return false;
            }
            function arrayMap(array, iteratee) {
              var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
              while (++index2 < length) {
                result[index2] = iteratee(array[index2], index2, array);
              }
              return result;
            }
            function arrayPush(array, values) {
              var index2 = -1, length = values.length, offset = array.length;
              while (++index2 < length) {
                array[offset + index2] = values[index2];
              }
              return array;
            }
            function arrayReduce(array, iteratee, accumulator, initAccum) {
              var index2 = -1, length = array == null ? 0 : array.length;
              if (initAccum && length) {
                accumulator = array[++index2];
              }
              while (++index2 < length) {
                accumulator = iteratee(accumulator, array[index2], index2, array);
              }
              return accumulator;
            }
            function arrayReduceRight(array, iteratee, accumulator, initAccum) {
              var length = array == null ? 0 : array.length;
              if (initAccum && length) {
                accumulator = array[--length];
              }
              while (length--) {
                accumulator = iteratee(accumulator, array[length], length, array);
              }
              return accumulator;
            }
            function arraySome(array, predicate) {
              var index2 = -1, length = array == null ? 0 : array.length;
              while (++index2 < length) {
                if (predicate(array[index2], index2, array)) {
                  return true;
                }
              }
              return false;
            }
            var asciiSize = baseProperty("length");
            function asciiToArray(string) {
              return string.split("");
            }
            function asciiWords(string) {
              return string.match(reAsciiWord) || [];
            }
            function baseFindKey(collection, predicate, eachFunc) {
              var result;
              eachFunc(collection, function(value, key, collection2) {
                if (predicate(value, key, collection2)) {
                  result = key;
                  return false;
                }
              });
              return result;
            }
            function baseFindIndex(array, predicate, fromIndex, fromRight) {
              var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
              while (fromRight ? index2-- : ++index2 < length) {
                if (predicate(array[index2], index2, array)) {
                  return index2;
                }
              }
              return -1;
            }
            function baseIndexOf(array, value, fromIndex) {
              return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
            }
            function baseIndexOfWith(array, value, fromIndex, comparator) {
              var index2 = fromIndex - 1, length = array.length;
              while (++index2 < length) {
                if (comparator(array[index2], value)) {
                  return index2;
                }
              }
              return -1;
            }
            function baseIsNaN(value) {
              return value !== value;
            }
            function baseMean(array, iteratee) {
              var length = array == null ? 0 : array.length;
              return length ? baseSum(array, iteratee) / length : NAN;
            }
            function baseProperty(key) {
              return function(object) {
                return object == null ? undefined$1 : object[key];
              };
            }
            function basePropertyOf(object) {
              return function(key) {
                return object == null ? undefined$1 : object[key];
              };
            }
            function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
              eachFunc(collection, function(value, index2, collection2) {
                accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
              });
              return accumulator;
            }
            function baseSortBy(array, comparer) {
              var length = array.length;
              array.sort(comparer);
              while (length--) {
                array[length] = array[length].value;
              }
              return array;
            }
            function baseSum(array, iteratee) {
              var result, index2 = -1, length = array.length;
              while (++index2 < length) {
                var current = iteratee(array[index2]);
                if (current !== undefined$1) {
                  result = result === undefined$1 ? current : result + current;
                }
              }
              return result;
            }
            function baseTimes(n, iteratee) {
              var index2 = -1, result = Array(n);
              while (++index2 < n) {
                result[index2] = iteratee(index2);
              }
              return result;
            }
            function baseToPairs(object, props) {
              return arrayMap(props, function(key) {
                return [key, object[key]];
              });
            }
            function baseTrim(string) {
              return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
            }
            function baseUnary(func) {
              return function(value) {
                return func(value);
              };
            }
            function baseValues(object, props) {
              return arrayMap(props, function(key) {
                return object[key];
              });
            }
            function cacheHas(cache, key) {
              return cache.has(key);
            }
            function charsStartIndex(strSymbols, chrSymbols) {
              var index2 = -1, length = strSymbols.length;
              while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
              }
              return index2;
            }
            function charsEndIndex(strSymbols, chrSymbols) {
              var index2 = strSymbols.length;
              while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
              }
              return index2;
            }
            function countHolders(array, placeholder) {
              var length = array.length, result = 0;
              while (length--) {
                if (array[length] === placeholder) {
                  ++result;
                }
              }
              return result;
            }
            var deburrLetter = basePropertyOf(deburredLetters);
            var escapeHtmlChar = basePropertyOf(htmlEscapes);
            function escapeStringChar(chr) {
              return "\\" + stringEscapes[chr];
            }
            function getValue(object, key) {
              return object == null ? undefined$1 : object[key];
            }
            function hasUnicode(string) {
              return reHasUnicode.test(string);
            }
            function hasUnicodeWord(string) {
              return reHasUnicodeWord.test(string);
            }
            function iteratorToArray(iterator) {
              var data, result = [];
              while (!(data = iterator.next()).done) {
                result.push(data.value);
              }
              return result;
            }
            function mapToArray(map) {
              var index2 = -1, result = Array(map.size);
              map.forEach(function(value, key) {
                result[++index2] = [key, value];
              });
              return result;
            }
            function overArg(func, transform) {
              return function(arg) {
                return func(transform(arg));
              };
            }
            function replaceHolders(array, placeholder) {
              var index2 = -1, length = array.length, resIndex = 0, result = [];
              while (++index2 < length) {
                var value = array[index2];
                if (value === placeholder || value === PLACEHOLDER) {
                  array[index2] = PLACEHOLDER;
                  result[resIndex++] = index2;
                }
              }
              return result;
            }
            function setToArray(set) {
              var index2 = -1, result = Array(set.size);
              set.forEach(function(value) {
                result[++index2] = value;
              });
              return result;
            }
            function setToPairs(set) {
              var index2 = -1, result = Array(set.size);
              set.forEach(function(value) {
                result[++index2] = [value, value];
              });
              return result;
            }
            function strictIndexOf(array, value, fromIndex) {
              var index2 = fromIndex - 1, length = array.length;
              while (++index2 < length) {
                if (array[index2] === value) {
                  return index2;
                }
              }
              return -1;
            }
            function strictLastIndexOf(array, value, fromIndex) {
              var index2 = fromIndex + 1;
              while (index2--) {
                if (array[index2] === value) {
                  return index2;
                }
              }
              return index2;
            }
            function stringSize(string) {
              return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
            }
            function stringToArray(string) {
              return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
            }
            function trimmedEndIndex(string) {
              var index2 = string.length;
              while (index2-- && reWhitespace.test(string.charAt(index2))) {
              }
              return index2;
            }
            var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
            function unicodeSize(string) {
              var result = reUnicode.lastIndex = 0;
              while (reUnicode.test(string)) {
                ++result;
              }
              return result;
            }
            function unicodeToArray(string) {
              return string.match(reUnicode) || [];
            }
            function unicodeWords(string) {
              return string.match(reUnicodeWord) || [];
            }
            var runInContext = (function runInContext2(context) {
              context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
              var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
              var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
              var coreJsData = context["__core-js_shared__"];
              var funcToString = funcProto.toString;
              var hasOwnProperty = objectProto.hasOwnProperty;
              var idCounter = 0;
              var maskSrcKey = (function() {
                var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                return uid ? "Symbol(src)_1." + uid : "";
              })();
              var nativeObjectToString = objectProto.toString;
              var objectCtorString = funcToString.call(Object2);
              var oldDash = root._;
              var reIsNative = RegExp2(
                "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
              );
              var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
              var defineProperty2 = (function() {
                try {
                  var func = getNative(Object2, "defineProperty");
                  func({}, "", {});
                  return func;
                } catch (e) {
                }
              })();
              var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
              var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
              var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
              var metaMap = WeakMap2 && new WeakMap2();
              var realNames = {};
              var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
              var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
              function lodash2(value) {
                if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                  if (value instanceof LodashWrapper) {
                    return value;
                  }
                  if (hasOwnProperty.call(value, "__wrapped__")) {
                    return wrapperClone(value);
                  }
                }
                return new LodashWrapper(value);
              }
              var baseCreate = /* @__PURE__ */ (function() {
                function object() {
                }
                return function(proto) {
                  if (!isObject(proto)) {
                    return {};
                  }
                  if (objectCreate) {
                    return objectCreate(proto);
                  }
                  object.prototype = proto;
                  var result2 = new object();
                  object.prototype = undefined$1;
                  return result2;
                };
              })();
              function baseLodash() {
              }
              function LodashWrapper(value, chainAll) {
                this.__wrapped__ = value;
                this.__actions__ = [];
                this.__chain__ = !!chainAll;
                this.__index__ = 0;
                this.__values__ = undefined$1;
              }
              lodash2.templateSettings = {
                /**
                 * Used to detect `data` property values to be HTML-escaped.
                 *
                 * @memberOf _.templateSettings
                 * @type {RegExp}
                 */
                "escape": reEscape,
                /**
                 * Used to detect code to be evaluated.
                 *
                 * @memberOf _.templateSettings
                 * @type {RegExp}
                 */
                "evaluate": reEvaluate,
                /**
                 * Used to detect `data` property values to inject.
                 *
                 * @memberOf _.templateSettings
                 * @type {RegExp}
                 */
                "interpolate": reInterpolate,
                /**
                 * Used to reference the data object in the template text.
                 *
                 * @memberOf _.templateSettings
                 * @type {string}
                 */
                "variable": "",
                /**
                 * Used to import variables into the compiled template.
                 *
                 * @memberOf _.templateSettings
                 * @type {Object}
                 */
                "imports": {
                  /**
                   * A reference to the `lodash` function.
                   *
                   * @memberOf _.templateSettings.imports
                   * @type {Function}
                   */
                  "_": lodash2
                }
              };
              lodash2.prototype = baseLodash.prototype;
              lodash2.prototype.constructor = lodash2;
              LodashWrapper.prototype = baseCreate(baseLodash.prototype);
              LodashWrapper.prototype.constructor = LodashWrapper;
              function LazyWrapper(value) {
                this.__wrapped__ = value;
                this.__actions__ = [];
                this.__dir__ = 1;
                this.__filtered__ = false;
                this.__iteratees__ = [];
                this.__takeCount__ = MAX_ARRAY_LENGTH;
                this.__views__ = [];
              }
              function lazyClone() {
                var result2 = new LazyWrapper(this.__wrapped__);
                result2.__actions__ = copyArray(this.__actions__);
                result2.__dir__ = this.__dir__;
                result2.__filtered__ = this.__filtered__;
                result2.__iteratees__ = copyArray(this.__iteratees__);
                result2.__takeCount__ = this.__takeCount__;
                result2.__views__ = copyArray(this.__views__);
                return result2;
              }
              function lazyReverse() {
                if (this.__filtered__) {
                  var result2 = new LazyWrapper(this);
                  result2.__dir__ = -1;
                  result2.__filtered__ = true;
                } else {
                  result2 = this.clone();
                  result2.__dir__ *= -1;
                }
                return result2;
              }
              function lazyValue() {
                var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
                if (!isArr || !isRight && arrLength == length && takeCount == length) {
                  return baseWrapperValue(array, this.__actions__);
                }
                var result2 = [];
                outer:
                  while (length-- && resIndex < takeCount) {
                    index2 += dir;
                    var iterIndex = -1, value = array[index2];
                    while (++iterIndex < iterLength) {
                      var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                      if (type == LAZY_MAP_FLAG) {
                        value = computed;
                      } else if (!computed) {
                        if (type == LAZY_FILTER_FLAG) {
                          continue outer;
                        } else {
                          break outer;
                        }
                      }
                    }
                    result2[resIndex++] = value;
                  }
                return result2;
              }
              LazyWrapper.prototype = baseCreate(baseLodash.prototype);
              LazyWrapper.prototype.constructor = LazyWrapper;
              function Hash(entries) {
                var index2 = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index2 < length) {
                  var entry = entries[index2];
                  this.set(entry[0], entry[1]);
                }
              }
              function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {};
                this.size = 0;
              }
              function hashDelete(key) {
                var result2 = this.has(key) && delete this.__data__[key];
                this.size -= result2 ? 1 : 0;
                return result2;
              }
              function hashGet(key) {
                var data = this.__data__;
                if (nativeCreate) {
                  var result2 = data[key];
                  return result2 === HASH_UNDEFINED ? undefined$1 : result2;
                }
                return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
              }
              function hashHas(key) {
                var data = this.__data__;
                return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty.call(data, key);
              }
              function hashSet(key, value) {
                var data = this.__data__;
                this.size += this.has(key) ? 0 : 1;
                data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
                return this;
              }
              Hash.prototype.clear = hashClear;
              Hash.prototype["delete"] = hashDelete;
              Hash.prototype.get = hashGet;
              Hash.prototype.has = hashHas;
              Hash.prototype.set = hashSet;
              function ListCache(entries) {
                var index2 = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index2 < length) {
                  var entry = entries[index2];
                  this.set(entry[0], entry[1]);
                }
              }
              function listCacheClear() {
                this.__data__ = [];
                this.size = 0;
              }
              function listCacheDelete(key) {
                var data = this.__data__, index2 = assocIndexOf(data, key);
                if (index2 < 0) {
                  return false;
                }
                var lastIndex = data.length - 1;
                if (index2 == lastIndex) {
                  data.pop();
                } else {
                  splice.call(data, index2, 1);
                }
                --this.size;
                return true;
              }
              function listCacheGet(key) {
                var data = this.__data__, index2 = assocIndexOf(data, key);
                return index2 < 0 ? undefined$1 : data[index2][1];
              }
              function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1;
              }
              function listCacheSet(key, value) {
                var data = this.__data__, index2 = assocIndexOf(data, key);
                if (index2 < 0) {
                  ++this.size;
                  data.push([key, value]);
                } else {
                  data[index2][1] = value;
                }
                return this;
              }
              ListCache.prototype.clear = listCacheClear;
              ListCache.prototype["delete"] = listCacheDelete;
              ListCache.prototype.get = listCacheGet;
              ListCache.prototype.has = listCacheHas;
              ListCache.prototype.set = listCacheSet;
              function MapCache(entries) {
                var index2 = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index2 < length) {
                  var entry = entries[index2];
                  this.set(entry[0], entry[1]);
                }
              }
              function mapCacheClear() {
                this.size = 0;
                this.__data__ = {
                  "hash": new Hash(),
                  "map": new (Map2 || ListCache)(),
                  "string": new Hash()
                };
              }
              function mapCacheDelete(key) {
                var result2 = getMapData(this, key)["delete"](key);
                this.size -= result2 ? 1 : 0;
                return result2;
              }
              function mapCacheGet(key) {
                return getMapData(this, key).get(key);
              }
              function mapCacheHas(key) {
                return getMapData(this, key).has(key);
              }
              function mapCacheSet(key, value) {
                var data = getMapData(this, key), size2 = data.size;
                data.set(key, value);
                this.size += data.size == size2 ? 0 : 1;
                return this;
              }
              MapCache.prototype.clear = mapCacheClear;
              MapCache.prototype["delete"] = mapCacheDelete;
              MapCache.prototype.get = mapCacheGet;
              MapCache.prototype.has = mapCacheHas;
              MapCache.prototype.set = mapCacheSet;
              function SetCache(values2) {
                var index2 = -1, length = values2 == null ? 0 : values2.length;
                this.__data__ = new MapCache();
                while (++index2 < length) {
                  this.add(values2[index2]);
                }
              }
              function setCacheAdd(value) {
                this.__data__.set(value, HASH_UNDEFINED);
                return this;
              }
              function setCacheHas(value) {
                return this.__data__.has(value);
              }
              SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
              SetCache.prototype.has = setCacheHas;
              function Stack(entries) {
                var data = this.__data__ = new ListCache(entries);
                this.size = data.size;
              }
              function stackClear() {
                this.__data__ = new ListCache();
                this.size = 0;
              }
              function stackDelete(key) {
                var data = this.__data__, result2 = data["delete"](key);
                this.size = data.size;
                return result2;
              }
              function stackGet(key) {
                return this.__data__.get(key);
              }
              function stackHas(key) {
                return this.__data__.has(key);
              }
              function stackSet(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache) {
                  var pairs = data.__data__;
                  if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                    pairs.push([key, value]);
                    this.size = ++data.size;
                    return this;
                  }
                  data = this.__data__ = new MapCache(pairs);
                }
                data.set(key, value);
                this.size = data.size;
                return this;
              }
              Stack.prototype.clear = stackClear;
              Stack.prototype["delete"] = stackDelete;
              Stack.prototype.get = stackGet;
              Stack.prototype.has = stackHas;
              Stack.prototype.set = stackSet;
              function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType2, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
                for (var key in value) {
                  if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                  (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                  isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                  isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
                  isIndex(key, length)))) {
                    result2.push(key);
                  }
                }
                return result2;
              }
              function arraySample(array) {
                var length = array.length;
                return length ? array[baseRandom(0, length - 1)] : undefined$1;
              }
              function arraySampleSize(array, n) {
                return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
              }
              function arrayShuffle(array) {
                return shuffleSelf(copyArray(array));
              }
              function assignMergeValue(object, key, value) {
                if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
                  baseAssignValue(object, key, value);
                }
              }
              function assignValue(object, key, value) {
                var objValue = object[key];
                if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
                  baseAssignValue(object, key, value);
                }
              }
              function assocIndexOf(array, key) {
                var length = array.length;
                while (length--) {
                  if (eq(array[length][0], key)) {
                    return length;
                  }
                }
                return -1;
              }
              function baseAggregator(collection, setter, iteratee2, accumulator) {
                baseEach(collection, function(value, key, collection2) {
                  setter(accumulator, value, iteratee2(value), collection2);
                });
                return accumulator;
              }
              function baseAssign(object, source) {
                return object && copyObject(source, keys(source), object);
              }
              function baseAssignIn(object, source) {
                return object && copyObject(source, keysIn(source), object);
              }
              function baseAssignValue(object, key, value) {
                if (key == "__proto__" && defineProperty2) {
                  defineProperty2(object, key, {
                    "configurable": true,
                    "enumerable": true,
                    "value": value,
                    "writable": true
                  });
                } else {
                  object[key] = value;
                }
              }
              function baseAt(object, paths) {
                var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
                while (++index2 < length) {
                  result2[index2] = skip ? undefined$1 : get(object, paths[index2]);
                }
                return result2;
              }
              function baseClamp(number, lower, upper) {
                if (number === number) {
                  if (upper !== undefined$1) {
                    number = number <= upper ? number : upper;
                  }
                  if (lower !== undefined$1) {
                    number = number >= lower ? number : lower;
                  }
                }
                return number;
              }
              function baseClone(value, bitmask, customizer, key, object, stack) {
                var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                if (customizer) {
                  result2 = object ? customizer(value, key, object, stack) : customizer(value);
                }
                if (result2 !== undefined$1) {
                  return result2;
                }
                if (!isObject(value)) {
                  return value;
                }
                var isArr = isArray(value);
                if (isArr) {
                  result2 = initCloneArray(value);
                  if (!isDeep) {
                    return copyArray(value, result2);
                  }
                } else {
                  var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                  if (isBuffer(value)) {
                    return cloneBuffer(value, isDeep);
                  }
                  if (tag == objectTag || tag == argsTag || isFunc && !object) {
                    result2 = isFlat || isFunc ? {} : initCloneObject(value);
                    if (!isDeep) {
                      return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                    }
                  } else {
                    if (!cloneableTags[tag]) {
                      return object ? value : {};
                    }
                    result2 = initCloneByTag(value, tag, isDeep);
                  }
                }
                stack || (stack = new Stack());
                var stacked = stack.get(value);
                if (stacked) {
                  return stacked;
                }
                stack.set(value, result2);
                if (isSet(value)) {
                  value.forEach(function(subValue) {
                    result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
                  });
                } else if (isMap(value)) {
                  value.forEach(function(subValue, key2) {
                    result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
                  });
                }
                var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
                var props = isArr ? undefined$1 : keysFunc(value);
                arrayEach(props || value, function(subValue, key2) {
                  if (props) {
                    key2 = subValue;
                    subValue = value[key2];
                  }
                  assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
                });
                return result2;
              }
              function baseConforms(source) {
                var props = keys(source);
                return function(object) {
                  return baseConformsTo(object, source, props);
                };
              }
              function baseConformsTo(object, source, props) {
                var length = props.length;
                if (object == null) {
                  return !length;
                }
                object = Object2(object);
                while (length--) {
                  var key = props[length], predicate = source[key], value = object[key];
                  if (value === undefined$1 && !(key in object) || !predicate(value)) {
                    return false;
                  }
                }
                return true;
              }
              function baseDelay(func, wait, args) {
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                return setTimeout2(function() {
                  func.apply(undefined$1, args);
                }, wait);
              }
              function baseDifference(array, values2, iteratee2, comparator) {
                var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
                if (!length) {
                  return result2;
                }
                if (iteratee2) {
                  values2 = arrayMap(values2, baseUnary(iteratee2));
                }
                if (comparator) {
                  includes2 = arrayIncludesWith;
                  isCommon = false;
                } else if (values2.length >= LARGE_ARRAY_SIZE) {
                  includes2 = cacheHas;
                  isCommon = false;
                  values2 = new SetCache(values2);
                }
                outer:
                  while (++index2 < length) {
                    var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed === computed) {
                      var valuesIndex = valuesLength;
                      while (valuesIndex--) {
                        if (values2[valuesIndex] === computed) {
                          continue outer;
                        }
                      }
                      result2.push(value);
                    } else if (!includes2(values2, computed, comparator)) {
                      result2.push(value);
                    }
                  }
                return result2;
              }
              var baseEach = createBaseEach(baseForOwn);
              var baseEachRight = createBaseEach(baseForOwnRight, true);
              function baseEvery(collection, predicate) {
                var result2 = true;
                baseEach(collection, function(value, index2, collection2) {
                  result2 = !!predicate(value, index2, collection2);
                  return result2;
                });
                return result2;
              }
              function baseExtremum(array, iteratee2, comparator) {
                var index2 = -1, length = array.length;
                while (++index2 < length) {
                  var value = array[index2], current = iteratee2(value);
                  if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                    var computed = current, result2 = value;
                  }
                }
                return result2;
              }
              function baseFill(array, value, start, end) {
                var length = array.length;
                start = toInteger(start);
                if (start < 0) {
                  start = -start > length ? 0 : length + start;
                }
                end = end === undefined$1 || end > length ? length : toInteger(end);
                if (end < 0) {
                  end += length;
                }
                end = start > end ? 0 : toLength(end);
                while (start < end) {
                  array[start++] = value;
                }
                return array;
              }
              function baseFilter(collection, predicate) {
                var result2 = [];
                baseEach(collection, function(value, index2, collection2) {
                  if (predicate(value, index2, collection2)) {
                    result2.push(value);
                  }
                });
                return result2;
              }
              function baseFlatten(array, depth, predicate, isStrict, result2) {
                var index2 = -1, length = array.length;
                predicate || (predicate = isFlattenable);
                result2 || (result2 = []);
                while (++index2 < length) {
                  var value = array[index2];
                  if (depth > 0 && predicate(value)) {
                    if (depth > 1) {
                      baseFlatten(value, depth - 1, predicate, isStrict, result2);
                    } else {
                      arrayPush(result2, value);
                    }
                  } else if (!isStrict) {
                    result2[result2.length] = value;
                  }
                }
                return result2;
              }
              var baseFor = createBaseFor();
              var baseForRight = createBaseFor(true);
              function baseForOwn(object, iteratee2) {
                return object && baseFor(object, iteratee2, keys);
              }
              function baseForOwnRight(object, iteratee2) {
                return object && baseForRight(object, iteratee2, keys);
              }
              function baseFunctions(object, props) {
                return arrayFilter(props, function(key) {
                  return isFunction2(object[key]);
                });
              }
              function baseGet(object, path) {
                path = castPath(path, object);
                var index2 = 0, length = path.length;
                while (object != null && index2 < length) {
                  object = object[toKey(path[index2++])];
                }
                return index2 && index2 == length ? object : undefined$1;
              }
              function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result2 = keysFunc(object);
                return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
              }
              function baseGetTag(value) {
                if (value == null) {
                  return value === undefined$1 ? undefinedTag : nullTag;
                }
                return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString2(value);
              }
              function baseGt(value, other) {
                return value > other;
              }
              function baseHas(object, key) {
                return object != null && hasOwnProperty.call(object, key);
              }
              function baseHasIn(object, key) {
                return object != null && key in Object2(object);
              }
              function baseInRange(number, start, end) {
                return number >= nativeMin(start, end) && number < nativeMax(start, end);
              }
              function baseIntersection(arrays, iteratee2, comparator) {
                var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
                while (othIndex--) {
                  var array = arrays[othIndex];
                  if (othIndex && iteratee2) {
                    array = arrayMap(array, baseUnary(iteratee2));
                  }
                  maxLength = nativeMin(array.length, maxLength);
                  caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
                }
                array = arrays[0];
                var index2 = -1, seen2 = caches[0];
                outer:
                  while (++index2 < length && result2.length < maxLength) {
                    var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
                    value = comparator || value !== 0 ? value : 0;
                    if (!(seen2 ? cacheHas(seen2, computed) : includes2(result2, computed, comparator))) {
                      othIndex = othLength;
                      while (--othIndex) {
                        var cache = caches[othIndex];
                        if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                          continue outer;
                        }
                      }
                      if (seen2) {
                        seen2.push(computed);
                      }
                      result2.push(value);
                    }
                  }
                return result2;
              }
              function baseInverter(object, setter, iteratee2, accumulator) {
                baseForOwn(object, function(value, key, object2) {
                  setter(accumulator, iteratee2(value), key, object2);
                });
                return accumulator;
              }
              function baseInvoke(object, path, args) {
                path = castPath(path, object);
                object = parent(object, path);
                var func = object == null ? object : object[toKey(last(path))];
                return func == null ? undefined$1 : apply(func, object, args);
              }
              function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag;
              }
              function baseIsArrayBuffer(value) {
                return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
              }
              function baseIsDate(value) {
                return isObjectLike(value) && baseGetTag(value) == dateTag;
              }
              function baseIsEqual(value, other, bitmask, customizer, stack) {
                if (value === other) {
                  return true;
                }
                if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
                  return value !== value && other !== other;
                }
                return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
              }
              function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                objTag = objTag == argsTag ? objectTag : objTag;
                othTag = othTag == argsTag ? objectTag : othTag;
                var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                if (isSameTag && isBuffer(object)) {
                  if (!isBuffer(other)) {
                    return false;
                  }
                  objIsArr = true;
                  objIsObj = false;
                }
                if (isSameTag && !objIsObj) {
                  stack || (stack = new Stack());
                  return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                }
                if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                  var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                  if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                    stack || (stack = new Stack());
                    return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                  }
                }
                if (!isSameTag) {
                  return false;
                }
                stack || (stack = new Stack());
                return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
              }
              function baseIsMap(value) {
                return isObjectLike(value) && getTag(value) == mapTag;
              }
              function baseIsMatch(object, source, matchData, customizer) {
                var index2 = matchData.length, length = index2, noCustomizer = !customizer;
                if (object == null) {
                  return !length;
                }
                object = Object2(object);
                while (index2--) {
                  var data = matchData[index2];
                  if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                    return false;
                  }
                }
                while (++index2 < length) {
                  data = matchData[index2];
                  var key = data[0], objValue = object[key], srcValue = data[1];
                  if (noCustomizer && data[2]) {
                    if (objValue === undefined$1 && !(key in object)) {
                      return false;
                    }
                  } else {
                    var stack = new Stack();
                    if (customizer) {
                      var result2 = customizer(objValue, srcValue, key, object, source, stack);
                    }
                    if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                      return false;
                    }
                  }
                }
                return true;
              }
              function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) {
                  return false;
                }
                var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
                return pattern.test(toSource(value));
              }
              function baseIsRegExp(value) {
                return isObjectLike(value) && baseGetTag(value) == regexpTag;
              }
              function baseIsSet(value) {
                return isObjectLike(value) && getTag(value) == setTag;
              }
              function baseIsTypedArray(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
              }
              function baseIteratee(value) {
                if (typeof value == "function") {
                  return value;
                }
                if (value == null) {
                  return identity;
                }
                if (typeof value == "object") {
                  return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
                }
                return property(value);
              }
              function baseKeys(object) {
                if (!isPrototype(object)) {
                  return nativeKeys(object);
                }
                var result2 = [];
                for (var key in Object2(object)) {
                  if (hasOwnProperty.call(object, key) && key != "constructor") {
                    result2.push(key);
                  }
                }
                return result2;
              }
              function baseKeysIn(object) {
                if (!isObject(object)) {
                  return nativeKeysIn(object);
                }
                var isProto = isPrototype(object), result2 = [];
                for (var key in object) {
                  if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                    result2.push(key);
                  }
                }
                return result2;
              }
              function baseLt(value, other) {
                return value < other;
              }
              function baseMap(collection, iteratee2) {
                var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
                baseEach(collection, function(value, key, collection2) {
                  result2[++index2] = iteratee2(value, key, collection2);
                });
                return result2;
              }
              function baseMatches(source) {
                var matchData = getMatchData(source);
                if (matchData.length == 1 && matchData[0][2]) {
                  return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                }
                return function(object) {
                  return object === source || baseIsMatch(object, source, matchData);
                };
              }
              function baseMatchesProperty(path, srcValue) {
                if (isKey(path) && isStrictComparable(srcValue)) {
                  return matchesStrictComparable(toKey(path), srcValue);
                }
                return function(object) {
                  var objValue = get(object, path);
                  return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                };
              }
              function baseMerge(object, source, srcIndex, customizer, stack) {
                if (object === source) {
                  return;
                }
                baseFor(source, function(srcValue, key) {
                  stack || (stack = new Stack());
                  if (isObject(srcValue)) {
                    baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                  } else {
                    var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
                    if (newValue === undefined$1) {
                      newValue = srcValue;
                    }
                    assignMergeValue(object, key, newValue);
                  }
                }, keysIn);
              }
              function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
                if (stacked) {
                  assignMergeValue(object, key, stacked);
                  return;
                }
                var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
                var isCommon = newValue === undefined$1;
                if (isCommon) {
                  var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                  newValue = srcValue;
                  if (isArr || isBuff || isTyped) {
                    if (isArray(objValue)) {
                      newValue = objValue;
                    } else if (isArrayLikeObject(objValue)) {
                      newValue = copyArray(objValue);
                    } else if (isBuff) {
                      isCommon = false;
                      newValue = cloneBuffer(srcValue, true);
                    } else if (isTyped) {
                      isCommon = false;
                      newValue = cloneTypedArray(srcValue, true);
                    } else {
                      newValue = [];
                    }
                  } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    newValue = objValue;
                    if (isArguments(objValue)) {
                      newValue = toPlainObject(objValue);
                    } else if (!isObject(objValue) || isFunction2(objValue)) {
                      newValue = initCloneObject(srcValue);
                    }
                  } else {
                    isCommon = false;
                  }
                }
                if (isCommon) {
                  stack.set(srcValue, newValue);
                  mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                  stack["delete"](srcValue);
                }
                assignMergeValue(object, key, newValue);
              }
              function baseNth(array, n) {
                var length = array.length;
                if (!length) {
                  return;
                }
                n += n < 0 ? length : 0;
                return isIndex(n, length) ? array[n] : undefined$1;
              }
              function baseOrderBy(collection, iteratees, orders) {
                if (iteratees.length) {
                  iteratees = arrayMap(iteratees, function(iteratee2) {
                    if (isArray(iteratee2)) {
                      return function(value) {
                        return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                      };
                    }
                    return iteratee2;
                  });
                } else {
                  iteratees = [identity];
                }
                var index2 = -1;
                iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                var result2 = baseMap(collection, function(value, key, collection2) {
                  var criteria = arrayMap(iteratees, function(iteratee2) {
                    return iteratee2(value);
                  });
                  return { "criteria": criteria, "index": ++index2, "value": value };
                });
                return baseSortBy(result2, function(object, other) {
                  return compareMultiple(object, other, orders);
                });
              }
              function basePick(object, paths) {
                return basePickBy(object, paths, function(value, path) {
                  return hasIn(object, path);
                });
              }
              function basePickBy(object, paths, predicate) {
                var index2 = -1, length = paths.length, result2 = {};
                while (++index2 < length) {
                  var path = paths[index2], value = baseGet(object, path);
                  if (predicate(value, path)) {
                    baseSet(result2, castPath(path, object), value);
                  }
                }
                return result2;
              }
              function basePropertyDeep(path) {
                return function(object) {
                  return baseGet(object, path);
                };
              }
              function basePullAll(array, values2, iteratee2, comparator) {
                var indexOf3 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen2 = array;
                if (array === values2) {
                  values2 = copyArray(values2);
                }
                if (iteratee2) {
                  seen2 = arrayMap(array, baseUnary(iteratee2));
                }
                while (++index2 < length) {
                  var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
                  while ((fromIndex = indexOf3(seen2, computed, fromIndex, comparator)) > -1) {
                    if (seen2 !== array) {
                      splice.call(seen2, fromIndex, 1);
                    }
                    splice.call(array, fromIndex, 1);
                  }
                }
                return array;
              }
              function basePullAt(array, indexes) {
                var length = array ? indexes.length : 0, lastIndex = length - 1;
                while (length--) {
                  var index2 = indexes[length];
                  if (length == lastIndex || index2 !== previous) {
                    var previous = index2;
                    if (isIndex(index2)) {
                      splice.call(array, index2, 1);
                    } else {
                      baseUnset(array, index2);
                    }
                  }
                }
                return array;
              }
              function baseRandom(lower, upper) {
                return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
              }
              function baseRange(start, end, step, fromRight) {
                var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
                while (length--) {
                  result2[fromRight ? length : ++index2] = start;
                  start += step;
                }
                return result2;
              }
              function baseRepeat(string, n) {
                var result2 = "";
                if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                  return result2;
                }
                do {
                  if (n % 2) {
                    result2 += string;
                  }
                  n = nativeFloor(n / 2);
                  if (n) {
                    string += string;
                  }
                } while (n);
                return result2;
              }
              function baseRest(func, start) {
                return setToString(overRest(func, start, identity), func + "");
              }
              function baseSample(collection) {
                return arraySample(values(collection));
              }
              function baseSampleSize(collection, n) {
                var array = values(collection);
                return shuffleSelf(array, baseClamp(n, 0, array.length));
              }
              function baseSet(object, path, value, customizer) {
                if (!isObject(object)) {
                  return object;
                }
                path = castPath(path, object);
                var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
                while (nested != null && ++index2 < length) {
                  var key = toKey(path[index2]), newValue = value;
                  if (key === "__proto__" || key === "constructor" || key === "prototype") {
                    return object;
                  }
                  if (index2 != lastIndex) {
                    var objValue = nested[key];
                    newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
                    if (newValue === undefined$1) {
                      newValue = isObject(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
                    }
                  }
                  assignValue(nested, key, newValue);
                  nested = nested[key];
                }
                return object;
              }
              var baseSetData = !metaMap ? identity : function(func, data) {
                metaMap.set(func, data);
                return func;
              };
              var baseSetToString = !defineProperty2 ? identity : function(func, string) {
                return defineProperty2(func, "toString", {
                  "configurable": true,
                  "enumerable": false,
                  "value": constant(string),
                  "writable": true
                });
              };
              function baseShuffle(collection) {
                return shuffleSelf(values(collection));
              }
              function baseSlice(array, start, end) {
                var index2 = -1, length = array.length;
                if (start < 0) {
                  start = -start > length ? 0 : length + start;
                }
                end = end > length ? length : end;
                if (end < 0) {
                  end += length;
                }
                length = start > end ? 0 : end - start >>> 0;
                start >>>= 0;
                var result2 = Array2(length);
                while (++index2 < length) {
                  result2[index2] = array[index2 + start];
                }
                return result2;
              }
              function baseSome(collection, predicate) {
                var result2;
                baseEach(collection, function(value, index2, collection2) {
                  result2 = predicate(value, index2, collection2);
                  return !result2;
                });
                return !!result2;
              }
              function baseSortedIndex(array, value, retHighest) {
                var low = 0, high = array == null ? low : array.length;
                if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                  while (low < high) {
                    var mid = low + high >>> 1, computed = array[mid];
                    if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                      low = mid + 1;
                    } else {
                      high = mid;
                    }
                  }
                  return high;
                }
                return baseSortedIndexBy(array, value, identity, retHighest);
              }
              function baseSortedIndexBy(array, value, iteratee2, retHighest) {
                var low = 0, high = array == null ? 0 : array.length;
                if (high === 0) {
                  return 0;
                }
                value = iteratee2(value);
                var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
                while (low < high) {
                  var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                  if (valIsNaN) {
                    var setLow = retHighest || othIsReflexive;
                  } else if (valIsUndefined) {
                    setLow = othIsReflexive && (retHighest || othIsDefined);
                  } else if (valIsNull) {
                    setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                  } else if (valIsSymbol) {
                    setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                  } else if (othIsNull || othIsSymbol) {
                    setLow = false;
                  } else {
                    setLow = retHighest ? computed <= value : computed < value;
                  }
                  if (setLow) {
                    low = mid + 1;
                  } else {
                    high = mid;
                  }
                }
                return nativeMin(high, MAX_ARRAY_INDEX);
              }
              function baseSortedUniq(array, iteratee2) {
                var index2 = -1, length = array.length, resIndex = 0, result2 = [];
                while (++index2 < length) {
                  var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
                  if (!index2 || !eq(computed, seen2)) {
                    var seen2 = computed;
                    result2[resIndex++] = value === 0 ? 0 : value;
                  }
                }
                return result2;
              }
              function baseToNumber(value) {
                if (typeof value == "number") {
                  return value;
                }
                if (isSymbol(value)) {
                  return NAN;
                }
                return +value;
              }
              function baseToString(value) {
                if (typeof value == "string") {
                  return value;
                }
                if (isArray(value)) {
                  return arrayMap(value, baseToString) + "";
                }
                if (isSymbol(value)) {
                  return symbolToString ? symbolToString.call(value) : "";
                }
                var result2 = value + "";
                return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
              }
              function baseUniq(array, iteratee2, comparator) {
                var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen2 = result2;
                if (comparator) {
                  isCommon = false;
                  includes2 = arrayIncludesWith;
                } else if (length >= LARGE_ARRAY_SIZE) {
                  var set2 = iteratee2 ? null : createSet(array);
                  if (set2) {
                    return setToArray(set2);
                  }
                  isCommon = false;
                  includes2 = cacheHas;
                  seen2 = new SetCache();
                } else {
                  seen2 = iteratee2 ? [] : result2;
                }
                outer:
                  while (++index2 < length) {
                    var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed === computed) {
                      var seenIndex = seen2.length;
                      while (seenIndex--) {
                        if (seen2[seenIndex] === computed) {
                          continue outer;
                        }
                      }
                      if (iteratee2) {
                        seen2.push(computed);
                      }
                      result2.push(value);
                    } else if (!includes2(seen2, computed, comparator)) {
                      if (seen2 !== result2) {
                        seen2.push(computed);
                      }
                      result2.push(value);
                    }
                  }
                return result2;
              }
              function baseUnset(object, path) {
                path = castPath(path, object);
                object = parent(object, path);
                return object == null || delete object[toKey(last(path))];
              }
              function baseUpdate(object, path, updater, customizer) {
                return baseSet(object, path, updater(baseGet(object, path)), customizer);
              }
              function baseWhile(array, predicate, isDrop, fromRight) {
                var length = array.length, index2 = fromRight ? length : -1;
                while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
                }
                return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
              }
              function baseWrapperValue(value, actions) {
                var result2 = value;
                if (result2 instanceof LazyWrapper) {
                  result2 = result2.value();
                }
                return arrayReduce(actions, function(result3, action) {
                  return action.func.apply(action.thisArg, arrayPush([result3], action.args));
                }, result2);
              }
              function baseXor(arrays, iteratee2, comparator) {
                var length = arrays.length;
                if (length < 2) {
                  return length ? baseUniq(arrays[0]) : [];
                }
                var index2 = -1, result2 = Array2(length);
                while (++index2 < length) {
                  var array = arrays[index2], othIndex = -1;
                  while (++othIndex < length) {
                    if (othIndex != index2) {
                      result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
                    }
                  }
                }
                return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
              }
              function baseZipObject(props, values2, assignFunc) {
                var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
                while (++index2 < length) {
                  var value = index2 < valsLength ? values2[index2] : undefined$1;
                  assignFunc(result2, props[index2], value);
                }
                return result2;
              }
              function castArrayLikeObject(value) {
                return isArrayLikeObject(value) ? value : [];
              }
              function castFunction(value) {
                return typeof value == "function" ? value : identity;
              }
              function castPath(value, object) {
                if (isArray(value)) {
                  return value;
                }
                return isKey(value, object) ? [value] : stringToPath(toString(value));
              }
              var castRest = baseRest;
              function castSlice(array, start, end) {
                var length = array.length;
                end = end === undefined$1 ? length : end;
                return !start && end >= length ? array : baseSlice(array, start, end);
              }
              var clearTimeout = ctxClearTimeout || function(id) {
                return root.clearTimeout(id);
              };
              function cloneBuffer(buffer, isDeep) {
                if (isDeep) {
                  return buffer.slice();
                }
                var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                buffer.copy(result2);
                return result2;
              }
              function cloneArrayBuffer(arrayBuffer) {
                var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
                new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
                return result2;
              }
              function cloneDataView(dataView, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
              }
              function cloneRegExp(regexp) {
                var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                result2.lastIndex = regexp.lastIndex;
                return result2;
              }
              function cloneSymbol(symbol) {
                return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
              }
              function cloneTypedArray(typedArray, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
              }
              function compareAscending(value, other) {
                if (value !== other) {
                  var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
                  var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                  if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                    return 1;
                  }
                  if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                    return -1;
                  }
                }
                return 0;
              }
              function compareMultiple(object, other, orders) {
                var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
                while (++index2 < length) {
                  var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
                  if (result2) {
                    if (index2 >= ordersLength) {
                      return result2;
                    }
                    var order = orders[index2];
                    return result2 * (order == "desc" ? -1 : 1);
                  }
                }
                return object.index - other.index;
              }
              function composeArgs(args, partials, holders, isCurried) {
                var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
                while (++leftIndex < leftLength) {
                  result2[leftIndex] = partials[leftIndex];
                }
                while (++argsIndex < holdersLength) {
                  if (isUncurried || argsIndex < argsLength) {
                    result2[holders[argsIndex]] = args[argsIndex];
                  }
                }
                while (rangeLength--) {
                  result2[leftIndex++] = args[argsIndex++];
                }
                return result2;
              }
              function composeArgsRight(args, partials, holders, isCurried) {
                var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
                while (++argsIndex < rangeLength) {
                  result2[argsIndex] = args[argsIndex];
                }
                var offset = argsIndex;
                while (++rightIndex < rightLength) {
                  result2[offset + rightIndex] = partials[rightIndex];
                }
                while (++holdersIndex < holdersLength) {
                  if (isUncurried || argsIndex < argsLength) {
                    result2[offset + holders[holdersIndex]] = args[argsIndex++];
                  }
                }
                return result2;
              }
              function copyArray(source, array) {
                var index2 = -1, length = source.length;
                array || (array = Array2(length));
                while (++index2 < length) {
                  array[index2] = source[index2];
                }
                return array;
              }
              function copyObject(source, props, object, customizer) {
                var isNew = !object;
                object || (object = {});
                var index2 = -1, length = props.length;
                while (++index2 < length) {
                  var key = props[index2];
                  var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
                  if (newValue === undefined$1) {
                    newValue = source[key];
                  }
                  if (isNew) {
                    baseAssignValue(object, key, newValue);
                  } else {
                    assignValue(object, key, newValue);
                  }
                }
                return object;
              }
              function copySymbols(source, object) {
                return copyObject(source, getSymbols(source), object);
              }
              function copySymbolsIn(source, object) {
                return copyObject(source, getSymbolsIn(source), object);
              }
              function createAggregator(setter, initializer) {
                return function(collection, iteratee2) {
                  var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                  return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
                };
              }
              function createAssigner(assigner) {
                return baseRest(function(object, sources) {
                  var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
                  customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
                  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? undefined$1 : customizer;
                    length = 1;
                  }
                  object = Object2(object);
                  while (++index2 < length) {
                    var source = sources[index2];
                    if (source) {
                      assigner(object, source, index2, customizer);
                    }
                  }
                  return object;
                });
              }
              function createBaseEach(eachFunc, fromRight) {
                return function(collection, iteratee2) {
                  if (collection == null) {
                    return collection;
                  }
                  if (!isArrayLike(collection)) {
                    return eachFunc(collection, iteratee2);
                  }
                  var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
                  while (fromRight ? index2-- : ++index2 < length) {
                    if (iteratee2(iterable[index2], index2, iterable) === false) {
                      break;
                    }
                  }
                  return collection;
                };
              }
              function createBaseFor(fromRight) {
                return function(object, iteratee2, keysFunc) {
                  var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
                  while (length--) {
                    var key = props[fromRight ? length : ++index2];
                    if (iteratee2(iterable[key], key, iterable) === false) {
                      break;
                    }
                  }
                  return object;
                };
              }
              function createBind(func, bitmask, thisArg) {
                var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                function wrapper() {
                  var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                  return fn.apply(isBind ? thisArg : this, arguments);
                }
                return wrapper;
              }
              function createCaseFirst(methodName) {
                return function(string) {
                  string = toString(string);
                  var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
                  var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                  var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                  return chr[methodName]() + trailing;
                };
              }
              function createCompounder(callback) {
                return function(string) {
                  return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
                };
              }
              function createCtor(Ctor) {
                return function() {
                  var args = arguments;
                  switch (args.length) {
                    case 0:
                      return new Ctor();
                    case 1:
                      return new Ctor(args[0]);
                    case 2:
                      return new Ctor(args[0], args[1]);
                    case 3:
                      return new Ctor(args[0], args[1], args[2]);
                    case 4:
                      return new Ctor(args[0], args[1], args[2], args[3]);
                    case 5:
                      return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                    case 6:
                      return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                    case 7:
                      return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                  }
                  var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
                  return isObject(result2) ? result2 : thisBinding;
                };
              }
              function createCurry(func, bitmask, arity) {
                var Ctor = createCtor(func);
                function wrapper() {
                  var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
                  while (index2--) {
                    args[index2] = arguments[index2];
                  }
                  var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                  length -= holders.length;
                  if (length < arity) {
                    return createRecurry(
                      func,
                      bitmask,
                      createHybrid,
                      wrapper.placeholder,
                      undefined$1,
                      args,
                      holders,
                      undefined$1,
                      undefined$1,
                      arity - length
                    );
                  }
                  var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                  return apply(fn, this, args);
                }
                return wrapper;
              }
              function createFind(findIndexFunc) {
                return function(collection, predicate, fromIndex) {
                  var iterable = Object2(collection);
                  if (!isArrayLike(collection)) {
                    var iteratee2 = getIteratee(predicate, 3);
                    collection = keys(collection);
                    predicate = function(key) {
                      return iteratee2(iterable[key], key, iterable);
                    };
                  }
                  var index2 = findIndexFunc(collection, predicate, fromIndex);
                  return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
                };
              }
              function createFlow(fromRight) {
                return flatRest(function(funcs) {
                  var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
                  if (fromRight) {
                    funcs.reverse();
                  }
                  while (index2--) {
                    var func = funcs[index2];
                    if (typeof func != "function") {
                      throw new TypeError2(FUNC_ERROR_TEXT);
                    }
                    if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                      var wrapper = new LodashWrapper([], true);
                    }
                  }
                  index2 = wrapper ? index2 : length;
                  while (++index2 < length) {
                    func = funcs[index2];
                    var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
                    if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                      wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                    } else {
                      wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                    }
                  }
                  return function() {
                    var args = arguments, value = args[0];
                    if (wrapper && args.length == 1 && isArray(value)) {
                      return wrapper.plant(value).value();
                    }
                    var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
                    while (++index3 < length) {
                      result2 = funcs[index3].call(this, result2);
                    }
                    return result2;
                  };
                });
              }
              function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
                var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
                function wrapper() {
                  var length = arguments.length, args = Array2(length), index2 = length;
                  while (index2--) {
                    args[index2] = arguments[index2];
                  }
                  if (isCurried) {
                    var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                  }
                  if (partials) {
                    args = composeArgs(args, partials, holders, isCurried);
                  }
                  if (partialsRight) {
                    args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                  }
                  length -= holdersCount;
                  if (isCurried && length < arity) {
                    var newHolders = replaceHolders(args, placeholder);
                    return createRecurry(
                      func,
                      bitmask,
                      createHybrid,
                      wrapper.placeholder,
                      thisArg,
                      args,
                      newHolders,
                      argPos,
                      ary2,
                      arity - length
                    );
                  }
                  var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                  length = args.length;
                  if (argPos) {
                    args = reorder(args, argPos);
                  } else if (isFlip && length > 1) {
                    args.reverse();
                  }
                  if (isAry && ary2 < length) {
                    args.length = ary2;
                  }
                  if (this && this !== root && this instanceof wrapper) {
                    fn = Ctor || createCtor(fn);
                  }
                  return fn.apply(thisBinding, args);
                }
                return wrapper;
              }
              function createInverter(setter, toIteratee) {
                return function(object, iteratee2) {
                  return baseInverter(object, setter, toIteratee(iteratee2), {});
                };
              }
              function createMathOperation(operator, defaultValue) {
                return function(value, other) {
                  var result2;
                  if (value === undefined$1 && other === undefined$1) {
                    return defaultValue;
                  }
                  if (value !== undefined$1) {
                    result2 = value;
                  }
                  if (other !== undefined$1) {
                    if (result2 === undefined$1) {
                      return other;
                    }
                    if (typeof value == "string" || typeof other == "string") {
                      value = baseToString(value);
                      other = baseToString(other);
                    } else {
                      value = baseToNumber(value);
                      other = baseToNumber(other);
                    }
                    result2 = operator(value, other);
                  }
                  return result2;
                };
              }
              function createOver(arrayFunc) {
                return flatRest(function(iteratees) {
                  iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                  return baseRest(function(args) {
                    var thisArg = this;
                    return arrayFunc(iteratees, function(iteratee2) {
                      return apply(iteratee2, thisArg, args);
                    });
                  });
                });
              }
              function createPadding(length, chars) {
                chars = chars === undefined$1 ? " " : baseToString(chars);
                var charsLength = chars.length;
                if (charsLength < 2) {
                  return charsLength ? baseRepeat(chars, length) : chars;
                }
                var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
              }
              function createPartial(func, bitmask, thisArg, partials) {
                var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                function wrapper() {
                  var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                  while (++leftIndex < leftLength) {
                    args[leftIndex] = partials[leftIndex];
                  }
                  while (argsLength--) {
                    args[leftIndex++] = arguments[++argsIndex];
                  }
                  return apply(fn, isBind ? thisArg : this, args);
                }
                return wrapper;
              }
              function createRange(fromRight) {
                return function(start, end, step) {
                  if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                    end = step = undefined$1;
                  }
                  start = toFinite(start);
                  if (end === undefined$1) {
                    end = start;
                    start = 0;
                  } else {
                    end = toFinite(end);
                  }
                  step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
                  return baseRange(start, end, step, fromRight);
                };
              }
              function createRelationalOperation(operator) {
                return function(value, other) {
                  if (!(typeof value == "string" && typeof other == "string")) {
                    value = toNumber(value);
                    other = toNumber(other);
                  }
                  return operator(value, other);
                };
              }
              function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
                var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
                bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
                bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
                if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                  bitmask &= -4;
                }
                var newData = [
                  func,
                  bitmask,
                  thisArg,
                  newPartials,
                  newHolders,
                  newPartialsRight,
                  newHoldersRight,
                  argPos,
                  ary2,
                  arity
                ];
                var result2 = wrapFunc.apply(undefined$1, newData);
                if (isLaziable(func)) {
                  setData(result2, newData);
                }
                result2.placeholder = placeholder;
                return setWrapToString(result2, func, bitmask);
              }
              function createRound(methodName) {
                var func = Math2[methodName];
                return function(number, precision) {
                  number = toNumber(number);
                  precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
                  if (precision && nativeIsFinite(number)) {
                    var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                    pair = (toString(value) + "e").split("e");
                    return +(pair[0] + "e" + (+pair[1] - precision));
                  }
                  return func(number);
                };
              }
              var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
                return new Set2(values2);
              };
              function createToPairs(keysFunc) {
                return function(object) {
                  var tag = getTag(object);
                  if (tag == mapTag) {
                    return mapToArray(object);
                  }
                  if (tag == setTag) {
                    return setToPairs(object);
                  }
                  return baseToPairs(object, keysFunc(object));
                };
              }
              function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
                var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                if (!isBindKey && typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                var length = partials ? partials.length : 0;
                if (!length) {
                  bitmask &= -97;
                  partials = holders = undefined$1;
                }
                ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
                arity = arity === undefined$1 ? arity : toInteger(arity);
                length -= holders ? holders.length : 0;
                if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                  var partialsRight = partials, holdersRight = holders;
                  partials = holders = undefined$1;
                }
                var data = isBindKey ? undefined$1 : getData(func);
                var newData = [
                  func,
                  bitmask,
                  thisArg,
                  partials,
                  holders,
                  partialsRight,
                  holdersRight,
                  argPos,
                  ary2,
                  arity
                ];
                if (data) {
                  mergeData(newData, data);
                }
                func = newData[0];
                bitmask = newData[1];
                thisArg = newData[2];
                partials = newData[3];
                holders = newData[4];
                arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
                if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                  bitmask &= -25;
                }
                if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                  var result2 = createBind(func, bitmask, thisArg);
                } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                  result2 = createCurry(func, bitmask, arity);
                } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                  result2 = createPartial(func, bitmask, thisArg, partials);
                } else {
                  result2 = createHybrid.apply(undefined$1, newData);
                }
                var setter = data ? baseSetData : setData;
                return setWrapToString(setter(result2, newData), func, bitmask);
              }
              function customDefaultsAssignIn(objValue, srcValue, key, object) {
                if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  return srcValue;
                }
                return objValue;
              }
              function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
                if (isObject(objValue) && isObject(srcValue)) {
                  stack.set(srcValue, objValue);
                  baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
                  stack["delete"](srcValue);
                }
                return objValue;
              }
              function customOmitClone(value) {
                return isPlainObject(value) ? undefined$1 : value;
              }
              function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                  return false;
                }
                var arrStacked = stack.get(array);
                var othStacked = stack.get(other);
                if (arrStacked && othStacked) {
                  return arrStacked == other && othStacked == array;
                }
                var index2 = -1, result2 = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
                stack.set(array, other);
                stack.set(other, array);
                while (++index2 < arrLength) {
                  var arrValue = array[index2], othValue = other[index2];
                  if (customizer) {
                    var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
                  }
                  if (compared !== undefined$1) {
                    if (compared) {
                      continue;
                    }
                    result2 = false;
                    break;
                  }
                  if (seen2) {
                    if (!arraySome(other, function(othValue2, othIndex) {
                      if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                        return seen2.push(othIndex);
                      }
                    })) {
                      result2 = false;
                      break;
                    }
                  } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                    result2 = false;
                    break;
                  }
                }
                stack["delete"](array);
                stack["delete"](other);
                return result2;
              }
              function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                switch (tag) {
                  case dataViewTag:
                    if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                      return false;
                    }
                    object = object.buffer;
                    other = other.buffer;
                  case arrayBufferTag:
                    if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                      return false;
                    }
                    return true;
                  case boolTag:
                  case dateTag:
                  case numberTag:
                    return eq(+object, +other);
                  case errorTag:
                    return object.name == other.name && object.message == other.message;
                  case regexpTag:
                  case stringTag:
                    return object == other + "";
                  case mapTag:
                    var convert = mapToArray;
                  case setTag:
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                    convert || (convert = setToArray);
                    if (object.size != other.size && !isPartial) {
                      return false;
                    }
                    var stacked = stack.get(object);
                    if (stacked) {
                      return stacked == other;
                    }
                    bitmask |= COMPARE_UNORDERED_FLAG;
                    stack.set(object, other);
                    var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                    stack["delete"](object);
                    return result2;
                  case symbolTag:
                    if (symbolValueOf) {
                      return symbolValueOf.call(object) == symbolValueOf.call(other);
                    }
                }
                return false;
              }
              function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                if (objLength != othLength && !isPartial) {
                  return false;
                }
                var index2 = objLength;
                while (index2--) {
                  var key = objProps[index2];
                  if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                    return false;
                  }
                }
                var objStacked = stack.get(object);
                var othStacked = stack.get(other);
                if (objStacked && othStacked) {
                  return objStacked == other && othStacked == object;
                }
                var result2 = true;
                stack.set(object, other);
                stack.set(other, object);
                var skipCtor = isPartial;
                while (++index2 < objLength) {
                  key = objProps[index2];
                  var objValue = object[key], othValue = other[key];
                  if (customizer) {
                    var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                  }
                  if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                    result2 = false;
                    break;
                  }
                  skipCtor || (skipCtor = key == "constructor");
                }
                if (result2 && !skipCtor) {
                  var objCtor = object.constructor, othCtor = other.constructor;
                  if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                    result2 = false;
                  }
                }
                stack["delete"](object);
                stack["delete"](other);
                return result2;
              }
              function flatRest(func) {
                return setToString(overRest(func, undefined$1, flatten), func + "");
              }
              function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols);
              }
              function getAllKeysIn(object) {
                return baseGetAllKeys(object, keysIn, getSymbolsIn);
              }
              var getData = !metaMap ? noop : function(func) {
                return metaMap.get(func);
              };
              function getFuncName(func) {
                var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
                while (length--) {
                  var data = array[length], otherFunc = data.func;
                  if (otherFunc == null || otherFunc == func) {
                    return data.name;
                  }
                }
                return result2;
              }
              function getHolder(func) {
                var object = hasOwnProperty.call(lodash2, "placeholder") ? lodash2 : func;
                return object.placeholder;
              }
              function getIteratee() {
                var result2 = lodash2.iteratee || iteratee;
                result2 = result2 === iteratee ? baseIteratee : result2;
                return arguments.length ? result2(arguments[0], arguments[1]) : result2;
              }
              function getMapData(map2, key) {
                var data = map2.__data__;
                return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
              }
              function getMatchData(object) {
                var result2 = keys(object), length = result2.length;
                while (length--) {
                  var key = result2[length], value = object[key];
                  result2[length] = [key, value, isStrictComparable(value)];
                }
                return result2;
              }
              function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : undefined$1;
              }
              function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                try {
                  value[symToStringTag] = undefined$1;
                  var unmasked = true;
                } catch (e) {
                }
                var result2 = nativeObjectToString.call(value);
                if (unmasked) {
                  if (isOwn) {
                    value[symToStringTag] = tag;
                  } else {
                    delete value[symToStringTag];
                  }
                }
                return result2;
              }
              var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
                if (object == null) {
                  return [];
                }
                object = Object2(object);
                return arrayFilter(nativeGetSymbols(object), function(symbol) {
                  return propertyIsEnumerable.call(object, symbol);
                });
              };
              var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
                var result2 = [];
                while (object) {
                  arrayPush(result2, getSymbols(object));
                  object = getPrototype(object);
                }
                return result2;
              };
              var getTag = baseGetTag;
              if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
                getTag = function(value) {
                  var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
                  if (ctorString) {
                    switch (ctorString) {
                      case dataViewCtorString:
                        return dataViewTag;
                      case mapCtorString:
                        return mapTag;
                      case promiseCtorString:
                        return promiseTag;
                      case setCtorString:
                        return setTag;
                      case weakMapCtorString:
                        return weakMapTag;
                    }
                  }
                  return result2;
                };
              }
              function getView(start, end, transforms) {
                var index2 = -1, length = transforms.length;
                while (++index2 < length) {
                  var data = transforms[index2], size2 = data.size;
                  switch (data.type) {
                    case "drop":
                      start += size2;
                      break;
                    case "dropRight":
                      end -= size2;
                      break;
                    case "take":
                      end = nativeMin(end, start + size2);
                      break;
                    case "takeRight":
                      start = nativeMax(start, end - size2);
                      break;
                  }
                }
                return { "start": start, "end": end };
              }
              function getWrapDetails(source) {
                var match = source.match(reWrapDetails);
                return match ? match[1].split(reSplitDetails) : [];
              }
              function hasPath(object, path, hasFunc) {
                path = castPath(path, object);
                var index2 = -1, length = path.length, result2 = false;
                while (++index2 < length) {
                  var key = toKey(path[index2]);
                  if (!(result2 = object != null && hasFunc(object, key))) {
                    break;
                  }
                  object = object[key];
                }
                if (result2 || ++index2 != length) {
                  return result2;
                }
                length = object == null ? 0 : object.length;
                return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
              }
              function initCloneArray(array) {
                var length = array.length, result2 = new array.constructor(length);
                if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                  result2.index = array.index;
                  result2.input = array.input;
                }
                return result2;
              }
              function initCloneObject(object) {
                return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
              }
              function initCloneByTag(object, tag, isDeep) {
                var Ctor = object.constructor;
                switch (tag) {
                  case arrayBufferTag:
                    return cloneArrayBuffer(object);
                  case boolTag:
                  case dateTag:
                    return new Ctor(+object);
                  case dataViewTag:
                    return cloneDataView(object, isDeep);
                  case float32Tag:
                  case float64Tag:
                  case int8Tag:
                  case int16Tag:
                  case int32Tag:
                  case uint8Tag:
                  case uint8ClampedTag:
                  case uint16Tag:
                  case uint32Tag:
                    return cloneTypedArray(object, isDeep);
                  case mapTag:
                    return new Ctor();
                  case numberTag:
                  case stringTag:
                    return new Ctor(object);
                  case regexpTag:
                    return cloneRegExp(object);
                  case setTag:
                    return new Ctor();
                  case symbolTag:
                    return cloneSymbol(object);
                }
              }
              function insertWrapDetails(source, details) {
                var length = details.length;
                if (!length) {
                  return source;
                }
                var lastIndex = length - 1;
                details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
                details = details.join(length > 2 ? ", " : " ");
                return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
              }
              function isFlattenable(value) {
                return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
              }
              function isIndex(value, length) {
                var type = typeof value;
                length = length == null ? MAX_SAFE_INTEGER : length;
                return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
              }
              function isIterateeCall(value, index2, object) {
                if (!isObject(object)) {
                  return false;
                }
                var type = typeof index2;
                if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
                  return eq(object[index2], value);
                }
                return false;
              }
              function isKey(value, object) {
                if (isArray(value)) {
                  return false;
                }
                var type = typeof value;
                if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
                  return true;
                }
                return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
              }
              function isKeyable(value) {
                var type = typeof value;
                return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
              }
              function isLaziable(func) {
                var funcName = getFuncName(func), other = lodash2[funcName];
                if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
                  return false;
                }
                if (func === other) {
                  return true;
                }
                var data = getData(other);
                return !!data && func === data[0];
              }
              function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
              }
              var isMaskable = coreJsData ? isFunction2 : stubFalse;
              function isPrototype(value) {
                var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
                return value === proto;
              }
              function isStrictComparable(value) {
                return value === value && !isObject(value);
              }
              function matchesStrictComparable(key, srcValue) {
                return function(object) {
                  if (object == null) {
                    return false;
                  }
                  return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
                };
              }
              function memoizeCapped(func) {
                var result2 = memoize(func, function(key) {
                  if (cache.size === MAX_MEMOIZE_SIZE) {
                    cache.clear();
                  }
                  return key;
                });
                var cache = result2.cache;
                return result2;
              }
              function mergeData(data, source) {
                var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
                var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
                if (!(isCommon || isCombo)) {
                  return data;
                }
                if (srcBitmask & WRAP_BIND_FLAG) {
                  data[2] = source[2];
                  newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                }
                var value = source[3];
                if (value) {
                  var partials = data[3];
                  data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                  data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                }
                value = source[5];
                if (value) {
                  partials = data[5];
                  data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                  data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                }
                value = source[7];
                if (value) {
                  data[7] = value;
                }
                if (srcBitmask & WRAP_ARY_FLAG) {
                  data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                }
                if (data[9] == null) {
                  data[9] = source[9];
                }
                data[0] = source[0];
                data[1] = newBitmask;
                return data;
              }
              function nativeKeysIn(object) {
                var result2 = [];
                if (object != null) {
                  for (var key in Object2(object)) {
                    result2.push(key);
                  }
                }
                return result2;
              }
              function objectToString2(value) {
                return nativeObjectToString.call(value);
              }
              function overRest(func, start, transform2) {
                start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
                return function() {
                  var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
                  while (++index2 < length) {
                    array[index2] = args[start + index2];
                  }
                  index2 = -1;
                  var otherArgs = Array2(start + 1);
                  while (++index2 < start) {
                    otherArgs[index2] = args[index2];
                  }
                  otherArgs[start] = transform2(array);
                  return apply(func, this, otherArgs);
                };
              }
              function parent(object, path) {
                return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
              }
              function reorder(array, indexes) {
                var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
                while (length--) {
                  var index2 = indexes[length];
                  array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
                }
                return array;
              }
              function safeGet(object, key) {
                if (key === "constructor" && typeof object[key] === "function") {
                  return;
                }
                if (key == "__proto__") {
                  return;
                }
                return object[key];
              }
              var setData = shortOut(baseSetData);
              var setTimeout2 = ctxSetTimeout || function(func, wait) {
                return root.setTimeout(func, wait);
              };
              var setToString = shortOut(baseSetToString);
              function setWrapToString(wrapper, reference, bitmask) {
                var source = reference + "";
                return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
              }
              function shortOut(func) {
                var count = 0, lastCalled = 0;
                return function() {
                  var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                  lastCalled = stamp;
                  if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                      return arguments[0];
                    }
                  } else {
                    count = 0;
                  }
                  return func.apply(undefined$1, arguments);
                };
              }
              function shuffleSelf(array, size2) {
                var index2 = -1, length = array.length, lastIndex = length - 1;
                size2 = size2 === undefined$1 ? length : size2;
                while (++index2 < size2) {
                  var rand = baseRandom(index2, lastIndex), value = array[rand];
                  array[rand] = array[index2];
                  array[index2] = value;
                }
                array.length = size2;
                return array;
              }
              var stringToPath = memoizeCapped(function(string) {
                var result2 = [];
                if (string.charCodeAt(0) === 46) {
                  result2.push("");
                }
                string.replace(rePropName, function(match, number, quote, subString) {
                  result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
                });
                return result2;
              });
              function toKey(value) {
                if (typeof value == "string" || isSymbol(value)) {
                  return value;
                }
                var result2 = value + "";
                return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
              }
              function toSource(func) {
                if (func != null) {
                  try {
                    return funcToString.call(func);
                  } catch (e) {
                  }
                  try {
                    return func + "";
                  } catch (e) {
                  }
                }
                return "";
              }
              function updateWrapDetails(details, bitmask) {
                arrayEach(wrapFlags, function(pair) {
                  var value = "_." + pair[0];
                  if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                    details.push(value);
                  }
                });
                return details.sort();
              }
              function wrapperClone(wrapper) {
                if (wrapper instanceof LazyWrapper) {
                  return wrapper.clone();
                }
                var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                result2.__actions__ = copyArray(wrapper.__actions__);
                result2.__index__ = wrapper.__index__;
                result2.__values__ = wrapper.__values__;
                return result2;
              }
              function chunk(array, size2, guard) {
                if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
                  size2 = 1;
                } else {
                  size2 = nativeMax(toInteger(size2), 0);
                }
                var length = array == null ? 0 : array.length;
                if (!length || size2 < 1) {
                  return [];
                }
                var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
                while (index2 < length) {
                  result2[resIndex++] = baseSlice(array, index2, index2 += size2);
                }
                return result2;
              }
              function compact(array) {
                var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
                while (++index2 < length) {
                  var value = array[index2];
                  if (value) {
                    result2[resIndex++] = value;
                  }
                }
                return result2;
              }
              function concat() {
                var length = arguments.length;
                if (!length) {
                  return [];
                }
                var args = Array2(length - 1), array = arguments[0], index2 = length;
                while (index2--) {
                  args[index2 - 1] = arguments[index2];
                }
                return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
              }
              var difference = baseRest(function(array, values2) {
                return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
              });
              var differenceBy = baseRest(function(array, values2) {
                var iteratee2 = last(values2);
                if (isArrayLikeObject(iteratee2)) {
                  iteratee2 = undefined$1;
                }
                return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
              });
              var differenceWith = baseRest(function(array, values2) {
                var comparator = last(values2);
                if (isArrayLikeObject(comparator)) {
                  comparator = undefined$1;
                }
                return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
              });
              function drop(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined$1 ? 1 : toInteger(n);
                return baseSlice(array, n < 0 ? 0 : n, length);
              }
              function dropRight(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined$1 ? 1 : toInteger(n);
                n = length - n;
                return baseSlice(array, 0, n < 0 ? 0 : n);
              }
              function dropRightWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
              }
              function dropWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
              }
              function fill(array, value, start, end) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
                  start = 0;
                  end = length;
                }
                return baseFill(array, value, start, end);
              }
              function findIndex(array, predicate, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
                if (index2 < 0) {
                  index2 = nativeMax(length + index2, 0);
                }
                return baseFindIndex(array, getIteratee(predicate, 3), index2);
              }
              function findLastIndex(array, predicate, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index2 = length - 1;
                if (fromIndex !== undefined$1) {
                  index2 = toInteger(fromIndex);
                  index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
                }
                return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
              }
              function flatten(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseFlatten(array, 1) : [];
              }
              function flattenDeep(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseFlatten(array, INFINITY) : [];
              }
              function flattenDepth(array, depth) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                depth = depth === undefined$1 ? 1 : toInteger(depth);
                return baseFlatten(array, depth);
              }
              function fromPairs(pairs) {
                var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
                while (++index2 < length) {
                  var pair = pairs[index2];
                  result2[pair[0]] = pair[1];
                }
                return result2;
              }
              function head(array) {
                return array && array.length ? array[0] : undefined$1;
              }
              function indexOf2(array, value, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
                if (index2 < 0) {
                  index2 = nativeMax(length + index2, 0);
                }
                return baseIndexOf(array, value, index2);
              }
              function initial(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseSlice(array, 0, -1) : [];
              }
              var intersection = baseRest(function(arrays) {
                var mapped = arrayMap(arrays, castArrayLikeObject);
                return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
              });
              var intersectionBy = baseRest(function(arrays) {
                var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                if (iteratee2 === last(mapped)) {
                  iteratee2 = undefined$1;
                } else {
                  mapped.pop();
                }
                return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
              });
              var intersectionWith = baseRest(function(arrays) {
                var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                comparator = typeof comparator == "function" ? comparator : undefined$1;
                if (comparator) {
                  mapped.pop();
                }
                return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
              });
              function join(array, separator) {
                return array == null ? "" : nativeJoin.call(array, separator);
              }
              function last(array) {
                var length = array == null ? 0 : array.length;
                return length ? array[length - 1] : undefined$1;
              }
              function lastIndexOf(array, value, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index2 = length;
                if (fromIndex !== undefined$1) {
                  index2 = toInteger(fromIndex);
                  index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
                }
                return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
              }
              function nth(array, n) {
                return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
              }
              var pull = baseRest(pullAll);
              function pullAll(array, values2) {
                return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
              }
              function pullAllBy(array, values2, iteratee2) {
                return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
              }
              function pullAllWith(array, values2, comparator) {
                return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
              }
              var pullAt = flatRest(function(array, indexes) {
                var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
                basePullAt(array, arrayMap(indexes, function(index2) {
                  return isIndex(index2, length) ? +index2 : index2;
                }).sort(compareAscending));
                return result2;
              });
              function remove(array, predicate) {
                var result2 = [];
                if (!(array && array.length)) {
                  return result2;
                }
                var index2 = -1, indexes = [], length = array.length;
                predicate = getIteratee(predicate, 3);
                while (++index2 < length) {
                  var value = array[index2];
                  if (predicate(value, index2, array)) {
                    result2.push(value);
                    indexes.push(index2);
                  }
                }
                basePullAt(array, indexes);
                return result2;
              }
              function reverse(array) {
                return array == null ? array : nativeReverse.call(array);
              }
              function slice(array, start, end) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
                  start = 0;
                  end = length;
                } else {
                  start = start == null ? 0 : toInteger(start);
                  end = end === undefined$1 ? length : toInteger(end);
                }
                return baseSlice(array, start, end);
              }
              function sortedIndex(array, value) {
                return baseSortedIndex(array, value);
              }
              function sortedIndexBy(array, value, iteratee2) {
                return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
              }
              function sortedIndexOf(array, value) {
                var length = array == null ? 0 : array.length;
                if (length) {
                  var index2 = baseSortedIndex(array, value);
                  if (index2 < length && eq(array[index2], value)) {
                    return index2;
                  }
                }
                return -1;
              }
              function sortedLastIndex(array, value) {
                return baseSortedIndex(array, value, true);
              }
              function sortedLastIndexBy(array, value, iteratee2) {
                return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
              }
              function sortedLastIndexOf(array, value) {
                var length = array == null ? 0 : array.length;
                if (length) {
                  var index2 = baseSortedIndex(array, value, true) - 1;
                  if (eq(array[index2], value)) {
                    return index2;
                  }
                }
                return -1;
              }
              function sortedUniq(array) {
                return array && array.length ? baseSortedUniq(array) : [];
              }
              function sortedUniqBy(array, iteratee2) {
                return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
              }
              function tail(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseSlice(array, 1, length) : [];
              }
              function take(array, n, guard) {
                if (!(array && array.length)) {
                  return [];
                }
                n = guard || n === undefined$1 ? 1 : toInteger(n);
                return baseSlice(array, 0, n < 0 ? 0 : n);
              }
              function takeRight(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined$1 ? 1 : toInteger(n);
                n = length - n;
                return baseSlice(array, n < 0 ? 0 : n, length);
              }
              function takeRightWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
              }
              function takeWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
              }
              var union = baseRest(function(arrays) {
                return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
              });
              var unionBy = baseRest(function(arrays) {
                var iteratee2 = last(arrays);
                if (isArrayLikeObject(iteratee2)) {
                  iteratee2 = undefined$1;
                }
                return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
              });
              var unionWith = baseRest(function(arrays) {
                var comparator = last(arrays);
                comparator = typeof comparator == "function" ? comparator : undefined$1;
                return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
              });
              function uniq(array) {
                return array && array.length ? baseUniq(array) : [];
              }
              function uniqBy(array, iteratee2) {
                return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
              }
              function uniqWith(array, comparator) {
                comparator = typeof comparator == "function" ? comparator : undefined$1;
                return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
              }
              function unzip(array) {
                if (!(array && array.length)) {
                  return [];
                }
                var length = 0;
                array = arrayFilter(array, function(group) {
                  if (isArrayLikeObject(group)) {
                    length = nativeMax(group.length, length);
                    return true;
                  }
                });
                return baseTimes(length, function(index2) {
                  return arrayMap(array, baseProperty(index2));
                });
              }
              function unzipWith(array, iteratee2) {
                if (!(array && array.length)) {
                  return [];
                }
                var result2 = unzip(array);
                if (iteratee2 == null) {
                  return result2;
                }
                return arrayMap(result2, function(group) {
                  return apply(iteratee2, undefined$1, group);
                });
              }
              var without = baseRest(function(array, values2) {
                return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
              });
              var xor = baseRest(function(arrays) {
                return baseXor(arrayFilter(arrays, isArrayLikeObject));
              });
              var xorBy = baseRest(function(arrays) {
                var iteratee2 = last(arrays);
                if (isArrayLikeObject(iteratee2)) {
                  iteratee2 = undefined$1;
                }
                return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
              });
              var xorWith = baseRest(function(arrays) {
                var comparator = last(arrays);
                comparator = typeof comparator == "function" ? comparator : undefined$1;
                return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
              });
              var zip = baseRest(unzip);
              function zipObject(props, values2) {
                return baseZipObject(props || [], values2 || [], assignValue);
              }
              function zipObjectDeep(props, values2) {
                return baseZipObject(props || [], values2 || [], baseSet);
              }
              var zipWith = baseRest(function(arrays) {
                var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
                iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
                return unzipWith(arrays, iteratee2);
              });
              function chain(value) {
                var result2 = lodash2(value);
                result2.__chain__ = true;
                return result2;
              }
              function tap(value, interceptor) {
                interceptor(value);
                return value;
              }
              function thru(value, interceptor) {
                return interceptor(value);
              }
              var wrapperAt = flatRest(function(paths) {
                var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
                  return baseAt(object, paths);
                };
                if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
                  return this.thru(interceptor);
                }
                value = value.slice(start, +start + (length ? 1 : 0));
                value.__actions__.push({
                  "func": thru,
                  "args": [interceptor],
                  "thisArg": undefined$1
                });
                return new LodashWrapper(value, this.__chain__).thru(function(array) {
                  if (length && !array.length) {
                    array.push(undefined$1);
                  }
                  return array;
                });
              });
              function wrapperChain() {
                return chain(this);
              }
              function wrapperCommit() {
                return new LodashWrapper(this.value(), this.__chain__);
              }
              function wrapperNext() {
                if (this.__values__ === undefined$1) {
                  this.__values__ = toArray(this.value());
                }
                var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
                return { "done": done, "value": value };
              }
              function wrapperToIterator() {
                return this;
              }
              function wrapperPlant(value) {
                var result2, parent2 = this;
                while (parent2 instanceof baseLodash) {
                  var clone2 = wrapperClone(parent2);
                  clone2.__index__ = 0;
                  clone2.__values__ = undefined$1;
                  if (result2) {
                    previous.__wrapped__ = clone2;
                  } else {
                    result2 = clone2;
                  }
                  var previous = clone2;
                  parent2 = parent2.__wrapped__;
                }
                previous.__wrapped__ = value;
                return result2;
              }
              function wrapperReverse() {
                var value = this.__wrapped__;
                if (value instanceof LazyWrapper) {
                  var wrapped = value;
                  if (this.__actions__.length) {
                    wrapped = new LazyWrapper(this);
                  }
                  wrapped = wrapped.reverse();
                  wrapped.__actions__.push({
                    "func": thru,
                    "args": [reverse],
                    "thisArg": undefined$1
                  });
                  return new LodashWrapper(wrapped, this.__chain__);
                }
                return this.thru(reverse);
              }
              function wrapperValue() {
                return baseWrapperValue(this.__wrapped__, this.__actions__);
              }
              var countBy = createAggregator(function(result2, value, key) {
                if (hasOwnProperty.call(result2, key)) {
                  ++result2[key];
                } else {
                  baseAssignValue(result2, key, 1);
                }
              });
              function every(collection, predicate, guard) {
                var func = isArray(collection) ? arrayEvery : baseEvery;
                if (guard && isIterateeCall(collection, predicate, guard)) {
                  predicate = undefined$1;
                }
                return func(collection, getIteratee(predicate, 3));
              }
              function filter(collection, predicate) {
                var func = isArray(collection) ? arrayFilter : baseFilter;
                return func(collection, getIteratee(predicate, 3));
              }
              var find = createFind(findIndex);
              var findLast = createFind(findLastIndex);
              function flatMap(collection, iteratee2) {
                return baseFlatten(map(collection, iteratee2), 1);
              }
              function flatMapDeep(collection, iteratee2) {
                return baseFlatten(map(collection, iteratee2), INFINITY);
              }
              function flatMapDepth(collection, iteratee2, depth) {
                depth = depth === undefined$1 ? 1 : toInteger(depth);
                return baseFlatten(map(collection, iteratee2), depth);
              }
              function forEach(collection, iteratee2) {
                var func = isArray(collection) ? arrayEach : baseEach;
                return func(collection, getIteratee(iteratee2, 3));
              }
              function forEachRight(collection, iteratee2) {
                var func = isArray(collection) ? arrayEachRight : baseEachRight;
                return func(collection, getIteratee(iteratee2, 3));
              }
              var groupBy = createAggregator(function(result2, value, key) {
                if (hasOwnProperty.call(result2, key)) {
                  result2[key].push(value);
                } else {
                  baseAssignValue(result2, key, [value]);
                }
              });
              function includes(collection, value, fromIndex, guard) {
                collection = isArrayLike(collection) ? collection : values(collection);
                fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                var length = collection.length;
                if (fromIndex < 0) {
                  fromIndex = nativeMax(length + fromIndex, 0);
                }
                return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
              }
              var invokeMap = baseRest(function(collection, path, args) {
                var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
                baseEach(collection, function(value) {
                  result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
                });
                return result2;
              });
              var keyBy = createAggregator(function(result2, value, key) {
                baseAssignValue(result2, key, value);
              });
              function map(collection, iteratee2) {
                var func = isArray(collection) ? arrayMap : baseMap;
                return func(collection, getIteratee(iteratee2, 3));
              }
              function orderBy(collection, iteratees, orders, guard) {
                if (collection == null) {
                  return [];
                }
                if (!isArray(iteratees)) {
                  iteratees = iteratees == null ? [] : [iteratees];
                }
                orders = guard ? undefined$1 : orders;
                if (!isArray(orders)) {
                  orders = orders == null ? [] : [orders];
                }
                return baseOrderBy(collection, iteratees, orders);
              }
              var partition = createAggregator(function(result2, value, key) {
                result2[key ? 0 : 1].push(value);
              }, function() {
                return [[], []];
              });
              function reduce(collection, iteratee2, accumulator) {
                var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
              }
              function reduceRight(collection, iteratee2, accumulator) {
                var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
                return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
              }
              function reject(collection, predicate) {
                var func = isArray(collection) ? arrayFilter : baseFilter;
                return func(collection, negate(getIteratee(predicate, 3)));
              }
              function sample(collection) {
                var func = isArray(collection) ? arraySample : baseSample;
                return func(collection);
              }
              function sampleSize(collection, n, guard) {
                if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
                  n = 1;
                } else {
                  n = toInteger(n);
                }
                var func = isArray(collection) ? arraySampleSize : baseSampleSize;
                return func(collection, n);
              }
              function shuffle(collection) {
                var func = isArray(collection) ? arrayShuffle : baseShuffle;
                return func(collection);
              }
              function size(collection) {
                if (collection == null) {
                  return 0;
                }
                if (isArrayLike(collection)) {
                  return isString(collection) ? stringSize(collection) : collection.length;
                }
                var tag = getTag(collection);
                if (tag == mapTag || tag == setTag) {
                  return collection.size;
                }
                return baseKeys(collection).length;
              }
              function some(collection, predicate, guard) {
                var func = isArray(collection) ? arraySome : baseSome;
                if (guard && isIterateeCall(collection, predicate, guard)) {
                  predicate = undefined$1;
                }
                return func(collection, getIteratee(predicate, 3));
              }
              var sortBy = baseRest(function(collection, iteratees) {
                if (collection == null) {
                  return [];
                }
                var length = iteratees.length;
                if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                  iteratees = [];
                } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                  iteratees = [iteratees[0]];
                }
                return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
              });
              var now = ctxNow || function() {
                return root.Date.now();
              };
              function after(n, func) {
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                n = toInteger(n);
                return function() {
                  if (--n < 1) {
                    return func.apply(this, arguments);
                  }
                };
              }
              function ary(func, n, guard) {
                n = guard ? undefined$1 : n;
                n = func && n == null ? func.length : n;
                return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
              }
              function before(n, func) {
                var result2;
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                n = toInteger(n);
                return function() {
                  if (--n > 0) {
                    result2 = func.apply(this, arguments);
                  }
                  if (n <= 1) {
                    func = undefined$1;
                  }
                  return result2;
                };
              }
              var bind = baseRest(function(func, thisArg, partials) {
                var bitmask = WRAP_BIND_FLAG;
                if (partials.length) {
                  var holders = replaceHolders(partials, getHolder(bind));
                  bitmask |= WRAP_PARTIAL_FLAG;
                }
                return createWrap(func, bitmask, thisArg, partials, holders);
              });
              var bindKey = baseRest(function(object, key, partials) {
                var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                if (partials.length) {
                  var holders = replaceHolders(partials, getHolder(bindKey));
                  bitmask |= WRAP_PARTIAL_FLAG;
                }
                return createWrap(key, bitmask, object, partials, holders);
              });
              function curry(func, arity, guard) {
                arity = guard ? undefined$1 : arity;
                var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
                result2.placeholder = curry.placeholder;
                return result2;
              }
              function curryRight(func, arity, guard) {
                arity = guard ? undefined$1 : arity;
                var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
                result2.placeholder = curryRight.placeholder;
                return result2;
              }
              function debounce(func, wait, options) {
                var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                wait = toNumber(wait) || 0;
                if (isObject(options)) {
                  leading = !!options.leading;
                  maxing = "maxWait" in options;
                  maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                  trailing = "trailing" in options ? !!options.trailing : trailing;
                }
                function invokeFunc(time) {
                  var args = lastArgs, thisArg = lastThis;
                  lastArgs = lastThis = undefined$1;
                  lastInvokeTime = time;
                  result2 = func.apply(thisArg, args);
                  return result2;
                }
                function leadingEdge(time) {
                  lastInvokeTime = time;
                  timerId = setTimeout2(timerExpired, wait);
                  return leading ? invokeFunc(time) : result2;
                }
                function remainingWait(time) {
                  var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                  return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
                }
                function shouldInvoke(time) {
                  var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                  return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                }
                function timerExpired() {
                  var time = now();
                  if (shouldInvoke(time)) {
                    return trailingEdge(time);
                  }
                  timerId = setTimeout2(timerExpired, remainingWait(time));
                }
                function trailingEdge(time) {
                  timerId = undefined$1;
                  if (trailing && lastArgs) {
                    return invokeFunc(time);
                  }
                  lastArgs = lastThis = undefined$1;
                  return result2;
                }
                function cancel() {
                  if (timerId !== undefined$1) {
                    clearTimeout(timerId);
                  }
                  lastInvokeTime = 0;
                  lastArgs = lastCallTime = lastThis = timerId = undefined$1;
                }
                function flush() {
                  return timerId === undefined$1 ? result2 : trailingEdge(now());
                }
                function debounced() {
                  var time = now(), isInvoking = shouldInvoke(time);
                  lastArgs = arguments;
                  lastThis = this;
                  lastCallTime = time;
                  if (isInvoking) {
                    if (timerId === undefined$1) {
                      return leadingEdge(lastCallTime);
                    }
                    if (maxing) {
                      clearTimeout(timerId);
                      timerId = setTimeout2(timerExpired, wait);
                      return invokeFunc(lastCallTime);
                    }
                  }
                  if (timerId === undefined$1) {
                    timerId = setTimeout2(timerExpired, wait);
                  }
                  return result2;
                }
                debounced.cancel = cancel;
                debounced.flush = flush;
                return debounced;
              }
              var defer = baseRest(function(func, args) {
                return baseDelay(func, 1, args);
              });
              var delay = baseRest(function(func, wait, args) {
                return baseDelay(func, toNumber(wait) || 0, args);
              });
              function flip(func) {
                return createWrap(func, WRAP_FLIP_FLAG);
              }
              function memoize(func, resolver) {
                if (typeof func != "function" || resolver != null && typeof resolver != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                var memoized = function() {
                  var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                  if (cache.has(key)) {
                    return cache.get(key);
                  }
                  var result2 = func.apply(this, args);
                  memoized.cache = cache.set(key, result2) || cache;
                  return result2;
                };
                memoized.cache = new (memoize.Cache || MapCache)();
                return memoized;
              }
              memoize.Cache = MapCache;
              function negate(predicate) {
                if (typeof predicate != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                return function() {
                  var args = arguments;
                  switch (args.length) {
                    case 0:
                      return !predicate.call(this);
                    case 1:
                      return !predicate.call(this, args[0]);
                    case 2:
                      return !predicate.call(this, args[0], args[1]);
                    case 3:
                      return !predicate.call(this, args[0], args[1], args[2]);
                  }
                  return !predicate.apply(this, args);
                };
              }
              function once(func) {
                return before(2, func);
              }
              var overArgs = castRest(function(func, transforms) {
                transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
                var funcsLength = transforms.length;
                return baseRest(function(args) {
                  var index2 = -1, length = nativeMin(args.length, funcsLength);
                  while (++index2 < length) {
                    args[index2] = transforms[index2].call(this, args[index2]);
                  }
                  return apply(func, this, args);
                });
              });
              var partial = baseRest(function(func, partials) {
                var holders = replaceHolders(partials, getHolder(partial));
                return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
              });
              var partialRight = baseRest(function(func, partials) {
                var holders = replaceHolders(partials, getHolder(partialRight));
                return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
              });
              var rearg = flatRest(function(func, indexes) {
                return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
              });
              function rest(func, start) {
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                start = start === undefined$1 ? start : toInteger(start);
                return baseRest(func, start);
              }
              function spread(func, start) {
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                start = start == null ? 0 : nativeMax(toInteger(start), 0);
                return baseRest(function(args) {
                  var array = args[start], otherArgs = castSlice(args, 0, start);
                  if (array) {
                    arrayPush(otherArgs, array);
                  }
                  return apply(func, this, otherArgs);
                });
              }
              function throttle2(func, wait, options) {
                var leading = true, trailing = true;
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (isObject(options)) {
                  leading = "leading" in options ? !!options.leading : leading;
                  trailing = "trailing" in options ? !!options.trailing : trailing;
                }
                return debounce(func, wait, {
                  "leading": leading,
                  "maxWait": wait,
                  "trailing": trailing
                });
              }
              function unary(func) {
                return ary(func, 1);
              }
              function wrap(value, wrapper) {
                return partial(castFunction(wrapper), value);
              }
              function castArray() {
                if (!arguments.length) {
                  return [];
                }
                var value = arguments[0];
                return isArray(value) ? value : [value];
              }
              function clone(value) {
                return baseClone(value, CLONE_SYMBOLS_FLAG);
              }
              function cloneWith(value, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
              }
              function cloneDeep(value) {
                return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
              }
              function cloneDeepWith(value, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
              }
              function conformsTo(object, source) {
                return source == null || baseConformsTo(object, source, keys(source));
              }
              function eq(value, other) {
                return value === other || value !== value && other !== other;
              }
              var gt = createRelationalOperation(baseGt);
              var gte = createRelationalOperation(function(value, other) {
                return value >= other;
              });
              var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
                return arguments;
              })()) ? baseIsArguments : function(value) {
                return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
              };
              var isArray = Array2.isArray;
              var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
              function isArrayLike(value) {
                return value != null && isLength(value.length) && !isFunction2(value);
              }
              function isArrayLikeObject(value) {
                return isObjectLike(value) && isArrayLike(value);
              }
              function isBoolean(value) {
                return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
              }
              var isBuffer = nativeIsBuffer || stubFalse;
              var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
              function isElement(value) {
                return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
              }
              function isEmpty(value) {
                if (value == null) {
                  return true;
                }
                if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                  return !value.length;
                }
                var tag = getTag(value);
                if (tag == mapTag || tag == setTag) {
                  return !value.size;
                }
                if (isPrototype(value)) {
                  return !baseKeys(value).length;
                }
                for (var key in value) {
                  if (hasOwnProperty.call(value, key)) {
                    return false;
                  }
                }
                return true;
              }
              function isEqual(value, other) {
                return baseIsEqual(value, other);
              }
              function isEqualWith(value, other, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                var result2 = customizer ? customizer(value, other) : undefined$1;
                return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
              }
              function isError(value) {
                if (!isObjectLike(value)) {
                  return false;
                }
                var tag = baseGetTag(value);
                return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
              }
              function isFinite2(value) {
                return typeof value == "number" && nativeIsFinite(value);
              }
              function isFunction2(value) {
                if (!isObject(value)) {
                  return false;
                }
                var tag = baseGetTag(value);
                return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
              }
              function isInteger(value) {
                return typeof value == "number" && value == toInteger(value);
              }
              function isLength(value) {
                return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
              }
              function isObject(value) {
                var type = typeof value;
                return value != null && (type == "object" || type == "function");
              }
              function isObjectLike(value) {
                return value != null && typeof value == "object";
              }
              var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
              function isMatch(object, source) {
                return object === source || baseIsMatch(object, source, getMatchData(source));
              }
              function isMatchWith(object, source, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return baseIsMatch(object, source, getMatchData(source), customizer);
              }
              function isNaN2(value) {
                return isNumber(value) && value != +value;
              }
              function isNative(value) {
                if (isMaskable(value)) {
                  throw new Error2(CORE_ERROR_TEXT);
                }
                return baseIsNative(value);
              }
              function isNull(value) {
                return value === null;
              }
              function isNil(value) {
                return value == null;
              }
              function isNumber(value) {
                return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
              }
              function isPlainObject(value) {
                if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                  return false;
                }
                var proto = getPrototype(value);
                if (proto === null) {
                  return true;
                }
                var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
                return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
              }
              var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
              function isSafeInteger(value) {
                return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
              }
              var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
              function isString(value) {
                return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
              }
              function isSymbol(value) {
                return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
              }
              var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
              function isUndefined(value) {
                return value === undefined$1;
              }
              function isWeakMap(value) {
                return isObjectLike(value) && getTag(value) == weakMapTag;
              }
              function isWeakSet(value) {
                return isObjectLike(value) && baseGetTag(value) == weakSetTag;
              }
              var lt = createRelationalOperation(baseLt);
              var lte = createRelationalOperation(function(value, other) {
                return value <= other;
              });
              function toArray(value) {
                if (!value) {
                  return [];
                }
                if (isArrayLike(value)) {
                  return isString(value) ? stringToArray(value) : copyArray(value);
                }
                if (symIterator && value[symIterator]) {
                  return iteratorToArray(value[symIterator]());
                }
                var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
                return func(value);
              }
              function toFinite(value) {
                if (!value) {
                  return value === 0 ? value : 0;
                }
                value = toNumber(value);
                if (value === INFINITY || value === -INFINITY) {
                  var sign = value < 0 ? -1 : 1;
                  return sign * MAX_INTEGER;
                }
                return value === value ? value : 0;
              }
              function toInteger(value) {
                var result2 = toFinite(value), remainder = result2 % 1;
                return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
              }
              function toLength(value) {
                return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
              }
              function toNumber(value) {
                if (typeof value == "number") {
                  return value;
                }
                if (isSymbol(value)) {
                  return NAN;
                }
                if (isObject(value)) {
                  var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                  value = isObject(other) ? other + "" : other;
                }
                if (typeof value != "string") {
                  return value === 0 ? value : +value;
                }
                value = baseTrim(value);
                var isBinary = reIsBinary.test(value);
                return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
              }
              function toPlainObject(value) {
                return copyObject(value, keysIn(value));
              }
              function toSafeInteger(value) {
                return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
              }
              function toString(value) {
                return value == null ? "" : baseToString(value);
              }
              var assign = createAssigner(function(object, source) {
                if (isPrototype(source) || isArrayLike(source)) {
                  copyObject(source, keys(source), object);
                  return;
                }
                for (var key in source) {
                  if (hasOwnProperty.call(source, key)) {
                    assignValue(object, key, source[key]);
                  }
                }
              });
              var assignIn = createAssigner(function(object, source) {
                copyObject(source, keysIn(source), object);
              });
              var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
                copyObject(source, keysIn(source), object, customizer);
              });
              var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
                copyObject(source, keys(source), object, customizer);
              });
              var at = flatRest(baseAt);
              function create(prototype, properties) {
                var result2 = baseCreate(prototype);
                return properties == null ? result2 : baseAssign(result2, properties);
              }
              var defaults = baseRest(function(object, sources) {
                object = Object2(object);
                var index2 = -1;
                var length = sources.length;
                var guard = length > 2 ? sources[2] : undefined$1;
                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                  length = 1;
                }
                while (++index2 < length) {
                  var source = sources[index2];
                  var props = keysIn(source);
                  var propsIndex = -1;
                  var propsLength = props.length;
                  while (++propsIndex < propsLength) {
                    var key = props[propsIndex];
                    var value = object[key];
                    if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                      object[key] = source[key];
                    }
                  }
                }
                return object;
              });
              var defaultsDeep = baseRest(function(args) {
                args.push(undefined$1, customDefaultsMerge);
                return apply(mergeWith, undefined$1, args);
              });
              function findKey(object, predicate) {
                return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
              }
              function findLastKey(object, predicate) {
                return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
              }
              function forIn(object, iteratee2) {
                return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
              }
              function forInRight(object, iteratee2) {
                return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
              }
              function forOwn(object, iteratee2) {
                return object && baseForOwn(object, getIteratee(iteratee2, 3));
              }
              function forOwnRight(object, iteratee2) {
                return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
              }
              function functions(object) {
                return object == null ? [] : baseFunctions(object, keys(object));
              }
              function functionsIn(object) {
                return object == null ? [] : baseFunctions(object, keysIn(object));
              }
              function get(object, path, defaultValue) {
                var result2 = object == null ? undefined$1 : baseGet(object, path);
                return result2 === undefined$1 ? defaultValue : result2;
              }
              function has(object, path) {
                return object != null && hasPath(object, path, baseHas);
              }
              function hasIn(object, path) {
                return object != null && hasPath(object, path, baseHasIn);
              }
              var invert = createInverter(function(result2, value, key) {
                if (value != null && typeof value.toString != "function") {
                  value = nativeObjectToString.call(value);
                }
                result2[value] = key;
              }, constant(identity));
              var invertBy = createInverter(function(result2, value, key) {
                if (value != null && typeof value.toString != "function") {
                  value = nativeObjectToString.call(value);
                }
                if (hasOwnProperty.call(result2, value)) {
                  result2[value].push(key);
                } else {
                  result2[value] = [key];
                }
              }, getIteratee);
              var invoke = baseRest(baseInvoke);
              function keys(object) {
                return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
              }
              function keysIn(object) {
                return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
              }
              function mapKeys(object, iteratee2) {
                var result2 = {};
                iteratee2 = getIteratee(iteratee2, 3);
                baseForOwn(object, function(value, key, object2) {
                  baseAssignValue(result2, iteratee2(value, key, object2), value);
                });
                return result2;
              }
              function mapValues(object, iteratee2) {
                var result2 = {};
                iteratee2 = getIteratee(iteratee2, 3);
                baseForOwn(object, function(value, key, object2) {
                  baseAssignValue(result2, key, iteratee2(value, key, object2));
                });
                return result2;
              }
              var merge = createAssigner(function(object, source, srcIndex) {
                baseMerge(object, source, srcIndex);
              });
              var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
                baseMerge(object, source, srcIndex, customizer);
              });
              var omit = flatRest(function(object, paths) {
                var result2 = {};
                if (object == null) {
                  return result2;
                }
                var isDeep = false;
                paths = arrayMap(paths, function(path) {
                  path = castPath(path, object);
                  isDeep || (isDeep = path.length > 1);
                  return path;
                });
                copyObject(object, getAllKeysIn(object), result2);
                if (isDeep) {
                  result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
                }
                var length = paths.length;
                while (length--) {
                  baseUnset(result2, paths[length]);
                }
                return result2;
              });
              function omitBy(object, predicate) {
                return pickBy(object, negate(getIteratee(predicate)));
              }
              var pick = flatRest(function(object, paths) {
                return object == null ? {} : basePick(object, paths);
              });
              function pickBy(object, predicate) {
                if (object == null) {
                  return {};
                }
                var props = arrayMap(getAllKeysIn(object), function(prop) {
                  return [prop];
                });
                predicate = getIteratee(predicate);
                return basePickBy(object, props, function(value, path) {
                  return predicate(value, path[0]);
                });
              }
              function result(object, path, defaultValue) {
                path = castPath(path, object);
                var index2 = -1, length = path.length;
                if (!length) {
                  length = 1;
                  object = undefined$1;
                }
                while (++index2 < length) {
                  var value = object == null ? undefined$1 : object[toKey(path[index2])];
                  if (value === undefined$1) {
                    index2 = length;
                    value = defaultValue;
                  }
                  object = isFunction2(value) ? value.call(object) : value;
                }
                return object;
              }
              function set(object, path, value) {
                return object == null ? object : baseSet(object, path, value);
              }
              function setWith(object, path, value, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return object == null ? object : baseSet(object, path, value, customizer);
              }
              var toPairs = createToPairs(keys);
              var toPairsIn = createToPairs(keysIn);
              function transform(object, iteratee2, accumulator) {
                var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                iteratee2 = getIteratee(iteratee2, 4);
                if (accumulator == null) {
                  var Ctor = object && object.constructor;
                  if (isArrLike) {
                    accumulator = isArr ? new Ctor() : [];
                  } else if (isObject(object)) {
                    accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
                  } else {
                    accumulator = {};
                  }
                }
                (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
                  return iteratee2(accumulator, value, index2, object2);
                });
                return accumulator;
              }
              function unset(object, path) {
                return object == null ? true : baseUnset(object, path);
              }
              function update(object, path, updater) {
                return object == null ? object : baseUpdate(object, path, castFunction(updater));
              }
              function updateWith(object, path, updater, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
              }
              function values(object) {
                return object == null ? [] : baseValues(object, keys(object));
              }
              function valuesIn(object) {
                return object == null ? [] : baseValues(object, keysIn(object));
              }
              function clamp(number, lower, upper) {
                if (upper === undefined$1) {
                  upper = lower;
                  lower = undefined$1;
                }
                if (upper !== undefined$1) {
                  upper = toNumber(upper);
                  upper = upper === upper ? upper : 0;
                }
                if (lower !== undefined$1) {
                  lower = toNumber(lower);
                  lower = lower === lower ? lower : 0;
                }
                return baseClamp(toNumber(number), lower, upper);
              }
              function inRange(number, start, end) {
                start = toFinite(start);
                if (end === undefined$1) {
                  end = start;
                  start = 0;
                } else {
                  end = toFinite(end);
                }
                number = toNumber(number);
                return baseInRange(number, start, end);
              }
              function random2(lower, upper, floating) {
                if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
                  upper = floating = undefined$1;
                }
                if (floating === undefined$1) {
                  if (typeof upper == "boolean") {
                    floating = upper;
                    upper = undefined$1;
                  } else if (typeof lower == "boolean") {
                    floating = lower;
                    lower = undefined$1;
                  }
                }
                if (lower === undefined$1 && upper === undefined$1) {
                  lower = 0;
                  upper = 1;
                } else {
                  lower = toFinite(lower);
                  if (upper === undefined$1) {
                    upper = lower;
                    lower = 0;
                  } else {
                    upper = toFinite(upper);
                  }
                }
                if (lower > upper) {
                  var temp = lower;
                  lower = upper;
                  upper = temp;
                }
                if (floating || lower % 1 || upper % 1) {
                  var rand = nativeRandom();
                  return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
                }
                return baseRandom(lower, upper);
              }
              var camelCase = createCompounder(function(result2, word, index2) {
                word = word.toLowerCase();
                return result2 + (index2 ? capitalize(word) : word);
              });
              function capitalize(string) {
                return upperFirst(toString(string).toLowerCase());
              }
              function deburr(string) {
                string = toString(string);
                return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
              }
              function endsWith(string, target, position) {
                string = toString(string);
                target = baseToString(target);
                var length = string.length;
                position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
                var end = position;
                position -= target.length;
                return position >= 0 && string.slice(position, end) == target;
              }
              function escape2(string) {
                string = toString(string);
                return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
              }
              function escapeRegExp(string) {
                string = toString(string);
                return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
              }
              var kebabCase = createCompounder(function(result2, word, index2) {
                return result2 + (index2 ? "-" : "") + word.toLowerCase();
              });
              var lowerCase = createCompounder(function(result2, word, index2) {
                return result2 + (index2 ? " " : "") + word.toLowerCase();
              });
              var lowerFirst = createCaseFirst("toLowerCase");
              function pad(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                if (!length || strLength >= length) {
                  return string;
                }
                var mid = (length - strLength) / 2;
                return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
              }
              function padEnd(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
              }
              function padStart(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
              }
              function parseInt2(string, radix, guard) {
                if (guard || radix == null) {
                  radix = 0;
                } else if (radix) {
                  radix = +radix;
                }
                return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
              }
              function repeat(string, n, guard) {
                if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
                  n = 1;
                } else {
                  n = toInteger(n);
                }
                return baseRepeat(toString(string), n);
              }
              function replace() {
                var args = arguments, string = toString(args[0]);
                return args.length < 3 ? string : string.replace(args[1], args[2]);
              }
              var snakeCase = createCompounder(function(result2, word, index2) {
                return result2 + (index2 ? "_" : "") + word.toLowerCase();
              });
              function split(string, separator, limit) {
                if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
                  separator = limit = undefined$1;
                }
                limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
                if (!limit) {
                  return [];
                }
                string = toString(string);
                if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
                  separator = baseToString(separator);
                  if (!separator && hasUnicode(string)) {
                    return castSlice(stringToArray(string), 0, limit);
                  }
                }
                return string.split(separator, limit);
              }
              var startCase = createCompounder(function(result2, word, index2) {
                return result2 + (index2 ? " " : "") + upperFirst(word);
              });
              function startsWith(string, target, position) {
                string = toString(string);
                position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
                target = baseToString(target);
                return string.slice(position, position + target.length) == target;
              }
              function template(string, options, guard) {
                var settings = lodash2.templateSettings;
                if (guard && isIterateeCall(string, options, guard)) {
                  options = undefined$1;
                }
                string = toString(string);
                options = assignInWith({}, options, settings, customDefaultsAssignIn);
                var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
                var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                var reDelimiters = RegExp2(
                  (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
                  "g"
                );
                var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                  interpolateValue || (interpolateValue = esTemplateValue);
                  source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
                  if (escapeValue) {
                    isEscaping = true;
                    source += "' +\n__e(" + escapeValue + ") +\n'";
                  }
                  if (evaluateValue) {
                    isEvaluating = true;
                    source += "';\n" + evaluateValue + ";\n__p += '";
                  }
                  if (interpolateValue) {
                    source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                  }
                  index2 = offset + match.length;
                  return match;
                });
                source += "';\n";
                var variable = hasOwnProperty.call(options, "variable") && options.variable;
                if (!variable) {
                  source = "with (obj) {\n" + source + "\n}\n";
                } else if (reForbiddenIdentifierChars.test(variable)) {
                  throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
                }
                source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                var result2 = attempt(function() {
                  return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
                });
                result2.source = source;
                if (isError(result2)) {
                  throw result2;
                }
                return result2;
              }
              function toLower(value) {
                return toString(value).toLowerCase();
              }
              function toUpper(value) {
                return toString(value).toUpperCase();
              }
              function trim(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined$1)) {
                  return baseTrim(string);
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
                return castSlice(strSymbols, start, end).join("");
              }
              function trimEnd(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined$1)) {
                  return string.slice(0, trimmedEndIndex(string) + 1);
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                return castSlice(strSymbols, 0, end).join("");
              }
              function trimStart(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined$1)) {
                  return string.replace(reTrimStart, "");
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
                return castSlice(strSymbols, start).join("");
              }
              function truncate(string, options) {
                var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                if (isObject(options)) {
                  var separator = "separator" in options ? options.separator : separator;
                  length = "length" in options ? toInteger(options.length) : length;
                  omission = "omission" in options ? baseToString(options.omission) : omission;
                }
                string = toString(string);
                var strLength = string.length;
                if (hasUnicode(string)) {
                  var strSymbols = stringToArray(string);
                  strLength = strSymbols.length;
                }
                if (length >= strLength) {
                  return string;
                }
                var end = length - stringSize(omission);
                if (end < 1) {
                  return omission;
                }
                var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
                if (separator === undefined$1) {
                  return result2 + omission;
                }
                if (strSymbols) {
                  end += result2.length - end;
                }
                if (isRegExp(separator)) {
                  if (string.slice(end).search(separator)) {
                    var match, substring = result2;
                    if (!separator.global) {
                      separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                    }
                    separator.lastIndex = 0;
                    while (match = separator.exec(substring)) {
                      var newEnd = match.index;
                    }
                    result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
                  }
                } else if (string.indexOf(baseToString(separator), end) != end) {
                  var index2 = result2.lastIndexOf(separator);
                  if (index2 > -1) {
                    result2 = result2.slice(0, index2);
                  }
                }
                return result2 + omission;
              }
              function unescape2(string) {
                string = toString(string);
                return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
              }
              var upperCase = createCompounder(function(result2, word, index2) {
                return result2 + (index2 ? " " : "") + word.toUpperCase();
              });
              var upperFirst = createCaseFirst("toUpperCase");
              function words(string, pattern, guard) {
                string = toString(string);
                pattern = guard ? undefined$1 : pattern;
                if (pattern === undefined$1) {
                  return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
                }
                return string.match(pattern) || [];
              }
              var attempt = baseRest(function(func, args) {
                try {
                  return apply(func, undefined$1, args);
                } catch (e) {
                  return isError(e) ? e : new Error2(e);
                }
              });
              var bindAll = flatRest(function(object, methodNames) {
                arrayEach(methodNames, function(key) {
                  key = toKey(key);
                  baseAssignValue(object, key, bind(object[key], object));
                });
                return object;
              });
              function cond(pairs) {
                var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
                pairs = !length ? [] : arrayMap(pairs, function(pair) {
                  if (typeof pair[1] != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  return [toIteratee(pair[0]), pair[1]];
                });
                return baseRest(function(args) {
                  var index2 = -1;
                  while (++index2 < length) {
                    var pair = pairs[index2];
                    if (apply(pair[0], this, args)) {
                      return apply(pair[1], this, args);
                    }
                  }
                });
              }
              function conforms(source) {
                return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
              }
              function constant(value) {
                return function() {
                  return value;
                };
              }
              function defaultTo(value, defaultValue) {
                return value == null || value !== value ? defaultValue : value;
              }
              var flow = createFlow();
              var flowRight = createFlow(true);
              function identity(value) {
                return value;
              }
              function iteratee(func) {
                return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
              }
              function matches(source) {
                return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
              }
              function matchesProperty(path, srcValue) {
                return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
              }
              var method = baseRest(function(path, args) {
                return function(object) {
                  return baseInvoke(object, path, args);
                };
              });
              var methodOf = baseRest(function(object, args) {
                return function(path) {
                  return baseInvoke(object, path, args);
                };
              });
              function mixin(object, source, options) {
                var props = keys(source), methodNames = baseFunctions(source, props);
                if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
                  options = source;
                  source = object;
                  object = this;
                  methodNames = baseFunctions(source, keys(source));
                }
                var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
                arrayEach(methodNames, function(methodName) {
                  var func = source[methodName];
                  object[methodName] = func;
                  if (isFunc) {
                    object.prototype[methodName] = function() {
                      var chainAll = this.__chain__;
                      if (chain2 || chainAll) {
                        var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                        actions.push({ "func": func, "args": arguments, "thisArg": object });
                        result2.__chain__ = chainAll;
                        return result2;
                      }
                      return func.apply(object, arrayPush([this.value()], arguments));
                    };
                  }
                });
                return object;
              }
              function noConflict() {
                if (root._ === this) {
                  root._ = oldDash;
                }
                return this;
              }
              function noop() {
              }
              function nthArg(n) {
                n = toInteger(n);
                return baseRest(function(args) {
                  return baseNth(args, n);
                });
              }
              var over = createOver(arrayMap);
              var overEvery = createOver(arrayEvery);
              var overSome = createOver(arraySome);
              function property(path) {
                return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
              }
              function propertyOf(object) {
                return function(path) {
                  return object == null ? undefined$1 : baseGet(object, path);
                };
              }
              var range = createRange();
              var rangeRight = createRange(true);
              function stubArray() {
                return [];
              }
              function stubFalse() {
                return false;
              }
              function stubObject() {
                return {};
              }
              function stubString() {
                return "";
              }
              function stubTrue() {
                return true;
              }
              function times(n, iteratee2) {
                n = toInteger(n);
                if (n < 1 || n > MAX_SAFE_INTEGER) {
                  return [];
                }
                var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
                iteratee2 = getIteratee(iteratee2);
                n -= MAX_ARRAY_LENGTH;
                var result2 = baseTimes(length, iteratee2);
                while (++index2 < n) {
                  iteratee2(index2);
                }
                return result2;
              }
              function toPath(value) {
                if (isArray(value)) {
                  return arrayMap(value, toKey);
                }
                return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
              }
              function uniqueId(prefix) {
                var id = ++idCounter;
                return toString(prefix) + id;
              }
              var add = createMathOperation(function(augend, addend) {
                return augend + addend;
              }, 0);
              var ceil = createRound("ceil");
              var divide = createMathOperation(function(dividend, divisor) {
                return dividend / divisor;
              }, 1);
              var floor = createRound("floor");
              function max2(array) {
                return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
              }
              function maxBy(array, iteratee2) {
                return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
              }
              function mean(array) {
                return baseMean(array, identity);
              }
              function meanBy(array, iteratee2) {
                return baseMean(array, getIteratee(iteratee2, 2));
              }
              function min(array) {
                return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
              }
              function minBy(array, iteratee2) {
                return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
              }
              var multiply = createMathOperation(function(multiplier, multiplicand) {
                return multiplier * multiplicand;
              }, 1);
              var round = createRound("round");
              var subtract = createMathOperation(function(minuend, subtrahend) {
                return minuend - subtrahend;
              }, 0);
              function sum(array) {
                return array && array.length ? baseSum(array, identity) : 0;
              }
              function sumBy(array, iteratee2) {
                return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
              }
              lodash2.after = after;
              lodash2.ary = ary;
              lodash2.assign = assign;
              lodash2.assignIn = assignIn;
              lodash2.assignInWith = assignInWith;
              lodash2.assignWith = assignWith;
              lodash2.at = at;
              lodash2.before = before;
              lodash2.bind = bind;
              lodash2.bindAll = bindAll;
              lodash2.bindKey = bindKey;
              lodash2.castArray = castArray;
              lodash2.chain = chain;
              lodash2.chunk = chunk;
              lodash2.compact = compact;
              lodash2.concat = concat;
              lodash2.cond = cond;
              lodash2.conforms = conforms;
              lodash2.constant = constant;
              lodash2.countBy = countBy;
              lodash2.create = create;
              lodash2.curry = curry;
              lodash2.curryRight = curryRight;
              lodash2.debounce = debounce;
              lodash2.defaults = defaults;
              lodash2.defaultsDeep = defaultsDeep;
              lodash2.defer = defer;
              lodash2.delay = delay;
              lodash2.difference = difference;
              lodash2.differenceBy = differenceBy;
              lodash2.differenceWith = differenceWith;
              lodash2.drop = drop;
              lodash2.dropRight = dropRight;
              lodash2.dropRightWhile = dropRightWhile;
              lodash2.dropWhile = dropWhile;
              lodash2.fill = fill;
              lodash2.filter = filter;
              lodash2.flatMap = flatMap;
              lodash2.flatMapDeep = flatMapDeep;
              lodash2.flatMapDepth = flatMapDepth;
              lodash2.flatten = flatten;
              lodash2.flattenDeep = flattenDeep;
              lodash2.flattenDepth = flattenDepth;
              lodash2.flip = flip;
              lodash2.flow = flow;
              lodash2.flowRight = flowRight;
              lodash2.fromPairs = fromPairs;
              lodash2.functions = functions;
              lodash2.functionsIn = functionsIn;
              lodash2.groupBy = groupBy;
              lodash2.initial = initial;
              lodash2.intersection = intersection;
              lodash2.intersectionBy = intersectionBy;
              lodash2.intersectionWith = intersectionWith;
              lodash2.invert = invert;
              lodash2.invertBy = invertBy;
              lodash2.invokeMap = invokeMap;
              lodash2.iteratee = iteratee;
              lodash2.keyBy = keyBy;
              lodash2.keys = keys;
              lodash2.keysIn = keysIn;
              lodash2.map = map;
              lodash2.mapKeys = mapKeys;
              lodash2.mapValues = mapValues;
              lodash2.matches = matches;
              lodash2.matchesProperty = matchesProperty;
              lodash2.memoize = memoize;
              lodash2.merge = merge;
              lodash2.mergeWith = mergeWith;
              lodash2.method = method;
              lodash2.methodOf = methodOf;
              lodash2.mixin = mixin;
              lodash2.negate = negate;
              lodash2.nthArg = nthArg;
              lodash2.omit = omit;
              lodash2.omitBy = omitBy;
              lodash2.once = once;
              lodash2.orderBy = orderBy;
              lodash2.over = over;
              lodash2.overArgs = overArgs;
              lodash2.overEvery = overEvery;
              lodash2.overSome = overSome;
              lodash2.partial = partial;
              lodash2.partialRight = partialRight;
              lodash2.partition = partition;
              lodash2.pick = pick;
              lodash2.pickBy = pickBy;
              lodash2.property = property;
              lodash2.propertyOf = propertyOf;
              lodash2.pull = pull;
              lodash2.pullAll = pullAll;
              lodash2.pullAllBy = pullAllBy;
              lodash2.pullAllWith = pullAllWith;
              lodash2.pullAt = pullAt;
              lodash2.range = range;
              lodash2.rangeRight = rangeRight;
              lodash2.rearg = rearg;
              lodash2.reject = reject;
              lodash2.remove = remove;
              lodash2.rest = rest;
              lodash2.reverse = reverse;
              lodash2.sampleSize = sampleSize;
              lodash2.set = set;
              lodash2.setWith = setWith;
              lodash2.shuffle = shuffle;
              lodash2.slice = slice;
              lodash2.sortBy = sortBy;
              lodash2.sortedUniq = sortedUniq;
              lodash2.sortedUniqBy = sortedUniqBy;
              lodash2.split = split;
              lodash2.spread = spread;
              lodash2.tail = tail;
              lodash2.take = take;
              lodash2.takeRight = takeRight;
              lodash2.takeRightWhile = takeRightWhile;
              lodash2.takeWhile = takeWhile;
              lodash2.tap = tap;
              lodash2.throttle = throttle2;
              lodash2.thru = thru;
              lodash2.toArray = toArray;
              lodash2.toPairs = toPairs;
              lodash2.toPairsIn = toPairsIn;
              lodash2.toPath = toPath;
              lodash2.toPlainObject = toPlainObject;
              lodash2.transform = transform;
              lodash2.unary = unary;
              lodash2.union = union;
              lodash2.unionBy = unionBy;
              lodash2.unionWith = unionWith;
              lodash2.uniq = uniq;
              lodash2.uniqBy = uniqBy;
              lodash2.uniqWith = uniqWith;
              lodash2.unset = unset;
              lodash2.unzip = unzip;
              lodash2.unzipWith = unzipWith;
              lodash2.update = update;
              lodash2.updateWith = updateWith;
              lodash2.values = values;
              lodash2.valuesIn = valuesIn;
              lodash2.without = without;
              lodash2.words = words;
              lodash2.wrap = wrap;
              lodash2.xor = xor;
              lodash2.xorBy = xorBy;
              lodash2.xorWith = xorWith;
              lodash2.zip = zip;
              lodash2.zipObject = zipObject;
              lodash2.zipObjectDeep = zipObjectDeep;
              lodash2.zipWith = zipWith;
              lodash2.entries = toPairs;
              lodash2.entriesIn = toPairsIn;
              lodash2.extend = assignIn;
              lodash2.extendWith = assignInWith;
              mixin(lodash2, lodash2);
              lodash2.add = add;
              lodash2.attempt = attempt;
              lodash2.camelCase = camelCase;
              lodash2.capitalize = capitalize;
              lodash2.ceil = ceil;
              lodash2.clamp = clamp;
              lodash2.clone = clone;
              lodash2.cloneDeep = cloneDeep;
              lodash2.cloneDeepWith = cloneDeepWith;
              lodash2.cloneWith = cloneWith;
              lodash2.conformsTo = conformsTo;
              lodash2.deburr = deburr;
              lodash2.defaultTo = defaultTo;
              lodash2.divide = divide;
              lodash2.endsWith = endsWith;
              lodash2.eq = eq;
              lodash2.escape = escape2;
              lodash2.escapeRegExp = escapeRegExp;
              lodash2.every = every;
              lodash2.find = find;
              lodash2.findIndex = findIndex;
              lodash2.findKey = findKey;
              lodash2.findLast = findLast;
              lodash2.findLastIndex = findLastIndex;
              lodash2.findLastKey = findLastKey;
              lodash2.floor = floor;
              lodash2.forEach = forEach;
              lodash2.forEachRight = forEachRight;
              lodash2.forIn = forIn;
              lodash2.forInRight = forInRight;
              lodash2.forOwn = forOwn;
              lodash2.forOwnRight = forOwnRight;
              lodash2.get = get;
              lodash2.gt = gt;
              lodash2.gte = gte;
              lodash2.has = has;
              lodash2.hasIn = hasIn;
              lodash2.head = head;
              lodash2.identity = identity;
              lodash2.includes = includes;
              lodash2.indexOf = indexOf2;
              lodash2.inRange = inRange;
              lodash2.invoke = invoke;
              lodash2.isArguments = isArguments;
              lodash2.isArray = isArray;
              lodash2.isArrayBuffer = isArrayBuffer;
              lodash2.isArrayLike = isArrayLike;
              lodash2.isArrayLikeObject = isArrayLikeObject;
              lodash2.isBoolean = isBoolean;
              lodash2.isBuffer = isBuffer;
              lodash2.isDate = isDate;
              lodash2.isElement = isElement;
              lodash2.isEmpty = isEmpty;
              lodash2.isEqual = isEqual;
              lodash2.isEqualWith = isEqualWith;
              lodash2.isError = isError;
              lodash2.isFinite = isFinite2;
              lodash2.isFunction = isFunction2;
              lodash2.isInteger = isInteger;
              lodash2.isLength = isLength;
              lodash2.isMap = isMap;
              lodash2.isMatch = isMatch;
              lodash2.isMatchWith = isMatchWith;
              lodash2.isNaN = isNaN2;
              lodash2.isNative = isNative;
              lodash2.isNil = isNil;
              lodash2.isNull = isNull;
              lodash2.isNumber = isNumber;
              lodash2.isObject = isObject;
              lodash2.isObjectLike = isObjectLike;
              lodash2.isPlainObject = isPlainObject;
              lodash2.isRegExp = isRegExp;
              lodash2.isSafeInteger = isSafeInteger;
              lodash2.isSet = isSet;
              lodash2.isString = isString;
              lodash2.isSymbol = isSymbol;
              lodash2.isTypedArray = isTypedArray;
              lodash2.isUndefined = isUndefined;
              lodash2.isWeakMap = isWeakMap;
              lodash2.isWeakSet = isWeakSet;
              lodash2.join = join;
              lodash2.kebabCase = kebabCase;
              lodash2.last = last;
              lodash2.lastIndexOf = lastIndexOf;
              lodash2.lowerCase = lowerCase;
              lodash2.lowerFirst = lowerFirst;
              lodash2.lt = lt;
              lodash2.lte = lte;
              lodash2.max = max2;
              lodash2.maxBy = maxBy;
              lodash2.mean = mean;
              lodash2.meanBy = meanBy;
              lodash2.min = min;
              lodash2.minBy = minBy;
              lodash2.stubArray = stubArray;
              lodash2.stubFalse = stubFalse;
              lodash2.stubObject = stubObject;
              lodash2.stubString = stubString;
              lodash2.stubTrue = stubTrue;
              lodash2.multiply = multiply;
              lodash2.nth = nth;
              lodash2.noConflict = noConflict;
              lodash2.noop = noop;
              lodash2.now = now;
              lodash2.pad = pad;
              lodash2.padEnd = padEnd;
              lodash2.padStart = padStart;
              lodash2.parseInt = parseInt2;
              lodash2.random = random2;
              lodash2.reduce = reduce;
              lodash2.reduceRight = reduceRight;
              lodash2.repeat = repeat;
              lodash2.replace = replace;
              lodash2.result = result;
              lodash2.round = round;
              lodash2.runInContext = runInContext2;
              lodash2.sample = sample;
              lodash2.size = size;
              lodash2.snakeCase = snakeCase;
              lodash2.some = some;
              lodash2.sortedIndex = sortedIndex;
              lodash2.sortedIndexBy = sortedIndexBy;
              lodash2.sortedIndexOf = sortedIndexOf;
              lodash2.sortedLastIndex = sortedLastIndex;
              lodash2.sortedLastIndexBy = sortedLastIndexBy;
              lodash2.sortedLastIndexOf = sortedLastIndexOf;
              lodash2.startCase = startCase;
              lodash2.startsWith = startsWith;
              lodash2.subtract = subtract;
              lodash2.sum = sum;
              lodash2.sumBy = sumBy;
              lodash2.template = template;
              lodash2.times = times;
              lodash2.toFinite = toFinite;
              lodash2.toInteger = toInteger;
              lodash2.toLength = toLength;
              lodash2.toLower = toLower;
              lodash2.toNumber = toNumber;
              lodash2.toSafeInteger = toSafeInteger;
              lodash2.toString = toString;
              lodash2.toUpper = toUpper;
              lodash2.trim = trim;
              lodash2.trimEnd = trimEnd;
              lodash2.trimStart = trimStart;
              lodash2.truncate = truncate;
              lodash2.unescape = unescape2;
              lodash2.uniqueId = uniqueId;
              lodash2.upperCase = upperCase;
              lodash2.upperFirst = upperFirst;
              lodash2.each = forEach;
              lodash2.eachRight = forEachRight;
              lodash2.first = head;
              mixin(lodash2, (function() {
                var source = {};
                baseForOwn(lodash2, function(func, methodName) {
                  if (!hasOwnProperty.call(lodash2.prototype, methodName)) {
                    source[methodName] = func;
                  }
                });
                return source;
              })(), { "chain": false });
              lodash2.VERSION = VERSION;
              arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
                lodash2[methodName].placeholder = lodash2;
              });
              arrayEach(["drop", "take"], function(methodName, index2) {
                LazyWrapper.prototype[methodName] = function(n) {
                  n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
                  var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
                  if (result2.__filtered__) {
                    result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
                  } else {
                    result2.__views__.push({
                      "size": nativeMin(n, MAX_ARRAY_LENGTH),
                      "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                    });
                  }
                  return result2;
                };
                LazyWrapper.prototype[methodName + "Right"] = function(n) {
                  return this.reverse()[methodName](n).reverse();
                };
              });
              arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
                var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                LazyWrapper.prototype[methodName] = function(iteratee2) {
                  var result2 = this.clone();
                  result2.__iteratees__.push({
                    "iteratee": getIteratee(iteratee2, 3),
                    "type": type
                  });
                  result2.__filtered__ = result2.__filtered__ || isFilter;
                  return result2;
                };
              });
              arrayEach(["head", "last"], function(methodName, index2) {
                var takeName = "take" + (index2 ? "Right" : "");
                LazyWrapper.prototype[methodName] = function() {
                  return this[takeName](1).value()[0];
                };
              });
              arrayEach(["initial", "tail"], function(methodName, index2) {
                var dropName = "drop" + (index2 ? "" : "Right");
                LazyWrapper.prototype[methodName] = function() {
                  return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                };
              });
              LazyWrapper.prototype.compact = function() {
                return this.filter(identity);
              };
              LazyWrapper.prototype.find = function(predicate) {
                return this.filter(predicate).head();
              };
              LazyWrapper.prototype.findLast = function(predicate) {
                return this.reverse().find(predicate);
              };
              LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
                if (typeof path == "function") {
                  return new LazyWrapper(this);
                }
                return this.map(function(value) {
                  return baseInvoke(value, path, args);
                });
              });
              LazyWrapper.prototype.reject = function(predicate) {
                return this.filter(negate(getIteratee(predicate)));
              };
              LazyWrapper.prototype.slice = function(start, end) {
                start = toInteger(start);
                var result2 = this;
                if (result2.__filtered__ && (start > 0 || end < 0)) {
                  return new LazyWrapper(result2);
                }
                if (start < 0) {
                  result2 = result2.takeRight(-start);
                } else if (start) {
                  result2 = result2.drop(start);
                }
                if (end !== undefined$1) {
                  end = toInteger(end);
                  result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
                }
                return result2;
              };
              LazyWrapper.prototype.takeRightWhile = function(predicate) {
                return this.reverse().takeWhile(predicate).reverse();
              };
              LazyWrapper.prototype.toArray = function() {
                return this.take(MAX_ARRAY_LENGTH);
              };
              baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
                if (!lodashFunc) {
                  return;
                }
                lodash2.prototype[methodName] = function() {
                  var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
                  var interceptor = function(value2) {
                    var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
                    return isTaker && chainAll ? result3[0] : result3;
                  };
                  if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                    isLazy = useLazy = false;
                  }
                  var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                  if (!retUnwrapped && useLazy) {
                    value = onlyLazy ? value : new LazyWrapper(this);
                    var result2 = func.apply(value, args);
                    result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
                    return new LodashWrapper(result2, chainAll);
                  }
                  if (isUnwrapped && onlyLazy) {
                    return func.apply(this, args);
                  }
                  result2 = this.thru(interceptor);
                  return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
                };
              });
              arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
                var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                lodash2.prototype[methodName] = function() {
                  var args = arguments;
                  if (retUnwrapped && !this.__chain__) {
                    var value = this.value();
                    return func.apply(isArray(value) ? value : [], args);
                  }
                  return this[chainName](function(value2) {
                    return func.apply(isArray(value2) ? value2 : [], args);
                  });
                };
              });
              baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                var lodashFunc = lodash2[methodName];
                if (lodashFunc) {
                  var key = lodashFunc.name + "";
                  if (!hasOwnProperty.call(realNames, key)) {
                    realNames[key] = [];
                  }
                  realNames[key].push({ "name": methodName, "func": lodashFunc });
                }
              });
              realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
                "name": "wrapper",
                "func": undefined$1
              }];
              LazyWrapper.prototype.clone = lazyClone;
              LazyWrapper.prototype.reverse = lazyReverse;
              LazyWrapper.prototype.value = lazyValue;
              lodash2.prototype.at = wrapperAt;
              lodash2.prototype.chain = wrapperChain;
              lodash2.prototype.commit = wrapperCommit;
              lodash2.prototype.next = wrapperNext;
              lodash2.prototype.plant = wrapperPlant;
              lodash2.prototype.reverse = wrapperReverse;
              lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
              lodash2.prototype.first = lodash2.prototype.head;
              if (symIterator) {
                lodash2.prototype[symIterator] = wrapperToIterator;
              }
              return lodash2;
            });
            var _ = runInContext();
            if (freeModule) {
              (freeModule.exports = _)._ = _;
              freeExports._ = _;
            } else {
              root._ = _;
            }
          }).call(lodash);
        })(lodash$1, lodash$1.exports);
        return lodash$1.exports;
      }
      var lodashExports = requireLodash();
      const loading$1 = "_loading_jnpqx_59";
      const footer$1 = "_footer_jnpqx_161";
      const styles$6 = {
        "hot-song-modal": "_hot-song-modal_jnpqx_1",
        "modal-title": "_modal-title_jnpqx_1",
        "title-content": "_title-content_jnpqx_4",
        "title-stats": "_title-stats_jnpqx_10",
        "stat-item": "_stat-item_jnpqx_14",
        loading: loading$1,
        "stat-value": "_stat-value_jnpqx_62",
        "stat-label": "_stat-label_jnpqx_74",
        "song-table": "_song-table_jnpqx_97",
        "song-info": "_song-info_jnpqx_100",
        "album-cover": "_album-cover_jnpqx_100",
        "song-details": "_song-details_jnpqx_113",
        "song-name": "_song-name_jnpqx_117",
        "song-album": "_song-album_jnpqx_126",
        "singer-info": "_singer-info_jnpqx_90",
        "singer-name": "_singer-name_jnpqx_134",
        "singer-id": "_singer-id_jnpqx_142",
        "song-id-text": "_song-id-text_jnpqx_150",
        "song-mid-text": "_song-mid-text_jnpqx_151",
        footer: footer$1,
        "selected-count": "_selected-count_jnpqx_167"
      };
      const { Text: Text$2, Title: Title$2 } = Typography;
      const defaultLoadingData = {
        total: 0,
        loadedSong: 0,
        songList: [],
        totalSong: 0,
        totalAlbum: 0,
        totalMV: 0,
        extras: []
      };
      const HotSongModal = (props, ref) => {
        const { visible, close } = useVisible(
          {
            onOpen: (params) => {
              console.log("params", params);
              setSingerInfo(params);
            },
            onReset: () => {
              setSingerInfo({});
              setSelectedRowKeys([]);
              setSelectedRows([]);
              setLoadingData({
                ...defaultLoadingData
              });
            }
          },
          ref
        );
        const { downloadConfig } = useConfig();
        const { quality: defaultQuality } = downloadConfig;
        const { play, pause, isPlaying, download, getUrl, getLyric, convertToNeteaseMusic } = usePlayMusic();
        const [singerInfo, setSingerInfo] = useState({});
        const [loadingData, setLoadingData] = useState(defaultLoadingData);
        const { loading: loading2 } = useGetData(
          () => getSingerAllHotSong(singerInfo.singerMid, {
            onChange: (result) => {
              setLoadingData({
                total: result.total,
                loadedSong: result.songList.length,
                songList: result.songList,
                totalSong: result.total,
                totalAlbum: result.totalAlbum,
                totalMV: result.totalMV,
                extras: result.extras
              });
            }
          }),
          void 0,
          {
            monitors: [singerInfo.singerMid, visible],
            returnFunction: () => !visible || !singerInfo.singerMid
          }
        );
        const { songList = [], totalSong, totalAlbum, totalMV, extras } = loadingData;
        const [searchParams, setSearchParams] = useState({
          keyword: ""
        });
        const searchFormOptions = [
          {
            label: "歌曲名称",
            name: "name",
            type: "select",
            options: uniqueArrayByKey(songList, "name").map((item) => ({
              label: item.name,
              value: item.name
            })),
            inputProps: {
              mode: "multiple"
            }
          },
          {
            label: "专辑名称",
            name: "albumName",
            type: "select",
            options: uniqueArrayByKey(
              songList.map((item) => item.album),
              "name"
            ).map((item) => ({
              label: item.name,
              value: item.name
            })),
            inputProps: {
              mode: "multiple"
            }
          }
        ];
        const { filteredList, setFilteredList, handleFilter } = useFilter(songList, {
          fields: {
            name: {
              getValue: (item) => item.name
            },
            albumName: {
              getValue: (item) => item.album?.name
            }
          }
        });
        const handleChooseQuality = (record, quality) => {
          setFilteredList(
            filteredList.map((item) => {
              if (item.mid === record.mid) {
                return {
                  ...item,
                  quality
                };
              }
              return item;
            })
          );
        };
        const handlePlay = (record) => {
          console.log("record", record);
          const { mid, quality, file } = record;
          const finalQuality = getQuality$2(file, defaultQuality, quality);
          console.log("当前播放歌曲:", record.name, "音质:", finalQuality);
          play(mid, finalQuality);
        };
        const handleDownload = async (record) => {
          try {
            const { mid, name: name2, quality, file } = record;
            const finalQuality = getQuality$2(file, defaultQuality, quality);
            console.log("当前下载歌曲:", name2, "音质:", finalQuality);
            await download(mid, finalQuality);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleConvertToNeteaseMusic = async (record) => {
          try {
            const { mid, name: name2, quality, file } = record;
            const finalQuality = getQuality$2(file, defaultQuality, quality);
            console.log("当前转存网易云歌曲:", name2, "音质:", finalQuality);
            await convertToNeteaseMusic(mid, { quality: finalQuality });
          } catch (error) {
            console.log("error", error);
            msgError("转存网易云失败");
          }
        };
        const columns = [
          {
            title: "歌曲信息",
            dataIndex: "name",
            key: "name",
            width: 250,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$6["song-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6["album-cover"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Image,
                {
                  width: 40,
                  height: 40,
                  src: record.album?.mid ? getAlbumPicUrl(record.album.mid) : "",
                  alt: record.album?.name || "专辑封面"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6["song-details"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6["song-name"], title: text, children: text }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6["song-album"], title: record.album?.name || "未知专辑", children: record.album?.name || "未知专辑" })
              ] })
            ] })
          },
          {
            title: "歌手",
            dataIndex: "singer",
            key: "singer",
            width: 200,
            render: (singer) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "small", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}), src: singerInfo?.singerPic, size: 40 }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6["singer-info"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6["singer-name"], title: singer?.[0]?.name || "未知歌手", children: singer?.[0]?.name || "未知歌手" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6["singer-id"], title: singer?.[0]?.id?.toString() || "", children: singer?.[0]?.id || "" })
              ] })
            ] })
          },
          {
            title: "时长",
            dataIndex: "interval",
            key: "interval",
            width: 100,
            align: "center",
            render: (interval) => {
              const minutes = Math.floor(interval / 60);
              const seconds = interval % 60;
              return `${minutes}:${seconds.toString().padStart(2, "0")}`;
            }
          },
          {
            title: "音质",
            dataIndex: "file",
            key: "file",
            width: 100,
            align: "center",
            render: (file, record) => {
              const qualityList = getFile_qualityList(file);
              const defaultValue = qualityList.includes(defaultQuality) ? defaultQuality : qualityList[0];
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select,
                {
                  options: qualityList.map((quality) => ({
                    label: quality,
                    value: quality
                  })),
                  defaultValue,
                  style: { width: "100%" },
                  onChange: (value) => {
                    handleChooseQuality(record, value);
                  }
                }
              );
            }
          },
          // 格式
          {
            title: "格式",
            dataIndex: "format",
            key: "format",
            width: 150,
            align: "center",
            render: (_, record) => {
              const qualityList = getFile_qualityList(record.file);
              const qualityColorMap = {
                flac: "green",
                ape: "volcano",
                320: "blue",
                m4a: "orange",
                128: "gray"
              };
              const qualityTextMap = {
                flac: "FLAC",
                ape: "APE",
                320: "320k",
                m4a: "M4A",
                128: "128k"
              };
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Space, { wrap: true, children: qualityList.map((quality) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: qualityColorMap[quality], children: qualityTextMap[quality] || quality }, quality)) });
            }
          },
          {
            title: "发布时间",
            dataIndex: "time_public",
            key: "time_public",
            width: 150,
            align: "center",
            render: (_, __, index2) => {
              const extra = extras?.[index2];
              const uploadTime = extra?.upload_time || "";
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Text$2, { className: styles$6["upload-time"], title: uploadTime, children: uploadTime });
            }
          },
          {
            title: "歌曲ID",
            dataIndex: "id",
            key: "id",
            width: 120,
            align: "center",
            render: (id) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$6["song-id-text"], text: id + "" })
          },
          {
            title: "歌曲MID",
            dataIndex: "mid",
            key: "mid",
            width: 200,
            align: "center",
            render: (mid) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$6["song-mid-text"], text: mid })
          },
          {
            title: "操作",
            key: "action",
            width: 250,
            align: "center",
            fixed: "right",
            render: (_, record) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "small", wrap: true, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    icon: isPlaying === record.mid ? /* @__PURE__ */ jsxRuntimeExports.jsx(PauseCircleOutlined, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                    onClick: () => {
                      if (isPlaying === record.mid) {
                        pause();
                      } else {
                        handlePlay(record);
                      }
                    },
                    children: "播放"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MyButton,
                  {
                    type: "link",
                    size: "small",
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}),
                    onClick: () => handleDownload(record),
                    children: "下载"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MyButton,
                  {
                    type: "link",
                    size: "small",
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CloudDownloadOutlined, {}),
                    onClick: () => handleConvertToNeteaseMusic(record),
                    children: "转存网易云"
                  }
                )
              ] });
            }
          }
        ];
        const [selectedRowKeys, setSelectedRowKeys] = useState([]);
        const [selectedRows, setSelectedRows] = useState([]);
        const rowSelection = {
          preserveSelectedRowKeys: true,
          selectedRowKeys,
          onChange: (selectedRowKeys2, selectedRows2) => {
            setSelectedRowKeys(selectedRowKeys2);
            setSelectedRows(selectedRows2);
            console.log("selectedRowKeys", selectedRowKeys2);
            console.log("selectedRows", selectedRows2);
          }
        };
        const renderTitle = () => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6["modal-title"], children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6["title-content"], children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Title$2, { level: 4, style: { margin: 0 }, children: [
              singerInfo.singerName,
              " - 热门歌曲"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6["title-stats"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$6["stat-item"]} ${loading2 ? styles$6["loading"] : ""}`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6["stat-label"], children: "歌曲" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6["stat-value"], children: loading2 ? "..." : totalSong || 0 })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$6["stat-item"]} ${loading2 ? styles$6["loading"] : ""}`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6["stat-label"], children: "专辑" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6["stat-value"], children: loading2 ? "..." : totalAlbum || 0 })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$6["stat-item"]} ${loading2 ? styles$6["loading"] : ""}`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6["stat-label"], children: "MV" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6["stat-value"], children: loading2 ? "..." : totalMV || 0 })
              ] })
            ] })
          ] }) });
        };
        const handleBatchConvertToNeteaseMusic = async () => {
          try {
            if (selectedRows.length === 0) {
              msgWarning("请先选择要转存网易云的歌曲");
              return;
            }
            const loadingKey = "convert-to-netease-music";
            message$1.loading({
              key: loadingKey,
              content: `正在准备转存网易云 ${selectedRows.length} 首歌曲`,
              duration: 0
            });
            let songIndex = 1;
            for (const song of selectedRows) {
              const record = song;
              const finalQuality = getQuality$2(record.file, defaultQuality, record.quality);
              message$1.loading({
                key: loadingKey,
                content: `第 ${songIndex++} / ${selectedRows.length} 首歌曲：《${song.name}》 开始转存！`,
                duration: 0
              });
              await convertToNeteaseMusic(song.mid, { quality: finalQuality });
            }
            message$1.success({
              key: loadingKey,
              content: `成功转存 ${selectedRows.length} 首歌曲！`,
              duration: 0
            });
            message$1.destroy(loadingKey);
          } catch (error) {
            console.error("批量转存网易云失败:", error);
          }
        };
        const handleBatchDownloadJson = async () => {
          try {
            if (selectedRows.length === 0) {
              msgWarning("请先选择要下载的歌曲");
              return;
            }
            console.log("selectedRows", selectedRows);
            const groupData = lodashExports.groupBy(selectedRows, "album.mid");
            console.log("groupData", groupData);
            const result = [];
            const loadingKey = "download-json";
            message$1.loading({
              key: loadingKey,
              content: `正在准备下载 ${selectedRows.length} 首歌曲，其中包括 ${Object.keys(groupData).length} 个专辑`,
              duration: 0
            });
            let albumIndex = 1;
            let songIndex = 1;
            for (const albumMid in groupData) {
              const album = groupData[albumMid];
              const albumName = album[0].album.name;
              const albumCover = getAlbumPicUrl(albumMid);
              message$1.loading({
                key: loadingKey,
                content: `开始下载第 ${albumIndex} / ${Object.keys(groupData).length} 个专辑 ：《${albumName}》`,
                duration: 0
              });
              const promiseArr = album.map((song) => async () => {
                const lrcContent = await getLyric(song.mid);
                const finalQuality = getQuality$2(song.file, defaultQuality);
                const url = await getUrl(song.mid, finalQuality);
                message$1.loading({
                  key: loadingKey,
                  content: `第 ${songIndex++} / ${album.length} 首歌曲：《${song.name}》 下载完成！`,
                  duration: 0
                });
                return {
                  songName: song.name,
                  url,
                  lrcContent
                };
              });
              const albumSongs = await promiseLimit(promiseArr, 6);
              result.push({
                albumName,
                albumCover,
                list: albumSongs
              });
              message$1.success({
                key: loadingKey,
                content: `第 ${albumIndex++} / ${Object.keys(groupData).length} 个专辑：《${albumName}》下载完成！`,
                duration: 0
              });
            }
            message$1.destroy(loadingKey);
            downloadAsJson(result, `${singerInfo.singerName}-专辑`);
          } catch (error) {
            console.error("批量下载JSON失败:", error);
          }
        };
        const handleBatchDownload = async () => {
          try {
            if (selectedRows.length === 0) {
              msgWarning("请先选择要下载的歌曲");
              return;
            }
            const loadingKey = "download-song";
            message$1.loading({
              key: loadingKey,
              content: `正在准备下载 ${selectedRows.length} 首歌曲`,
              duration: 0
            });
            let songIndex = 1;
            for (const song of selectedRows) {
              const finalQuality = getQuality$2(song.file, defaultQuality);
              message$1.loading({
                key: loadingKey,
                content: `第 ${songIndex++} / ${selectedRows.length} 首歌曲：《${song.name}》 开始下载！`,
                duration: 0
              });
              await download(song.mid, finalQuality);
              message$1.success({
                key: loadingKey,
                content: `第 ${songIndex++} / ${selectedRows.length} 首歌曲：《${song.name}》 下载完成！`,
                duration: 0
              });
            }
            msgSuccess(`成功下载 ${selectedRows.length} 首歌曲！`);
            message$1.destroy(loadingKey);
          } catch (error) {
            console.error("批量下载失败:", error);
          }
        };
        const renderFooter = () => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6["footer"], children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6["selected-count"], children: [
              "已选择 ",
              selectedRows.length,
              " 首歌曲"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
              selectedRowKeys?.length < songList?.length ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    setSelectedRowKeys(songList?.map((item) => item.mid) || []);
                    setSelectedRows(songList || []);
                  },
                  children: "全部选择"
                }
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    setSelectedRowKeys([]);
                    setSelectedRows([]);
                  },
                  children: "清空选择"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                MyButton,
                {
                  type: "primary",
                  onClick: handleBatchConvertToNeteaseMusic,
                  disabled: !selectedRows?.length,
                  children: [
                    "转存网易云",
                    selectedRows?.length ? `(${selectedRows?.length})` : ""
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                MyButton,
                {
                  type: "primary",
                  onClick: handleBatchDownloadJson,
                  disabled: !selectedRows?.length,
                  children: [
                    "下载JSON",
                    selectedRows?.length ? `(${selectedRows?.length})` : ""
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(MyButton, { type: "primary", onClick: handleBatchDownload, disabled: !selectedRows?.length, children: [
                "下载选中歌曲",
                selectedRows?.length ? `(${selectedRows?.length})` : ""
              ] })
            ] })
          ] });
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            title: renderTitle(),
            open: visible,
            onCancel: close,
            footer: renderFooter(),
            width: 1200,
            centered: true,
            className: styles$6["hot-song-modal"],
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                SearchForm$1,
                {
                  options: searchFormOptions,
                  searchParams,
                  onSearch: handleFilter,
                  style: { marginBottom: 16 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Table,
                {
                  rowSelection,
                  columns,
                  dataSource: filteredList || [],
                  rowKey: "mid",
                  loading: loading2 && !loadingData.loadedSong,
                  pagination: {
                    showSizeChanger: true,
                    showQuickJumper: true,
                    showTotal: (total) => `共 ${total} 首歌曲`
                  },
                  scroll: { y: 500, x: 1100 },
                  className: styles$6["song-table"]
                }
              )
            ]
          }
        );
      };
      const HotSongModal$1 = forwardRef(HotSongModal);
      const getQuality$2 = (file, defaultQuality, chooseQuality) => {
        const qualityList = getFile_qualityList(file);
        const songDefaultQuality = qualityList.includes(defaultQuality) ? defaultQuality : qualityList[0];
        const finalQuality = chooseQuality || songDefaultQuality;
        return finalQuality;
      };
      const loading = "_loading_1fb5b_49";
      const footer = "_footer_1fb5b_152";
      const styles$5 = {
        "album-list-modal": "_album-list-modal_1fb5b_1",
        "modal-title": "_modal-title_1fb5b_1",
        "title-content": "_title-content_1fb5b_4",
        "title-stats": "_title-stats_1fb5b_10",
        "stat-item": "_stat-item_1fb5b_14",
        loading,
        "stat-value": "_stat-value_1fb5b_52",
        "stat-label": "_stat-label_1fb5b_60",
        "album-table": "_album-table_1fb5b_76",
        "album-info": "_album-info_1fb5b_79",
        "album-cover": "_album-cover_1fb5b_79",
        "album-details": "_album-details_1fb5b_92",
        "album-name": "_album-name_1fb5b_97",
        "album-trans-name": "_album-trans-name_1fb5b_106",
        "album-type": "_album-type_1fb5b_115",
        "singer-info": "_singer-info_1fb5b_118",
        "singer-name": "_singer-name_1fb5b_118",
        "singer-id": "_singer-id_1fb5b_126",
        "album-id-text": "_album-id-text_1fb5b_134",
        "album-mid-text": "_album-mid-text_1fb5b_135",
        "publish-date": "_publish-date_1fb5b_145",
        footer,
        "selected-count": "_selected-count_1fb5b_159",
        "selected-info": "_selected-info_1fb5b_163"
      };
      const { Text: Text$1, Title: Title$1 } = Typography;
      const AlbumListModal = forwardRef((props, ref) => {
        const { visible, close } = useVisible(
          {
            onOpen: (params) => {
              console.log("params", params);
              setSingerInfo(params);
            },
            onReset: () => {
              setSingerInfo({});
            }
          },
          ref
        );
        const [singerInfo, setSingerInfo] = useState({});
        const albumDetailRef = useCompRef();
        const { data, loading: loading2 } = useGetData(getSingerAllAlbum, singerInfo.singerMid, {
          monitors: [singerInfo.singerMid, visible],
          returnFunction: () => !visible || !singerInfo.singerMid,
          initialValue: [],
          callback: (data2) => {
            console.log("data", data2);
          }
        });
        const searchFormOptions = [
          {
            label: "专辑名称",
            name: "albumName",
            type: "select",
            options: uniqueArrayByKey(data, "albumName").map((item) => ({
              label: item.albumName,
              value: item.albumName
            })),
            inputProps: {
              mode: "multiple"
            }
          }
        ];
        const { filteredList, handleFilter } = useFilter(data, {
          fields: {
            albumName: {
              getValue: (item) => item.albumName
            }
          }
        });
        const { pause, isPlaying } = usePlayMusic();
        const {
          playAlbum,
          downloadAlbumSong,
          getDownLoadJson
        } = useGetAlbumDetail();
        const [playing, setPlaying] = useState();
        const handlePlay = async (record) => {
          try {
            setPlaying(record.albumMid);
            const { albumMid, albumName } = record;
            const hide = msgLoading(`正在加载《${albumName}》...`);
            await playAlbum(albumMid);
            hide();
            msgSuccess(`《${albumName}》开始播放`);
          } catch (error) {
            console.error("播放失败:", error);
          } finally {
            setPlaying(void 0);
          }
        };
        const [downloading, setDownloading] = useState();
        const handleDownload = async (record) => {
          try {
            setDownloading(record.albumMid);
            const { albumMid, albumName } = record;
            const hide = msgLoading(`正在准备下载《${albumName}》...`);
            await downloadAlbumSong(albumMid);
            hide();
            msgSuccess(`《${albumName}》下载成功！`);
          } catch (error) {
            console.error("下载失败:", error);
          } finally {
            setDownloading(void 0);
          }
        };
        const [downloadingJson, setDownloadingJson] = useState(void 0);
        const handleDownloadJson = async (record) => {
          try {
            setDownloadingJson(record.albumMid);
            const { albumMid, albumName } = record;
            const res = await getDownLoadJson(albumMid);
            downloadAsJson([res], `${albumName}-专辑`);
          } catch (error) {
            msgError("下载JSON失败: " + error.message);
          } finally {
            setDownloadingJson(void 0);
          }
        };
        const columns = [
          {
            title: "专辑信息",
            dataIndex: "albumName",
            key: "albumName",
            width: 300,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$5["album-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["album-cover"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Image,
                {
                  width: 60,
                  height: 60,
                  src: getAlbumPicUrl(record.albumMid),
                  alt: text,
                  fallback: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3Ik1RnG4W+FgYxN"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["album-details"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["album-name"], title: text, children: text }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["album-trans-name"], title: record.albumTranName || "", children: record.albumTranName || "" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["album-type"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: "blue", children: record.albumType || "专辑" }) })
              ] })
            ] })
          },
          {
            title: "歌手",
            dataIndex: "singerName",
            key: "singerName",
            width: 200,
            render: (singerName) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "small", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}), src: singerInfo?.singerPic, size: 40 }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["singer-info"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["singer-name"], title: singerName || "未知歌手", children: singerName || "未知歌手" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["singer-id"], title: singerInfo?.singerId?.toString() || "", children: singerInfo?.singerId || "" })
              ] })
            ] })
          },
          {
            title: "发行时间",
            dataIndex: "publishDate",
            key: "publishDate",
            width: 150,
            align: "center",
            render: (publishDate) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { className: styles$5["publish-date"], title: publishDate, children: publishDate || "未知" });
            }
          },
          {
            title: "歌曲数",
            dataIndex: "totalNum",
            key: "totalNum",
            width: 100,
            align: "center",
            render: (totalNum) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Tag, { color: "green", children: [
              totalNum || 0,
              " 首"
            ] })
          },
          {
            title: "专辑ID",
            dataIndex: "albumID",
            key: "albumID",
            width: 120,
            align: "center",
            render: (albumID) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$5["album-id-text"], text: albumID + "" })
          },
          {
            title: "专辑MID",
            dataIndex: "albumMid",
            key: "albumMid",
            width: 200,
            align: "center",
            render: (albumMid) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$5["album-mid-text"], text: albumMid })
          },
          {
            title: "操作",
            key: "action",
            width: 300,
            align: "center",
            fixed: "right",
            onCell: () => ({
              style: {
                cursor: "default"
              },
              onClick: (e) => e.stopPropagation()
            }),
            render: (_, record) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    loading: playing === record.albumMid,
                    icon: playing === record.albumMid ? /* @__PURE__ */ jsxRuntimeExports.jsx(PauseCircleOutlined, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                    onClick: () => {
                      if (isPlaying === record.albumMid) {
                        pause();
                      } else {
                        handlePlay(record);
                        return;
                      }
                    },
                    title: "播放专辑",
                    children: "播放"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    loading: downloadingJson === record.albumMid,
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SaveOutlined, {}),
                    onClick: () => handleDownloadJson(record),
                    title: "下载JSON",
                    children: "下载JSON"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    loading: downloading === record.albumMid,
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}),
                    onClick: () => handleDownload(record),
                    title: "下载专辑",
                    children: "下载"
                  }
                )
              ] });
            }
          }
        ];
        const [selectedRowKeys, setSelectedRowKeys] = useState([]);
        const [selectedRows, setSelectedRows] = useState([]);
        const rowSelection = {
          preserveSelectedRowKeys: true,
          selectedRowKeys,
          onChange: (selectedRowKeys2, selectedRows2) => {
            setSelectedRowKeys(selectedRowKeys2);
            setSelectedRows(selectedRows2);
            console.log("selectedRowKeys", selectedRowKeys2);
            console.log("selectedRows", selectedRows2);
          }
        };
        const renderTitle = () => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["modal-title"], children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["title-content"], children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Title$1, { level: 4, style: { margin: 0 }, children: [
              singerInfo.singerName,
              " - 专辑列表"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["title-stats"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$5["stat-item"]} ${loading2 ? styles$5["loading"] : ""}`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5["stat-label"], children: "专辑" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5["stat-value"], children: loading2 ? "..." : data?.length || 0 })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$5["stat-item"]} ${loading2 ? styles$5["loading"] : ""}`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5["stat-label"], children: "歌曲" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5["stat-value"], children: loading2 ? "..." : data?.reduce((sum, album) => sum + (album.totalNum || 0), 0) || 0 })
              ] })
            ] })
          ] }) });
        };
        const handleBatchDownload = async () => {
          if (selectedRows.length === 0) {
            msgWarning("请先选择要下载的专辑");
            return;
          }
          const loadingKey = "download-album";
          try {
            message$1.loading({
              key: loadingKey,
              content: `正在准备下载 ${selectedRows.length} 张专辑...`,
              duration: 0
            });
            let index2 = 1;
            for (const album of selectedRows) {
              message$1.loading({
                key: loadingKey,
                content: `正在下载第 ${index2} 张专辑 ${album.albumName}...`,
                duration: 0
              });
              await downloadAlbumSong(album.albumMid);
              message$1.success({
                key: loadingKey,
                content: `第 ${index2} 张专辑 ${album.albumName} 下载成功！`,
                duration: 1
              });
              index2++;
            }
          } catch (error) {
            msgError("批量下载失败: " + error.message);
            console.error("批量下载失败:", error);
          } finally {
            message$1.destroy(loadingKey);
          }
        };
        const handleBatchDownloadJson = async () => {
          if (selectedRows.length === 0) {
            msgWarning("请先选择要下载的专辑");
            return;
          }
          const loadingKey = "download-album-json";
          try {
            message$1.loading({
              key: loadingKey,
              content: `正在准备下载 ${selectedRows.length} 张专辑...`,
              duration: 0
            });
            const result = [];
            let index2 = 1;
            for (const album of selectedRows) {
              console.log("album", album);
              message$1.loading({
                key: loadingKey,
                content: `正在下载第 ${index2} 张专辑 ${album.albumName}...`,
                duration: 0
              });
              const res = await getDownLoadJson(album.albumMid);
              result.push(res);
              message$1.success({
                key: loadingKey,
                content: `第 ${index2} 张专辑 ${album.albumName} 下载成功！`,
                duration: 1
              });
              index2++;
            }
            downloadAsJson(result, `${singerInfo.singerName}-专辑`);
            message$1.success({
              key: loadingKey,
              content: `成功下载 ${selectedRows.length} 张专辑！`,
              duration: 1
            });
          } catch (error) {
            console.error("批量下载JSON失败:", error);
            message$1.destroy(loadingKey);
            msgError("批量下载JSON失败: " + error.message);
          } finally {
            message$1.destroy(loadingKey);
          }
        };
        const renderFooter = () => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["footer"], children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["selected-count"], children: [
              "已选择 ",
              selectedRows.length,
              " 张专辑",
              selectedRows.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5["selected-info"], children: [
                "（共 ",
                selectedRows.reduce((sum, album) => sum + (album.totalNum || 0), 0),
                " 首歌曲）"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    setSelectedRowKeys(filteredList?.map((item) => item.albumMid) || []);
                    setSelectedRows(filteredList || []);
                  },
                  disabled: filteredList?.length === 0,
                  children: "全部选择"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    setSelectedRowKeys([]);
                    setSelectedRows([]);
                  },
                  disabled: selectedRows.length === 0,
                  children: "清空选择"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                MyButton,
                {
                  type: "primary",
                  onClick: handleBatchDownloadJson,
                  disabled: selectedRows.length === 0,
                  children: [
                    "下载Json",
                    selectedRows?.length ? `(${selectedRows?.length})` : ""
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                MyButton,
                {
                  type: "primary",
                  onClick: handleBatchDownload,
                  disabled: selectedRows.length === 0,
                  children: [
                    "下载选中专辑",
                    selectedRows?.length ? `(${selectedRows?.length})` : ""
                  ]
                }
              )
            ] })
          ] });
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            title: renderTitle(),
            open: visible,
            onCancel: close,
            footer: renderFooter(),
            width: 1200,
            centered: true,
            className: styles$5["album-list-modal"],
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                SearchForm$1,
                {
                  options: searchFormOptions,
                  onSearch: handleFilter,
                  style: { marginBottom: 16 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Table,
                {
                  rowSelection,
                  columns,
                  dataSource: filteredList || [],
                  rowKey: "albumMid",
                  loading: loading2,
                  scroll: { y: 500, x: 1100 },
                  className: styles$5["album-table"],
                  onRow: (record) => ({
                    style: {
                      cursor: "pointer"
                    },
                    onClick: () => {
                      albumDetailRef.current?.open({ albummid: record.albumMid });
                    }
                  }),
                  pagination: {
                    showSizeChanger: true,
                    showQuickJumper: true,
                    align: "end",
                    showTotal: (total) => `共 ${total} 张专辑`
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(AlbumDetail, { ref: albumDetailRef })
            ]
          }
        );
      });
      const styles$4 = {
        "singer-search-modal": "_singer-search-modal_1jeib_2",
        "singer-info": "_singer-info_1jeib_8",
        "singer-avatar": "_singer-avatar_1jeib_12",
        "singer-details": "_singer-details_1jeib_21",
        "singer-name": "_singer-name_1jeib_26",
        "singer-country": "_singer-country_1jeib_32",
        "singer-id": "_singer-id_1jeib_43",
        "singer-id-text": "_singer-id-text_1jeib_54",
        "singer-mid-text": "_singer-mid-text_1jeib_64"
      };
      const defaultSearchParams$2 = {
        cur_page: 1,
        area: Area.全部,
        sex: Sex.全部,
        genre: Genre.全部
      };
      const SingerSearch = forwardRef((props, ref) => {
        const { visible, close } = useVisible({}, ref);
        const [keyword, setKeyword] = useState("");
        const [searchParams, setSearchParams] = useState(defaultSearchParams$2);
        const searchFormOptions = [
          // 地区
          {
            label: "地区",
            name: "area",
            type: "select",
            options: AreaList
          },
          // 性别
          {
            label: "性别",
            name: "sex",
            type: "select",
            options: SexList
          },
          // 流派
          {
            label: "流派",
            name: "genre",
            type: "select",
            options: GenreList
          },
          // 歌手名称
          {
            label: "歌手名称",
            type: "input",
            inputProps: {
              placeholder: "请输入歌手名称",
              value: keyword,
              allowClear: true,
              onChange: (e) => {
                console.log("e", e);
                setKeyword(e.target.value);
              }
            }
          }
        ];
        const handleSearch = (values) => {
          const newParams = Object.fromEntries(
            searchFormOptions.filter((item) => item.name).map((item) => [item.name, values[item.name]])
          );
          setSearchParams({
            ...searchParams,
            ...newParams
          });
        };
        const hotSongModalRef = useCompRef();
        const handleHotSong = (record) => {
          hotSongModalRef.current.open({
            singerId: record.singer_id,
            singerMid: record.singer_mid,
            singerName: record.singer_name,
            singerPic: record.singer_pic
          });
        };
        const albumModalRef = useCompRef();
        const handleAlbum = (record) => {
          albumModalRef.current.open({
            singerId: record.singer_id,
            singerMid: record.singer_mid,
            singerName: record.singer_name,
            singerPic: record.singer_pic
          });
        };
        const columns = [
          {
            title: "歌手信息",
            dataIndex: "singer_name",
            key: "singer_name",
            width: 300,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$4["singer-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Avatar,
                {
                  src: record.singer_pic,
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}),
                  size: 48,
                  className: styles$4["singer-avatar"]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$4["singer-details"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$4["singer-name"], children: text }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$4["singer-country"], children: record.country || "未知地区" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$4["singer-id"], children: [
                  "ID: ",
                  record.singer_id
                ] })
              ] })
            ] })
          },
          {
            title: "歌手ID",
            dataIndex: "singer_id",
            key: "singer_id",
            width: 120,
            align: "center",
            render: (id) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$4["singer-id-text"], text: id + "" })
          },
          {
            title: "歌手MID",
            dataIndex: "singer_mid",
            key: "singer_mid",
            width: 200,
            align: "center",
            render: (mid) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$4["singer-mid-text"], text: mid })
          },
          {
            title: "操作",
            key: "action",
            width: 200,
            align: "center",
            render: (_, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}),
                  onClick: () => handleHotSong(record),
                  children: "查看热门歌曲"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "link",
                  color: "danger",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                  onClick: () => handleAlbum(record),
                  children: "查看专辑"
                }
              )
            ] })
          }
        ];
        const { data, loading: loading2 } = useGetData(getSingerList, searchParams, {
          monitors: [searchParams, visible],
          returnFunction: () => !visible
        });
        const renderList = useMemo(() => {
          return data.singerlist?.filter(
            (item) => item.singer_name.toLocaleLowerCase().includes(keyword.toLocaleLowerCase() || "")
          ) || [];
        }, [data, keyword]);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            title: "歌手查询",
            open: visible,
            onCancel: close,
            footer: null,
            width: 1200,
            centered: true,
            className: styles$4["singer-search-modal"],
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SearchForm$1, { options: searchFormOptions, searchParams, onSearch: handleSearch }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Table,
                {
                  columns,
                  dataSource: renderList,
                  rowKey: "singer_mid",
                  loading: loading2,
                  pagination: false,
                  scroll: { y: 500, x: 1e3 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Pagination,
                {
                  current: searchParams.cur_page,
                  total: data.total,
                  align: "end",
                  showSizeChanger: false,
                  showQuickJumper: true,
                  showTotal: (total) => `共 ${total} 位歌手`,
                  onChange: (page) => {
                    setSearchParams({
                      ...searchParams,
                      cur_page: page
                    });
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(HotSongModal$1, { ref: hotSongModalRef }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(AlbumListModal, { ref: albumModalRef })
            ]
          }
        );
      });
      function getQQAvatarUrl(qqNumber, size = 640, prefix = "q1") {
        const safeQQ = encodeURIComponent(qqNumber);
        const safeSize = Number(size) || 100;
        const safePrefix = ["q1", "q2", "q3", "q4"].includes(prefix) ? prefix : "q1";
        return `https://${safePrefix}.qlogo.cn/g?b=qq&nk=${safeQQ}&s=${safeSize}`;
      }
      const styles$3 = {
        "song-list-detail-modal": "_song-list-detail-modal_pu8y8_1",
        "modal-header": "_modal-header_pu8y8_1",
        "modal-title": "_modal-title_pu8y8_1",
        "playlist-basic-info": "_playlist-basic-info_pu8y8_4",
        "playlist-info": "_playlist-info_pu8y8_13",
        "playlist-name": "_playlist-name_pu8y8_19",
        "creator-info": "_creator-info_pu8y8_23",
        "creator-name": "_creator-name_pu8y8_28",
        "playlist-stats": "_playlist-stats_pu8y8_32",
        "playlist-desc": "_playlist-desc_pu8y8_41",
        "description-text": "_description-text_pu8y8_44",
        "song-info": "_song-info_pu8y8_68",
        "song-name": "_song-name_pu8y8_73",
        "song-artist": "_song-artist_pu8y8_79",
        "artist-item": "_artist-item_pu8y8_87",
        "artist-name": "_artist-name_pu8y8_91",
        "artist-separator": "_artist-separator_pu8y8_95",
        "song-id": "_song-id_pu8y8_100",
        "id-copy": "_id-copy_pu8y8_100",
        "album-info": "_album-info_pu8y8_103",
        "album-details": "_album-details_pu8y8_107",
        "album-name": "_album-name_pu8y8_114",
        "album-id": "_album-id_pu8y8_122",
        "singer-list": "_singer-list_pu8y8_125",
        "singer-item": "_singer-item_pu8y8_130",
        "singer-details": "_singer-details_pu8y8_134",
        "singer-name": "_singer-name_pu8y8_141"
      };
      const { Text, Title } = Typography;
      const SongListDetail = forwardRef((_, ref) => {
        const { visible, close } = useVisible(
          {
            onOpen(params) {
              if (params) {
                setCurrentDissid(params.dissid);
              }
            }
          },
          ref
        );
        const [currentDissid, setCurrentDissid] = useState("");
        const [inputMid, setInputMid] = useState("");
        const { downloadConfig, functionConfig } = useConfig();
        const { quality: defaultQuality } = downloadConfig;
        const { uploadConcurrency } = functionConfig;
        const {
          getPlaylistDetail,
          getPlaylistDownloadJson
        } = useGetSonglistDetail();
        const { play, isPlaying, pause, download, convertToNeteaseMusic } = usePlayMusic();
        const { data: detail, loading: loading2 } = useGetData(getPlaylistDetail, currentDissid, {
          initialValue: {},
          returnFunction: () => !currentDissid || !visible,
          monitors: [currentDissid, visible],
          callback: (data) => {
            console.log("data", data);
          }
        });
        const list = useMemo(() => {
          return detail?.songlist || [];
        }, [detail]);
        const { filteredList, handleFilter, setFilteredList } = useFilter(list || [], {
          fields: {
            name: {
              getValue: (item) => item.name
            },
            albumName: {
              getValue: (item) => item.album.name
            },
            singer: {
              getValue: (item) => item.singer.map((s) => s.name).join(" / ")
            }
          }
        });
        const searchFormOptions = [
          {
            label: "名字",
            name: "name",
            type: "select",
            inputProps: {
              mode: "multiple"
            },
            options: uniqueArrayByKey(list, "name").map((item) => ({
              label: item.name,
              value: item.name
            }))
          },
          // 歌手
          {
            label: "歌手",
            name: "singer",
            type: "select",
            inputProps: {
              mode: "multiple"
            },
            options: Object.entries(
              lodashExports.groupBy(list, (item) => item.singer.map((s) => s.name).join(" / "))
            ).map(([key]) => ({
              label: key,
              value: key
            }))
          },
          // 专辑
          {
            label: "专辑",
            name: "albumName",
            type: "select",
            inputProps: {
              mode: "multiple"
            },
            options: Object.entries(lodashExports.groupBy(list, (item) => item.album.name)).map(([key]) => ({
              label: key,
              value: key
            }))
          },
          // 歌单ID
          {
            label: "歌单ID",
            type: "input",
            inputProps: {
              placeholder: "请输入歌单ID",
              value: inputMid,
              onChange: (e) => setInputMid(e.target.value.trim()),
              onPressEnter: () => {
                if (inputMid) {
                  setCurrentDissid(inputMid);
                }
              }
            }
          }
        ];
        const handleChooseQuality = (record, quality) => {
          setFilteredList(
            filteredList.map((item) => {
              if (item.mid === record.mid) {
                return {
                  ...item,
                  quality
                };
              }
              return item;
            })
          );
        };
        const handlePlay = (record) => {
          if (isPlaying) {
            pause();
          } else {
            const { file, quality } = record;
            const finalQuality = getQuality$1(file, defaultQuality, quality);
            play(record.mid, finalQuality);
          }
        };
        const handleDownload = async (record) => {
          try {
            const { file, quality } = record;
            const finalQuality = getQuality$1(file, defaultQuality, quality);
            await download(record.mid, finalQuality);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleDownloadNeteaseMusic = async (record) => {
          try {
            const { file, quality } = record;
            const finalQuality = getQuality$1(file, defaultQuality, quality);
            await convertToNeteaseMusic(record.mid, { quality: finalQuality });
            msgSuccess("歌曲转存网易云成功");
          } catch (error) {
            console.log("error", error);
            msgError("歌曲转存网易云失败");
          }
        };
        const songColumns = [
          {
            title: "歌曲信息",
            dataIndex: "name",
            key: "name",
            width: 280,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3["song-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["song-name"], children: text }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["song-artist"], children: record.singer?.map((s, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$3["artist-item"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3["artist-name"], children: s.name }),
                index2 < record.singer.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3["artist-separator"], children: "/" })
              ] }, s.mid || index2)) || "-" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["song-id"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { text: record.mid, className: styles$3["id-copy"] }) })
            ] })
          },
          {
            title: "专辑信息",
            dataIndex: "album",
            key: "album",
            width: 280,
            render: (album) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$3["album-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Image,
                {
                  width: 60,
                  height: 60,
                  src: album?.mid ? getAlbumPicUrl(album.mid, { size: "300x300" }) : "",
                  alt: album?.name || "",
                  fallback: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3Ik1RnG4W+FgYxN",
                  style: { borderRadius: 4 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3["album-details"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["album-name"], title: album?.name || "-", children: album?.name || "-" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["album-id"], children: album?.mid ? /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { text: album.mid, className: styles$3["id-copy"] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { type: "secondary", children: "-" }) })
              ] })
            ] })
          },
          {
            title: "歌手信息",
            dataIndex: "singer",
            key: "singer",
            width: 220,
            render: (singers) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["singer-list"], children: singers?.map((singer, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3["singer-item"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Avatar,
                {
                  src: getSingerPic(singer.mid),
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}),
                  size: 32,
                  style: { marginRight: 8 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3["singer-details"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["singer-name"], children: singer.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { text: singer.mid, className: styles$3["id-copy"] })
              ] })
            ] }, singer.mid || index2)) || "-" })
          },
          {
            title: "音质",
            dataIndex: "file",
            key: "file",
            width: 120,
            align: "center",
            render: (file, record) => {
              const qualityList = getFile_qualityList(file);
              const defaultValue = qualityList.includes(defaultQuality) ? defaultQuality : qualityList[0];
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select,
                {
                  options: qualityList.map((quality) => ({
                    label: quality,
                    value: quality
                  })),
                  defaultValue,
                  style: { width: "100%" },
                  onChange: (value) => {
                    handleChooseQuality(record, value);
                  }
                }
              );
            }
          },
          // 格式
          {
            title: "格式",
            dataIndex: "format",
            key: "format",
            width: 150,
            align: "center",
            render: (_2, record) => {
              const qualityList = getFile_qualityList(record.file);
              const qualityColorMap = {
                flac: "green",
                ape: "volcano",
                320: "blue",
                m4a: "orange",
                128: "gray"
              };
              const qualityTextMap = {
                flac: "FLAC",
                ape: "APE",
                320: "320k",
                m4a: "M4A",
                128: "128k"
              };
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Space, { wrap: true, children: qualityList.map((quality) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: qualityColorMap[quality], children: qualityTextMap[quality] || quality }, quality)) });
            }
          },
          {
            title: "操作",
            key: "action",
            width: 200,
            align: "center",
            fixed: "right",
            render: (_2, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "small", wrap: true, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "link",
                  size: "small",
                  icon: isPlaying === record.mid ? /* @__PURE__ */ jsxRuntimeExports.jsx(PauseCircleOutlined, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                  onClick: () => handlePlay(record),
                  children: "播放"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                MyButton,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}),
                  onClick: () => handleDownload(record),
                  children: "下载"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                MyButton,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CloudDownloadOutlined, {}),
                  onClick: () => handleDownloadNeteaseMusic(record),
                  children: "转存网易云"
                }
              )
            ] })
          }
        ];
        const renderTitle = () => {
          const { pic_mid, dissname, nickname, isvip, visitnum, scoreavage, songnum, desc, uin } = detail || {};
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3["modal-header"], children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Title, { level: 4, className: styles$3["modal-title"], children: "歌单详情" }),
            detail && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3["playlist-basic-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Image,
                {
                  src: pic_mid ? `https://y.gtimg.cn/music/photo_new/T002R300x300M000${pic_mid}.jpg` : "",
                  alt: dissname,
                  width: 80,
                  height: 80,
                  style: { borderRadius: 8 },
                  fallback: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3Ik1RnG4W+FgYxN"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3["playlist-info"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Title, { level: 5, className: styles$3["playlist-name"], children: dissname }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3["creator-info"], children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Avatar,
                    {
                      src: getQQAvatarUrl(uin),
                      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}),
                      size: 24,
                      style: { marginRight: 8 }
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { className: styles$3["creator-name"], children: nickname || "未知用户" }),
                  isvip === 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: "gold", children: "VIP" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["playlist-stats"], children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { type: "secondary", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOutlined, {}),
                    " ",
                    visitnum?.toLocaleString() || 0,
                    " 播放"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { type: "secondary", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(StarOutlined, {}),
                    " ",
                    scoreavage || "-",
                    " 评分"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { type: "secondary", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(TrophyOutlined, {}),
                    " ",
                    songnum || 0,
                    " 首歌曲"
                  ] })
                ] }) }),
                desc && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3["playlist-desc"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { type: "secondary", className: styles$3["description-text"], children: desc }) })
              ] })
            ] })
          ] });
        };
        const [selectedRowKeys, setSelectedRowKeys] = useState([]);
        const [selectedRows, setSelectedRows] = useState([]);
        const rowSelection = {
          preserveSelectedRowKeys: true,
          selectedRowKeys,
          onChange: (selectedRowKeys2, selectedRows2) => {
            setSelectedRowKeys(selectedRowKeys2);
            setSelectedRows(selectedRows2);
          }
        };
        const handleBatchDownload = async () => {
          try {
            if (selectedRows.length === 0) {
              msgWarning("请先选择要下载的歌曲");
              return;
            }
            const loadingKey = "download-song";
            message$1.loading({
              key: loadingKey,
              content: `正在准备下载 ${selectedRows.length} 首歌曲`,
              duration: 0
            });
            let songIndex = 1;
            for (const song of selectedRows) {
              message$1.loading({
                key: loadingKey,
                content: `正在下载第 ${songIndex} 首歌曲 ${song.name}...`,
                duration: 0
              });
              const finalQuality = getQuality$1(song.file, defaultQuality);
              await download(song.mid, finalQuality);
              message$1.success({
                key: loadingKey,
                content: `第 ${songIndex} 首歌曲 ${song.name} 下载成功！`,
                duration: 0
              });
              songIndex++;
            }
            msgSuccess(`成功下载 ${selectedRows.length} 首歌曲！`);
            message$1.destroy(loadingKey);
          } catch (error) {
            console.error("下载选中歌曲失败:", error);
          }
        };
        const handleDownloadAllJson = async () => {
          if (!currentDissid) return;
          try {
            const data = await getPlaylistDownloadJson(currentDissid);
            console.log("data", data);
            downloadAsJson(data, `${data.playlistName}.json`);
          } catch (error) {
            console.error("下载歌单JSON失败:", error);
          }
        };
        const handleConvertToNeteaseMusicPlaylistSong = async () => {
          if (!selectedRows.length) return;
          const loadingKey = "convert-to-netease-music-playlist-song";
          message$1.loading({
            key: loadingKey,
            content: `正在转存歌单歌曲...`,
            duration: 0
          });
          try {
            const task = selectedRows.map((item) => async () => {
              await convertToNeteaseMusic(item.mid, {
                onChange: (msg) => {
                  message$1.loading({
                    key: loadingKey,
                    content: msg,
                    duration: 0
                  });
                }
              });
            });
            await promiseLimit(task, uploadConcurrency);
            message$1.success({
              key: loadingKey,
              content: `转存歌单歌曲成功`,
              duration: 0
            });
          } catch (error) {
            console.error("转存网易云歌单歌曲失败:", error);
          }
        };
        const renderFooter = () => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
            selectedRowKeys?.length < list.length ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectOutlined, {}),
                onClick: () => {
                  setSelectedRowKeys(list?.map((item) => item.mid) || []);
                  setSelectedRows(list || []);
                },
                children: "全部选择"
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectOutlined, {}),
                onClick: () => {
                  setSelectedRowKeys([]);
                  setSelectedRows([]);
                },
                children: "清空选择"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              MyButton,
              {
                type: "primary",
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}),
                onClick: handleBatchDownload,
                disabled: !selectedRows?.length,
                children: [
                  "下载选中歌曲",
                  selectedRows?.length ? `(${selectedRows?.length})` : ""
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              MyButton,
              {
                type: "primary",
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FileOutlined, {}),
                onClick: handleDownloadAllJson,
                disabled: !list?.length,
                children: [
                  "下载全部JSON",
                  list?.length ? `(${list?.length})` : ""
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              MyButton,
              {
                type: "primary",
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CloudDownloadOutlined, {}),
                onClick: handleConvertToNeteaseMusicPlaylistSong,
                disabled: !selectedRows?.length,
                children: [
                  "转存网易云歌单选中歌曲",
                  selectedRows?.length ? `(${selectedRows?.length})` : ""
                ]
              }
            )
          ] });
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            title: renderTitle(),
            open: visible,
            onCancel: close,
            footer: renderFooter(),
            width: 1200,
            centered: true,
            className: styles$3["song-list-detail-modal"],
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                SearchForm$1,
                {
                  options: searchFormOptions,
                  onSearch: handleFilter,
                  style: {
                    marginBottom: 0
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Table,
                {
                  columns: songColumns,
                  dataSource: filteredList,
                  rowSelection,
                  rowKey: "mid",
                  loading: loading2,
                  scroll: { y: 400, x: 800 },
                  pagination: {
                    showSizeChanger: true,
                    showQuickJumper: true,
                    showTotal: (total) => `共 ${total} 首歌曲`
                  }
                }
              )
            ]
          }
        );
      });
      const getQuality$1 = (file, defaultQuality, chooseQuality) => {
        const qualityList = getFile_qualityList(file);
        const songDefaultQuality = qualityList.includes(defaultQuality) ? defaultQuality : qualityList[0];
        const finalQuality = chooseQuality || songDefaultQuality;
        return finalQuality;
      };
      const introduction = "_introduction_1h6z1_47";
      const styles$2 = {
        "song-list-search-modal": "_song-list-search-modal_1h6z1_1",
        "play-count-overlay": "_play-count-overlay_1h6z1_1",
        "playlist-cover-container": "_playlist-cover-container_1h6z1_19",
        "playlist-info": "_playlist-info_1h6z1_23",
        "playlist-name": "_playlist-name_1h6z1_28",
        "creator-info": "_creator-info_1h6z1_32",
        "creator-name": "_creator-name_1h6z1_39",
        "creator-qq": "_creator-qq_1h6z1_43",
        introduction,
        "time-info": "_time-info_1h6z1_79",
        "create-time": "_create-time_1h6z1_85",
        "commit-time": "_commit-time_1h6z1_91",
        "playlist-id": "_playlist-id_1h6z1_95"
      };
      const { Option } = Select;
      const defaultSearchParams$1 = {
        pageNum: 0,
        pageSize: 20
      };
      const SongListSearch = forwardRef((props, ref) => {
        const { visible, close } = useVisible({}, ref);
        const [searchParams, setSearchParams] = useState(defaultSearchParams$1);
        const {
          playPlaylist,
          downloadPlaylistSong,
          getPlaylistDownloadJson
        } = useGetSonglistDetail();
        const { data: songListCategory } = useGetData(getSongListCategory, void 0, {
          monitors: [visible],
          returnFunction: () => !visible,
          initialValue: [],
          callback: (data2) => {
            console.log("data", data2);
          }
        });
        const categoryOptions = useMemo(() => {
          return songListCategory?.map((item) => ({
            label: item.categoryGroupName,
            value: item.categoryGroupName,
            checkable: false,
            children: item.items.map((item2) => ({
              label: item2.categoryName,
              value: item2.categoryId
            }))
          }));
        }, [songListCategory]);
        const searchFormOptions = [
          // 分类
          {
            label: "分类",
            name: "categoryIds",
            type: "treeSelect",
            inputProps: {
              treeData: categoryOptions
            }
          },
          // 排序
          {
            label: "排序",
            name: "sortId",
            type: "select",
            options: [
              { label: "默认", value: 1 },
              { label: "最新", value: 2 },
              { label: "最热", value: 3 },
              { label: "评分", value: 4 },
              { label: "none", value: 5 }
            ],
            inputProps: {
              mode: void 0,
              allowClear: true
            }
          }
        ];
        const handleSearch = (values) => {
          const newParams = Object.fromEntries(
            searchFormOptions.filter((item) => item.name).map((item) => [item.name, values[item.name]])
          );
          setSearchParams({
            ...searchParams,
            ...newParams
          });
        };
        const handlePlay = async (record) => {
          console.log("播放歌单:", record);
          try {
            await playPlaylist(record.dissid);
          } catch (error) {
            console.error("播放歌单失败:", error);
          }
        };
        const songListDetailRef = useCompRef();
        const handleViewDetail = async (record) => {
          console.log("查看歌单详情:", record);
          songListDetailRef.current?.open({
            dissid: record.dissid
          });
        };
        const handleDownload = async (record) => {
          console.log("下载歌单:", record);
          try {
            await downloadPlaylistSong(record.dissid);
          } catch (error) {
            console.error("下载歌单失败:", error);
          }
        };
        const handleDownloadJson = async (record) => {
          console.log("下载歌单json:", record);
          try {
            const data2 = await getPlaylistDownloadJson(record.dissid);
            console.log("data", data2);
            downloadAsJson(data2, `${data2.playlistName}.json`);
          } catch (error) {
            console.error("下载歌单json失败:", error);
          }
        };
        const columns = [
          {
            title: "歌单信息",
            dataIndex: "dissname",
            key: "dissname",
            width: 400,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2["playlist-cover-container"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Image,
                  {
                    src: record.imgurl,
                    alt: text,
                    width: 60,
                    height: 60,
                    style: { borderRadius: 8 },
                    fallback: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3Ik1RnG4W+FgYxN"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2["play-count-overlay"], children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: formatPlayCount(record.listennum || 0) }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2["playlist-info"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2["playlist-name"], children: text }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2["creator-info"], children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Avatar,
                    {
                      src: getQQAvatarUrl(record.creator?.qq),
                      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}),
                      size: 20,
                      style: { marginRight: 8 }
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$2["creator-name"], children: record.creator?.name || "未知用户" }),
                  record.creator?.isVip === 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: "gold", children: "VIP" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2["creator-qq"], children: [
                  "QQ: ",
                  record.creator?.qq || "-"
                ] }),
                record.introduction && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2["introduction"], children: record.introduction })
              ] })
            ] })
          },
          {
            title: "时间信息",
            key: "time-info",
            width: 180,
            render: (_, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2["time-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2["create-time"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ClockCircleOutlined, { style: { color: "#666" } }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: record.createtime ? new Date(record.createtime).toLocaleDateString() : "-" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2["commit-time"], children: [
                "提交: ",
                record.commit_time ? new Date(record.commit_time).toLocaleDateString() : "-"
              ] })
            ] })
          },
          {
            title: "歌单ID",
            dataIndex: "dissid",
            key: "dissid",
            width: 150,
            align: "center",
            render: (dissid) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { text: dissid, className: styles$2["playlist-id"] })
          },
          {
            title: "操作",
            key: "action",
            width: 350,
            align: "center",
            fixed: "right",
            onCell: () => ({
              style: {
                cursor: "default"
              },
              onClick: (e) => e.stopPropagation()
            }),
            render: (_, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                MyButton,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                  onClick: () => handlePlay(record),
                  children: "播放"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                MyButton,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}),
                  onClick: () => handleDownload(record),
                  children: "下载"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                MyButton,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FileOutlined, {}),
                  onClick: () => handleDownloadJson(record),
                  children: "下载json"
                }
              )
            ] })
          }
        ];
        const { data, loading: loading2 } = useGetData(
          getSongList,
          {
            ...searchParams,
            limit: searchParams.pageSize,
            page: searchParams.pageNum
          },
          {
            returnFunction: () => !visible,
            monitors: [searchParams, visible],
            callback: (data2) => {
              console.log("data", data2);
            }
          }
        );
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            title: "歌单查询",
            open: visible,
            onCancel: close,
            footer: null,
            width: 1200,
            centered: true,
            className: styles$2["song-list-search-modal"],
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                SearchForm$1,
                {
                  options: searchFormOptions,
                  searchParams,
                  onSearch: handleSearch,
                  style: {
                    marginBottom: 16
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Table,
                {
                  columns,
                  dataSource: data?.list || [],
                  rowKey: "dissid",
                  loading: loading2,
                  onRow: (record) => ({
                    style: {
                      cursor: "pointer"
                    },
                    onClick: () => handleViewDetail(record)
                  }),
                  scroll: { y: 500, x: 970 },
                  pagination: false
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Pagination,
                {
                  align: "end",
                  total: data?.sum || 0,
                  current: searchParams.pageNum,
                  pageSize: searchParams.pageSize,
                  showSizeChanger: true,
                  showTotal: (total) => `共 ${total} 个歌单`,
                  onChange: (page, pageSize) => {
                    setSearchParams({ ...searchParams, pageNum: page, pageSize });
                  },
                  style: { marginTop: 16 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SongListDetail, { ref: songListDetailRef })
            ]
          }
        );
      });
      const formatPlayCount = (count) => {
        if (count >= 1e8) {
          return `${(count / 1e8).toFixed(1)}亿`;
        } else if (count >= 1e4) {
          return `${(count / 1e4).toFixed(1)}万`;
        } else {
          return count.toString();
        }
      };
      const typeMap = {
        song: 0,
        album: 8,
        user: 9,
        playlist: 2,
        lyric: 7,
        mv: 12
      };
      const getSearchResult = async (keyword, type = "song", options) => {
        const { pageNum = 1, pageSize = 20 } = options || {};
        const params = {
          w: keyword,
          n: pageSize,
          p: pageNum,
          catZhida: 1,
          format: "json",
          outCharset: "utf-8",
          t: typeMap[type],
          cr: 1,
          lossless: 0,
          flag_qc: 0,
          platform: "yqq.json",
          g_tk: 5381
        };
        console.log("params", params);
        const res = await qqMusicRequest(
          `/soso/fcgi-bin/client_search_cp?${new URLSearchParams(params).toString()}`,
          {
            method: "GET"
          },
          "c"
        );
        if (res.code === 0) {
          return res.data;
        }
        throw new Error("搜索失败");
      };
      const getWebSearchResult = async (keyword, type = "song", options) => {
        const { pageNum = 1, pageSize = 20 } = {};
        const params = {
          req_1: {
            method: "DoSearchForQQMusicDesktop",
            module: "music.search.SearchCgiService",
            param: {
              num_per_page: Number(pageSize),
              page_num: Number(pageNum),
              query: keyword,
              search_type: Number(typeMap[type])
            }
          }
        };
        console.log("params", params);
        const res = await qqMusicRequest(
          `/cgi-bin/musicu.fcg`,
          {
            method: "POST",
            data: JSON.stringify(params)
          },
          "u"
        );
        console.log("res", res);
      };
      const styles$1 = {
        "song-search-modal": "_song-search-modal_15iqn_1",
        "modal-title": "_modal-title_15iqn_1",
        "title-content": "_title-content_15iqn_6",
        "title-text": "_title-text_15iqn_11",
        "song-table": "_song-table_15iqn_16",
        "song-info": "_song-info_15iqn_16",
        "song-cover": "_song-cover_15iqn_21",
        "song-details": "_song-details_15iqn_31",
        "song-name": "_song-name_15iqn_36",
        "song-album": "_song-album_15iqn_46",
        "singer-info": "_singer-info_15iqn_55",
        "singer-name": "_singer-name_15iqn_60",
        "song-mid-text": "_song-mid-text_15iqn_75"
      };
      const SongTab$1 = ({ data, loading: loading2 }) => {
        const { downloadConfig } = useConfig();
        const { quality: defaultQuality } = downloadConfig;
        const { play, download, isPlaying, pause, getLyric, convertToNeteaseMusic } = usePlayMusic();
        const [list, setList] = useState(data);
        useEffect(() => {
          setList(data);
        }, [data]);
        const handleChooseQuality = (record, quality) => {
          setList(
            list.map((item) => {
              if (item.songmid === record.songmid) {
                return {
                  ...item,
                  quality
                };
              }
              return item;
            })
          );
        };
        const handlePlay = (record) => {
          console.log("播放歌曲:", record);
          if (isPlaying) {
            pause();
          } else {
            const finalQuality = getQuality(record, defaultQuality, record.quality);
            play(record.songmid, finalQuality);
          }
        };
        const handleDownload = async (record) => {
          try {
            const finalQuality = getQuality(record, defaultQuality, record.quality);
            await download(record.songmid, finalQuality);
          } catch (error) {
            console.error("下载歌曲失败:", error);
          }
        };
        const handleDownloadLyric = async (record) => {
          try {
            const lyric = await getLyric(record.songmid);
            downloadAsLRC(lyric, record.songname);
          } catch (error) {
            console.error("下载歌词失败:", error);
          }
        };
        const handleDownloadNeteaseMusic = async (record) => {
          try {
            await convertToNeteaseMusic(record.songmid);
            msgSuccess("歌曲转存网易云成功");
          } catch (error) {
            console.log("error", error);
            msgError("歌曲转存网易云失败");
          }
        };
        const columns_song = [
          {
            title: "歌曲信息",
            dataIndex: "songname",
            width: 300,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$1["song-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-cover"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { src: getAlbumPicUrl(record.albummid) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1["song-details"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-name"], title: text, children: text }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-album"], title: record.albumname || "", children: record.albumname || "" })
              ] })
            ] })
          },
          {
            title: "歌手",
            dataIndex: "singer",
            width: 200,
            render: (singers) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "small", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { src: getSingerPic(singers[0].mid), width: 40, height: 40 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["singer-info"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: styles$1["singer-name"],
                  title: singers?.map((s) => s.name).join("/") || "未知歌手",
                  children: singers?.map((s) => s.name).join("/") || "未知歌手"
                }
              ) })
            ] })
          },
          {
            title: "专辑",
            dataIndex: "albumname",
            width: 200,
            ellipsis: true
          },
          {
            title: "大小",
            dataIndex: "size128",
            width: 120,
            align: "center",
            render: (_, record) => {
              const quality = record.quality || defaultQuality;
              const sizeKey = `size${quality}`;
              if (record.quality) {
                console.log("quality", quality);
                console.log("sizeKey", sizeKey);
              }
              const size = record[sizeKey] || 0;
              return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                Math.round(size / 1024 / 1024),
                "MB"
              ] });
            }
          },
          // 音质选择器
          {
            title: "音质",
            key: "quality",
            width: 150,
            align: "center",
            render: (_, record) => {
              const qualityList = getFileQualityList(record);
              const defaultValue = qualityList.includes(defaultQuality) ? defaultQuality : qualityList[0];
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select,
                {
                  options: qualityList.map((quality) => ({
                    label: quality,
                    value: quality
                  })),
                  defaultValue,
                  style: { width: "100%" },
                  onChange: (value) => {
                    handleChooseQuality(record, value);
                  }
                }
              );
            }
          },
          {
            title: "格式",
            key: "format",
            width: 150,
            align: "center",
            render: (_, record) => {
              const qualityList = getFileQualityList(record);
              const qualityColorMap = {
                flac: "green",
                ape: "volcano",
                320: "blue",
                m4a: "orange",
                128: "gray"
              };
              const qualityTextMap = {
                flac: "FLAC",
                ape: "APE",
                320: "320k",
                m4a: "M4A",
                128: "128k"
              };
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Space, { wrap: true, children: qualityList.map((quality) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: qualityColorMap[quality], children: qualityTextMap[quality] || quality }, quality)) });
            }
          },
          {
            title: "歌曲ID",
            dataIndex: "songmid",
            width: 200,
            align: "center",
            render: (songmid) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$1["song-mid-text"], text: songmid })
          },
          {
            title: "操作",
            key: "action",
            width: 300,
            align: "center",
            fixed: "right",
            render: (_, record) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "small", wrap: true, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    icon: isPlaying === record.songmid ? /* @__PURE__ */ jsxRuntimeExports.jsx(PauseCircleOutlined, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                    onClick: () => handlePlay(record),
                    title: "播放歌曲",
                    children: "播放"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MyButton,
                  {
                    type: "link",
                    size: "small",
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}),
                    onClick: () => handleDownload(record),
                    title: "下载歌曲",
                    children: "下载"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MyButton,
                  {
                    type: "link",
                    size: "small",
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FileOutlined, {}),
                    onClick: () => handleDownloadLyric(record),
                    title: "下载歌词",
                    children: "下载歌词"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MyButton,
                  {
                    type: "link",
                    size: "small",
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CloudDownloadOutlined, {}),
                    onClick: () => handleDownloadNeteaseMusic(record),
                    title: "转存网易云",
                    children: "转存网易云"
                  }
                )
              ] });
            }
          }
        ];
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Table,
          {
            columns: columns_song,
            dataSource: list,
            rowKey: "songmid",
            loading: loading2,
            scroll: { y: 500, x: 1100 },
            className: styles$1["song-table"],
            pagination: false
          }
        );
      };
      const getQuality = (record, defaultQuality, chooseQuality) => {
        const qualityList = getFileQualityList(record);
        const songDefaultQuality = qualityList.includes(defaultQuality) ? defaultQuality : qualityList[0];
        const finalQuality = chooseQuality || songDefaultQuality;
        return finalQuality;
      };
      const AlbumTab$1 = ({ data, loading: loading2 }) => {
        const albumDetailRef = useCompRef();
        const { pause, isPlaying } = usePlayMusic();
        const {
          playAlbum,
          downloadAlbumSong,
          getDownLoadJson
        } = useGetAlbumDetail();
        const [playing, setPlaying] = useState();
        const handlePlay = async (record) => {
          try {
            setPlaying(record.albumMID);
            const { albumMID, albumName } = record;
            const hide = msgLoading(`正在加载《${albumName}》...`);
            await playAlbum(albumMID);
            hide();
            msgSuccess(`《${albumName}》开始播放`);
          } catch (error) {
            console.error("播放失败:", error);
          } finally {
            setPlaying(void 0);
          }
        };
        const [downloading, setDownloading] = useState();
        const handleDownload = async (record) => {
          const loadingKey = "download-album-song";
          try {
            setDownloading(record.albumMID);
            const { albumMID, albumName } = record;
            message$1.loading({
              key: loadingKey,
              content: `正在下载专辑歌曲《${albumName}》...`,
              duration: 0
            });
            await downloadAlbumSong(albumMID, {
              onChange: (options) => {
                message$1.loading({
                  key: loadingKey,
                  content: `正在下载第${options.index}首歌曲《${options.songList[options.index - 1].songname}》...`,
                  duration: 0
                });
              }
            });
            message$1.destroy(loadingKey);
            msgSuccess(`《${albumName}》下载成功！`);
          } catch (error) {
            console.error("下载失败:", error);
          } finally {
            setDownloading(void 0);
            message$1.destroy(loadingKey);
          }
        };
        const [downloadingJson, setDownloadingJson] = useState(void 0);
        const handleDownloadJson = async (record) => {
          if (!record.albumMID) return;
          try {
            setDownloadingJson(record.albumMID);
            const { albumMID, albumName } = record;
            const res = await getDownLoadJson(albumMID);
            downloadAsJson([res], `${albumName}-专辑`);
          } catch (error) {
            msgError("下载JSON失败: " + error.message);
          } finally {
            setDownloadingJson(void 0);
          }
        };
        const columns_album = [
          {
            title: "专辑信息",
            dataIndex: "albumName",
            width: 300,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$1["song-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-cover"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { src: getAlbumPicUrl(record.albumMID) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: styles$1["song-details"],
                  style: {
                    cursor: "pointer"
                  },
                  onClick: () => albumDetailRef.current?.open({ albummid: record.albumMID }),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-name"], title: text, children: text }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-album"], title: record.singerName || "", children: record.singerName || "" })
                  ]
                }
              )
            ] })
          },
          {
            title: "歌手",
            dataIndex: "singerName",
            width: 200,
            ellipsis: true
          },
          {
            title: "发布时间",
            dataIndex: "publicTime",
            width: 150,
            align: "center"
          },
          {
            title: "歌曲数量",
            dataIndex: "song_count",
            width: 100,
            align: "center"
          },
          {
            title: "专辑ID",
            dataIndex: "albumMID",
            width: 200,
            align: "center",
            render: (albumMID) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$1["song-mid-text"], text: albumMID })
          },
          {
            title: "操作",
            key: "action",
            width: 300,
            align: "center",
            fixed: "right",
            render: (_, record) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    loading: playing === record.albumMID,
                    icon: playing === record.albumMID ? /* @__PURE__ */ jsxRuntimeExports.jsx(PauseCircleOutlined, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                    onClick: () => {
                      if (isPlaying === record.albumMID) {
                        pause();
                      } else {
                        handlePlay(record);
                        return;
                      }
                    },
                    title: "播放专辑",
                    children: "播放"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    loading: downloadingJson === record.albumMID,
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SaveOutlined, {}),
                    onClick: () => handleDownloadJson(record),
                    title: "下载JSON",
                    children: "下载JSON"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    loading: downloading === record.albumMID,
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadOutlined, {}),
                    onClick: () => handleDownload(record),
                    title: "下载专辑",
                    children: "下载"
                  }
                )
              ] });
            }
          }
        ];
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Table,
            {
              columns: columns_album,
              dataSource: data,
              rowKey: "albumMID",
              loading: loading2,
              scroll: { y: 500, x: 1100 },
              className: styles$1["song-table"],
              pagination: false
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(AlbumDetail, { ref: albumDetailRef })
        ] });
      };
      const SingerTab$1 = ({ data, loading: loading2 }) => {
        const hotSongModalRef = useCompRef();
        const handleHotSong = (record) => {
          hotSongModalRef.current.open({
            singerId: record.singerID,
            singerMid: record.singerMID,
            singerName: record.singerName,
            singerPic: record.singerPic
          });
        };
        const albumModalRef = useCompRef();
        const handleAlbum = (record) => {
          albumModalRef.current.open({
            singerId: record.singerID,
            singerMid: record.singerMID,
            singerName: record.singerName,
            singerPic: record.singerPic
          });
        };
        const columns_singer = [
          {
            title: "歌手信息",
            dataIndex: "singerName",
            width: 300,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$1["song-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-cover"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { src: record.singerPic }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-details"], children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-name"], title: text, children: text }) })
            ] })
          },
          {
            title: "歌曲数量",
            dataIndex: "songNum",
            width: 100,
            align: "center"
          },
          {
            title: "专辑数量",
            dataIndex: "albumNum",
            width: 100,
            align: "center"
          },
          {
            title: "MV数量",
            dataIndex: "mvNum",
            width: 100,
            align: "center"
          },
          {
            title: "歌手ID",
            dataIndex: "singerMID",
            width: 200,
            align: "center",
            render: (singerMID) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$1["song-mid-text"], text: singerMID })
          },
          {
            title: "操作",
            key: "action",
            width: 200,
            align: "center",
            render: (_, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}),
                  onClick: () => handleHotSong(record),
                  children: "查看热门歌曲"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "link",
                  color: "danger",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                  onClick: () => handleAlbum(record),
                  children: "查看专辑"
                }
              )
            ] })
          }
        ];
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Table,
            {
              columns: columns_singer,
              dataSource: data,
              rowKey: "singerMID",
              loading: loading2,
              scroll: { y: 500, x: 1100 },
              className: styles$1["song-table"],
              pagination: false
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(HotSongModal$1, { ref: hotSongModalRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(AlbumListModal, { ref: albumModalRef })
        ] });
      };
      const MvTab = ({ data, loading: loading2 }) => {
        const columns_mv = [
          {
            title: "MV信息",
            dataIndex: "mv_name",
            width: 300,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$1["song-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-cover"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { src: record.mv_pic_url }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1["song-details"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-name"], title: text, children: text }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-album"], title: record.singer_name || "", children: record.singer_name || "" })
              ] })
            ] })
          },
          {
            title: "歌手",
            dataIndex: "singer_name",
            width: 200,
            ellipsis: true
          },
          {
            title: "时长",
            dataIndex: "duration",
            width: 100,
            align: "center",
            render: (duration) => {
              const minutes = Math.floor(duration / 60);
              const seconds = duration % 60;
              return `${minutes}:${seconds.toString().padStart(2, "0")}`;
            }
          },
          {
            title: "播放次数",
            dataIndex: "play_count",
            width: 120,
            align: "center",
            render: (count) => {
              if (count >= 1e4) {
                return `${(count / 1e4).toFixed(1)}万`;
              }
              return count.toString();
            }
          },
          {
            title: "发布时间",
            dataIndex: "publish_date",
            width: 150,
            align: "center"
          },
          {
            title: "MV ID",
            dataIndex: "mv_id",
            width: 150,
            align: "center",
            render: (mv_id) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$1["song-mid-text"], text: mv_id.toString() })
          }
        ];
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Table,
          {
            columns: columns_mv,
            dataSource: data,
            rowKey: "mv_id",
            loading: loading2,
            scroll: { y: 500, x: 1100 },
            className: styles$1["song-table"],
            pagination: false
          }
        );
      };
      const LyricTab = ({ data, loading: loading2 }) => {
        const columns_lyric = [
          {
            title: "歌曲信息",
            dataIndex: "songname",
            width: 300,
            render: (text, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: "middle", className: styles$1["song-info"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-cover"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { src: getAlbumPicUrl(record.albummid) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1["song-details"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-name"], title: text, children: text }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["song-album"], title: record.albumname || "", children: record.albumname || "" })
              ] })
            ] })
          },
          {
            title: "歌手",
            dataIndex: "singer",
            width: 200,
            render: (singers) => /* @__PURE__ */ jsxRuntimeExports.jsx(Space, { size: "small", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["singer-info"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: styles$1["singer-name"],
                title: singers?.map((s) => s.name).join("/") || "未知歌手",
                children: singers?.map((s) => s.name).join("/") || "未知歌手"
              }
            ) }) })
          },
          {
            title: "歌词预览",
            dataIndex: "content",
            width: 300,
            ellipsis: true,
            render: (content) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { title: content, style: { maxWidth: 300 }, children: [
              content?.substring(0, 50),
              "..."
            ] })
          },
          {
            title: "歌曲ID",
            dataIndex: "songmid",
            width: 200,
            align: "center",
            render: (songmid) => /* @__PURE__ */ jsxRuntimeExports.jsx(CopyText, { className: styles$1["song-mid-text"], text: songmid })
          }
        ];
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Table,
          {
            columns: columns_lyric,
            dataSource: data,
            rowKey: "songmid",
            loading: loading2,
            scroll: { y: 500, x: 1100 },
            className: styles$1["song-table"],
            pagination: false
          }
        );
      };
      const defaultSearchParams = {
        pageNum: 1,
        pageSize: 20,
        type: "song"
      };
      const SongSearch = forwardRef((props, ref) => {
        const { visible, close } = useVisible({}, ref);
        const [searchParams, setSearchParams] = useState(defaultSearchParams);
        const searchFormOptions = [
          // 歌曲名称
          {
            label: "歌曲名称",
            name: "keyword",
            type: "input",
            inputProps: {
              placeholder: "请输入歌曲名称"
            }
          }
        ];
        const handleSearch = (values) => {
          const newParams = Object.fromEntries(
            searchFormOptions.filter((item) => item.name).map((item) => [item.name, values[item.name]])
          );
          setSearchParams({
            ...searchParams,
            ...newParams
          });
        };
        const { data, loading: loading2 } = useGetData(
          () => getSearchResult(searchParams.keyword, searchParams.type, searchParams),
          void 0,
          {
            returnFunction: () => !searchParams.keyword || !visible,
            monitors: [searchParams, visible]
          }
        );
        const renderTitle = () => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["modal-title"], children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1["title-content"], children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$1["title-text"], children: "歌曲查询" }) }) });
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            title: renderTitle(),
            open: visible,
            onCancel: close,
            width: 1200,
            centered: true,
            className: styles$1["song-search-modal"],
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                SearchForm$1,
                {
                  options: searchFormOptions,
                  onSearch: handleSearch,
                  style: { marginBottom: 16 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Tabs,
                {
                  activeKey: searchParams.type,
                  onChange: (key) => setSearchParams({ ...searchParams, type: key, pageNum: 1 }),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs.TabPane, { tab: "歌曲", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SongTab$1, { data: data?.song?.list || [], loading: loading2 }) }, "song"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs.TabPane, { tab: "专辑", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlbumTab$1, { data: data?.album?.list || [], loading: loading2 }) }, "album"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs.TabPane, { tab: "歌手", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SingerTab$1, { data: data?.singer?.list || [], loading: loading2 }) }, "user"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs.TabPane, { tab: "MV", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MvTab, { data: data?.mv?.list || [], loading: loading2 }) }, "mv"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs.TabPane, { tab: "歌词", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LyricTab, { data: data?.lyric?.list || [], loading: loading2 }) }, "lyric")
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Pagination,
                {
                  align: "end",
                  total: (() => {
                    switch (searchParams.type) {
                      case "song":
                        return data?.song?.totalnum || 0;
                      case "album":
                        return data?.album?.totalnum || 0;
                      case "user":
                        return data?.singer?.totalnum || 0;
                      case "mv":
                        return data?.mv?.totalnum || 0;
                      case "lyric":
                        return data?.lyric?.totalnum || 0;
                      default:
                        return 0;
                    }
                  })(),
                  current: searchParams.pageNum,
                  pageSize: searchParams.pageSize,
                  showSizeChanger: true,
                  showTotal: (total) => {
                    const typeMap2 = {
                      song: "首歌曲",
                      album: "张专辑",
                      user: "位歌手",
                      mv: "个MV",
                      lyric: "首歌词"
                    };
                    return `共 ${total} ${typeMap2[searchParams.type] || "条记录"}`;
                  },
                  onChange: (page, pageSize) => {
                    setSearchParams({ ...searchParams, pageNum: page, pageSize });
                  },
                  style: { marginTop: 16 }
                }
              )
            ]
          }
        );
      });
      const AlbumTab = () => {
        const [albummid, setAlbummid] = useState("0016l2F430zMux");
        const [getAlbumInfoLoading, setGetAlbumInfoLoading] = useState(false);
        const handleGetAlbumInfo = async () => {
          try {
            setGetAlbumInfoLoading(true);
            const res = await getAlbumInfo(albummid);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setGetAlbumInfoLoading(false);
          }
        };
        const [getAlbumPicUrlLoading, setGetAlbumPicUrlLoading] = useState(false);
        const handleGetAlbumPicUrl = async () => {
          try {
            setGetAlbumPicUrlLoading(true);
            const res = getAlbumPicUrl(albummid);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setGetAlbumPicUrlLoading(false);
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取专辑信息", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              placeholder: "请输入专辑mid",
              style: { width: 300 },
              value: albummid,
              onChange: (e) => setAlbummid(e.target.value)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetAlbumInfo, loading: getAlbumInfoLoading, children: "获取专辑信息" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetAlbumPicUrl, loading: getAlbumPicUrlLoading, children: "获取专辑图片" })
        ] }) }) });
      };
      function SettingItem(props) {
        const { value, onChange, type = "switch", disabled, ...otherProps } = props;
        switch (type) {
          case "input":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                value,
                onChange: (e) => onChange?.(e.target.value),
                disabled,
                ...otherProps
              }
            );
          case "select":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              Select,
              {
                value,
                onChange,
                disabled,
                ...otherProps
              }
            );
          case "radio":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              Radio.Group,
              {
                value,
                onChange: (e) => onChange?.(e.target.value),
                disabled,
                ...otherProps
              }
            );
          case "checkbox":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              Checkbox.Group,
              {
                value,
                onChange,
                disabled,
                ...otherProps
              }
            );
          case "date":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              DatePicker,
              {
                value,
                onChange,
                disabled,
                ...otherProps
              }
            );
          case "time":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              TimePicker,
              {
                value,
                onChange,
                disabled,
                ...otherProps
              }
            );
          case "switch":
          default:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              Switch,
              {
                checked: value,
                onChange,
                disabled,
                ...otherProps
              }
            );
        }
      }
      const { Item: Item$1 } = Descriptions;
      const getQualityOptions = () => {
        return [
          { label: "128k MP3", value: "128" },
          { label: "320k MP3", value: "320" },
          { label: "FLAC", value: "flac" }
        ];
      };
      const DOWNLOAD_SETTING_STRATEGIES = [
        {
          label: "下载音质",
          key: "quality",
          type: "select",
          options: getQualityOptions(),
          style: { width: "100%" }
        },
        {
          label: "是否下载歌词",
          key: "downloadLyric",
          type: "switch"
        },
        {
          label: "是否内嵌歌词封面",
          key: "embedLyricCover",
          type: "switch"
        }
      ];
      const DownloadSettingTab = () => {
        const { downloadConfig, setDownloadConfig } = useConfig();
        const handleConfigChange = (key, value) => {
          setDownloadConfig({
            ...downloadConfig,
            [key]: value
          });
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Descriptions,
          {
            column: 3,
            size: "default",
            bordered: true,
            style: {
              minWidth: 800
            },
            children: DOWNLOAD_SETTING_STRATEGIES.map((strategy) => {
              const { type, key, label, ...rest } = strategy;
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Item$1, { label, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                SettingItem,
                {
                  value: downloadConfig[key],
                  onChange: ((value) => handleConfigChange(key, value)),
                  type,
                  ...rest
                }
              ) }, key);
            })
          }
        );
      };
      const FlacTab = () => {
        const [flacFile, setFlacFile] = useState(null);
        const [flacTagName, setFlacTagName] = useState("all");
        const [flacTagValue, setFlacTagValue] = useState("");
        const [flacPicture, setFlacPicture] = useState(null);
        const [picturePreview, setPicturePreview] = useState(null);
        const [flacTags, setFlacTags] = useState({});
        const [flacFileList, setFlacFileList] = useState([]);
        const [pictureFileList, setPictureFileList] = useState([]);
        const loadFlacTags = async (file) => {
          if (!file) return;
          try {
            if (flacTags.cover) {
              URL.revokeObjectURL(flacTags.cover);
            }
            const tags = await readAllFlacTag(file);
            const covers = await readFlacPictures(file) || [];
            const cover = covers.length > 0 ? URL.createObjectURL(covers[covers.length - 1]) : null;
            setFlacTags({
              ...tags,
              cover
            });
            console.log("FLAC 标签:", tags);
          } catch (error) {
            console.error("读取 FLAC 标签失败:", error);
            msgError("读取 FLAC 标签失败");
          }
        };
        useEffect(() => {
          if (flacFile) {
            loadFlacTags(flacFile);
          }
          return () => {
            if (flacTags.cover) {
              URL.revokeObjectURL(flacTags.cover);
            }
          };
        }, [flacFile]);
        const handleFlacFileChange = ({ fileList }) => {
          setFlacFileList(fileList);
          if (fileList.length > 0 && fileList[0].originFileObj) {
            const file = fileList[0].originFileObj;
            setFlacFile(file);
          } else {
            setFlacFile(null);
            setFlacTags({});
          }
        };
        const handlePictureChange = ({ fileList }) => {
          setPictureFileList(fileList);
          if (fileList.length > 0 && fileList[0].originFileObj) {
            const file = fileList[0].originFileObj;
            setFlacPicture(file);
            const reader = new FileReader();
            reader.onload = (e) => {
              setPicturePreview(e.target?.result);
            };
            reader.readAsDataURL(file);
          } else {
            setFlacPicture(null);
            setPicturePreview(null);
          }
        };
        const handleReadFlacTag = async () => {
          try {
            if (!flacFile) {
              msgError("请选择文件");
              return;
            }
            if (flacTagName === "all") {
              const res = await readAllFlacTag(flacFile);
              setFlacTags(res);
              msgSuccess("读取所有标签成功，请查看下方信息");
              console.log("res", res);
            } else {
              const res = await readFlacTag(flacFile, flacTagName);
              msgSuccess(`读取标签 ${FLAC_TAGS[flacTagName]} 成功: ${res || "无值"}`);
              console.log("res", res);
            }
          } catch (error) {
            console.log("error", error);
            msgError("读取标签失败");
          }
        };
        const handleWriteFlacTag = async () => {
          try {
            if (!flacFile) {
              msgError("请选择文件");
              return;
            }
            if (flacTagName === "all") {
              msgError("请选择具体标签");
              return;
            }
            if (!flacTagValue.trim()) {
              msgError("请输入标签值");
              return;
            }
            const res = await writeFlacTag(flacFile, flacTagName, flacTagValue);
            if (res) {
              console.log("res", res);
              setFlacFile(new File([res], flacFile.name));
              msgSuccess("写入标签成功");
            }
          } catch (error) {
            console.log("error", error);
            msgError("写入标签失败");
          }
        };
        const handleEmbedFlacPicture = async () => {
          try {
            if (!flacFile) {
              msgError("请选择文件");
              return;
            }
            if (!flacPicture) {
              msgError("请选择图片");
              return;
            }
            const res = await embedFlacPicture(flacFile, flacPicture);
            if (res) {
              console.log("res", res);
              setFlacFile(new File([res], flacFile.name));
              msgSuccess("嵌入图片成功");
            }
          } catch (error) {
            console.log("error", error);
            msgError("嵌入图片失败");
          }
        };
        const handleDownloadFlacFile = async () => {
          try {
            if (!flacFile) {
              msgError("请选择文件");
              return;
            }
            downloadFileWithBlob(flacFile, flacFile.name || "test.flac");
            msgSuccess("文件下载成功");
          } catch (error) {
            console.log("error", error);
            msgError("文件下载失败");
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "FLAC 文件", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Upload,
            {
              fileList: flacFileList,
              accept: ".flac",
              maxCount: 1,
              beforeUpload: async () => {
                return false;
              },
              onChange: handleFlacFileChange,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UploadOutlined, {}), children: "选择 FLAC 文件" })
            }
          ) }),
          Object.keys(flacTags).length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "FLAC 标签信息", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { size: "small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions, { column: 2, size: "small", children: Object.entries(flacTags).map(([key, value]) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Descriptions.Item,
            {
              label: FLAC_TAGS[key] || key.toUpperCase(),
              children: key === "cover" && value ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                Image,
                {
                  src: value,
                  alt: "封面",
                  width: 100,
                  height: 100,
                  style: { objectFit: "cover", borderRadius: 4 },
                  preview: true
                }
              ) : key === "cover" ? "无封面" : value
            },
            key
          )) }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "标签操作", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { wrap: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Select,
              {
                style: { width: 150 },
                options: [
                  { label: "全部", value: "all" },
                  ...Object.entries(FLAC_TAGS).map(([key, value]) => ({
                    label: value,
                    value: key
                  }))
                ],
                value: flacTagName,
                onChange: (value) => setFlacTagName(value)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                placeholder: "请输入标签值",
                value: flacTagValue,
                onChange: (e) => setFlacTagValue(e.target.value),
                style: { width: 200 }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleReadFlacTag, children: "读取标签" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleWriteFlacTag, children: "写入标签" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "封面图片", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { wrap: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Upload,
              {
                fileList: pictureFileList,
                accept: ".jpg,.png,.jpeg",
                maxCount: 1,
                beforeUpload: async () => {
                  return false;
                },
                onChange: handlePictureChange,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(PictureOutlined, {}), children: "选择图片" })
              }
            ),
            picturePreview && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Image,
              {
                src: picturePreview,
                alt: "封面预览",
                width: 100,
                height: 100,
                style: { objectFit: "cover", borderRadius: 4 },
                preview: true
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleEmbedFlacPicture, children: "嵌入图片" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "文件操作", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleDownloadFlacFile, children: "下载最新文件" }) })
        ] });
      };
      const { Item } = Descriptions;
      const FUNCTION_SWITCH_STRATEGIES = [
        {
          label: "搜索",
          key: "enableSearch",
          type: "switch"
        },
        {
          label: "GitHub信息",
          key: "enableGithubInfo",
          type: "switch"
        },
        {
          label: "功能开关Tab",
          key: "enableFunctionSwitchTab",
          type: "switch",
          disabled: true
        },
        {
          label: "下载设置Tab",
          key: "enableDownloadSetting",
          type: "switch"
        },
        {
          label: "并发上传歌曲数量",
          key: "uploadConcurrency",
          type: "input"
        },
        {
          label: "演唱会关键词",
          key: "liveKeywords",
          type: "select",
          mode: "tags",
          tokenSeparators: [",", "，", " "],
          style: { width: "100%" }
        },
        {
          label: "测试Modal",
          key: "enableTestModal",
          type: "switch"
        }
      ];
      const FunctionSwitchTab = () => {
        const { functionConfig, setFunctionConfig } = useConfig();
        const handleSwitchChange = (key, checked) => {
          setFunctionConfig({
            ...functionConfig,
            [key]: checked
          });
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Descriptions, { column: 3, bordered: true, children: FUNCTION_SWITCH_STRATEGIES.map((strategy) => {
          const { type, key, label, disabled, ...rest } = strategy;
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Item, { label, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            SettingItem,
            {
              value: functionConfig[key],
              onChange: (value) => handleSwitchChange(key, value),
              type,
              disabled,
              ...rest
            }
          ) }, key);
        }) });
      };
      const SearchTab = () => {
        const [getSearchResultLoading, setGetSearchResultLoading] = useState(false);
        const [getSearchResultParams, setGetSearchResultParams] = useState({
          keyword: "",
          type: "song"
        });
        const handleGetSearchResult = async () => {
          try {
            setGetSearchResultLoading(true);
            const res = await getSearchResult(getSearchResultParams.keyword, getSearchResultParams.type);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setGetSearchResultLoading(false);
          }
        };
        const [getWebSearchResultLoading, setGetWebSearchResultLoading] = useState(false);
        const handleGetWebSearchResult = async () => {
          try {
            setGetWebSearchResultLoading(true);
            const res = await getWebSearchResult(
              getSearchResultParams.keyword,
              getSearchResultParams.type
            );
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setGetWebSearchResultLoading(false);
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取搜索结果", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              placeholder: "请输入搜索关键词",
              style: { width: 300 },
              value: getSearchResultParams.keyword,
              onChange: (e) => setGetSearchResultParams({ ...getSearchResultParams, keyword: e.target.value })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Select,
            {
              options: Object.entries(ResourceType).map(([key, value]) => ({
                label: key,
                value
              })),
              style: { width: 150 },
              value: getSearchResultParams.type,
              onChange: (value) => setGetSearchResultParams({ ...getSearchResultParams, type: value }),
              allowClear: true
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetSearchResult, loading: getSearchResultLoading, children: "获取搜索结果" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              onClick: handleGetWebSearchResult,
              loading: getWebSearchResultLoading,
              children: "获取web搜索结果"
            }
          )
        ] }) }) });
      };
      const SingerTab = () => {
        const [getSingerListParams, setGetSingerListParams] = useState({
          area: -100,
          sex: -100,
          genre: -100,
          cur_page: 1
        });
        const handleGetSingerList = async () => {
          try {
            const res = await getSingerList(getSingerListParams);
            console.log("res", res);
            msgSuccess("获取歌手列表成功,请打开控制台查看");
          } catch (error) {
            console.log("error", error);
          }
        };
        const [mid, setMid] = useState("003fA5G40k6hKc");
        const handleGetSingerInfo = async () => {
          try {
            const res = await getSingerInfo(mid);
            console.log("res", res);
            msgSuccess("获取歌手信息成功,请打开控制台查看");
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetSingerAlbum = async () => {
          try {
            const res = await getSingerAlbum(mid);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetSingerAllAlbum = async () => {
          try {
            const res = await getSingerAllAlbum(mid);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetSingerFollowCount = async () => {
          try {
            const res = await getSingerFollowCount(mid);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetSingerHotSong = async () => {
          try {
            const res = await getSingerHotSong(mid);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetSingerAllHotSong = async () => {
          try {
            const res = await getSingerAllHotSong(mid);
            console.log("res", res);
            msgSuccess("获取歌手全部热门歌曲成功,请打开控制台查看");
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetSimilarSinger = async () => {
          try {
            const res = await getSimilarSinger(mid);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取歌手列表", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Select,
              {
                options: AreaList,
                style: {
                  width: 150
                },
                value: getSingerListParams.area,
                onChange: (value) => setGetSingerListParams({ ...getSingerListParams, area: value })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Select,
              {
                options: GenreList,
                style: {
                  width: 150
                },
                value: getSingerListParams.genre,
                onChange: (value) => setGetSingerListParams({ ...getSingerListParams, genre: value })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Select,
              {
                options: SexList,
                style: {
                  width: 150
                },
                value: getSingerListParams.sex,
                onChange: (value) => setGetSingerListParams({ ...getSingerListParams, sex: value })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSingerList, children: "获取歌手列表" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取歌手信息", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { wrap: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                placeholder: "请输入歌手mid",
                style: { width: 300 },
                value: mid,
                onChange: (e) => setMid(e.target.value)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSingerInfo, children: "获取歌手信息" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSingerAlbum, children: "获取歌手专辑" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSingerAllAlbum, children: "获取歌手所有专辑" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSingerFollowCount, children: "获取歌手被关注数量" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSingerHotSong, children: "获取歌手热门歌曲" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSingerAllHotSong, children: "获取歌手全部热门歌曲" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSimilarSinger, children: "获取相似歌手" })
          ] }) })
        ] });
      };
      const SongListTab = () => {
        const [getSongListLoading, setGetSongListLoading] = useState(false);
        const [getSongListCategoryLoading, setGetSongListCategoryLoading] = useState(false);
        const handleGetSongListCategory = async () => {
          try {
            setGetSongListCategoryLoading(true);
            const res = await getSongListCategory();
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setGetSongListCategoryLoading(false);
          }
        };
        const handleGetSongList = async () => {
          try {
            setGetSongListLoading(true);
            const res = await getSongList();
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setGetSongListLoading(false);
          }
        };
        const [disstid, setDisstid] = useState("7011264340");
        const [getSongListDetailLoading, setGetSongListDetailLoading] = useState(false);
        const handleGetSongListDetail = async () => {
          try {
            setGetSongListDetailLoading(true);
            const res = await getSongListDetail(disstid);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setGetSongListDetailLoading(false);
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取歌单列表", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                type: "primary",
                onClick: handleGetSongListCategory,
                loading: getSongListCategoryLoading,
                children: "获取歌单分类列表"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetSongList, loading: getSongListLoading, children: "获取歌单列表" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取歌单详情", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                placeholder: "请输入歌单id",
                style: { width: 300 },
                value: disstid,
                onChange: (e) => setDisstid(e.target.value)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                type: "primary",
                onClick: handleGetSongListDetail,
                loading: getSongListDetailLoading,
                children: "获取歌单详情"
              }
            )
          ] }) })
        ] });
      };
      const SongTab = () => {
        const { convertToNeteaseMusic } = usePlayMusic();
        const [songmid, setSongmid] = useState("003rJSwm3TechU");
        const handleGetSongLyric = async () => {
          try {
            const res = await getSongLyric(songmid);
            console.log("res", res);
            msgSuccess("歌曲歌词获取成功");
          } catch (error) {
            console.log("error", error);
            msgError("歌曲歌词获取失败");
          }
        };
        const handleGetSongPlayUrl = async () => {
          try {
            const res = await getSongPlayUrl(songmid.split(","));
            console.log("res", res);
            msgSuccess("歌曲播放链接获取成功");
          } catch (error) {
            console.log("error", error);
            msgError("歌曲播放链接获取失败");
          }
        };
        const handleGetSongInfo = async () => {
          try {
            const res = await getSongInfo(songmid);
            console.log("res", res);
            msgSuccess("歌曲信息获取成功");
          } catch (error) {
            console.log("error", error);
            msgError("歌曲信息获取失败");
          }
        };
        const handleConvertToNeteaseMusic = async () => {
          try {
            const res = await convertToNeteaseMusic(songmid);
            msgSuccess("歌曲转存网易云成功");
          } catch (error) {
            console.log("error", error);
            msgError("歌曲转存网易云失败");
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取歌曲信息", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              placeholder: "请输入歌曲mid",
              style: { width: 300 },
              value: songmid,
              onChange: (e) => setSongmid(e.target.value)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSongLyric, children: "获取歌曲歌词" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSongPlayUrl, children: "获取歌曲播放链接" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetSongInfo, children: "获取歌曲信息" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleConvertToNeteaseMusic, children: "歌曲转存网易云" })
        ] }) }) });
      };
      const NeteaseMusicTab = () => {
        const handleGetUserAccount = async () => {
          const res = await getUserAccount();
          console.log("res", res);
        };
        const [file, setFile] = useState(null);
        const handleUploadLocalSong = async () => {
          if (!file) return;
          const res = await uploadLocalSong(file);
          console.log("res", res);
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "网易云用户信息", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleGetUserAccount, children: "获取用户信息" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "上传本地歌曲", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { wrap: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Upload,
              {
                accept: ".mp3,.flac,.wav,.m4a,.aac,.ogg,.ape",
                maxCount: 1,
                beforeUpload: async (file2) => {
                  return false;
                },
                onChange: (info) => {
                  setFile(info.fileList[0].originFileObj);
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UploadOutlined, {}), children: "选择本地歌曲" })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MyButton, { type: "primary", onClick: handleUploadLocalSong, children: "上传本地歌曲" })
          ] }) })
        ] });
      };
      const TestModal = forwardRef((_, ref) => {
        const { visible, close } = useVisible({}, ref);
        const { functionConfig } = useConfig();
        const { enableFunctionSwitchTab, enableDownloadSetting } = functionConfig;
        const tabItems = [
          {
            key: "singer",
            label: "歌手",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(SingerTab, {})
          },
          {
            key: "album",
            label: "专辑",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlbumTab, {})
          },
          {
            key: "song",
            label: "歌曲",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(SongTab, {})
          },
          {
            key: "songList",
            label: "歌单",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(SongListTab, {})
          },
          {
            key: "search",
            label: "搜索",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(SearchTab, {})
          },
          {
            key: "neteaseMusic",
            label: "网易云音乐",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(NeteaseMusicTab, {})
          },
          {
            key: "flac",
            label: "FLAC",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(FlacTab, {})
          },
          enableFunctionSwitchTab && {
            key: "functionSwitchTab",
            label: "功能开关",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(FunctionSwitchTab, {})
          },
          enableDownloadSetting && {
            key: "downloadSetting",
            label: "下载设置",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadSettingTab, {})
          }
        ].filter(Boolean);
        const [cookie, setCookie] = useLocalStorageState("neteaseMusicCookie", {
          defaultValue: "",
          listenStorageChange: true
        });
        const handleGetUserAccount = async () => {
          if (!cookie) return;
          const res = await getUserAccount();
          console.log("res", res);
          if (res.code !== 200) {
            console.log("cookie无效，已置空。");
            setCookie("");
            return;
          }
        };
        useEffect(() => {
          handleGetUserAccount();
        }, []);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            title: "测试Modal",
            open: visible,
            onCancel: close,
            width: 1200,
            styles: {
              body: {
                maxHeight: "75vh",
                overflowY: "auto"
              }
            },
            footer: null,
            centered: true,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs, { items: tabItems })
          }
        );
      });
      const styles = {
        "button-group": "_button-group_fmug6_1"
      };
      const ButtonGroup = () => {
        const { functionConfig } = useConfig();
        const { enableSearch, enableGithubInfo, enableTestModal } = functionConfig;
        const singerSearchRef = useCompRef();
        const handleSingerSearch = () => {
          singerSearchRef.current.open();
        };
        const songListSearchRef = useCompRef();
        const handleSongListSearch = () => {
          songListSearchRef.current.open();
        };
        const songSearchRef = useCompRef();
        const handleSongSearch = () => {
          songSearchRef.current.open();
        };
        const songListDetailRef = useCompRef();
        const handleSongListDetail = () => {
          songListDetailRef.current.open();
        };
        const albumDetailRef = useCompRef();
        const handleAlbumDetail = () => {
          albumDetailRef.current.open();
        };
        const testModalRef = useCompRef();
        const handleTestModal = () => {
          testModalRef.current.open();
        };
        const githubInfoRef = useCompRef();
        const handleGithubInfo = () => {
          githubInfoRef.current.open();
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles["button-group"], children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "歌手查询", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined, {}),
              onClick: handleSingerSearch,
              className: styles["button"]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "歌单查询", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UnorderedListOutlined, {}),
              onClick: handleSongListSearch,
              className: styles["button"]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "歌单详情", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerOutlined, {}),
              onClick: handleSongListDetail,
              className: styles["button"]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "专辑详情", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(BookOutlined, {}),
              onClick: handleAlbumDetail,
              className: styles["button"]
            }
          ) }),
          enableSearch && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "歌曲查询", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SearchOutlined, {}),
              onClick: handleSongSearch,
              className: styles["button"]
            }
          ) }),
          enableTestModal && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "testModal", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoCircleOutlined, {}),
              onClick: handleTestModal,
              className: styles["button"]
            }
          ) }),
          enableGithubInfo && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "githubInfo", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(GithubOutlined, {}),
              onClick: handleGithubInfo,
              className: styles["button"]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TestModal, { ref: testModalRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SingerSearch, { ref: singerSearchRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SongListSearch, { ref: songListSearchRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SongListDetail, { ref: songListDetailRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(AlbumDetail, { ref: albumDetailRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SongSearch, { ref: songSearchRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(GithubInfo, { ref: githubInfoRef })
        ] });
      };
      function App() {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "App", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ConfigProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(App$1, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ModalUtils, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonGroup, {})
        ] }) }) });
      }
      const themeToken = {
        colorPrimary: "#31C27C",
        // QQ音乐特征绿色
        colorPrimaryHover: "#2DB573",
        colorPrimaryActive: "#28A069",
        // 文字颜色
        colorText: "#333333",
        colorTextSecondary: "#666666",
        colorTextTertiary: "#999999",
        colorTextDescription: "#666666",
        // 背景色
        colorBgContainer: "#FFFFFF",
        colorBgLayout: "#F5F5F5",
        colorBgMask: "rgba(0, 0, 0, 0.45)",
        // 边框颜色
        colorBorder: "#E1E1E1",
        colorBorderSecondary: "#F0F0F0",
        // 链接颜色
        colorLink: "#31C27C",
        colorLinkHover: "#2DB573",
        colorLinkActive: "#28A069",
        // 成功、警告、错误状态色
        colorSuccess: "#52C41A",
        colorWarning: "#FAAD14",
        colorError: "#FF4D4F",
        // 字体
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif',
        fontSize: 14,
        // 圆角
        borderRadius: 4,
        borderRadiusLG: 8,
        borderRadiusSM: 2,
        // 间距
        marginXS: 8,
        marginSM: 12,
        margin: 16,
        marginMD: 20,
        marginLG: 24,
        marginXL: 32,
        // 动画
        motionDurationFast: "0.1s",
        motionDurationMid: "0.2s",
        motionDurationSlow: "0.3s",
        motionEaseInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
        motionEaseOut: "cubic-bezier(0.0, 0, 0.2, 1)"
      };
      const themeComponentsToken = {
        // 组件级别的样式定制
        Button: {
          colorPrimary: "#31C27C",
          algorithm: true
          // 启用算法
        },
        Input: {
          colorBorder: "#E1E1E1",
          algorithm: true
        },
        Table: {}
      };
      const theme = {
        token: themeToken,
        components: themeComponentsToken
      };
      ReactDOM.createRoot(
        (() => {
          const app = document.createElement("div");
          document.body.append(app);
          return app;
        })()
      ).render(
        /* @__PURE__ */ jsxRuntimeExports.jsx(require$$0.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ConfigProvider,
          {
            locale: zhCN,
            theme,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {})
          }
        ) })
      );

    })
  };
}));

System.import("./__entry.js", "./");